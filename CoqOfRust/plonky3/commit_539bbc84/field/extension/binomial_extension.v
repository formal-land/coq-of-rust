(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module extension.
  Module binomial_extension.
    (* StructRecord
      {
        name := "BinomialExtensionField";
        const_params := [ "D" ];
        ty_params := [ "FA" ];
        fields := [ ("value", Ty.apply (Ty.path "array") [ D ] [ FA ]) ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (* Clone *)
      Definition clone
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "array") [ D ] [ FA ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "value"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *) [ ("clone", InstanceField.Method (clone D FA)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            M.match_operator (|
              Ty.tuple [],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq D FA))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_marker_StructuralPartialEq_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_FA_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (* PartialEq *)
      Definition eq
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                other
              |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ D ] [ FA ],
                [],
                [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *) [ ("eq", InstanceField.Method (eq D FA)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_FA_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (* Hash *)
      Definition hash
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply (Ty.path "array") [ D ] [ FA ],
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *) [ ("hash", InstanceField.Method (hash D FA)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (* Debug *)
      Definition fmt
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "BinomialExtensionField" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "value" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ] ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                "value"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt D FA)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module underscore.
      Module Impl_serde_ser_Serialize_where_serde_ser_Serialize_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
        Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
            [ D ]
            [ FA ].
        
        (* Serialize *)
        Definition serialize
            (D : Value.t)
            (FA : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self D FA in
          match ε, τ, α with
          | [], [ __S ], [ self; __serializer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ]
                    ],
                  self
                |) in
              let __serializer := M.alloc (| __S, __serializer |) in
              M.catch_return
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                  ]) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ __serde_state :
                        Ty.associated_in_trait
                          "serde::ser::Serializer"
                          []
                          []
                          __S
                          "SerializeStruct" :=
                      M.match_operator (|
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct",
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct"
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "SerializeStruct";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  [],
                                  "serialize_struct",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  mk_str (| "BinomialExtensionField" |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.cast (Ty.path "usize") (Value.Bool false);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val :=
                                M.copy (|
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  γ0_0
                                |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::_::serialize::__SerializeWith")
                                      [ D ]
                                      [ FA ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "value" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::_::serialize::__SerializeWith")
                                            [ D ]
                                            [ FA ],
                                          Value.mkStructRecord
                                            "p3_field::extension::binomial_extension::_::serialize::__SerializeWith"
                                            [ D ]
                                            [ FA ]
                                            [
                                              ("values",
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                            "value"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]);
                                              ("phantom",
                                                Value.StructTuple
                                                  "core::marker::PhantomData"
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                      [ D ]
                                                      [ FA ]
                                                  ]
                                                  [])
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                          ],
                        M.get_trait_method (|
                          "serde::ser::SerializeStruct",
                          Ty.associated_in_trait
                            "serde::ser::Serializer"
                            []
                            []
                            __S
                            "SerializeStruct",
                          [],
                          [],
                          "end",
                          [],
                          []
                        |),
                        [ M.read (| __serde_state |) ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (D : Value.t) (FA : Ty.t),
          M.IsTraitInstance
            "serde::ser::Serialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self D FA)
            (* Instance *) [ ("serialize", InstanceField.Method (serialize D FA)) ].
      End Impl_serde_ser_Serialize_where_serde_ser_Serialize_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Module Impl_serde_de_Deserialize_where_serde_de_Deserialize_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
        Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
            [ D ]
            [ FA ].
        
        (* Deserialize *)
        Definition deserialize
            (D : Value.t)
            (FA : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self D FA in
          match ε, τ, α with
          | [], [ __D ], [ __deserializer ] =>
            ltac:(M.monadic
              (let __deserializer := M.alloc (| __D, __deserializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ];
                    Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                  ],
                M.get_trait_method (|
                  "serde::de::Deserializer",
                  __D,
                  [],
                  [],
                  "deserialize_struct",
                  [],
                  [
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::binomial_extension::_'1::deserialize::__Visitor")
                      [ D ]
                      [ FA ]
                  ]
                |),
                [
                  M.read (| __deserializer |);
                  mk_str (| "BinomialExtensionField" |);
                  M.read (|
                    get_constant (|
                      "p3_field::extension::binomial_extension::_'1::deserialize::FIELDS",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                        ]
                    |)
                  |);
                  Value.mkStructRecord
                    "p3_field::extension::binomial_extension::_'1::deserialize::__Visitor"
                    [ D ]
                    [ FA ]
                    [
                      ("marker",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ FA ]
                          ]
                          []);
                      ("lifetime",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                          [])
                    ]
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (D : Value.t) (FA : Ty.t),
          M.IsTraitInstance
            "serde::de::Deserialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self D FA)
            (* Instance *) [ ("deserialize", InstanceField.Method (deserialize D FA)) ].
      End Impl_serde_de_Deserialize_where_serde_de_Deserialize_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    End underscore.
    
    
    Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_FA_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (* PartialOrd *)
      Definition partial_cmp
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                other
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "array") [ D ] [ FA ],
                [],
                [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp D FA)) ].
    End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_FA_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_cmp_Ord_where_core_cmp_Ord_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (* Ord *)
      Definition cmp
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                other
              |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::cmp::Ord",
                Ty.apply (Ty.path "array") [ D ] [ FA ],
                [],
                [],
                "cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp D FA)) ].
    End Impl_core_cmp_Ord_where_core_cmp_Ord_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_default_Default_where_p3_field_field_FieldAlgebra_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn default() -> Self {
              Self {
                  value: array::from_fn(|_| FA::ZERO),
              }
          }
      *)
      Definition default
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ D ],
                      [ FA; Ty.function [ Ty.path "usize" ] FA ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  FA,
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.read (|
                                          get_constant (|
                                            "p3_field::field::FieldAlgebra::ZERO",
                                            FA
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *) [ ("default", InstanceField.Method (default D FA)) ].
    End Impl_core_default_Default_where_p3_field_field_FieldAlgebra_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_convert_From_where_p3_field_field_FieldAlgebra_FA_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn from(x: FA) -> Self {
              Self {
                  value: field_to_array(x),
              }
          }
      *)
      Definition from
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| FA, x |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ FA ] |),
                    [ M.read (| x |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *) [ ("from", InstanceField.Method (from D FA)) ].
    End Impl_core_convert_From_where_p3_field_field_FieldAlgebra_FA_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_p3_field_packed_Packable_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::packed::Packable"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *) [].
    End Impl_p3_field_packed_Packable_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    Module Impl_p3_field_field_ExtensionField_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*     type ExtensionPacking = BinomialExtensionField<F::Packing, D>; *)
      Definition _ExtensionPacking (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ].
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::field::ExtensionField"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self D F)
          (* Instance *) [ ("ExtensionPacking", InstanceField.Ty (_ExtensionPacking D F)) ].
    End Impl_p3_field_field_ExtensionField_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    Module Impl_p3_field_extension_HasFrobenius_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*
          fn frobenius(&self) -> Self {
              self.repeated_frobenius(1)
          }
      *)
      Definition frobenius
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F ],
              M.get_trait_method (|
                "p3_field::extension::HasFrobenius",
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F ],
                [],
                [ F ],
                "repeated_frobenius",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                Value.Integer IntegerKind.Usize 1
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn repeated_frobenius(&self, count: usize) -> Self {
              if count == 0 {
                  return *self;
              } else if count >= D {
                  // x |-> x^(n^D) is the identity, so x^(n^count) ==
                  // x^(n^(count % D))
                  return self.repeated_frobenius(count % D);
              }
              let arr: &[F] = self.as_base_slice();
      
              // z0 = DTH_ROOT^count = W^(k * count) where k = floor((n-1)/D)
              let mut z0 = F::DTH_ROOT;
              for _ in 1..count {
                  z0 *= F::DTH_ROOT;
              }
      
              let mut res = [F::ZERO; D];
              for (i, z) in z0.powers().take(D).enumerate() {
                  res[i] = arr[i] * z;
              }
      
              Self::from_base_slice(&res)
          }
      *)
      Definition repeated_frobenius
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  ],
                self
              |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.catch_return
              (Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| M.read (| M.deref (| M.read (| self |) |) |) |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          Ty.path "bool",
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.ge,
                                            [ M.read (| count |); D ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F ],
                                            M.get_trait_method (|
                                              "p3_field::extension::HasFrobenius",
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ F ],
                                              [],
                                              [ F ],
                                              "repeated_frobenius",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |);
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.rem,
                                                [ M.read (| count |); D ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |)))
                      ]
                    |) in
                  let~ arr : Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] :=
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                          M.get_trait_method (|
                            "p3_field::field::FieldExtensionAlgebra",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F ],
                            [],
                            [ F ],
                            "as_base_slice",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |) in
                  let~ z0 : F :=
                    M.read (|
                      get_constant (| "p3_field::extension::BinomiallyExtendable::DTH_ROOT", F |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.read (|
                      M.use
                        (M.alloc (|
                          Ty.tuple [],
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (|
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "into_iter",
                                  [],
                                  []
                                |),
                                [
                                  Value.mkStructRecord
                                    "core::ops::range::Range"
                                    []
                                    [ Ty.path "usize" ]
                                    [
                                      ("start", Value.Integer IntegerKind.Usize 1);
                                      ("end_", M.read (| count |))
                                    ]
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter :=
                                    M.copy (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      γ
                                    |) in
                                  M.read (|
                                    M.loop (|
                                      Ty.tuple [],
                                      ltac:(M.monadic
                                        (let~ _ : Ty.tuple [] :=
                                          M.match_operator (|
                                            Ty.tuple [],
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "usize" ],
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.path "usize" ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  [],
                                                  [],
                                                  "next",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.MutRef, iter |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let _ :=
                                                    M.is_struct_tuple (|
                                                      γ,
                                                      "core::option::Option::None"
                                                    |) in
                                                  M.never_to_any (| M.read (| M.break (||) |) |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  M.read (|
                                                    let~ _ : Ty.tuple [] :=
                                                      M.call_closure (|
                                                        Ty.tuple [],
                                                        M.get_trait_method (|
                                                          "core::ops::arith::MulAssign",
                                                          F,
                                                          [],
                                                          [ F ],
                                                          "mul_assign",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.MutRef, z0 |);
                                                          M.read (|
                                                            get_constant (|
                                                              "p3_field::extension::BinomiallyExtendable::DTH_ROOT",
                                                              F
                                                            |)
                                                          |)
                                                        ]
                                                      |) in
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                  |)))
                                            ]
                                          |) in
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                    |)
                                  |)))
                            ]
                          |)
                        |))
                    |) in
                  let~ res : Ty.apply (Ty.path "array") [ D ] [ F ] :=
                    lib.repeat (|
                      M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", F |) |),
                      D
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.read (|
                      M.use
                        (M.alloc (|
                          Ty.tuple [],
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::take::Take")
                                    []
                                    [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                ],
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::take::Take")
                                      []
                                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::take::Take")
                                        []
                                        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                    ],
                                  [],
                                  [],
                                  "into_iter",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::take::Take")
                                          []
                                          [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::take::Take")
                                        []
                                        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                                      [],
                                      [],
                                      "enumerate",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::take::Take")
                                          []
                                          [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                                          [],
                                          [],
                                          "take",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                                            M.get_trait_method (|
                                              "p3_field::field::FieldAlgebra",
                                              F,
                                              [],
                                              [],
                                              "powers",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, z0 |) ]
                                          |);
                                          D
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter :=
                                    M.copy (|
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::take::Take")
                                            []
                                            [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ]
                                            ]
                                        ],
                                      γ
                                    |) in
                                  M.read (|
                                    M.loop (|
                                      Ty.tuple [],
                                      ltac:(M.monadic
                                        (let~ _ : Ty.tuple [] :=
                                          M.match_operator (|
                                            Ty.tuple [],
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.tuple [ Ty.path "usize"; F ] ],
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.tuple [ Ty.path "usize"; F ] ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::enumerate::Enumerate")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::take::Take")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "p3_field::field::Powers")
                                                            []
                                                            [ F ]
                                                        ]
                                                    ],
                                                  [],
                                                  [],
                                                  "next",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.MutRef, iter |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let _ :=
                                                    M.is_struct_tuple (|
                                                      γ,
                                                      "core::option::Option::None"
                                                    |) in
                                                  M.never_to_any (| M.read (| M.break (||) |) |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let γ1_0 :=
                                                    M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                                  let γ1_1 :=
                                                    M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                                  let i := M.copy (| Ty.path "usize", γ1_0 |) in
                                                  let z := M.copy (| F, γ1_1 |) in
                                                  M.read (|
                                                    let~ _ : Ty.tuple [] :=
                                                      M.write (|
                                                        M.SubPointer.get_array_field (|
                                                          res,
                                                          M.read (| i |)
                                                        |),
                                                        M.call_closure (|
                                                          F,
                                                          M.get_trait_method (|
                                                            "core::ops::arith::Mul",
                                                            F,
                                                            [],
                                                            [ F ],
                                                            "mul",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.read (|
                                                              M.SubPointer.get_array_field (|
                                                                M.deref (| M.read (| arr |) |),
                                                                M.read (| i |)
                                                              |)
                                                            |);
                                                            M.read (| z |)
                                                          ]
                                                        |)
                                                      |) in
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                  |)))
                                            ]
                                          |) in
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                    |)
                                  |)))
                            ]
                          |)
                        |))
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ],
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F ],
                      M.get_trait_method (|
                        "p3_field::field::FieldExtensionAlgebra",
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F ],
                        [],
                        [ F ],
                        "from_base_slice",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ F ] ])
                            (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, res |) |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn frobenius_inv(&self) -> Self {
              // Writing 'a' for self, we need to compute a^(r-1):
              // r = n^D-1/n-1 = n^(D-1)+n^(D-2)+...+n
              let mut f = Self::ONE;
              for _ in 1..D {
                  f = (f * *self).frobenius();
              }
      
              // g = a^r is in the base field, so only compute that
              // coefficient rather than the full product.
              let a = self.value;
              let b = f.value;
              let mut g = F::ZERO;
              for i in 1..D {
                  g += a[i] * b[D - i];
              }
              g *= F::W;
              g += a[0] * b[0];
              debug_assert_eq!(Self::from(g), *self * f);
      
              f * g.inverse()
          }
      *)
      Definition frobenius_inv
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  ],
                self
              |) in
            M.read (|
              let~ f :
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F ] :=
                M.read (|
                  get_constant (|
                    "p3_field::field::FieldAlgebra::ONE",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [ ("start", Value.Integer IntegerKind.Usize 1); ("end_", D) ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.write (|
                                                    f,
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                        [ D ]
                                                        [ F ],
                                                      M.get_trait_method (|
                                                        "p3_field::extension::HasFrobenius",
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F ],
                                                        [],
                                                        [ F ],
                                                        "frobenius",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                              [ D ]
                                                              [ F ],
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                [ D ]
                                                                [ F ],
                                                              M.get_trait_method (|
                                                                "core::ops::arith::Mul",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                  [ D ]
                                                                  [ F ],
                                                                [],
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                    [ D ]
                                                                    [ F ]
                                                                ],
                                                                "mul",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (| f |);
                                                                M.read (|
                                                                  M.deref (| M.read (| self |) |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              let~ a : Ty.apply (Ty.path "array") [ D ] [ F ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ b : Ty.apply (Ty.path "array") [ D ] [ F ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    f,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ g : F :=
                M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", F |) |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [ ("start", Value.Integer IntegerKind.Usize 1); ("end_", D) ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_trait_method (|
                                                      "core::ops::arith::AddAssign",
                                                      F,
                                                      [],
                                                      [ F ],
                                                      "add_assign",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (| Pointer.Kind.MutRef, g |);
                                                      M.call_closure (|
                                                        F,
                                                        M.get_trait_method (|
                                                          "core::ops::arith::Mul",
                                                          F,
                                                          [],
                                                          [ F ],
                                                          "mul",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (|
                                                            M.SubPointer.get_array_field (|
                                                              a,
                                                              M.read (| i |)
                                                            |)
                                                          |);
                                                          M.read (|
                                                            M.SubPointer.get_array_field (|
                                                              b,
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.sub,
                                                                [ D; M.read (| i |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::MulAssign",
                    F,
                    [],
                    [ F ],
                    "mul_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, g |);
                    M.read (|
                      get_constant (| "p3_field::extension::BinomiallyExtendable::W", F |)
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    F,
                    [],
                    [ F ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, g |);
                    M.call_closure (|
                      F,
                      M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| a, Value.Integer IntegerKind.Usize 0 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| b, Value.Integer IntegerKind.Usize 0 |)
                        |)
                      ]
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F ]
                                      ];
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F ]
                                      ]
                                  ],
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F ],
                                          M.get_trait_method (|
                                            "core::convert::From",
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F ],
                                            [],
                                            [ F ],
                                            "from",
                                            [],
                                            []
                                          |),
                                          [ M.read (| g |) ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F ],
                                          M.get_trait_method (|
                                            "core::ops::arith::Mul",
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ F ]
                                            ],
                                            "mul",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| M.deref (| M.read (| self |) |) |);
                                            M.read (| f |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F ]
                                          ],
                                        γ0_0
                                      |) in
                                    let right_val :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F ]
                                          ],
                                        γ0_1
                                      |) in
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_trait_method (|
                                                        "core::cmp::PartialEq",
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                            [ D ]
                                                            [ F ]
                                                        ],
                                                        "eq",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    [] in
                                                M.alloc (|
                                                  Ty.path "never",
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F ];
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F ]
                                                      ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                        [ Ty.path "core::fmt::Arguments" ]
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F ],
                  M.get_trait_method (|
                    "core::ops::arith::Mul",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ],
                    [],
                    [ F ],
                    "mul",
                    [],
                    []
                  |),
                  [
                    M.read (| f |);
                    M.call_closure (|
                      F,
                      M.get_trait_method (|
                        "p3_field::field::Field",
                        F,
                        [],
                        [],
                        "inverse",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, g |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::extension::HasFrobenius"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self D F)
          (* Instance *)
          [
            ("frobenius", InstanceField.Method (frobenius D F));
            ("repeated_frobenius", InstanceField.Method (repeated_frobenius D F));
            ("frobenius_inv", InstanceField.Method (frobenius_inv D F))
          ].
    End Impl_p3_field_extension_HasFrobenius_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    Module Impl_p3_field_field_FieldAlgebra_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type F = BinomialExtensionField<FA::F, D>; *)
      Definition _F (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] FA "F" ].
      
      (*
          const ZERO: Self = Self {
              value: [FA::ZERO; D],
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ FA ] *)
      Definition value_ZERO
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ],
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  lib.repeat (|
                    M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", FA |) |),
                    D
                  |))
              ]
          |))).
      
      (*
          const ONE: Self = Self {
              value: field_to_array(FA::ONE),
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ FA ] *)
      Definition value_ONE
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ],
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ FA ] |),
                    [ M.read (| get_constant (| "p3_field::field::FieldAlgebra::ONE", FA |) |) ]
                  |))
              ]
          |))).
      
      (*
          const TWO: Self = Self {
              value: field_to_array(FA::TWO),
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ FA ] *)
      Definition value_TWO
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ],
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ FA ] |),
                    [ M.read (| get_constant (| "p3_field::field::FieldAlgebra::TWO", FA |) |) ]
                  |))
              ]
          |))).
      
      (*
          const NEG_ONE: Self = Self {
              value: field_to_array(FA::NEG_ONE),
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ FA ] *)
      Definition value_NEG_ONE
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ],
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ FA ] |),
                    [ M.read (| get_constant (| "p3_field::field::FieldAlgebra::NEG_ONE", FA |) |) ]
                  |))
              ]
          |))).
      
      (*
          fn from_f(f: Self::F) -> Self {
              Self {
                  value: f.value.map(FA::from_f),
              }
          }
      *)
      Definition from_f
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ f ] =>
          ltac:(M.monadic
            (let f :=
              M.alloc (|
                Ty.associated_in_trait
                  "p3_field::field::FieldAlgebra"
                  []
                  []
                  (Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ])
                  "F",
                f
              |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "array")
                        [ D ]
                        [ Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] FA "F" ],
                      "map",
                      [],
                      [
                        Ty.function
                          [ Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] FA "F" ]
                          FA;
                        FA
                      ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          f,
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |)
                      |);
                      M.get_trait_method (|
                        "p3_field::field::FieldAlgebra",
                        FA,
                        [],
                        [],
                        "from_f",
                        [],
                        []
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_canonical_u8(n: u8) -> Self {
              FA::from_canonical_u8(n).into()
          }
      *)
      Definition from_canonical_u8
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "u8", n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::convert::Into",
                FA,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_canonical_u8",
                    [],
                    []
                  |),
                  [ M.read (| n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_canonical_u16(n: u16) -> Self {
              FA::from_canonical_u16(n).into()
          }
      *)
      Definition from_canonical_u16
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "u16", n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::convert::Into",
                FA,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_canonical_u16",
                    [],
                    []
                  |),
                  [ M.read (| n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_canonical_u32(n: u32) -> Self {
              FA::from_canonical_u32(n).into()
          }
      *)
      Definition from_canonical_u32
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "u32", n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::convert::Into",
                FA,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_canonical_u32",
                    [],
                    []
                  |),
                  [ M.read (| n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_canonical_u64(n: u64) -> Self {
              FA::from_canonical_u64(n).into()
          }
      *)
      Definition from_canonical_u64
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "u64", n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::convert::Into",
                FA,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_canonical_u64",
                    [],
                    []
                  |),
                  [ M.read (| n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_canonical_usize(n: usize) -> Self {
              FA::from_canonical_usize(n).into()
          }
      *)
      Definition from_canonical_usize
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "usize", n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::convert::Into",
                FA,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_canonical_usize",
                    [],
                    []
                  |),
                  [ M.read (| n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_wrapped_u32(n: u32) -> Self {
              FA::from_wrapped_u32(n).into()
          }
      *)
      Definition from_wrapped_u32
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "u32", n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::convert::Into",
                FA,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_wrapped_u32",
                    [],
                    []
                  |),
                  [ M.read (| n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_wrapped_u64(n: u64) -> Self {
              FA::from_wrapped_u64(n).into()
          }
      *)
      Definition from_wrapped_u64
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "u64", n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::convert::Into",
                FA,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_wrapped_u64",
                    [],
                    []
                  |),
                  [ M.read (| n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn square(&self) -> Self {
              match D {
                  2 => {
                      let a = self.value.clone();
                      let mut res = Self::default();
                      res.value[0] = a[0].square() + a[1].square() * FA::from_f(FA::F::W);
                      res.value[1] = a[0].clone() * a[1].double();
                      res
                  }
                  3 => {
                      let mut res = Self::default();
                      cubic_square(&self.value, &mut res.value, FA::F::W);
                      res
                  }
                  _ => <Self as Mul<Self>>::mul(self.clone(), self.clone()),
              }
          }
      *)
      Definition square
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.alloc (| Ty.path "usize", D |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 2
                      |) in
                    M.read (|
                      let~ a : Ty.apply (Ty.path "array") [ D ] [ FA ] :=
                        M.call_closure (|
                          Ty.apply (Ty.path "array") [ D ] [ FA ],
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply (Ty.path "array") [ D ] [ FA ],
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                "value"
                              |)
                            |)
                          ]
                        |) in
                      let~ res :
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ FA ],
                            [],
                            [],
                            "default",
                            [],
                            []
                          |),
                          []
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (|
                            M.SubPointer.get_struct_record_field (|
                              res,
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "value"
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |),
                          M.call_closure (|
                            FA,
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              FA,
                              [],
                              [ FA ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                FA,
                                M.get_trait_method (|
                                  "p3_field::field::FieldAlgebra",
                                  FA,
                                  [],
                                  [],
                                  "square",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 0
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                FA,
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  FA,
                                  [],
                                  [ FA ],
                                  "mul",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    FA,
                                    M.get_trait_method (|
                                      "p3_field::field::FieldAlgebra",
                                      FA,
                                      [],
                                      [],
                                      "square",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_array_field (|
                                          a,
                                          Value.Integer IntegerKind.Usize 1
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    FA,
                                    M.get_trait_method (|
                                      "p3_field::field::FieldAlgebra",
                                      FA,
                                      [],
                                      [],
                                      "from_f",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        get_constant (|
                                          "p3_field::extension::BinomiallyExtendable::W",
                                          Ty.associated_in_trait
                                            "p3_field::field::FieldAlgebra"
                                            []
                                            []
                                            FA
                                            "F"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (|
                            M.SubPointer.get_struct_record_field (|
                              res,
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "value"
                            |),
                            Value.Integer IntegerKind.Usize 1
                          |),
                          M.call_closure (|
                            FA,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              FA,
                              [],
                              [ FA ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                FA,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  FA,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 0
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                FA,
                                M.get_trait_method (|
                                  "p3_field::field::FieldAlgebra",
                                  FA,
                                  [],
                                  [],
                                  "double",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 3
                      |) in
                    M.read (|
                      let~ res :
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ FA ],
                            [],
                            [],
                            "default",
                            [],
                            []
                          |),
                          []
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "p3_field::extension::binomial_extension::cubic_square",
                            [ D ],
                            [ FA ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                                    "value"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    res,
                                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                                    "value"
                                  |)
                                |)
                              |)
                            |);
                            M.read (|
                              get_constant (|
                                "p3_field::extension::BinomiallyExtendable::W",
                                Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] FA "F"
                              |)
                            |)
                          ]
                        |) in
                      res
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ FA ],
                        [],
                        [
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ FA ],
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |);
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ FA ],
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn zero_vec(len: usize) -> Vec<Self> {
              // SAFETY: this is a repr(transparent) wrapper around an array.
              unsafe { convert_vec(FA::zero_vec(len * D)) }
          }
      *)
      Definition zero_vec
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ len ] =>
          ltac:(M.monadic
            (let len := M.alloc (| Ty.path "usize", len |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_function (|
                "p3_util::convert_vec",
                [],
                [
                  FA;
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ]
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ FA; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "zero_vec",
                    [],
                    []
                  |),
                  [ M.call_closure (| Ty.path "usize", BinOp.Wrap.mul, [ M.read (| len |); D ] |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "p3_field::field::FieldAlgebra"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *)
          [
            ("F", InstanceField.Ty (_F D FA));
            ("value_ZERO", InstanceField.Method (value_ZERO D FA));
            ("value_ONE", InstanceField.Method (value_ONE D FA));
            ("value_TWO", InstanceField.Method (value_TWO D FA));
            ("value_NEG_ONE", InstanceField.Method (value_NEG_ONE D FA));
            ("from_f", InstanceField.Method (from_f D FA));
            ("from_canonical_u8", InstanceField.Method (from_canonical_u8 D FA));
            ("from_canonical_u16", InstanceField.Method (from_canonical_u16 D FA));
            ("from_canonical_u32", InstanceField.Method (from_canonical_u32 D FA));
            ("from_canonical_u64", InstanceField.Method (from_canonical_u64 D FA));
            ("from_canonical_usize", InstanceField.Method (from_canonical_usize D FA));
            ("from_wrapped_u32", InstanceField.Method (from_wrapped_u32 D FA));
            ("from_wrapped_u64", InstanceField.Method (from_wrapped_u64 D FA));
            ("square", InstanceField.Method (square D FA));
            ("zero_vec", InstanceField.Method (zero_vec D FA))
          ].
    End Impl_p3_field_field_FieldAlgebra_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_p3_field_field_Field_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*     type Packing = Self; *)
      Definition _Packing (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*
          const GENERATOR: Self = Self {
              value: F::EXT_GENERATOR,
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ F ] *)
      Definition value_GENERATOR
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F ],
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ F ]
              [
                ("value",
                  M.read (|
                    get_constant (|
                      "p3_field::extension::BinomiallyExtendable::EXT_GENERATOR",
                      Ty.apply (Ty.path "array") [ D ] [ F ]
                    |)
                  |))
              ]
          |))).
      
      (*
          fn try_inverse(&self) -> Option<Self> {
              if self.is_zero() {
                  return None;
              }
      
              match D {
                  2 => Some(Self::from_base_slice(&qudratic_inv(&self.value, F::W))),
                  3 => Some(Self::from_base_slice(&cubic_inv(&self.value, F::W))),
                  _ => Some(self.frobenius_inv()),
              }
          }
      *)
      Definition try_inverse
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  ],
                self
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F ]
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "p3_field::field::Field",
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ F ],
                                      [],
                                      [],
                                      "is_zero",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::None"
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ F ]
                                    ]
                                    []
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F ]
                      ],
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F ]
                        ],
                      M.alloc (| Ty.path "usize", D |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.Usize 2
                              |) in
                            Value.StructTuple
                              "core::option::Option::Some"
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                  [ D ]
                                  [ F ]
                              ]
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path
                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                    [ D ]
                                    [ F ],
                                  M.get_trait_method (|
                                    "p3_field::field::FieldExtensionAlgebra",
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                      [ D ]
                                      [ F ],
                                    [],
                                    [ F ],
                                    "from_base_slice",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                      M.pointer_coercion
                                        M.PointerCoercion.Unsize
                                        (Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 2 ]
                                              [ F ]
                                          ])
                                        (Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [ F ],
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [ F ],
                                                  M.get_function (|
                                                    "p3_field::extension::binomial_extension::qudratic_inv",
                                                    [],
                                                    [ F ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                      M.pointer_coercion
                                                        M.PointerCoercion.Unsize
                                                        (Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "array") [ D ] [ F ]
                                                          ])
                                                        (Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                                "value"
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |);
                                                    M.read (|
                                                      get_constant (|
                                                        "p3_field::extension::BinomiallyExtendable::W",
                                                        F
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.Usize 3
                              |) in
                            Value.StructTuple
                              "core::option::Option::Some"
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                  [ D ]
                                  [ F ]
                              ]
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path
                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                    [ D ]
                                    [ F ],
                                  M.get_trait_method (|
                                    "p3_field::field::FieldExtensionAlgebra",
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                      [ D ]
                                      [ F ],
                                    [],
                                    [ F ],
                                    "from_base_slice",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                      M.pointer_coercion
                                        M.PointerCoercion.Unsize
                                        (Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 3 ]
                                              [ F ]
                                          ])
                                        (Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 3 ]
                                                  [ F ],
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 3 ]
                                                    [ F ],
                                                  M.get_function (|
                                                    "p3_field::extension::binomial_extension::cubic_inv",
                                                    [],
                                                    [ F ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                      M.pointer_coercion
                                                        M.PointerCoercion.Unsize
                                                        (Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "array") [ D ] [ F ]
                                                          ])
                                                        (Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                                "value"
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |);
                                                    M.read (|
                                                      get_constant (|
                                                        "p3_field::extension::BinomiallyExtendable::W",
                                                        F
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]));
                        fun γ =>
                          ltac:(M.monadic
                            (Value.StructTuple
                              "core::option::Option::Some"
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                  [ D ]
                                  [ F ]
                              ]
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path
                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                    [ D ]
                                    [ F ],
                                  M.get_trait_method (|
                                    "p3_field::extension::HasFrobenius",
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                      [ D ]
                                      [ F ],
                                    [],
                                    [ F ],
                                    "frobenius_inv",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              ]))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn halve(&self) -> Self {
              Self {
                  value: self.value.map(|x| x.halve()),
              }
          }
      *)
      Definition halve
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  ],
                self
              |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ F ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ F ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "array") [ D ] [ F ],
                      "map",
                      [],
                      [ Ty.function [ F ] F; F ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |)
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  F,
                                  M.alloc (| F, α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| F, γ |) in
                                        M.call_closure (|
                                          F,
                                          M.get_trait_method (|
                                            "p3_field::field::Field",
                                            F,
                                            [],
                                            [],
                                            "halve",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, x |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn order() -> BigUint {
              F::order().pow(D as u32)
          }
      *)
      Definition order
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "num_bigint::biguint::BigUint",
              M.get_associated_function (| Ty.path "num_bigint::biguint::BigUint", "pow", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Ty.path "num_bigint::biguint::BigUint",
                    M.call_closure (|
                      Ty.path "num_bigint::biguint::BigUint",
                      M.get_trait_method (| "p3_field::field::Field", F, [], [], "order", [], [] |),
                      []
                    |)
                  |)
                |);
                M.cast (Ty.path "u32") D
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::field::Field"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *)
          [
            ("Packing", InstanceField.Ty (_Packing D F));
            ("value_GENERATOR", InstanceField.Method (value_GENERATOR D F));
            ("try_inverse", InstanceField.Method (try_inverse D F));
            ("halve", InstanceField.Method (halve D F));
            ("order", InstanceField.Method (order D F))
          ].
    End Impl_p3_field_field_Field_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    Module Impl_core_fmt_Display_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*
          fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
              if self.is_zero() {
                  write!(f, "0")
              } else {
                  let str = self
                      .value
                      .iter()
                      .enumerate()
                      .filter(|(_, x)| !x.is_zero())
                      .map(|(i, x)| match (i, x.is_one()) {
                          (0, _) => format!("{x}"),
                          (1, true) => "X".to_string(),
                          (1, false) => format!("{x} X"),
                          (_, true) => format!("X^{i}"),
                          (_, false) => format!("{x} X^{i}"),
                      })
                      .join(" + ");
                  write!(f, "{}", str)
              }
          }
      *)
      Definition fmt
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "p3_field::field::Field",
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ F ],
                              [],
                              [],
                              "is_zero",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array [ mk_str (| "0" |) ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      let~ str : Ty.path "alloc::string::String" :=
                        M.call_closure (|
                          Ty.path "alloc::string::String",
                          M.get_trait_method (|
                            "itertools::Itertools",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::filter::Filter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                      []
                                      [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ];
                                    Ty.function
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.tuple
                                              [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                          ]
                                      ]
                                      (Ty.path "bool")
                                  ];
                                Ty.function
                                  [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ] ]
                                  (Ty.path "alloc::string::String")
                              ],
                            [],
                            [],
                            "join",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::filter::Filter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                          []
                                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ];
                                        Ty.function
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.tuple
                                                  [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "bool")
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                      ]
                                      (Ty.path "alloc::string::String")
                                  ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::filter::Filter")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            []
                                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                            ];
                                          Ty.function
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                        ]
                                        (Ty.path "alloc::string::String")
                                    ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::filter::Filter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                          []
                                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ];
                                        Ty.function
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.tuple
                                                  [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "bool")
                                      ],
                                    [],
                                    [],
                                    "map",
                                    [],
                                    [
                                      Ty.path "alloc::string::String";
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                        ]
                                        (Ty.path "alloc::string::String")
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::filter::Filter")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            []
                                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                            ];
                                          Ty.function
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")
                                        ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                          []
                                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ],
                                        [],
                                        [],
                                        "filter",
                                        [],
                                        [
                                          Ty.function
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            []
                                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                            [],
                                            [],
                                            "enumerate",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ F ],
                                                "iter",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                  M.pointer_coercion
                                                    M.PointerCoercion.Unsize
                                                    (Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "array") [ D ] [ F ] ])
                                                    (Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                        "value"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          ]
                                        |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    Ty.path "bool",
                                                    M.alloc (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path "usize";
                                                              Ty.apply (Ty.path "&") [] [ F ]
                                                            ]
                                                        ],
                                                      α0
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ := M.deref (| M.read (| γ |) |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ1_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let x :=
                                                            M.alloc (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [ Ty.apply (Ty.path "&") [] [ F ] ],
                                                              γ1_1
                                                            |) in
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              M.get_trait_method (|
                                                                "p3_field::field::Field",
                                                                F,
                                                                [],
                                                                [],
                                                                "is_zero",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (|
                                                                      M.deref (| M.read (| x |) |)
                                                                    |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)))
                                                    ]
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end))
                                      ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.path "alloc::string::String",
                                                M.alloc (|
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ],
                                                  α0
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                                      let x :=
                                                        M.copy (|
                                                          Ty.apply (Ty.path "&") [] [ F ],
                                                          γ0_1
                                                        |) in
                                                      M.match_operator (|
                                                        Ty.path "alloc::string::String",
                                                        M.alloc (|
                                                          Ty.tuple
                                                            [ Ty.path "usize"; Ty.path "bool" ],
                                                          Value.Tuple
                                                            [
                                                              M.read (| i |);
                                                              M.call_closure (|
                                                                Ty.path "bool",
                                                                M.get_trait_method (|
                                                                  "p3_field::field::Field",
                                                                  F,
                                                                  [],
                                                                  [],
                                                                  "is_one",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| x |) |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_0 |),
                                                                  Value.Integer IntegerKind.Usize 0
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            ""
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  []
                                                                                                  [
                                                                                                    F
                                                                                                  ]
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    x
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_0 |),
                                                                  Value.Integer IntegerKind.Usize 1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_trait_method (|
                                                                  "alloc::string::ToString",
                                                                  Ty.path "str",
                                                                  [],
                                                                  [],
                                                                  "to_string",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| mk_str (| "X" |) |)
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_0 |),
                                                                  Value.Integer IntegerKind.Usize 1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool false
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  2;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            2
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            ""
                                                                                          |);
                                                                                          mk_str (|
                                                                                            " X"
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  []
                                                                                                  [
                                                                                                    F
                                                                                                  ]
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    x
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            "X^"
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.path
                                                                                                  "usize"
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    i
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool false
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  2;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  2
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            2
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            ""
                                                                                          |);
                                                                                          mk_str (|
                                                                                            " X^"
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            2
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  []
                                                                                                  [
                                                                                                    F
                                                                                                  ]
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    x
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |);
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.path
                                                                                                  "usize"
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    i
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)))
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)
                              |)
                            |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| " + " |) |) |)
                          ]
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                [
                                  Value.Integer IntegerKind.Usize 1;
                                  Value.Integer IntegerKind.Usize 1
                                ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 1 ]
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                        Value.Array [ mk_str (| "" |) ]
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 1 ]
                                          [ Ty.path "core::fmt::rt::Argument" ],
                                        Value.Array
                                          [
                                            M.call_closure (|
                                              Ty.path "core::fmt::rt::Argument",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Argument",
                                                "new_display",
                                                [],
                                                [ Ty.path "alloc::string::String" ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.borrow (| Pointer.Kind.Ref, str |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt D F)) ].
    End Impl_core_fmt_Display_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    Module Impl_core_ops_arith_Neg_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn neg(self) -> Self {
              Self {
                  value: self.value.map(FA::neg),
              }
          }
      *)
      Definition neg
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                self
              |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "array") [ D ] [ FA ],
                      "map",
                      [],
                      [
                        Ty.function
                          [ FA ]
                          (Ty.associated_in_trait "core::ops::arith::Neg" [] [] FA "Output");
                        FA
                      ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |)
                      |);
                      M.get_trait_method (| "core::ops::arith::Neg", FA, [], [], "neg", [], [] |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D FA)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D FA)); ("neg", InstanceField.Method (neg D FA)) ].
    End Impl_core_ops_arith_Neg_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_Add_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn add(self, rhs: Self) -> Self {
              let mut res = self.value;
              for (r, rhs_val) in res.iter_mut().zip(rhs.value) {
                  *r += rhs_val;
              }
              Self { value: res }
          }
      *)
      Definition add
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                rhs
              |) in
            M.read (|
              let~ res : Ty.apply (Ty.path "array") [ D ] [ FA ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                              Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                  Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                                ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                    Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ],
                                  [],
                                  [],
                                  "zip",
                                  [],
                                  [ Ty.apply (Ty.path "array") [ D ] [ FA ] ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ FA ],
                                      "iter_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ FA ] ],
                                        M.pointer_coercion
                                          M.PointerCoercion.Unsize
                                          (Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "array") [ D ] [ FA ] ])
                                          (Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ FA ] ]),
                                        [ M.borrow (| Pointer.Kind.MutRef, res |) ]
                                      |)
                                    ]
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      rhs,
                                      "p3_field::extension::binomial_extension::BinomialExtensionField",
                                      "value"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                      Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                                    ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ FA ]; FA ]
                                            ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ FA ]; FA ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::zip::Zip")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::IterMut")
                                                    []
                                                    [ FA ];
                                                  Ty.apply
                                                    (Ty.path "core::array::iter::IntoIter")
                                                    [ D ]
                                                    [ FA ]
                                                ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let r :=
                                                M.copy (|
                                                  Ty.apply (Ty.path "&mut") [] [ FA ],
                                                  γ1_0
                                                |) in
                                              let rhs_val := M.copy (| FA, γ1_1 |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_trait_method (|
                                                      "core::ops::arith::AddAssign",
                                                      FA,
                                                      [],
                                                      [ FA ],
                                                      "add_assign",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| r |) |)
                                                      |);
                                                      M.read (| rhs_val |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                Value.mkStructRecord
                  "p3_field::extension::binomial_extension::BinomialExtensionField"
                  [ D ]
                  [ FA ]
                  [ ("value", M.read (| res |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D FA)); ("add", InstanceField.Method (add D FA)) ].
    End Impl_core_ops_arith_Add_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_Add_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn add(mut self, rhs: FA) -> Self {
              self.value[0] += rhs;
              self
          }
      *)
      Definition add
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                self
              |) in
            let rhs := M.alloc (| FA, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    FA,
                    [],
                    [ FA ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              self
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D FA)); ("add", InstanceField.Method (add D FA)) ].
    End Impl_core_ops_arith_Add_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_AddAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn add_assign(&mut self, rhs: Self) {
              for i in 0..D {
                  self.value[i] += rhs.value[i].clone();
              }
          }
      *)
      Definition add_assign
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                rhs
              |) in
            M.read (|
              M.use
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", D) ]
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter :=
                            M.copy (|
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              γ
                            |) in
                          M.read (|
                            M.loop (|
                              Ty.tuple [],
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.never_to_any (| M.read (| M.break (||) |) |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                          M.read (|
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "core::ops::arith::AddAssign",
                                                  FA,
                                                  [],
                                                  [ FA ],
                                                  "add_assign",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_array_field (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                        "value"
                                                      |),
                                                      M.read (| i |)
                                                    |)
                                                  |);
                                                  M.call_closure (|
                                                    FA,
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      FA,
                                                      [],
                                                      [],
                                                      "clone",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_array_field (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            rhs,
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                            "value"
                                                          |),
                                                          M.read (| i |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |) in
                                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            |)
                          |)))
                    ]
                  |)
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign D FA)) ].
    End Impl_core_ops_arith_AddAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_AddAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn add_assign(&mut self, rhs: FA) {
              self.value[0] += rhs;
          }
      *)
      Definition add_assign
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let rhs := M.alloc (| FA, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    FA,
                    [],
                    [ FA ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign D FA)) ].
    End Impl_core_ops_arith_AddAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_iter_traits_accum_Sum_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
              iter.fold(Self::ZERO, |acc, x| acc + x)
          }
      *)
      Definition sum
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "fold",
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ];
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ];
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ]
                    ]
                    (Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ])
                ]
              |),
              [
                M.read (| iter |);
                M.read (|
                  get_constant (|
                    "p3_field::field::FieldAlgebra::ZERO",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ FA ],
                            M.alloc (|
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ FA ],
                              α0
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc :=
                                    M.copy (|
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ FA ],
                                      γ
                                    |) in
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                      [ D ]
                                      [ FA ],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ FA ],
                                      α1
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x :=
                                            M.copy (|
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ FA ],
                                              γ
                                            |) in
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ FA ],
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ FA ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                  [ D ]
                                                  [ FA ]
                                              ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| acc |); M.read (| x |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Sum"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *) [ ("sum", InstanceField.Method (sum D FA)) ].
    End Impl_core_iter_traits_accum_Sum_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_Sub_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn sub(self, rhs: Self) -> Self {
              let mut res = self.value;
              for (r, rhs_val) in res.iter_mut().zip(rhs.value) {
                  *r -= rhs_val;
              }
              Self { value: res }
          }
      *)
      Definition sub
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                rhs
              |) in
            M.read (|
              let~ res : Ty.apply (Ty.path "array") [ D ] [ FA ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                              Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                  Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                                ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                    Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ],
                                  [],
                                  [],
                                  "zip",
                                  [],
                                  [ Ty.apply (Ty.path "array") [ D ] [ FA ] ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ FA ],
                                      "iter_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ FA ] ],
                                        M.pointer_coercion
                                          M.PointerCoercion.Unsize
                                          (Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "array") [ D ] [ FA ] ])
                                          (Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ FA ] ]),
                                        [ M.borrow (| Pointer.Kind.MutRef, res |) ]
                                      |)
                                    ]
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      rhs,
                                      "p3_field::extension::binomial_extension::BinomialExtensionField",
                                      "value"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ FA ];
                                      Ty.apply (Ty.path "core::array::iter::IntoIter") [ D ] [ FA ]
                                    ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ FA ]; FA ]
                                            ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ FA ]; FA ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::zip::Zip")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::IterMut")
                                                    []
                                                    [ FA ];
                                                  Ty.apply
                                                    (Ty.path "core::array::iter::IntoIter")
                                                    [ D ]
                                                    [ FA ]
                                                ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let r :=
                                                M.copy (|
                                                  Ty.apply (Ty.path "&mut") [] [ FA ],
                                                  γ1_0
                                                |) in
                                              let rhs_val := M.copy (| FA, γ1_1 |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_trait_method (|
                                                      "core::ops::arith::SubAssign",
                                                      FA,
                                                      [],
                                                      [ FA ],
                                                      "sub_assign",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| r |) |)
                                                      |);
                                                      M.read (| rhs_val |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                Value.mkStructRecord
                  "p3_field::extension::binomial_extension::BinomialExtensionField"
                  [ D ]
                  [ FA ]
                  [ ("value", M.read (| res |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D FA)); ("sub", InstanceField.Method (sub D FA)) ].
    End Impl_core_ops_arith_Sub_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_Sub_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn sub(self, rhs: FA) -> Self {
              let mut res = self.value;
              res[0] -= rhs;
              Self { value: res }
          }
      *)
      Definition sub
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                self
              |) in
            let rhs := M.alloc (| FA, rhs |) in
            M.read (|
              let~ res : Ty.apply (Ty.path "array") [ D ] [ FA ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::SubAssign",
                    FA,
                    [],
                    [ FA ],
                    "sub_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (| res, Value.Integer IntegerKind.Usize 0 |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                Value.mkStructRecord
                  "p3_field::extension::binomial_extension::BinomialExtensionField"
                  [ D ]
                  [ FA ]
                  [ ("value", M.read (| res |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D FA)); ("sub", InstanceField.Method (sub D FA)) ].
    End Impl_core_ops_arith_Sub_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_SubAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn sub_assign(&mut self, rhs: Self) {
              *self = self.clone() - rhs;
          }
      *)
      Definition sub_assign
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ],
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ FA ]
                      ],
                      "sub",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ FA ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| rhs |)
                    ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign D FA)) ].
    End Impl_core_ops_arith_SubAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_SubAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn sub_assign(&mut self, rhs: FA) {
              *self = self.clone() - rhs;
          }
      *)
      Definition sub_assign
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let rhs := M.alloc (| FA, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ],
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ],
                      [],
                      [ FA ],
                      "sub",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ FA ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| rhs |)
                    ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign D FA)) ].
    End Impl_core_ops_arith_SubAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_Mul_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn mul(self, rhs: Self) -> Self {
              let a = self.value;
              let b = rhs.value;
              let mut res = Self::default();
              let w = FA::F::W;
              let w_af = FA::from_f(w);
      
              match D {
                  2 => {
                      res.value[0] = a[0].clone() * b[0].clone() + a[1].clone() * w_af * b[1].clone();
                      res.value[1] = a[0].clone() * b[1].clone() + a[1].clone() * b[0].clone();
                  }
                  3 => cubic_mul(&a, &b, &mut res.value, w_af),
                  _ =>
                  {
                      #[allow(clippy::needless_range_loop)]
                      for i in 0..D {
                          for j in 0..D {
                              if i + j >= D {
                                  res.value[i + j - D] += a[i].clone() * w_af.clone() * b[j].clone();
                              } else {
                                  res.value[i + j] += a[i].clone() * b[j].clone();
                              }
                          }
                      }
                  }
              }
              res
          }
      *)
      Definition mul
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                rhs
              |) in
            M.read (|
              let~ a : Ty.apply (Ty.path "array") [ D ] [ FA ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ b : Ty.apply (Ty.path "array") [ D ] [ FA ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    rhs,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ res :
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |) in
              let~ w : Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] FA "F" :=
                M.read (|
                  get_constant (|
                    "p3_field::extension::BinomiallyExtendable::W",
                    Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] FA "F"
                  |)
                |) in
              let~ w_af : FA :=
                M.call_closure (|
                  FA,
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    FA,
                    [],
                    [],
                    "from_f",
                    [],
                    []
                  |),
                  [ M.read (| w |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.path "usize", D |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          is_constant_or_break_match (|
                            M.read (| γ |),
                            Value.Integer IntegerKind.Usize 2
                          |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.write (|
                              M.SubPointer.get_array_field (|
                                M.SubPointer.get_struct_record_field (|
                                  res,
                                  "p3_field::extension::binomial_extension::BinomialExtensionField",
                                  "value"
                                |),
                                Value.Integer IntegerKind.Usize 0
                              |),
                              M.call_closure (|
                                FA,
                                M.get_trait_method (|
                                  "core::ops::arith::Add",
                                  FA,
                                  [],
                                  [ FA ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    FA,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      FA,
                                      [],
                                      [ FA ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          FA,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_array_field (|
                                              a,
                                              Value.Integer IntegerKind.Usize 0
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          FA,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_array_field (|
                                              b,
                                              Value.Integer IntegerKind.Usize 0
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    FA,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      FA,
                                      [],
                                      [ FA ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::ops::arith::Mul",
                                          FA,
                                          [],
                                          [ FA ],
                                          "mul",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            FA,
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              FA,
                                              [],
                                              [],
                                              "clone",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_array_field (|
                                                  a,
                                                  Value.Integer IntegerKind.Usize 1
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.read (| w_af |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          FA,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_array_field (|
                                              b,
                                              Value.Integer IntegerKind.Usize 1
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.write (|
                              M.SubPointer.get_array_field (|
                                M.SubPointer.get_struct_record_field (|
                                  res,
                                  "p3_field::extension::binomial_extension::BinomialExtensionField",
                                  "value"
                                |),
                                Value.Integer IntegerKind.Usize 1
                              |),
                              M.call_closure (|
                                FA,
                                M.get_trait_method (|
                                  "core::ops::arith::Add",
                                  FA,
                                  [],
                                  [ FA ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    FA,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      FA,
                                      [],
                                      [ FA ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          FA,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_array_field (|
                                              a,
                                              Value.Integer IntegerKind.Usize 0
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          FA,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_array_field (|
                                              b,
                                              Value.Integer IntegerKind.Usize 1
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    FA,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      FA,
                                      [],
                                      [ FA ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          FA,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_array_field (|
                                              a,
                                              Value.Integer IntegerKind.Usize 1
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        FA,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          FA,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_array_field (|
                                              b,
                                              Value.Integer IntegerKind.Usize 0
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          is_constant_or_break_match (|
                            M.read (| γ |),
                            Value.Integer IntegerKind.Usize 3
                          |) in
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "p3_field::extension::binomial_extension::cubic_mul",
                            [ D ],
                            [ FA ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, b |) |)
                            |);
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    res,
                                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                                    "value"
                                  |)
                                |)
                              |)
                            |);
                            M.read (| w_af |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.read (|
                          M.use
                            (M.alloc (|
                              Ty.tuple [],
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      [],
                                      [],
                                      "into_iter",
                                      [],
                                      []
                                    |),
                                    [
                                      Value.mkStructRecord
                                        "core::ops::range::Range"
                                        []
                                        [ Ty.path "usize" ]
                                        [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", D)
                                        ]
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let iter :=
                                        M.copy (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          γ
                                        |) in
                                      M.read (|
                                        M.loop (|
                                          Ty.tuple [],
                                          ltac:(M.monadic
                                            (let~ _ : Ty.tuple [] :=
                                              M.match_operator (|
                                                Ty.tuple [],
                                                M.alloc (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.path "usize" ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::Range")
                                                        []
                                                        [ Ty.path "usize" ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.MutRef, iter |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let _ :=
                                                        M.is_struct_tuple (|
                                                          γ,
                                                          "core::option::Option::None"
                                                        |) in
                                                      M.never_to_any (|
                                                        M.read (| M.break (||) |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                                      M.read (|
                                                        M.use
                                                          (M.alloc (|
                                                            Ty.tuple [],
                                                            M.match_operator (|
                                                              Ty.tuple [],
                                                              M.alloc (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  []
                                                                  [ Ty.path "usize" ],
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ops::range::Range")
                                                                    []
                                                                    [ Ty.path "usize" ],
                                                                  M.get_trait_method (|
                                                                    "core::iter::traits::collect::IntoIterator",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::ops::range::Range")
                                                                      []
                                                                      [ Ty.path "usize" ],
                                                                    [],
                                                                    [],
                                                                    "into_iter",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    Value.mkStructRecord
                                                                      "core::ops::range::Range"
                                                                      []
                                                                      [ Ty.path "usize" ]
                                                                      [
                                                                        ("start",
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            0);
                                                                        ("end_", D)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |),
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let iter :=
                                                                      M.copy (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::ops::range::Range")
                                                                          []
                                                                          [ Ty.path "usize" ],
                                                                        γ
                                                                      |) in
                                                                    M.read (|
                                                                      M.loop (|
                                                                        Ty.tuple [],
                                                                        ltac:(M.monadic
                                                                          (let~ _ : Ty.tuple [] :=
                                                                            M.match_operator (|
                                                                              Ty.tuple [],
                                                                              M.alloc (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::option::Option")
                                                                                  []
                                                                                  [ Ty.path "usize"
                                                                                  ],
                                                                                M.call_closure (|
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::option::Option")
                                                                                    []
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ],
                                                                                  M.get_trait_method (|
                                                                                    "core::iter::traits::iterator::Iterator",
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::ops::range::Range")
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ],
                                                                                    [],
                                                                                    [],
                                                                                    "next",
                                                                                    [],
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.MutRef,
                                                                                      M.deref (|
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.MutRef,
                                                                                          iter
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let _ :=
                                                                                      M.is_struct_tuple (|
                                                                                        γ,
                                                                                        "core::option::Option::None"
                                                                                      |) in
                                                                                    M.never_to_any (|
                                                                                      M.read (|
                                                                                        M.break (||)
                                                                                      |)
                                                                                    |)));
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let γ0_0 :=
                                                                                      M.SubPointer.get_struct_tuple_field (|
                                                                                        γ,
                                                                                        "core::option::Option::Some",
                                                                                        0
                                                                                      |) in
                                                                                    let j :=
                                                                                      M.copy (|
                                                                                        Ty.path
                                                                                          "usize",
                                                                                        γ0_0
                                                                                      |) in
                                                                                    M.match_operator (|
                                                                                      Ty.tuple [],
                                                                                      M.alloc (|
                                                                                        Ty.tuple [],
                                                                                        Value.Tuple
                                                                                          []
                                                                                      |),
                                                                                      [
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (let
                                                                                                  γ :=
                                                                                              M.use
                                                                                                (M.alloc (|
                                                                                                  Ty.path
                                                                                                    "bool",
                                                                                                  M.call_closure (|
                                                                                                    Ty.path
                                                                                                      "bool",
                                                                                                    BinOp.ge,
                                                                                                    [
                                                                                                      M.call_closure (|
                                                                                                        Ty.path
                                                                                                          "usize",
                                                                                                        BinOp.Wrap.add,
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            i
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            j
                                                                                                          |)
                                                                                                        ]
                                                                                                      |);
                                                                                                      D
                                                                                                    ]
                                                                                                  |)
                                                                                                |)) in
                                                                                            let _ :=
                                                                                              is_constant_or_break_match (|
                                                                                                M.read (|
                                                                                                  γ
                                                                                                |),
                                                                                                Value.Bool
                                                                                                  true
                                                                                              |) in
                                                                                            M.read (|
                                                                                              let~
                                                                                                    _ :
                                                                                                  Ty.tuple
                                                                                                    [] :=
                                                                                                M.call_closure (|
                                                                                                  Ty.tuple
                                                                                                    [],
                                                                                                  M.get_trait_method (|
                                                                                                    "core::ops::arith::AddAssign",
                                                                                                    FA,
                                                                                                    [],
                                                                                                    [
                                                                                                      FA
                                                                                                    ],
                                                                                                    "add_assign",
                                                                                                    [],
                                                                                                    []
                                                                                                  |),
                                                                                                  [
                                                                                                    M.borrow (|
                                                                                                      Pointer.Kind.MutRef,
                                                                                                      M.SubPointer.get_array_field (|
                                                                                                        M.SubPointer.get_struct_record_field (|
                                                                                                          res,
                                                                                                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                                                                          "value"
                                                                                                        |),
                                                                                                        M.call_closure (|
                                                                                                          Ty.path
                                                                                                            "usize",
                                                                                                          BinOp.Wrap.sub,
                                                                                                          [
                                                                                                            M.call_closure (|
                                                                                                              Ty.path
                                                                                                                "usize",
                                                                                                              BinOp.Wrap.add,
                                                                                                              [
                                                                                                                M.read (|
                                                                                                                  i
                                                                                                                |);
                                                                                                                M.read (|
                                                                                                                  j
                                                                                                                |)
                                                                                                              ]
                                                                                                            |);
                                                                                                            D
                                                                                                          ]
                                                                                                        |)
                                                                                                      |)
                                                                                                    |);
                                                                                                    M.call_closure (|
                                                                                                      FA,
                                                                                                      M.get_trait_method (|
                                                                                                        "core::ops::arith::Mul",
                                                                                                        FA,
                                                                                                        [],
                                                                                                        [
                                                                                                          FA
                                                                                                        ],
                                                                                                        "mul",
                                                                                                        [],
                                                                                                        []
                                                                                                      |),
                                                                                                      [
                                                                                                        M.call_closure (|
                                                                                                          FA,
                                                                                                          M.get_trait_method (|
                                                                                                            "core::ops::arith::Mul",
                                                                                                            FA,
                                                                                                            [],
                                                                                                            [
                                                                                                              FA
                                                                                                            ],
                                                                                                            "mul",
                                                                                                            [],
                                                                                                            []
                                                                                                          |),
                                                                                                          [
                                                                                                            M.call_closure (|
                                                                                                              FA,
                                                                                                              M.get_trait_method (|
                                                                                                                "core::clone::Clone",
                                                                                                                FA,
                                                                                                                [],
                                                                                                                [],
                                                                                                                "clone",
                                                                                                                [],
                                                                                                                []
                                                                                                              |),
                                                                                                              [
                                                                                                                M.borrow (|
                                                                                                                  Pointer.Kind.Ref,
                                                                                                                  M.SubPointer.get_array_field (|
                                                                                                                    a,
                                                                                                                    M.read (|
                                                                                                                      i
                                                                                                                    |)
                                                                                                                  |)
                                                                                                                |)
                                                                                                              ]
                                                                                                            |);
                                                                                                            M.call_closure (|
                                                                                                              FA,
                                                                                                              M.get_trait_method (|
                                                                                                                "core::clone::Clone",
                                                                                                                FA,
                                                                                                                [],
                                                                                                                [],
                                                                                                                "clone",
                                                                                                                [],
                                                                                                                []
                                                                                                              |),
                                                                                                              [
                                                                                                                M.borrow (|
                                                                                                                  Pointer.Kind.Ref,
                                                                                                                  w_af
                                                                                                                |)
                                                                                                              ]
                                                                                                            |)
                                                                                                          ]
                                                                                                        |);
                                                                                                        M.call_closure (|
                                                                                                          FA,
                                                                                                          M.get_trait_method (|
                                                                                                            "core::clone::Clone",
                                                                                                            FA,
                                                                                                            [],
                                                                                                            [],
                                                                                                            "clone",
                                                                                                            [],
                                                                                                            []
                                                                                                          |),
                                                                                                          [
                                                                                                            M.borrow (|
                                                                                                              Pointer.Kind.Ref,
                                                                                                              M.SubPointer.get_array_field (|
                                                                                                                b,
                                                                                                                M.read (|
                                                                                                                  j
                                                                                                                |)
                                                                                                              |)
                                                                                                            |)
                                                                                                          ]
                                                                                                        |)
                                                                                                      ]
                                                                                                    |)
                                                                                                  ]
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                Ty.tuple
                                                                                                  [],
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)
                                                                                            |)));
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (M.read (|
                                                                                              let~
                                                                                                    _ :
                                                                                                  Ty.tuple
                                                                                                    [] :=
                                                                                                M.call_closure (|
                                                                                                  Ty.tuple
                                                                                                    [],
                                                                                                  M.get_trait_method (|
                                                                                                    "core::ops::arith::AddAssign",
                                                                                                    FA,
                                                                                                    [],
                                                                                                    [
                                                                                                      FA
                                                                                                    ],
                                                                                                    "add_assign",
                                                                                                    [],
                                                                                                    []
                                                                                                  |),
                                                                                                  [
                                                                                                    M.borrow (|
                                                                                                      Pointer.Kind.MutRef,
                                                                                                      M.SubPointer.get_array_field (|
                                                                                                        M.SubPointer.get_struct_record_field (|
                                                                                                          res,
                                                                                                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                                                                          "value"
                                                                                                        |),
                                                                                                        M.call_closure (|
                                                                                                          Ty.path
                                                                                                            "usize",
                                                                                                          BinOp.Wrap.add,
                                                                                                          [
                                                                                                            M.read (|
                                                                                                              i
                                                                                                            |);
                                                                                                            M.read (|
                                                                                                              j
                                                                                                            |)
                                                                                                          ]
                                                                                                        |)
                                                                                                      |)
                                                                                                    |);
                                                                                                    M.call_closure (|
                                                                                                      FA,
                                                                                                      M.get_trait_method (|
                                                                                                        "core::ops::arith::Mul",
                                                                                                        FA,
                                                                                                        [],
                                                                                                        [
                                                                                                          FA
                                                                                                        ],
                                                                                                        "mul",
                                                                                                        [],
                                                                                                        []
                                                                                                      |),
                                                                                                      [
                                                                                                        M.call_closure (|
                                                                                                          FA,
                                                                                                          M.get_trait_method (|
                                                                                                            "core::clone::Clone",
                                                                                                            FA,
                                                                                                            [],
                                                                                                            [],
                                                                                                            "clone",
                                                                                                            [],
                                                                                                            []
                                                                                                          |),
                                                                                                          [
                                                                                                            M.borrow (|
                                                                                                              Pointer.Kind.Ref,
                                                                                                              M.SubPointer.get_array_field (|
                                                                                                                a,
                                                                                                                M.read (|
                                                                                                                  i
                                                                                                                |)
                                                                                                              |)
                                                                                                            |)
                                                                                                          ]
                                                                                                        |);
                                                                                                        M.call_closure (|
                                                                                                          FA,
                                                                                                          M.get_trait_method (|
                                                                                                            "core::clone::Clone",
                                                                                                            FA,
                                                                                                            [],
                                                                                                            [],
                                                                                                            "clone",
                                                                                                            [],
                                                                                                            []
                                                                                                          |),
                                                                                                          [
                                                                                                            M.borrow (|
                                                                                                              Pointer.Kind.Ref,
                                                                                                              M.SubPointer.get_array_field (|
                                                                                                                b,
                                                                                                                M.read (|
                                                                                                                  j
                                                                                                                |)
                                                                                                              |)
                                                                                                            |)
                                                                                                          ]
                                                                                                        |)
                                                                                                      ]
                                                                                                    |)
                                                                                                  ]
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                Ty.tuple
                                                                                                  [],
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)
                                                                                            |)))
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |) in
                                                                          M.alloc (|
                                                                            Ty.tuple [],
                                                                            Value.Tuple []
                                                                          |)))
                                                                      |)
                                                                    |)))
                                                              ]
                                                            |)
                                                          |))
                                                      |)))
                                                ]
                                              |) in
                                            M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                        |)
                                      |)))
                                ]
                              |)
                            |))
                        |)))
                  ]
                |) in
              res
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D FA)); ("mul", InstanceField.Method (mul D FA)) ].
    End Impl_core_ops_arith_Mul_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_Mul_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn mul(self, rhs: FA) -> Self {
              Self {
                  value: self.value.map(|x| x * rhs.clone()),
              }
          }
      *)
      Definition mul
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                self
              |) in
            let rhs := M.alloc (| FA, rhs |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "array") [ D ] [ FA ],
                      "map",
                      [],
                      [ Ty.function [ FA ] FA; FA ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |)
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  FA,
                                  M.alloc (| FA, α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| FA, γ |) in
                                        M.call_closure (|
                                          FA,
                                          M.get_trait_method (|
                                            "core::ops::arith::Mul",
                                            FA,
                                            [],
                                            [ FA ],
                                            "mul",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| x |);
                                            M.call_closure (|
                                              FA,
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                FA,
                                                [],
                                                [],
                                                "clone",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D FA)); ("mul", InstanceField.Method (mul D FA)) ].
    End Impl_core_ops_arith_Mul_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_iter_traits_accum_Product_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn product<I: Iterator<Item = Self>>(iter: I) -> Self {
              iter.fold(Self::ONE, |acc, x| acc * x)
          }
      *)
      Definition product
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "fold",
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ];
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ];
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ]
                    ]
                    (Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ])
                ]
              |),
              [
                M.read (| iter |);
                M.read (|
                  get_constant (|
                    "p3_field::field::FieldAlgebra::ONE",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ FA ],
                            M.alloc (|
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ FA ],
                              α0
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc :=
                                    M.copy (|
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ FA ],
                                      γ
                                    |) in
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                      [ D ]
                                      [ FA ],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ FA ],
                                      α1
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x :=
                                            M.copy (|
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ FA ],
                                              γ
                                            |) in
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ FA ],
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ FA ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                  [ D ]
                                                  [ FA ]
                                              ],
                                              "mul",
                                              [],
                                              []
                                            |),
                                            [ M.read (| acc |); M.read (| x |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Product"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *) [ ("product", InstanceField.Method (product D FA)) ].
    End Impl_core_iter_traits_accum_Product_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_Div_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*
          fn div(self, rhs: Self) -> Self::Output {
              self * rhs.inverse()
          }
      *)
      Definition div
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F ],
                rhs
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F ],
              M.get_trait_method (|
                "core::ops::arith::Mul",
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F ],
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F ]
                ],
                "mul",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F ],
                  M.get_trait_method (|
                    "p3_field::field::Field",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ],
                    [],
                    [],
                    "inverse",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F ]
          ]
          (Self D F)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F)); ("div", InstanceField.Method (div D F)) ].
    End Impl_core_ops_arith_Div_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    Module Impl_core_ops_arith_DivAssign_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*
          fn div_assign(&mut self, rhs: Self) {
              *self = *self / rhs;
          }
      *)
      Definition div_assign
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F ],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ],
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F ]
                      ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F ]
          ]
          (Self D F)
          (* Instance *) [ ("div_assign", InstanceField.Method (div_assign D F)) ].
    End Impl_core_ops_arith_DivAssign_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    Module Impl_core_ops_arith_MulAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn mul_assign(&mut self, rhs: Self) {
              *self = self.clone() * rhs;
          }
      *)
      Definition mul_assign
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ FA ]
                      ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ FA ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| rhs |)
                    ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ FA ]
          ]
          (Self D FA)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign D FA)) ].
    End Impl_core_ops_arith_MulAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_core_ops_arith_MulAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*
          fn mul_assign(&mut self, rhs: FA) {
              *self = self.clone() * rhs;
          }
      *)
      Definition mul_assign
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            let rhs := M.alloc (| FA, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ FA ],
                      [],
                      [ FA ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ FA ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ FA ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| rhs |)
                    ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign D FA)) ].
    End Impl_core_ops_arith_MulAssign_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_p3_field_field_FieldExtensionAlgebra_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
      Definition Self (D : Value.t) (FA : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ FA ].
      
      (*     const D: usize = D; *)
      (* Ty.path "usize" *)
      Definition value_D
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        ltac:(M.monadic (M.alloc (| Ty.path "usize", D |))).
      
      (*
          fn from_base(b: FA) -> Self {
              Self {
                  value: field_to_array(b),
              }
          }
      *)
      Definition from_base
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ b ] =>
          ltac:(M.monadic
            (let b := M.alloc (| FA, b |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ FA ] |),
                    [ M.read (| b |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_base_slice(bs: &[FA]) -> Self {
              Self::from_base_fn(|i| bs[i].clone())
          }
      *)
      Definition from_base_slice
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ bs ] =>
          ltac:(M.monadic
            (let bs :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ FA ] ],
                bs
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ FA ],
              M.get_trait_method (|
                "p3_field::field::FieldExtensionAlgebra",
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ FA ],
                [],
                [ FA ],
                "from_base_fn",
                [],
                [ Ty.function [ Ty.path "usize" ] FA ]
              |),
              [
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            FA,
                            M.alloc (| Ty.path "usize", α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let i := M.copy (| Ty.path "usize", γ |) in
                                  M.call_closure (|
                                    FA,
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      FA,
                                      [],
                                      [],
                                      "clone",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_array_field (|
                                          M.deref (| M.read (| bs |) |),
                                          M.read (| i |)
                                        |)
                                      |)
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_base_fn<F: FnMut(usize) -> FA>(f: F) -> Self {
              Self {
                  value: array::from_fn(f),
              }
          }
      *)
      Definition from_base_fn
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [ F ], [ f ] =>
          ltac:(M.monadic
            (let f := M.alloc (| F, f |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ FA ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ FA ],
                    M.get_function (| "core::array::from_fn", [ D ], [ FA; F ] |),
                    [ M.read (| f |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_base_iter<I: Iterator<Item = FA>>(iter: I) -> Self {
              let mut res = Self::default();
              for (i, b) in iter.enumerate() {
                  res.value[i] = b;
              }
              res
          }
      *)
      Definition from_base_iter
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.read (|
              let~ res :
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ FA ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply (Ty.path "core::iter::adapters::enumerate::Enumerate") [] [ I ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                              []
                              [ I ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                []
                                [ I ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  []
                                  [ I ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  I,
                                  [],
                                  [],
                                  "enumerate",
                                  [],
                                  []
                                |),
                                [ M.read (| iter |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                    []
                                    [ I ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.tuple [ Ty.path "usize"; FA ] ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.tuple [ Ty.path "usize"; FA ] ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path
                                                  "core::iter::adapters::enumerate::Enumerate")
                                                []
                                                [ I ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let i := M.copy (| Ty.path "usize", γ1_0 |) in
                                              let b := M.copy (| FA, γ1_1 |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.write (|
                                                    M.SubPointer.get_array_field (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        res,
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                        "value"
                                                      |),
                                                      M.read (| i |)
                                                    |),
                                                    M.read (| b |)
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              res
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn as_base_slice(&self) -> &[FA] {
              &self.value
          }
      *)
      Definition as_base_slice
          (D : Value.t)
          (FA : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D FA in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ FA ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ FA ] ],
              M.pointer_coercion
                M.PointerCoercion.Unsize
                (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ])
                (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ FA ] ]),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (FA : Ty.t),
        M.IsTraitInstance
          "p3_field::field::FieldExtensionAlgebra"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ FA ]
          (Self D FA)
          (* Instance *)
          [
            ("value_D", InstanceField.Method (value_D D FA));
            ("from_base", InstanceField.Method (from_base D FA));
            ("from_base_slice", InstanceField.Method (from_base_slice D FA));
            ("from_base_fn", InstanceField.Method (from_base_fn D FA));
            ("from_base_iter", InstanceField.Method (from_base_iter D FA));
            ("as_base_slice", InstanceField.Method (as_base_slice D FA))
          ].
    End Impl_p3_field_field_FieldExtensionAlgebra_where_p3_field_field_FieldAlgebra_FA_where_p3_field_extension_BinomiallyExtendable_associated_in_trait_p3_field_field_FieldAlgebra___FA_F_FA_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_FA.
    
    Module Impl_rand_distributions_distribution_Distribution_where_p3_field_extension_BinomiallyExtendable_F_where_rand_distributions_distribution_Distribution_rand_distributions_Standard_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_for_rand_distributions_Standard.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t := Ty.path "rand::distributions::Standard".
      
      (*
          fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> BinomialExtensionField<F, D> {
              let mut res = [F::ZERO; D];
              for r in res.iter_mut() {
                  *r = Standard.sample(rng);
              }
              BinomialExtensionField::<F, D>::from_base_slice(&res)
          }
      *)
      Definition sample
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [ R ], [ self; rng ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "rand::distributions::Standard" ],
                self
              |) in
            let rng := M.alloc (| Ty.apply (Ty.path "&mut") [] [ R ], rng |) in
            M.read (|
              let~ res : Ty.apply (Ty.path "array") [ D ] [ F ] :=
                lib.repeat (|
                  M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", F |) |),
                  D
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ F ],
                                  "iter_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.Unsize
                                      (Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "array") [ D ] [ F ] ])
                                      (Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                                    [ M.borrow (| Pointer.Kind.MutRef, res |) ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.apply (Ty.path "&mut") [] [ F ] ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.apply (Ty.path "&mut") [] [ F ] ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                []
                                                [ F ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let r :=
                                                M.copy (|
                                                  Ty.apply (Ty.path "&mut") [] [ F ],
                                                  γ0_0
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.write (|
                                                    M.deref (| M.read (| r |) |),
                                                    M.call_closure (|
                                                      F,
                                                      M.get_trait_method (|
                                                        "rand::distributions::distribution::Distribution",
                                                        Ty.path "rand::distributions::Standard",
                                                        [],
                                                        [ F ],
                                                        "sample",
                                                        [],
                                                        [ R ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.path "rand::distributions::Standard",
                                                            Value.StructTuple
                                                              "rand::distributions::Standard"
                                                              []
                                                              []
                                                              []
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (| M.read (| rng |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F ],
                  M.get_trait_method (|
                    "p3_field::field::FieldExtensionAlgebra",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F ],
                    [],
                    [ F ],
                    "from_base_slice",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                      M.pointer_coercion
                        M.PointerCoercion.Unsize
                        (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ F ] ])
                        (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, res |) |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "rand::distributions::distribution::Distribution"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F ]
          ]
          (Self D F)
          (* Instance *) [ ("sample", InstanceField.Method (sample D F)) ].
    End Impl_rand_distributions_distribution_Distribution_where_p3_field_extension_BinomiallyExtendable_F_where_rand_distributions_distribution_Distribution_rand_distributions_Standard_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_for_rand_distributions_Standard.
    
    Module Impl_p3_field_field_TwoAdicField_where_p3_field_field_Field_F_where_p3_field_extension_HasTwoAdicBinomialExtension_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F ].
      
      (*     const TWO_ADICITY: usize = F::EXT_TWO_ADICITY; *)
      (* Ty.path "usize" *)
      Definition value_TWO_ADICITY
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        ltac:(M.monadic
          (get_constant (|
            "p3_field::extension::HasTwoAdicBinomialExtension::EXT_TWO_ADICITY",
            Ty.path "usize"
          |))).
      
      (*
          fn two_adic_generator(bits: usize) -> Self {
              Self {
                  value: F::ext_two_adic_generator(bits),
              }
          }
      *)
      Definition two_adic_generator
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ bits ] =>
          ltac:(M.monadic
            (let bits := M.alloc (| Ty.path "usize", bits |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ F ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ F ],
                    M.get_trait_method (|
                      "p3_field::extension::HasTwoAdicBinomialExtension",
                      F,
                      [ D ],
                      [],
                      "ext_two_adic_generator",
                      [],
                      []
                    |),
                    [ M.read (| bits |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::field::TwoAdicField"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *)
          [
            ("value_TWO_ADICITY", InstanceField.Method (value_TWO_ADICITY D F));
            ("two_adic_generator", InstanceField.Method (two_adic_generator D F))
          ].
    End Impl_p3_field_field_TwoAdicField_where_p3_field_field_Field_F_where_p3_field_extension_HasTwoAdicBinomialExtension_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F.
    
    (*
    fn qudratic_inv<F: Field>(a: &[F], w: F) -> [F; 2] {
        let scalar = (a[0].square() - w * a[1].square()).inverse();
        [a[0] * scalar, -a[1] * scalar]
    }
    *)
    Definition qudratic_inv (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ F ], [ a; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ], a |) in
          let w := M.alloc (| F, w |) in
          M.read (|
            let~ scalar : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      F,
                      M.call_closure (|
                        F,
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          F,
                          [],
                          [ F ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "p3_field::field::FieldAlgebra",
                              F,
                              [],
                              [],
                              "square",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| a |) |),
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              F,
                              [],
                              [ F ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.read (| w |);
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "p3_field::field::FieldAlgebra",
                                  F,
                                  [],
                                  [],
                                  "square",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      M.deref (| M.read (| a |) |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |) in
            M.alloc (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ],
              Value.Array
                [
                  M.call_closure (|
                    F,
                    M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                    [
                      M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |);
                      M.read (| scalar |)
                    ]
                  |);
                  M.call_closure (|
                    F,
                    M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                    [
                      M.call_closure (|
                        F,
                        M.get_trait_method (| "core::ops::arith::Neg", F, [], [], "neg", [], [] |),
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| a |) |),
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |)
                        ]
                      |);
                      M.read (| scalar |)
                    ]
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_qudratic_inv :
      M.IsFunction.C "p3_field::extension::binomial_extension::qudratic_inv" qudratic_inv.
    Admitted.
    Global Typeclasses Opaque qudratic_inv.
    
    (*
    fn cubic_inv<F: Field>(a: &[F], w: F) -> [F; 3] {
        let a0_square = a[0].square();
        let a1_square = a[1].square();
        let a2_w = w * a[2];
        let a0_a1 = a[0] * a[1];
    
        // scalar = (a0^3+wa1^3+w^2a2^3-3wa0a1a2)^-1
        let scalar = (a0_square * a[0] + w * a[1] * a1_square + a2_w.square() * a[2]
            - (F::ONE + F::TWO) * a2_w * a0_a1)
            .inverse();
    
        //scalar*[a0^2-wa1a2, wa2^2-a0a1, a1^2-a0a2]
        [
            scalar * (a0_square - a[1] * a2_w),
            scalar * (a2_w * a[2] - a0_a1),
            scalar * (a1_square - a[0] * a[2]),
        ]
    }
    *)
    Definition cubic_inv (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ F ], [ a; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ], a |) in
          let w := M.alloc (| F, w |) in
          M.read (|
            let~ a0_square : F :=
              M.call_closure (|
                F,
                M.get_trait_method (|
                  "p3_field::field::FieldAlgebra",
                  F,
                  [],
                  [],
                  "square",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |)
                ]
              |) in
            let~ a1_square : F :=
              M.call_closure (|
                F,
                M.get_trait_method (|
                  "p3_field::field::FieldAlgebra",
                  F,
                  [],
                  [],
                  "square",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |)
                ]
              |) in
            let~ a2_w : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                [
                  M.read (| w |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |)
                ]
              |) in
            let~ a0_a1 : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                [
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |)
                ]
              |) in
            let~ scalar : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      F,
                      M.call_closure (|
                        F,
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          F,
                          [],
                          [ F ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              F,
                              [],
                              [ F ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "core::ops::arith::Add",
                                  F,
                                  [],
                                  [ F ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      F,
                                      [],
                                      [ F ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (| a0_square |);
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.deref (| M.read (| a |) |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      F,
                                      [],
                                      [ F ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        F,
                                        M.get_trait_method (|
                                          "core::ops::arith::Mul",
                                          F,
                                          [],
                                          [ F ],
                                          "mul",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| w |);
                                          M.read (|
                                            M.SubPointer.get_array_field (|
                                              M.deref (| M.read (| a |) |),
                                              Value.Integer IntegerKind.Usize 1
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.read (| a1_square |)
                                    ]
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  F,
                                  [],
                                  [ F ],
                                  "mul",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "p3_field::field::FieldAlgebra",
                                      F,
                                      [],
                                      [],
                                      "square",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, a2_w |) ]
                                  |);
                                  M.read (|
                                    M.SubPointer.get_array_field (|
                                      M.deref (| M.read (| a |) |),
                                      Value.Integer IntegerKind.Usize 2
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              F,
                              [],
                              [ F ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  F,
                                  [],
                                  [ F ],
                                  "mul",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Add",
                                      F,
                                      [],
                                      [ F ],
                                      "add",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        get_constant (| "p3_field::field::FieldAlgebra::ONE", F |)
                                      |);
                                      M.read (|
                                        get_constant (| "p3_field::field::FieldAlgebra::TWO", F |)
                                      |)
                                    ]
                                  |);
                                  M.read (| a2_w |)
                                ]
                              |);
                              M.read (| a0_a1 |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |) in
            M.alloc (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 3 ] [ F ],
              Value.Array
                [
                  M.call_closure (|
                    F,
                    M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                    [
                      M.read (| scalar |);
                      M.call_closure (|
                        F,
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          F,
                          [],
                          [ F ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.read (| a0_square |);
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              F,
                              [],
                              [ F ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| a |) |),
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              |);
                              M.read (| a2_w |)
                            ]
                          |)
                        ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    F,
                    M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                    [
                      M.read (| scalar |);
                      M.call_closure (|
                        F,
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          F,
                          [],
                          [ F ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              F,
                              [],
                              [ F ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.read (| a2_w |);
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| a |) |),
                                  Value.Integer IntegerKind.Usize 2
                                |)
                              |)
                            ]
                          |);
                          M.read (| a0_a1 |)
                        ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    F,
                    M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                    [
                      M.read (| scalar |);
                      M.call_closure (|
                        F,
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          F,
                          [],
                          [ F ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.read (| a1_square |);
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              F,
                              [],
                              [ F ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| a |) |),
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| a |) |),
                                  Value.Integer IntegerKind.Usize 2
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_cubic_inv :
      M.IsFunction.C "p3_field::extension::binomial_extension::cubic_inv" cubic_inv.
    Admitted.
    Global Typeclasses Opaque cubic_inv.
    
    (*
    fn cubic_mul<FA: FieldAlgebra, const D: usize>(a: &[FA; D], b: &[FA; D], res: &mut [FA; D], w: FA) {
        assert_eq!(D, 3);
    
        let a0_b0 = a[0].clone() * b[0].clone();
        let a1_b1 = a[1].clone() * b[1].clone();
        let a2_b2 = a[2].clone() * b[2].clone();
    
        res[0] = a0_b0.clone()
            + ((a[1].clone() + a[2].clone()) * (b[1].clone() + b[2].clone())
                - a1_b1.clone()
                - a2_b2.clone())
                * w.clone();
        res[1] = (a[0].clone() + a[1].clone()) * (b[0].clone() + b[1].clone())
            - a0_b0.clone()
            - a1_b1.clone()
            + a2_b2.clone() * w;
        res[2] = (a[0].clone() + a[2].clone()) * (b[0].clone() + b[2].clone()) - a0_b0 - a2_b2 + a1_b1;
    }
    *)
    Definition cubic_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ FA ], [ a; b; res; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
              a
            |) in
          let b :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
              b
            |) in
          let res :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
              res
            |) in
          let w := M.alloc (| FA, w |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Ty.path "usize", D |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            let~ a0_b0 : FA :=
              M.call_closure (|
                FA,
                M.get_trait_method (| "core::ops::arith::Mul", FA, [], [ FA ], "mul", [], [] |),
                [
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| b |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ a1_b1 : FA :=
              M.call_closure (|
                FA,
                M.get_trait_method (| "core::ops::arith::Mul", FA, [], [ FA ], "mul", [], [] |),
                [
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| b |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ a2_b2 : FA :=
              M.call_closure (|
                FA,
                M.get_trait_method (| "core::ops::arith::Mul", FA, [], [ FA ], "mul", [], [] |),
                [
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| b |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 0
                |),
                M.call_closure (|
                  FA,
                  M.get_trait_method (| "core::ops::arith::Add", FA, [], [ FA ], "add", [], [] |),
                  [
                    M.call_closure (|
                      FA,
                      M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, a0_b0 |) ]
                    |);
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        FA,
                        [],
                        [ FA ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          FA,
                          M.get_trait_method (|
                            "core::ops::arith::Sub",
                            FA,
                            [],
                            [ FA ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::ops::arith::Sub",
                                FA,
                                [],
                                [ FA ],
                                "sub",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    FA,
                                    [],
                                    [ FA ],
                                    "mul",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::ops::arith::Add",
                                        FA,
                                        [],
                                        [ FA ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          FA,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            FA,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| a |) |),
                                                Value.Integer IntegerKind.Usize 1
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          FA,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            FA,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| a |) |),
                                                Value.Integer IntegerKind.Usize 2
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::ops::arith::Add",
                                        FA,
                                        [],
                                        [ FA ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          FA,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            FA,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| b |) |),
                                                Value.Integer IntegerKind.Usize 1
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          FA,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            FA,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| b |) |),
                                                Value.Integer IntegerKind.Usize 2
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    FA,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, a1_b1 |) ]
                                |)
                              ]
                            |);
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                FA,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, a2_b2 |) ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          FA,
                          M.get_trait_method (|
                            "core::clone::Clone",
                            FA,
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, w |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 1
                |),
                M.call_closure (|
                  FA,
                  M.get_trait_method (| "core::ops::arith::Add", FA, [], [ FA ], "add", [], [] |),
                  [
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        FA,
                        [],
                        [ FA ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          FA,
                          M.get_trait_method (|
                            "core::ops::arith::Sub",
                            FA,
                            [],
                            [ FA ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                FA,
                                [],
                                [ FA ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    FA,
                                    [],
                                    [ FA ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 1
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    FA,
                                    [],
                                    [ FA ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 1
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |);
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                FA,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, a0_b0 |) ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          FA,
                          M.get_trait_method (|
                            "core::clone::Clone",
                            FA,
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, a1_b1 |) ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        FA,
                        [],
                        [ FA ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          FA,
                          M.get_trait_method (|
                            "core::clone::Clone",
                            FA,
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, a2_b2 |) ]
                        |);
                        M.read (| w |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 2
                |),
                M.call_closure (|
                  FA,
                  M.get_trait_method (| "core::ops::arith::Add", FA, [], [ FA ], "add", [], [] |),
                  [
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        FA,
                        [],
                        [ FA ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          FA,
                          M.get_trait_method (|
                            "core::ops::arith::Sub",
                            FA,
                            [],
                            [ FA ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                FA,
                                [],
                                [ FA ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    FA,
                                    [],
                                    [ FA ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 2
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    FA,
                                    [],
                                    [ FA ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      FA,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        FA,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 2
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |);
                            M.read (| a0_b0 |)
                          ]
                        |);
                        M.read (| a2_b2 |)
                      ]
                    |);
                    M.read (| a1_b1 |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_cubic_mul :
      M.IsFunction.C "p3_field::extension::binomial_extension::cubic_mul" cubic_mul.
    Admitted.
    Global Typeclasses Opaque cubic_mul.
    
    (*
    fn cubic_square<FA: FieldAlgebra, const D: usize>(a: &[FA; D], res: &mut [FA; D], w: FA::F) {
        assert_eq!(D, 3);
    
        let w_a2 = a[2].clone() * FA::from_f(w);
    
        res[0] = a[0].square() + (a[1].clone() * w_a2.clone()).double();
        res[1] = w_a2 * a[2].clone() + (a[0].clone() * a[1].clone()).double();
        res[2] = a[1].square() + (a[0].clone() * a[2].clone()).double();
    }
    *)
    Definition cubic_square (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ FA ], [ a; res; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
              a
            |) in
          let res :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ D ] [ FA ] ],
              res
            |) in
          let w :=
            M.alloc (| Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] FA "F", w |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Ty.path "usize", D |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            let~ w_a2 : FA :=
              M.call_closure (|
                FA,
                M.get_trait_method (| "core::ops::arith::Mul", FA, [], [ FA ], "mul", [], [] |),
                [
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    FA,
                    M.get_trait_method (|
                      "p3_field::field::FieldAlgebra",
                      FA,
                      [],
                      [],
                      "from_f",
                      [],
                      []
                    |),
                    [ M.read (| w |) ]
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 0
                |),
                M.call_closure (|
                  FA,
                  M.get_trait_method (| "core::ops::arith::Add", FA, [], [ FA ], "add", [], [] |),
                  [
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "p3_field::field::FieldAlgebra",
                        FA,
                        [],
                        [],
                        "square",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| a |) |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "p3_field::field::FieldAlgebra",
                        FA,
                        [],
                        [],
                        "double",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            FA,
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                FA,
                                [],
                                [ FA ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    FA,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    FA,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, w_a2 |) ]
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 1
                |),
                M.call_closure (|
                  FA,
                  M.get_trait_method (| "core::ops::arith::Add", FA, [], [ FA ], "add", [], [] |),
                  [
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        FA,
                        [],
                        [ FA ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.read (| w_a2 |);
                        M.call_closure (|
                          FA,
                          M.get_trait_method (|
                            "core::clone::Clone",
                            FA,
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| a |) |),
                                Value.Integer IntegerKind.Usize 2
                              |)
                            |)
                          ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "p3_field::field::FieldAlgebra",
                        FA,
                        [],
                        [],
                        "double",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            FA,
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                FA,
                                [],
                                [ FA ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    FA,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    FA,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 2
                |),
                M.call_closure (|
                  FA,
                  M.get_trait_method (| "core::ops::arith::Add", FA, [], [ FA ], "add", [], [] |),
                  [
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "p3_field::field::FieldAlgebra",
                        FA,
                        [],
                        [],
                        "square",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| a |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      FA,
                      M.get_trait_method (|
                        "p3_field::field::FieldAlgebra",
                        FA,
                        [],
                        [],
                        "double",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            FA,
                            M.call_closure (|
                              FA,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                FA,
                                [],
                                [ FA ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    FA,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  FA,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    FA,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 2
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_cubic_square :
      M.IsFunction.C "p3_field::extension::binomial_extension::cubic_square" cubic_square.
    Admitted.
    Global Typeclasses Opaque cubic_square.
  End binomial_extension.
End extension.
