(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module field.
  (* Trait *)
  Module FieldAlgebra.
    Definition from_bool (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| Ty.path "bool", b |) in
          M.match_operator (|
            Self,
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use b in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.read (| get_constant (| "p3_field::field::FieldAlgebra::ONE", Self |) |)));
              fun γ =>
                ltac:(M.monadic
                  (M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", Self |) |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_from_bool :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "from_bool" from_bool.
    Definition double (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Self,
            M.get_trait_method (| "core::ops::arith::Add", Self, [], [ Self ], "add", [], [] |),
            [
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_double :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "double" double.
    Definition square (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Self,
            M.get_trait_method (| "core::ops::arith::Mul", Self, [], [ Self ], "mul", [], [] |),
            [
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_square :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "square" square.
    Definition cube (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Self,
            M.get_trait_method (| "core::ops::arith::Mul", Self, [], [ Self ], "mul", [], [] |),
            [
              M.call_closure (|
                Self,
                M.get_trait_method (|
                  "p3_field::field::FieldAlgebra",
                  Self,
                  [],
                  [],
                  "square",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_cube : M.IsProvidedMethod "p3_field::field::FieldAlgebra" "cube" cube.
    Definition exp_u64 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; power ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let power := M.alloc (| Ty.path "u64", power |) in
          M.call_closure (|
            Self,
            M.get_trait_method (|
              "p3_field::field::Field",
              Ty.associated_in_trait "p3_field::field::FieldAlgebra" [] [] Self "F",
              [],
              [],
              "exp_u64_generic",
              [],
              [ Self ]
            |),
            [
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.read (| power |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_exp_u64 :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "exp_u64" exp_u64.
    Definition exp_const_u64
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [ POWER ], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.match_operator (|
            Self,
            M.alloc (| Ty.path "u64", POWER |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 0
                    |) in
                  M.read (| get_constant (| "p3_field::field::FieldAlgebra::ONE", Self |) |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 1
                    |) in
                  M.call_closure (|
                    Self,
                    M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 2
                    |) in
                  M.call_closure (|
                    Self,
                    M.get_trait_method (|
                      "p3_field::field::FieldAlgebra",
                      Self,
                      [],
                      [],
                      "square",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 3
                    |) in
                  M.call_closure (|
                    Self,
                    M.get_trait_method (|
                      "p3_field::field::FieldAlgebra",
                      Self,
                      [],
                      [],
                      "cube",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 4
                    |) in
                  M.call_closure (|
                    Self,
                    M.get_trait_method (|
                      "p3_field::field::FieldAlgebra",
                      Self,
                      [],
                      [],
                      "square",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Self,
                          M.call_closure (|
                            Self,
                            M.get_trait_method (|
                              "p3_field::field::FieldAlgebra",
                              Self,
                              [],
                              [],
                              "square",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 5
                    |) in
                  M.call_closure (|
                    Self,
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Self,
                      [],
                      [ Self ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Self,
                        M.get_trait_method (|
                          "p3_field::field::FieldAlgebra",
                          Self,
                          [],
                          [],
                          "square",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Self,
                              M.call_closure (|
                                Self,
                                M.get_trait_method (|
                                  "p3_field::field::FieldAlgebra",
                                  Self,
                                  [],
                                  [],
                                  "square",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            |)
                          |)
                        ]
                      |);
                      M.call_closure (|
                        Self,
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Self,
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 6
                    |) in
                  M.call_closure (|
                    Self,
                    M.get_trait_method (|
                      "p3_field::field::FieldAlgebra",
                      Self,
                      [],
                      [],
                      "cube",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Self,
                          M.call_closure (|
                            Self,
                            M.get_trait_method (|
                              "p3_field::field::FieldAlgebra",
                              Self,
                              [],
                              [],
                              "square",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.U64 7
                    |) in
                  M.read (|
                    let~ x2 : Self :=
                      M.call_closure (|
                        Self,
                        M.get_trait_method (|
                          "p3_field::field::FieldAlgebra",
                          Self,
                          [],
                          [],
                          "square",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |) in
                    let~ x3 : Self :=
                      M.call_closure (|
                        Self,
                        M.get_trait_method (|
                          "core::ops::arith::Mul",
                          Self,
                          [],
                          [ Self ],
                          "mul",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Self,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Self,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, x2 |) ]
                          |);
                          M.call_closure (|
                            Self,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Self,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        ]
                      |) in
                    let~ x4 : Self :=
                      M.call_closure (|
                        Self,
                        M.get_trait_method (|
                          "p3_field::field::FieldAlgebra",
                          Self,
                          [],
                          [],
                          "square",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, x2 |) ]
                      |) in
                    M.alloc (|
                      Self,
                      M.call_closure (|
                        Self,
                        M.get_trait_method (|
                          "core::ops::arith::Mul",
                          Self,
                          [],
                          [ Self ],
                          "mul",
                          [],
                          []
                        |),
                        [ M.read (| x3 |); M.read (| x4 |) ]
                      |)
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.call_closure (|
                    Self,
                    M.get_trait_method (|
                      "p3_field::field::FieldAlgebra",
                      Self,
                      [],
                      [],
                      "exp_u64",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |); POWER ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_exp_const_u64 :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "exp_const_u64" exp_const_u64.
    Definition exp_power_of_2
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; power_log ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let power_log := M.alloc (| Ty.path "usize", power_log |) in
          M.read (|
            let~ res : Self :=
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.alloc (|
                    Ty.tuple [],
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.call_closure (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            Value.mkStructRecord
                              "core::ops::range::Range"
                              []
                              [ Ty.path "usize" ]
                              [
                                ("start", Value.Integer IntegerKind.Usize 0);
                                ("end_", M.read (| power_log |))
                              ]
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter :=
                              M.copy (|
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                γ
                              |) in
                            M.read (|
                              M.loop (|
                                Ty.tuple [],
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.never_to_any (| M.read (| M.break (||) |) |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            M.read (|
                                              let~ _ : Ty.tuple [] :=
                                                M.write (|
                                                  res,
                                                  M.call_closure (|
                                                    Self,
                                                    M.get_trait_method (|
                                                      "p3_field::field::FieldAlgebra",
                                                      Self,
                                                      [],
                                                      [],
                                                      "square",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, res |) ]
                                                  |)
                                                |) in
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                              |)
                            |)))
                      ]
                    |)
                  |))
              |) in
            res
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_exp_power_of_2 :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "exp_power_of_2" exp_power_of_2.
    Definition mul_2exp_u64
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let exp := M.alloc (| Ty.path "u64", exp |) in
          M.call_closure (|
            Self,
            M.get_trait_method (| "core::ops::arith::Mul", Self, [], [ Self ], "mul", [], [] |),
            [
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.call_closure (|
                Self,
                M.get_trait_method (|
                  "p3_field::field::FieldAlgebra",
                  Self,
                  [],
                  [],
                  "exp_u64",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    get_constant (| "p3_field::field::FieldAlgebra::TWO", Self |)
                  |);
                  M.read (| exp |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_mul_2exp_u64 :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "mul_2exp_u64" mul_2exp_u64.
    Definition powers (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ],
            M.get_trait_method (|
              "p3_field::field::FieldAlgebra",
              Self,
              [],
              [],
              "shifted_powers",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.read (| get_constant (| "p3_field::field::FieldAlgebra::ONE", Self |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_powers :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "powers" powers.
    Definition shifted_powers
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; start ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let start := M.alloc (| Self, start |) in
          Value.mkStructRecord
            "p3_field::field::Powers"
            []
            [ Self ]
            [
              ("base",
                M.call_closure (|
                  Self,
                  M.get_trait_method (| "core::clone::Clone", Self, [], [], "clone", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |));
              ("current", M.read (| start |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_shifted_powers :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "shifted_powers" shifted_powers.
    Definition powers_packed
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ P ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::field::Powers") [] [ P ],
            M.get_trait_method (|
              "p3_field::field::FieldAlgebra",
              Self,
              [],
              [],
              "shifted_powers_packed",
              [],
              [ P ]
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.read (| get_constant (| "p3_field::field::FieldAlgebra::ONE", Self |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_powers_packed :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "powers_packed" powers_packed.
    Definition shifted_powers_packed
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ P ], [ self; start ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let start := M.alloc (| Self, start |) in
          M.read (|
            let~ current : P :=
              M.call_closure (|
                P,
                M.get_trait_method (|
                  "p3_field::field::FieldAlgebra",
                  P,
                  [],
                  [],
                  "from_f",
                  [],
                  []
                |),
                [ M.read (| start |) ]
              |) in
            let~ slice : Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ] :=
              M.call_closure (|
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ],
                M.get_trait_method (|
                  "p3_field::packed::PackedValue",
                  P,
                  [],
                  [],
                  "as_slice_mut",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, current |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.alloc (|
                    Ty.tuple [],
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.call_closure (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            Value.mkStructRecord
                              "core::ops::range::Range"
                              []
                              [ Ty.path "usize" ]
                              [
                                ("start", Value.Integer IntegerKind.Usize 1);
                                ("end_",
                                  M.read (|
                                    get_constant (|
                                      "p3_field::packed::PackedValue::WIDTH",
                                      Ty.path "usize"
                                    |)
                                  |))
                              ]
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter :=
                              M.copy (|
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                γ
                              |) in
                            M.read (|
                              M.loop (|
                                Ty.tuple [],
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.never_to_any (| M.read (| M.break (||) |) |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                            M.read (|
                                              let~ _ : Ty.tuple [] :=
                                                M.write (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| slice |) |),
                                                    M.read (| i |)
                                                  |),
                                                  M.call_closure (|
                                                    Self,
                                                    M.get_trait_method (|
                                                      "core::ops::arith::Mul",
                                                      Self,
                                                      [],
                                                      [ Self ],
                                                      "mul",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Self,
                                                        M.get_trait_method (|
                                                          "core::clone::Clone",
                                                          Self,
                                                          [],
                                                          [],
                                                          "clone",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.SubPointer.get_array_field (|
                                                              M.deref (| M.read (| slice |) |),
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.sub,
                                                                [
                                                                  M.read (| i |);
                                                                  Value.Integer IntegerKind.Usize 1
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        Self,
                                                        M.get_trait_method (|
                                                          "core::clone::Clone",
                                                          Self,
                                                          [],
                                                          [],
                                                          "clone",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                              |)
                            |)))
                      ]
                    |)
                  |))
              |) in
            M.alloc (|
              Ty.apply (Ty.path "p3_field::field::Powers") [] [ P ],
              Value.mkStructRecord
                "p3_field::field::Powers"
                []
                [ P ]
                [
                  ("base",
                    M.call_closure (|
                      P,
                      M.get_trait_method (|
                        "p3_field::field::FieldAlgebra",
                        P,
                        [],
                        [],
                        "exp_u64",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            P,
                            M.call_closure (|
                              P,
                              M.get_trait_method (|
                                "p3_field::field::FieldAlgebra",
                                P,
                                [],
                                [],
                                "from_f",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Self,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    Self,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.cast
                          (Ty.path "u64")
                          (M.read (|
                            get_constant (|
                              "p3_field::packed::PackedValue::WIDTH",
                              Ty.path "usize"
                            |)
                          |))
                      ]
                    |));
                  ("current", M.read (| current |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_shifted_powers_packed :
      M.IsProvidedMethod
        "p3_field::field::FieldAlgebra"
        "shifted_powers_packed"
        shifted_powers_packed.
    Definition dot_product
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [ N ], [], [ u; v ] =>
        ltac:(M.monadic
          (let u :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Self ] ],
              u
            |) in
          let v :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Self ] ],
              v
            |) in
          M.call_closure (|
            Self,
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ]
                    ];
                  Ty.function
                    [
                      Ty.tuple
                        [ Ty.apply (Ty.path "&") [] [ Self ]; Ty.apply (Ty.path "&") [] [ Self ] ]
                    ]
                    Self
                ],
              [],
              [],
              "sum",
              [],
              [ Self ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ];
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ]
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.apply (Ty.path "&") [] [ Self ]; Ty.apply (Ty.path "&") [] [ Self ] ]
                      ]
                      Self
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ]
                    ],
                  [],
                  [],
                  "map",
                  [],
                  [
                    Self;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.apply (Ty.path "&") [] [ Self ]; Ty.apply (Ty.path "&") [] [ Self ] ]
                      ]
                      Self
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ];
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ],
                      [],
                      [],
                      "zip",
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Self ] ] ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Self ],
                          "iter",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ],
                            M.pointer_coercion
                              M.PointerCoercion.Unsize
                              (Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ N ] [ Self ] ])
                              (Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Self ] ]),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| u |) |) |) ]
                          |)
                        ]
                      |);
                      M.read (| v |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Self,
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ Self ];
                                    Ty.apply (Ty.path "&") [] [ Self ]
                                  ],
                                α0
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let x :=
                                      M.copy (| Ty.apply (Ty.path "&") [] [ Self ], γ0_0 |) in
                                    let y :=
                                      M.copy (| Ty.apply (Ty.path "&") [] [ Self ], γ0_1 |) in
                                    M.call_closure (|
                                      Self,
                                      M.get_trait_method (|
                                        "core::ops::arith::Mul",
                                        Self,
                                        [],
                                        [ Self ],
                                        "mul",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Self,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Self,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| x |) |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Self,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Self,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| y |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_dot_product :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "dot_product" dot_product.
    Definition zero_vec (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| Ty.path "usize", len |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ Self; Ty.path "alloc::alloc::Global" ],
            M.get_function (| "alloc::vec::from_elem", [], [ Self ] |),
            [
              M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", Self |) |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_zero_vec :
      M.IsProvidedMethod "p3_field::field::FieldAlgebra" "zero_vec" zero_vec.
  End FieldAlgebra.
  
  (* Trait *)
  Module Field.
    Definition is_zero (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", Self, [], [ Self ], "eq", [], [] |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                get_constant (| "p3_field::field::FieldAlgebra::ZERO", Self |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_is_zero : M.IsProvidedMethod "p3_field::field::Field" "is_zero" is_zero.
    Definition is_one (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", Self, [], [ Self ], "eq", [], [] |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                get_constant (| "p3_field::field::FieldAlgebra::ONE", Self |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_is_one : M.IsProvidedMethod "p3_field::field::Field" "is_one" is_one.
    Definition div_2exp_u64
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let exp := M.alloc (| Ty.path "u64", exp |) in
          M.call_closure (|
            Self,
            M.get_trait_method (| "core::ops::arith::Div", Self, [], [ Self ], "div", [], [] |),
            [
              M.read (| M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Self,
                M.get_trait_method (|
                  "p3_field::field::FieldAlgebra",
                  Self,
                  [],
                  [],
                  "exp_u64",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    get_constant (| "p3_field::field::FieldAlgebra::TWO", Self |)
                  |);
                  M.read (| exp |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_div_2exp_u64 :
      M.IsProvidedMethod "p3_field::field::Field" "div_2exp_u64" div_2exp_u64.
    Definition exp_u64_generic
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ FA ], [ val; power ] =>
        ltac:(M.monadic
          (let val := M.alloc (| FA, val |) in
          let power := M.alloc (| Ty.path "u64", power |) in
          M.call_closure (|
            FA,
            M.get_function (| "p3_field::exponentiation::exp_u64_by_squaring", [], [ FA ] |),
            [ M.read (| val |); M.read (| power |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_exp_u64_generic :
      M.IsProvidedMethod "p3_field::field::Field" "exp_u64_generic" exp_u64_generic.
    Definition inverse (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Self,
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Self ],
              "expect",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                M.get_trait_method (|
                  "p3_field::field::Field",
                  Self,
                  [],
                  [],
                  "try_inverse",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Tried to invert zero" |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_inverse : M.IsProvidedMethod "p3_field::field::Field" "inverse" inverse.
    Definition halve (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.read (|
            let~ half : Self :=
              M.call_closure (|
                Self,
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                  "expect",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                    M.get_trait_method (|
                      "p3_field::field::Field",
                      Self,
                      [],
                      [],
                      "try_inverse",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        get_constant (| "p3_field::field::FieldAlgebra::TWO", Self |)
                      |)
                    ]
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| mk_str (| "Cannot divide by 2 in fields with characteristic 2" |) |)
                  |)
                ]
              |) in
            M.alloc (|
              Self,
              M.call_closure (|
                Self,
                M.get_trait_method (| "core::ops::arith::Mul", Self, [], [ Self ], "mul", [], [] |),
                [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| half |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_halve : M.IsProvidedMethod "p3_field::field::Field" "halve" halve.
    Definition multiplicative_group_factors
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ primality_test : Ty.path "nums::miller_rabin::MillerRabin" :=
              Value.mkStructRecord
                "nums::miller_rabin::MillerRabin"
                []
                []
                [ ("error_bits", Value.Integer IntegerKind.Usize 128) ] in
            let~ composite_splitter : Ty.path "nums::pollard_rho::PollardRho" :=
              Value.StructTuple "nums::pollard_rho::PollardRho" [] [] [] in
            let~ factorizer :
                Ty.apply
                  (Ty.path "nums::adapters::FactorizerFromSplitter")
                  []
                  [
                    Ty.path "nums::miller_rabin::MillerRabin";
                    Ty.path "nums::pollard_rho::PollardRho"
                  ] :=
              Value.mkStructRecord
                "nums::adapters::FactorizerFromSplitter"
                []
                [ Ty.path "nums::miller_rabin::MillerRabin"; Ty.path "nums::pollard_rho::PollardRho"
                ]
                [
                  ("primality_test", M.read (| primality_test |));
                  ("composite_splitter", M.read (| composite_splitter |))
                ] in
            let~ n : Ty.path "num_bigint::biguint::BigUint" :=
              M.call_closure (|
                Ty.path "num_bigint::biguint::BigUint",
                M.get_trait_method (|
                  "core::ops::arith::Sub",
                  Ty.path "num_bigint::biguint::BigUint",
                  [],
                  [ Ty.path "num_bigint::biguint::BigUint" ],
                  "sub",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.path "num_bigint::biguint::BigUint",
                    M.get_trait_method (|
                      "p3_field::field::Field",
                      Self,
                      [],
                      [],
                      "order",
                      [],
                      []
                    |),
                    []
                  |);
                  M.call_closure (|
                    Ty.path "num_bigint::biguint::BigUint",
                    M.get_trait_method (|
                      "num_traits::identities::One",
                      Ty.path "num_bigint::biguint::BigUint",
                      [],
                      [],
                      "one",
                      [],
                      []
                    |),
                    []
                  |)
                ]
              |) in
            M.alloc (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.tuple [ Ty.path "num_bigint::biguint::BigUint"; Ty.path "usize" ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.tuple [ Ty.path "num_bigint::biguint::BigUint"; Ty.path "usize" ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "nums::traits::Factorizer",
                  Ty.apply
                    (Ty.path "nums::adapters::FactorizerFromSplitter")
                    []
                    [
                      Ty.path "nums::miller_rabin::MillerRabin";
                      Ty.path "nums::pollard_rho::PollardRho"
                    ],
                  [],
                  [],
                  "factor_counts",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, factorizer |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_multiplicative_group_factors :
      M.IsProvidedMethod
        "p3_field::field::Field"
        "multiplicative_group_factors"
        multiplicative_group_factors.
    Definition bits (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.cast
            (Ty.path "usize")
            (M.call_closure (|
              Ty.path "u64",
              M.get_associated_function (|
                Ty.path "num_bigint::biguint::BigUint",
                "bits",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Ty.path "num_bigint::biguint::BigUint",
                    M.call_closure (|
                      Ty.path "num_bigint::biguint::BigUint",
                      M.get_trait_method (|
                        "p3_field::field::Field",
                        Self,
                        [],
                        [],
                        "order",
                        [],
                        []
                      |),
                      []
                    |)
                  |)
                |)
              ]
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_bits : M.IsProvidedMethod "p3_field::field::Field" "bits" bits.
  End Field.
  
  (* Trait *)
  (* Empty module 'PrimeField' *)
  
  (* Trait *)
  Module PrimeField64.
    Definition to_unique_u64
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.path "u64",
            M.get_trait_method (|
              "p3_field::field::PrimeField64",
              Self,
              [],
              [],
              "as_canonical_u64",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_to_unique_u64 :
      M.IsProvidedMethod "p3_field::field::PrimeField64" "to_unique_u64" to_unique_u64.
  End PrimeField64.
  
  (* Trait *)
  Module PrimeField32.
    Definition to_unique_u32
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.path "u32",
            M.get_trait_method (|
              "p3_field::field::PrimeField32",
              Self,
              [],
              [],
              "as_canonical_u32",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_to_unique_u32 :
      M.IsProvidedMethod "p3_field::field::PrimeField32" "to_unique_u32" to_unique_u32.
  End PrimeField32.
  
  (* Trait *)
  Module FieldExtensionAlgebra.
    Definition monomial
        (Base Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ exponent ] =>
        ltac:(M.monadic
          (let exponent := M.alloc (| Ty.path "usize", exponent |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.read (| exponent |);
                                  M.read (|
                                    get_constant (|
                                      "p3_field::field::FieldExtensionAlgebra::D",
                                      Ty.path "usize"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [ Value.Integer IntegerKind.Usize 1 ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 1 ]
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                        Value.Array
                                          [ mk_str (| "requested monomial of too high degree" |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            let~ vec :
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ Base; Ty.path "alloc::alloc::Global" ] :=
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ Base; Ty.path "alloc::alloc::Global" ],
                M.get_function (| "alloc::vec::from_elem", [], [ Base ] |),
                [
                  M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", Base |) |);
                  M.read (|
                    get_constant (| "p3_field::field::FieldExtensionAlgebra::D", Ty.path "usize" |)
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Base ],
                    M.get_trait_method (|
                      "core::ops::index::IndexMut",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Base; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ Ty.path "usize" ],
                      "index_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, vec |); M.read (| exponent |) ]
                  |)
                |),
                M.read (| get_constant (| "p3_field::field::FieldAlgebra::ONE", Base |) |)
              |) in
            M.alloc (|
              Self,
              M.call_closure (|
                Self,
                M.get_trait_method (|
                  "p3_field::field::FieldExtensionAlgebra",
                  Self,
                  [],
                  [ Base ],
                  "from_base_slice",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Base ] ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Base; Ty.path "alloc::alloc::Global" ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, vec |) |)
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_monomial :
      forall (Base : Ty.t),
      M.IsProvidedMethod "p3_field::field::FieldExtensionAlgebra" "monomial" (monomial Base).
  End FieldExtensionAlgebra.
  
  (* Trait *)
  Module ExtensionField.
    Definition is_in_basefield
        (Base Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Base ],
              [],
              [],
              "all",
              [],
              [ Ty.function [ Ty.apply (Ty.path "&") [] [ Base ] ] (Ty.path "bool") ]
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.alloc (|
                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Base ],
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Base ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Base ],
                      "iter",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Base ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [] [ Base ],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ops::range::RangeFrom")
                                  []
                                  [ Ty.path "usize" ]
                              ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Base ] ],
                                    M.get_trait_method (|
                                      "p3_field::field::FieldExtensionAlgebra",
                                      Self,
                                      [],
                                      [ Base ],
                                      "as_base_slice",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |);
                              Value.mkStructRecord
                                "core::ops::range::RangeFrom"
                                []
                                [ Ty.path "usize" ]
                                [ ("start", Value.Integer IntegerKind.Usize 1) ]
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |);
              M.get_trait_method (| "p3_field::field::Field", Base, [], [], "is_zero", [], [] |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_is_in_basefield :
      forall (Base : Ty.t),
      M.IsProvidedMethod "p3_field::field::ExtensionField" "is_in_basefield" (is_in_basefield Base).
    Definition as_base
        (Base Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ Base ],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_trait_method (|
                            "p3_field::field::ExtensionField",
                            Self,
                            [],
                            [ Base ],
                            "is_in_basefield",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Base ]
                    [
                      M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Base ] ],
                              M.get_trait_method (|
                                "p3_field::field::FieldExtensionAlgebra",
                                Self,
                                [],
                                [ Base ],
                                "as_base_slice",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic (Value.StructTuple "core::option::Option::None" [] [ Base ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_as_base :
      forall (Base : Ty.t),
      M.IsProvidedMethod "p3_field::field::ExtensionField" "as_base" (as_base Base).
    Definition ext_powers_packed
        (Base Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.read (|
            let~ powers :
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ Self; Ty.path "alloc::alloc::Global" ] :=
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ Self; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "itertools::Itertools",
                  Ty.apply
                    (Ty.path "core::iter::adapters::take::Take")
                    []
                    [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ] ],
                  [],
                  [],
                  "collect_vec",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ] ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ],
                      [],
                      [],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ],
                        M.get_trait_method (|
                          "p3_field::field::FieldAlgebra",
                          Self,
                          [],
                          [],
                          "powers",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [
                          M.read (|
                            get_constant (|
                              "p3_field::packed::PackedValue::WIDTH",
                              Ty.path "usize"
                            |)
                          |);
                          Value.Integer IntegerKind.Usize 1
                        ]
                      |)
                    ]
                  |)
                ]
              |) in
            let~ current :
                Ty.associated_in_trait
                  "p3_field::field::ExtensionField"
                  []
                  [ Base ]
                  Self
                  "ExtensionPacking" :=
              M.call_closure (|
                Ty.associated_in_trait
                  "p3_field::field::ExtensionField"
                  []
                  [ Base ]
                  Self
                  "ExtensionPacking",
                M.get_trait_method (|
                  "p3_field::field::FieldExtensionAlgebra",
                  Ty.associated_in_trait
                    "p3_field::field::ExtensionField"
                    []
                    [ Base ]
                    Self
                    "ExtensionPacking",
                  [],
                  [ Ty.associated_in_trait "p3_field::field::Field" [] [] Base "Packing" ],
                  "from_base_fn",
                  [],
                  [
                    Ty.function
                      [ Ty.path "usize" ]
                      (Ty.associated_in_trait "p3_field::field::Field" [] [] Base "Packing")
                  ]
                |),
                [
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.associated_in_trait "p3_field::field::Field" [] [] Base "Packing",
                              M.alloc (| Ty.path "usize", α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let i := M.copy (| Ty.path "usize", γ |) in
                                    M.call_closure (|
                                      Ty.associated_in_trait
                                        "p3_field::field::Field"
                                        []
                                        []
                                        Base
                                        "Packing",
                                      M.get_trait_method (|
                                        "p3_field::packed::PackedValue",
                                        Ty.associated_in_trait
                                          "p3_field::field::Field"
                                          []
                                          []
                                          Base
                                          "Packing",
                                        [],
                                        [],
                                        "from_fn",
                                        [],
                                        [ Ty.function [ Ty.path "usize" ] Base ]
                                      |),
                                      [
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    Base,
                                                    M.alloc (| Ty.path "usize", α0 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let j :=
                                                            M.copy (| Ty.path "usize", γ |) in
                                                          M.read (|
                                                            M.SubPointer.get_array_field (|
                                                              M.deref (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Base ]
                                                                    ],
                                                                  M.get_trait_method (|
                                                                    "p3_field::field::FieldExtensionAlgebra",
                                                                    Self,
                                                                    [],
                                                                    [ Base ],
                                                                    "as_base_slice",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ Self ],
                                                                          M.get_trait_method (|
                                                                            "core::ops::index::Index",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::vec::Vec")
                                                                              []
                                                                              [
                                                                                Self;
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ],
                                                                            [],
                                                                            [ Ty.path "usize" ],
                                                                            "index",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              powers
                                                                            |);
                                                                            M.read (| j |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |),
                                                              M.read (| i |)
                                                            |)
                                                          |)))
                                                    ]
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end))
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |) in
            let~ multiplier :
                Ty.associated_in_trait
                  "p3_field::field::ExtensionField"
                  []
                  [ Base ]
                  Self
                  "ExtensionPacking" :=
              M.call_closure (|
                Ty.associated_in_trait
                  "p3_field::field::ExtensionField"
                  []
                  [ Base ]
                  Self
                  "ExtensionPacking",
                M.get_trait_method (|
                  "p3_field::field::FieldExtensionAlgebra",
                  Ty.associated_in_trait
                    "p3_field::field::ExtensionField"
                    []
                    [ Base ]
                    Self
                    "ExtensionPacking",
                  [],
                  [ Ty.associated_in_trait "p3_field::field::Field" [] [] Base "Packing" ],
                  "from_base_fn",
                  [],
                  [
                    Ty.function
                      [ Ty.path "usize" ]
                      (Ty.associated_in_trait "p3_field::field::Field" [] [] Base "Packing")
                  ]
                |),
                [
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.associated_in_trait "p3_field::field::Field" [] [] Base "Packing",
                              M.alloc (| Ty.path "usize", α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let i := M.copy (| Ty.path "usize", γ |) in
                                    M.call_closure (|
                                      Ty.associated_in_trait
                                        "p3_field::field::Field"
                                        []
                                        []
                                        Base
                                        "Packing",
                                      M.get_trait_method (|
                                        "core::convert::From",
                                        Ty.associated_in_trait
                                          "p3_field::field::Field"
                                          []
                                          []
                                          Base
                                          "Packing",
                                        [],
                                        [ Base ],
                                        "from",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Base ] ],
                                                M.get_trait_method (|
                                                  "p3_field::field::FieldExtensionAlgebra",
                                                  Self,
                                                  [],
                                                  [ Base ],
                                                  "as_base_slice",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply (Ty.path "&") [] [ Self ],
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [ Self; Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [],
                                                          [ Ty.path "usize" ],
                                                          "index",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.Ref, powers |);
                                                          M.read (|
                                                            get_constant (|
                                                              "p3_field::packed::PackedValue::WIDTH",
                                                              Ty.path "usize"
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |) in
            M.alloc (|
              Ty.apply
                (Ty.path "p3_field::field::Powers")
                []
                [
                  Ty.associated_in_trait
                    "p3_field::field::ExtensionField"
                    []
                    [ Base ]
                    Self
                    "ExtensionPacking"
                ],
              Value.mkStructRecord
                "p3_field::field::Powers"
                []
                [
                  Ty.associated_in_trait
                    "p3_field::field::ExtensionField"
                    []
                    [ Base ]
                    Self
                    "ExtensionPacking"
                ]
                [ ("base", M.read (| multiplier |)); ("current", M.read (| current |)) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_ext_powers_packed :
      forall (Base : Ty.t),
      M.IsProvidedMethod
        "p3_field::field::ExtensionField"
        "ext_powers_packed"
        (ext_powers_packed Base).
  End ExtensionField.
  
  Module Impl_p3_field_field_ExtensionField_where_p3_field_field_Field_F_F_for_F.
    Definition Self (F : Ty.t) : Ty.t := F.
    
    (*     type ExtensionPacking = F::Packing; *)
    Definition _ExtensionPacking (F : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing".
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "p3_field::field::ExtensionField"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self F)
        (* Instance *) [ ("ExtensionPacking", InstanceField.Ty (_ExtensionPacking F)) ].
  End Impl_p3_field_field_ExtensionField_where_p3_field_field_Field_F_F_for_F.
  
  Module Impl_p3_field_field_FieldExtensionAlgebra_where_p3_field_field_FieldAlgebra_FA_FA_for_FA.
    Definition Self (FA : Ty.t) : Ty.t := FA.
    
    (*     const D: usize = 1; *)
    (* Ty.path "usize" *)
    Definition value_D (FA : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self FA in
      ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 1 |))).
    
    (*
        fn from_base(b: FA) -> Self {
            b
        }
    *)
    Definition from_base (FA : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self FA in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| FA, b |) in
          M.read (| b |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_base_slice(bs: &[FA]) -> Self {
            assert_eq!(bs.len(), 1);
            bs[0].clone()
        }
    *)
    Definition from_base_slice
        (FA : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self FA in
      match ε, τ, α with
      | [], [], [ bs ] =>
        ltac:(M.monadic
          (let bs :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ FA ] ], bs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.path "usize",
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ FA ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bs |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 1 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            M.alloc (|
              FA,
              M.call_closure (|
                FA,
                M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| bs |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_base_iter<I: Iterator<Item = FA>>(mut iter: I) -> Self {
            iter.next().unwrap()
        }
    *)
    Definition from_base_iter
        (FA : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self FA in
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| I, iter |) in
          M.call_closure (|
            FA,
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ FA ],
              "unwrap",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ FA ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_base_fn<F: FnMut(usize) -> FA>(mut f: F) -> Self {
            f(0)
        }
    *)
    Definition from_base_fn (FA : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self FA in
      match ε, τ, α with
      | [], [ F ], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| F, f |) in
          M.call_closure (|
            FA,
            M.get_trait_method (|
              "core::ops::function::FnMut",
              F,
              [],
              [ Ty.tuple [ Ty.path "usize" ] ],
              "call_mut",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, f |);
              Value.Tuple [ Value.Integer IntegerKind.Usize 0 ]
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn as_base_slice(&self) -> &[FA] {
            slice::from_ref(self)
        }
    *)
    Definition as_base_slice
        (FA : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self FA in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ FA ], self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ FA ] ],
                M.get_function (| "core::slice::raw::from_ref", [], [ FA ] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (FA : Ty.t),
      M.IsTraitInstance
        "p3_field::field::FieldExtensionAlgebra"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ FA ]
        (Self FA)
        (* Instance *)
        [
          ("value_D", InstanceField.Method (value_D FA));
          ("from_base", InstanceField.Method (from_base FA));
          ("from_base_slice", InstanceField.Method (from_base_slice FA));
          ("from_base_iter", InstanceField.Method (from_base_iter FA));
          ("from_base_fn", InstanceField.Method (from_base_fn FA));
          ("as_base_slice", InstanceField.Method (as_base_slice FA))
        ].
  End Impl_p3_field_field_FieldExtensionAlgebra_where_p3_field_field_FieldAlgebra_FA_FA_for_FA.
  
  (* Trait *)
  (* Empty module 'TwoAdicField' *)
  
  (* StructRecord
    {
      name := "Powers";
      const_params := [];
      ty_params := [ "F" ];
      fields := [ ("base", F); ("current", F) ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_field_field_Powers_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ].
    
    (* Clone *)
    Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
              self
            |) in
          Value.mkStructRecord
            "p3_field::field::Powers"
            []
            [ F ]
            [
              ("base",
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::clone::Clone", F, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::field::Powers",
                            "base"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("current",
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::clone::Clone", F, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::field::Powers",
                            "current"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_field_field_Powers_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_field_field_Powers_F.
    Definition Self (F : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Powers" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "base" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply (Ty.path "&") [] [ F ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::field::Powers",
                          "base"
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "current" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ F ] ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "&") [] [ F ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::field::Powers",
                              "current"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_field_field_Powers_F.
  
  Module Impl_core_iter_traits_iterator_Iterator_where_p3_field_field_FieldAlgebra_FA_for_p3_field_field_Powers_FA.
    Definition Self (FA : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_field::field::Powers") [] [ FA ].
    
    (*     type Item = FA; *)
    Definition _Item (FA : Ty.t) : Ty.t := FA.
    
    (*
        fn next(&mut self) -> Option<FA> {
            let result = self.current.clone();
            self.current *= self.base.clone();
            Some(result)
        }
    *)
    Definition next (FA : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self FA in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ FA ] ],
              self
            |) in
          M.read (|
            let~ result : FA :=
              M.call_closure (|
                FA,
                M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::field::Powers",
                      "current"
                    |)
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::ops::arith::MulAssign",
                  FA,
                  [],
                  [ FA ],
                  "mul_assign",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::field::Powers",
                      "current"
                    |)
                  |);
                  M.call_closure (|
                    FA,
                    M.get_trait_method (| "core::clone::Clone", FA, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::field::Powers",
                          "base"
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (|
              Ty.apply (Ty.path "core::option::Option") [] [ FA ],
              Value.StructTuple "core::option::Option::Some" [] [ FA ] [ M.read (| result |) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (FA : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self FA)
        (* Instance *)
        [ ("Item", InstanceField.Ty (_Item FA)); ("next", InstanceField.Method (next FA)) ].
  End Impl_core_iter_traits_iterator_Iterator_where_p3_field_field_FieldAlgebra_FA_for_p3_field_field_Powers_FA.
End field.
