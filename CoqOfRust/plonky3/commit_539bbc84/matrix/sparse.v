(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sparse.
  (* StructRecord
    {
      name := "CsrMatrix";
      const_params := [];
      ty_params := [ "T" ];
      fields :=
        [
          ("width", Ty.path "usize");
          ("nonzero_values",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ]);
          ("row_indices",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_p3_matrix_sparse_CsrMatrix_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CsrMatrix" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "width" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_matrix::sparse::CsrMatrix",
                          "width"
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "nonzero_values" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ]
                    ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_matrix::sparse::CsrMatrix",
                          "nonzero_values"
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "row_indices" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                        ]
                    ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                            ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_matrix::sparse::CsrMatrix",
                              "row_indices"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_p3_matrix_sparse_CsrMatrix_T.
  
  Module Impl_p3_matrix_sparse_CsrMatrix_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ].
    
    (*
        fn row_index_range(&self, r: usize) -> Range<usize> {
            debug_assert!(r < self.height());
            self.row_indices[r]..self.row_indices[r + 1]
        }
    *)
    Definition row_index_range
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.read (|
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.lt,
                                            [
                                              M.read (| r |);
                                              M.call_closure (|
                                                Ty.path "usize",
                                                M.get_trait_method (|
                                                  "p3_matrix::Matrix",
                                                  Ty.apply
                                                    (Ty.path "p3_matrix::sparse::CsrMatrix")
                                                    []
                                                    [ T ],
                                                  [],
                                                  [ T ],
                                                  "height",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| self |) |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: r < self.height()" |) ]
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            M.alloc (|
              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
              Value.mkStructRecord
                "core::ops::range::Range"
                []
                [ Ty.path "usize" ]
                [
                  ("start",
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [ Ty.path "usize" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_matrix::sparse::CsrMatrix",
                                "row_indices"
                              |)
                            |);
                            M.read (| r |)
                          ]
                        |)
                      |)
                    |));
                  ("end_",
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [ Ty.path "usize" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_matrix::sparse::CsrMatrix",
                                "row_indices"
                              |)
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| r |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          ]
                        |)
                      |)
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_row_index_range :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "row_index_range" (row_index_range T).
    Admitted.
    Global Typeclasses Opaque row_index_range.
    
    (*
        pub fn sparse_row(&self, r: usize) -> &[(usize, T)] {
            &self.nonzero_values[self.row_index_range(r)]
        }
    *)
    Definition sparse_row (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_matrix::sparse::CsrMatrix",
                          "nonzero_values"
                        |)
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                          "row_index_range",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| r |)
                        ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_sparse_row :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "sparse_row" (sparse_row T).
    Admitted.
    Global Typeclasses Opaque sparse_row.
    
    (*
        pub fn sparse_row_mut(&mut self, r: usize) -> &mut [(usize, T)] {
            let range = self.row_index_range(r);
            &mut self.nonzero_values[range]
        }
    *)
    Definition sparse_row_mut
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ range : Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                      "row_index_range",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| r |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                            M.get_trait_method (|
                              "core::ops::index::IndexMut",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ],
                              "index_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_matrix::sparse::CsrMatrix",
                                  "nonzero_values"
                                |)
                              |);
                              M.read (| range |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_sparse_row_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "sparse_row_mut" (sparse_row_mut T).
    Admitted.
    Global Typeclasses Opaque sparse_row_mut.
    
    (*
        pub fn rand_fixed_row_weight<R: Rng>(
            rng: &mut R,
            rows: usize,
            cols: usize,
            row_weight: usize,
        ) -> Self
        where
            T: Default,
            Standard: Distribution<T>,
        {
            let nonzero_values = iter::repeat_with(|| (rng.gen_range(0..cols), rng.gen()))
                .take(rows * row_weight)
                .collect();
            let row_indices = (0..=rows).map(|r| r * row_weight).collect();
            Self {
                width: cols,
                nonzero_values,
                row_indices,
            }
        }
    *)
    Definition rand_fixed_row_weight
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ R ], [ rng; rows; cols; row_weight ] =>
        ltac:(M.monadic
          (let rng := M.alloc (| Ty.apply (Ty.path "&mut") [] [ R ], rng |) in
          let rows := M.alloc (| Ty.path "usize", rows |) in
          let cols := M.alloc (| Ty.path "usize", cols |) in
          let row_weight := M.alloc (| Ty.path "usize", row_weight |) in
          M.read (|
            let~ nonzero_values :
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::take::Take")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                        []
                        [ Ty.function [] (Ty.tuple [ Ty.path "usize"; T ]) ]
                    ],
                  [],
                  [],
                  "collect",
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                          []
                          [ Ty.function [] (Ty.tuple [ Ty.path "usize"; T ]) ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                        []
                        [ Ty.function [] (Ty.tuple [ Ty.path "usize"; T ]) ],
                      [],
                      [],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                          []
                          [ Ty.function [] (Ty.tuple [ Ty.path "usize"; T ]) ],
                        M.get_function (|
                          "core::iter::sources::repeat_with::repeat_with",
                          [],
                          [
                            Ty.tuple [ Ty.path "usize"; T ];
                            Ty.function [] (Ty.tuple [ Ty.path "usize"; T ])
                          ]
                        |),
                        [
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.tuple [ Ty.path "usize"; T ],
                                      M.alloc (| Ty.tuple [], α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (Value.Tuple
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "rand::rng::Rng",
                                                    R,
                                                    [],
                                                    [],
                                                    "gen_range",
                                                    [],
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::Range")
                                                        []
                                                        [ Ty.path "usize" ]
                                                    ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| rng |) |)
                                                    |);
                                                    Value.mkStructRecord
                                                      "core::ops::range::Range"
                                                      []
                                                      [ Ty.path "usize" ]
                                                      [
                                                        ("start",
                                                          Value.Integer IntegerKind.Usize 0);
                                                        ("end_", M.read (| cols |))
                                                      ]
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  T,
                                                  M.get_trait_method (|
                                                    "rand::rng::Rng",
                                                    R,
                                                    [],
                                                    [],
                                                    "gen",
                                                    [],
                                                    [ T ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| rng |) |)
                                                    |)
                                                  ]
                                                |)
                                              ]))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.mul,
                        [ M.read (| rows |); M.read (| row_weight |) ]
                      |)
                    ]
                  |)
                ]
              |) in
            let~ row_indices :
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "usize" ];
                      Ty.function [ Ty.path "usize" ] (Ty.path "usize")
                    ],
                  [],
                  [],
                  "collect",
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ops::range::RangeInclusive")
                          []
                          [ Ty.path "usize" ];
                        Ty.function [ Ty.path "usize" ] (Ty.path "usize")
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "usize" ],
                      [],
                      [],
                      "map",
                      [],
                      [ Ty.path "usize"; Ty.function [ Ty.path "usize" ] (Ty.path "usize") ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ops::range::RangeInclusive")
                          []
                          [ Ty.path "usize" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::ops::range::RangeInclusive")
                            []
                            [ Ty.path "usize" ],
                          "new",
                          [],
                          []
                        |),
                        [ Value.Integer IntegerKind.Usize 0; M.read (| rows |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.path "usize",
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let r := M.copy (| Ty.path "usize", γ |) in
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.mul,
                                          [ M.read (| r |); M.read (| row_weight |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |) in
            M.alloc (|
              Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
              Value.mkStructRecord
                "p3_matrix::sparse::CsrMatrix"
                []
                [ T ]
                [
                  ("width", M.read (| cols |));
                  ("nonzero_values", M.read (| nonzero_values |));
                  ("row_indices", M.read (| row_indices |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_rand_fixed_row_weight :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "rand_fixed_row_weight" (rand_fixed_row_weight T).
    Admitted.
    Global Typeclasses Opaque rand_fixed_row_weight.
  End Impl_p3_matrix_sparse_CsrMatrix_T.
  
  Module Impl_p3_matrix_Matrix_where_core_clone_Clone_T_where_core_default_Default_T_where_core_marker_Send_T_where_core_marker_Sync_T_T_for_p3_matrix_sparse_CsrMatrix_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ].
    
    (*
        fn width(&self) -> usize {
            self.width
        }
    *)
    Definition width (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "p3_matrix::sparse::CsrMatrix",
              "width"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn height(&self) -> usize {
            self.row_indices.len() - 1
        }
    *)
    Definition height (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.sub,
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                  "len",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::sparse::CsrMatrix",
                      "row_indices"
                    |)
                  |)
                ]
              |);
              Value.Integer IntegerKind.Usize 1
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn get(&self, r: usize, c: usize) -> T {
            self.sparse_row(r)
                .iter()
                .find(|(col, _)| *col == c)
                .map(|(_, val)| val.clone())
                .unwrap_or_default()
        }
    *)
    Definition get (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r; c ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          let c := M.alloc (| Ty.path "usize", c |) in
          M.call_closure (|
            T,
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              "unwrap_or_default",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ] T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.tuple [ Ty.path "usize"; T ] ],
                      [],
                      [],
                      "find",
                      [],
                      [
                        Ty.function
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ]
                          ]
                          (Ty.path "bool")
                      ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [ Ty.tuple [ Ty.path "usize"; T ] ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              []
                              [ Ty.tuple [ Ty.path "usize"; T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ],
                              "iter",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          []
                                          [ Ty.tuple [ Ty.path "usize"; T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                                      "sparse_row",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      M.read (| r |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.path "bool",
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.tuple [ Ty.path "usize"; T ] ]
                                      ],
                                    α0
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.deref (| M.read (| γ |) |) in
                                        let γ := M.deref (| M.read (| γ |) |) in
                                        let γ2_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ2_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let col :=
                                          M.alloc (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ2_0
                                          |) in
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| col |) |) |);
                                            M.read (| c |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              T,
                              M.alloc (|
                                Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ],
                                α0
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.deref (| M.read (| γ |) |) in
                                    let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let val :=
                                      M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ1_1 |) in
                                    M.call_closure (|
                                      T,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        T,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| val |) |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        type Row<'a>
            = <Vec<T> as IntoIterator>::IntoIter
        where
            Self: 'a;
    *)
    Definition _Row (T : Ty.t) : Ty.t :=
      Ty.associated_in_trait
        "core::iter::traits::collect::IntoIterator"
        []
        []
        (Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ])
        "IntoIter".
    
    (*
        fn row(&self, r: usize) -> Self::Row<'_> {
            let mut row = vec![T::default(); self.width()];
            for (c, v) in self.sparse_row(r) {
                row[*c] = v.clone();
            }
            row.into_iter()
        }
    *)
    Definition row (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          M.read (|
            let~ row :
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] :=
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_function (| "alloc::vec::from_elem", [], [ T ] |),
                [
                  M.call_closure (|
                    T,
                    M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                    []
                  |);
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "p3_matrix::Matrix",
                      Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                      [],
                      [ T ],
                      "width",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.alloc (|
                    Ty.tuple [],
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          []
                          [ Ty.tuple [ Ty.path "usize"; T ] ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [ Ty.tuple [ Ty.path "usize"; T ] ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ]
                                ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                                "sparse_row",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                                M.read (| r |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [ Ty.tuple [ Ty.path "usize"; T ] ],
                                γ
                              |) in
                            M.read (|
                              M.loop (|
                                Ty.tuple [],
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.tuple [ Ty.path "usize"; T ] ]
                                          ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.tuple [ Ty.path "usize"; T ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Iter")
                                              []
                                              [ Ty.tuple [ Ty.path "usize"; T ] ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.never_to_any (| M.read (| M.break (||) |) |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                                            let γ2_0 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                            let γ2_1 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                            let c :=
                                              M.alloc (|
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                γ2_0
                                              |) in
                                            let v :=
                                              M.alloc (| Ty.apply (Ty.path "&") [] [ T ], γ2_1 |) in
                                            M.read (|
                                              let~ _ : Ty.tuple [] :=
                                                M.write (|
                                                  M.deref (|
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&mut") [] [ T ],
                                                      M.get_trait_method (|
                                                        "core::ops::index::IndexMut",
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          []
                                                          [ T; Ty.path "alloc::alloc::Global" ],
                                                        [],
                                                        [ Ty.path "usize" ],
                                                        "index_mut",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (| Pointer.Kind.MutRef, row |);
                                                        M.read (| M.deref (| M.read (| c |) |) |)
                                                      ]
                                                    |)
                                                  |),
                                                  M.call_closure (|
                                                    T,
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      T,
                                                      [],
                                                      [],
                                                      "clone",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| v |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                              |)
                            |)))
                      ]
                    |)
                  |))
              |) in
            M.alloc (|
              Ty.apply
                (Ty.path "alloc::vec::into_iter::IntoIter")
                []
                [ T; Ty.path "alloc::alloc::Global" ],
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::into_iter::IntoIter")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  [],
                  "into_iter",
                  [],
                  []
                |),
                [ M.read (| row |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "p3_matrix::Matrix"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *)
        [
          ("width", InstanceField.Method (width T));
          ("height", InstanceField.Method (height T));
          ("get", InstanceField.Method (get T));
          ("Row", InstanceField.Ty (_Row T));
          ("row", InstanceField.Method (row T))
        ].
  End Impl_p3_matrix_Matrix_where_core_clone_Clone_T_where_core_default_Default_T_where_core_marker_Send_T_where_core_marker_Sync_T_T_for_p3_matrix_sparse_CsrMatrix_T.
End sparse.
