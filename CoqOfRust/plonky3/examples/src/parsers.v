(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module parsers.
  (*
  Enum FieldOptions
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "BabyBear";
          item := StructTuple [];
        };
        {
          name := "KoalaBear";
          item := StructTuple [];
        };
        {
          name := "Mersenne31";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_FieldOptions_BabyBear :
    M.IsDiscriminant "p3_examples::parsers::FieldOptions::BabyBear" 0.
  Axiom IsDiscriminant_FieldOptions_KoalaBear :
    M.IsDiscriminant "p3_examples::parsers::FieldOptions::KoalaBear" 1.
  Axiom IsDiscriminant_FieldOptions_Mersenne31 :
    M.IsDiscriminant "p3_examples::parsers::FieldOptions::Mersenne31" 2.
  
  Module Impl_core_fmt_Debug_for_p3_examples_parsers_FieldOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::FieldOptions".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::FieldOptions::BabyBear"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "BabyBear" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::FieldOptions::KoalaBear"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "KoalaBear" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::FieldOptions::Mersenne31"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Mersenne31" |) |) |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_p3_examples_parsers_FieldOptions.
  
  Module Impl_core_marker_Copy_for_p3_examples_parsers_FieldOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::FieldOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_p3_examples_parsers_FieldOptions.
  
  Module Impl_core_clone_Clone_for_p3_examples_parsers_FieldOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::FieldOptions".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_p3_examples_parsers_FieldOptions.
  
  Module Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_FieldOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::FieldOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_FieldOptions.
  
  Module Impl_core_cmp_PartialEq_p3_examples_parsers_FieldOptions_for_p3_examples_parsers_FieldOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::FieldOptions".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::FieldOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::FieldOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_examples::parsers::FieldOptions" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_p3_examples_parsers_FieldOptions_for_p3_examples_parsers_FieldOptions.
  
  Module Impl_core_cmp_Eq_for_p3_examples_parsers_FieldOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::FieldOptions".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_p3_examples_parsers_FieldOptions.
  
  (*
  Enum ProofOptions
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Blake3Permutations";
          item := StructTuple [];
        };
        {
          name := "KeccakFPermutations";
          item := StructTuple [];
        };
        {
          name := "Poseidon2Permutations";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_ProofOptions_Blake3Permutations :
    M.IsDiscriminant "p3_examples::parsers::ProofOptions::Blake3Permutations" 0.
  Axiom IsDiscriminant_ProofOptions_KeccakFPermutations :
    M.IsDiscriminant "p3_examples::parsers::ProofOptions::KeccakFPermutations" 1.
  Axiom IsDiscriminant_ProofOptions_Poseidon2Permutations :
    M.IsDiscriminant "p3_examples::parsers::ProofOptions::Poseidon2Permutations" 2.
  
  Module Impl_core_fmt_Debug_for_p3_examples_parsers_ProofOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::ProofOptions".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::ProofOptions::Blake3Permutations"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Blake3Permutations" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::ProofOptions::KeccakFPermutations"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "KeccakFPermutations" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::ProofOptions::Poseidon2Permutations"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Poseidon2Permutations" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_p3_examples_parsers_ProofOptions.
  
  Module Impl_core_marker_Copy_for_p3_examples_parsers_ProofOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::ProofOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_p3_examples_parsers_ProofOptions.
  
  Module Impl_core_clone_Clone_for_p3_examples_parsers_ProofOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::ProofOptions".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_p3_examples_parsers_ProofOptions.
  
  Module Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_ProofOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::ProofOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_ProofOptions.
  
  Module Impl_core_cmp_PartialEq_p3_examples_parsers_ProofOptions_for_p3_examples_parsers_ProofOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::ProofOptions".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::ProofOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::ProofOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_examples::parsers::ProofOptions" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_p3_examples_parsers_ProofOptions_for_p3_examples_parsers_ProofOptions.
  
  Module Impl_core_cmp_Eq_for_p3_examples_parsers_ProofOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::ProofOptions".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_p3_examples_parsers_ProofOptions.
  
  (*
  Enum DftOptions
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "None";
          item := StructTuple [];
        };
        {
          name := "Radix2DitParallel";
          item := StructTuple [];
        };
        {
          name := "RecursiveDft";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_DftOptions_None :
    M.IsDiscriminant "p3_examples::parsers::DftOptions::None" 0.
  Axiom IsDiscriminant_DftOptions_Radix2DitParallel :
    M.IsDiscriminant "p3_examples::parsers::DftOptions::Radix2DitParallel" 1.
  Axiom IsDiscriminant_DftOptions_RecursiveDft :
    M.IsDiscriminant "p3_examples::parsers::DftOptions::RecursiveDft" 2.
  
  Module Impl_core_fmt_Debug_for_p3_examples_parsers_DftOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::DftOptions".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (| γ, "p3_examples::parsers::DftOptions::None" |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "None" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::DftOptions::Radix2DitParallel"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Radix2DitParallel" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::DftOptions::RecursiveDft"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "RecursiveDft" |) |) |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_p3_examples_parsers_DftOptions.
  
  Module Impl_core_marker_Copy_for_p3_examples_parsers_DftOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::DftOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_p3_examples_parsers_DftOptions.
  
  Module Impl_core_clone_Clone_for_p3_examples_parsers_DftOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::DftOptions".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_p3_examples_parsers_DftOptions.
  
  Module Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_DftOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::DftOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_DftOptions.
  
  Module Impl_core_cmp_PartialEq_p3_examples_parsers_DftOptions_for_p3_examples_parsers_DftOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::DftOptions".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::DftOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::DftOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_examples::parsers::DftOptions" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_p3_examples_parsers_DftOptions_for_p3_examples_parsers_DftOptions.
  
  Module Impl_core_cmp_Eq_for_p3_examples_parsers_DftOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::DftOptions".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_p3_examples_parsers_DftOptions.
  
  (*
  Enum MerkleHashOptions
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "KeccakF";
          item := StructTuple [];
        };
        {
          name := "Poseidon2";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_MerkleHashOptions_KeccakF :
    M.IsDiscriminant "p3_examples::parsers::MerkleHashOptions::KeccakF" 0.
  Axiom IsDiscriminant_MerkleHashOptions_Poseidon2 :
    M.IsDiscriminant "p3_examples::parsers::MerkleHashOptions::Poseidon2" 1.
  
  Module Impl_core_fmt_Debug_for_p3_examples_parsers_MerkleHashOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::MerkleHashOptions".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::MerkleHashOptions::KeccakF"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "KeccakF" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::MerkleHashOptions::Poseidon2"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Poseidon2" |) |) |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_p3_examples_parsers_MerkleHashOptions.
  
  Module Impl_core_marker_Copy_for_p3_examples_parsers_MerkleHashOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::MerkleHashOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_p3_examples_parsers_MerkleHashOptions.
  
  Module Impl_core_clone_Clone_for_p3_examples_parsers_MerkleHashOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::MerkleHashOptions".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_p3_examples_parsers_MerkleHashOptions.
  
  Module Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_MerkleHashOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::MerkleHashOptions".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_p3_examples_parsers_MerkleHashOptions.
  
  Module Impl_core_cmp_PartialEq_p3_examples_parsers_MerkleHashOptions_for_p3_examples_parsers_MerkleHashOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::MerkleHashOptions".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::MerkleHashOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_examples::parsers::MerkleHashOptions" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_examples::parsers::MerkleHashOptions" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_p3_examples_parsers_MerkleHashOptions_for_p3_examples_parsers_MerkleHashOptions.
  
  Module Impl_core_cmp_Eq_for_p3_examples_parsers_MerkleHashOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::MerkleHashOptions".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_p3_examples_parsers_MerkleHashOptions.
  
  (*
  fn get_aliases(
      base: &'static str,
      min_unique_base_prefix: usize,
      alias: Option<Vec<(&'static str, usize)>>,
  ) -> PossibleValue {
      match alias {
          None => PossibleValue::new(base)
              .aliases((min_unique_base_prefix..base.len()).map(|i| &base[..i])),
          Some(vec) => PossibleValue::new(base).aliases(
              (min_unique_base_prefix..base.len())
                  .map(|i| &base[..i])
                  .chain(vec.into_iter().flat_map(|(alias, min_unique)| {
                      (min_unique..alias.len() + 1).map(|i| &alias[..i])
                  })),
          ),
      }
  }
  *)
  Definition get_aliases (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ base; min_unique_base_prefix; alias ] =>
      ltac:(M.monadic
        (let base := M.alloc (| base |) in
        let min_unique_base_prefix := M.alloc (| min_unique_base_prefix |) in
        let alias := M.alloc (| alias |) in
        M.read (|
          M.match_operator (|
            Ty.apply
              (Ty.path "*")
              []
              [ Ty.path "clap_builder::builder::possible_value::PossibleValue" ],
            alias,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "clap_builder::builder::possible_value::PossibleValue",
                      M.get_associated_function (|
                        Ty.path "clap_builder::builder::possible_value::PossibleValue",
                        "aliases",
                        [],
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                              Ty.function
                                [ Ty.tuple [ Ty.path "usize" ] ]
                                (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.path "clap_builder::builder::possible_value::PossibleValue",
                          M.get_associated_function (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            "new",
                            [],
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                          |),
                          [ M.read (| base |) ]
                        |);
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                              Ty.function
                                [ Ty.tuple [ Ty.path "usize" ] ]
                                (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            [],
                            "map",
                            [],
                            [
                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                              Ty.function
                                [ Ty.tuple [ Ty.path "usize" ] ]
                                (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                            ]
                          |),
                          [
                            Value.StructRecord
                              "core::ops::range::Range"
                              [
                                ("start", M.read (| min_unique_base_prefix |));
                                ("end_",
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (| Ty.path "str", "len", [], [] |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| base |) |)
                                      |)
                                    ]
                                  |))
                              ];
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Ty.apply
                                          (Ty.path "*")
                                          []
                                          [
                                            Ty.function
                                              [ Ty.tuple [ Ty.path "usize" ] ]
                                              (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                          ],
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let i := M.copy (| γ |) in
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                                    M.get_trait_method (|
                                                      "core::ops::index::Index",
                                                      Ty.path "str",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ops::range::RangeTo")
                                                          []
                                                          [ Ty.path "usize" ]
                                                      ],
                                                      "index",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| base |) |)
                                                      |);
                                                      Value.StructRecord
                                                        "core::ops::range::RangeTo"
                                                        [ ("end_", M.read (| i |)) ]
                                                    ]
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let vec := M.copy (| γ0_0 |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "clap_builder::builder::possible_value::PossibleValue",
                      M.get_associated_function (|
                        Ty.path "clap_builder::builder::possible_value::PossibleValue",
                        "aliases",
                        [],
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ];
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                    (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                ];
                              Ty.apply
                                (Ty.path "core::iter::adapters::flatten::FlatMap")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    []
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                          Ty.path "usize"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                        (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ];
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                      ])
                                ]
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.path "clap_builder::builder::possible_value::PossibleValue",
                          M.get_associated_function (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            "new",
                            [],
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                          |),
                          [ M.read (| base |) ]
                        |);
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::chain::Chain")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ];
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                    (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                ];
                              Ty.apply
                                (Ty.path "core::iter::adapters::flatten::FlatMap")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    []
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                          Ty.path "usize"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                        (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ];
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                      ])
                                ]
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                                Ty.function
                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                  (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                              ],
                            [],
                            [],
                            "chain",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::flatten::FlatMap")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    []
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                          Ty.path "usize"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                        (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ];
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                      ])
                                ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ];
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                    (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                [],
                                [],
                                "map",
                                [],
                                [
                                  Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                    (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                ]
                              |),
                              [
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [
                                    ("start", M.read (| min_unique_base_prefix |));
                                    ("end_",
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.path "str",
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| base |) |)
                                          |)
                                        ]
                                      |))
                                  ];
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                  (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let i := M.copy (| γ |) in
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.path "str",
                                                          [],
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::ops::range::RangeTo")
                                                              []
                                                              [ Ty.path "usize" ]
                                                          ],
                                                          "index",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| base |) |)
                                                          |);
                                                          Value.StructRecord
                                                            "core::ops::range::RangeTo"
                                                            [ ("end_", M.read (| i |)) ]
                                                        ]
                                                      |)
                                                    |)
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |);
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::flatten::FlatMap")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    []
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                          Ty.path "usize"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                        (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ];
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                      ])
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                  []
                                  [
                                    Ty.tuple
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ]; Ty.path "usize"
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [],
                                "flat_map",
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                        (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ];
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.apply (Ty.path "&") [] [ Ty.path "str" ])
                                      ])
                                ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    []
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                          Ty.path "usize"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  M.get_trait_method (|
                                    "core::iter::traits::collect::IntoIterator",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [],
                                    "into_iter",
                                    [],
                                    []
                                  |),
                                  [ M.read (| vec |) ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [ Ty.path "str" ];
                                                            Ty.path "usize"
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::Range")
                                                        []
                                                        [ Ty.path "usize" ];
                                                      Ty.function
                                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                                        (Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "str" ])
                                                    ])
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                  let γ0_1 :=
                                                    M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                  let alias := M.copy (| γ0_0 |) in
                                                  let min_unique := M.copy (| γ0_1 |) in
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ops::range::Range")
                                                          []
                                                          [ Ty.path "usize" ];
                                                        Ty.function
                                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                                          (Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ])
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::ops::range::Range")
                                                        []
                                                        [ Ty.path "usize" ],
                                                      [],
                                                      [],
                                                      "map",
                                                      [],
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.function
                                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                                          (Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ])
                                                      ]
                                                    |),
                                                    [
                                                      Value.StructRecord
                                                        "core::ops::range::Range"
                                                        [
                                                          ("start", M.read (| min_unique |));
                                                          ("end_",
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              BinOp.Wrap.add,
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_associated_function (|
                                                                    Ty.path "str",
                                                                    "len",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| alias |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |);
                                                                Value.Integer IntegerKind.Usize 1
                                                              ]
                                                            |))
                                                        ];
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              ltac:(M.monadic
                                                                (M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path "*")
                                                                    []
                                                                    [
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                        (Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "str" ])
                                                                    ],
                                                                  M.alloc (| α0 |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let i := M.copy (| γ |) in
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.call_closure (|
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [ Ty.path "str" ],
                                                                              M.get_trait_method (|
                                                                                "core::ops::index::Index",
                                                                                Ty.path "str",
                                                                                [],
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::ops::range::RangeTo")
                                                                                    []
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ]
                                                                                ],
                                                                                "index",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      alias
                                                                                    |)
                                                                                  |)
                                                                                |);
                                                                                Value.StructRecord
                                                                                  "core::ops::range::RangeTo"
                                                                                  [
                                                                                    ("end_",
                                                                                      M.read (|
                                                                                        i
                                                                                      |))
                                                                                  ]
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |)))
                                                                  ]
                                                                |)))
                                                            | _ =>
                                                              M.impossible
                                                                "wrong number of arguments"
                                                            end))
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_aliases :
    M.IsFunction.C "p3_examples::parsers::get_aliases" get_aliases.
  Admitted.
  Global Typeclasses Opaque get_aliases.
  
  Module Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_FieldOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::FieldOptions".
    
    (*
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::BabyBear, Self::KoalaBear, Self::Mersenne31]
        }
    *)
    Definition value_variants (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (* Unsize *)
          (M.pointer_coercion
            (M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Value.Array
                      [
                        Value.StructTuple "p3_examples::parsers::FieldOptions::BabyBear" [];
                        Value.StructTuple "p3_examples::parsers::FieldOptions::KoalaBear" [];
                        Value.StructTuple "p3_examples::parsers::FieldOptions::Mersenne31" []
                      ]
                  |)
                |)
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn to_possible_value(&self) -> Option<PossibleValue> {
            Some(match self {
                Self::BabyBear => get_aliases("baby-bear", 1, Some(vec![("babybear", 5), ("bb", 2)])),
                Self::KoalaBear => {
                    get_aliases("koala-bear", 1, Some(vec![("koalabear", 6), ("kb", 2)]))
                }
                Self::Mersenne31 => {
                    get_aliases("mersenne-31", 1, Some(vec![("mersenne31", 9), ("m31", 2)]))
                }
            })
        }
    *)
    Definition to_possible_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::option::Option::Some"
            [
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.path "clap_builder::builder::possible_value::PossibleValue" ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::FieldOptions::BabyBear"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "baby-bear" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "babybear" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 5
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "bb" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::FieldOptions::KoalaBear"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "koala-bear" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "koalabear" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 6
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "kb" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::FieldOptions::Mersenne31"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "mersenne-31" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "mersenne31" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 9
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "m31" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "clap_builder::derive::ValueEnum"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_variants", InstanceField.Method value_variants);
          ("to_possible_value", InstanceField.Method to_possible_value)
        ].
  End Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_FieldOptions.
  
  Module Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_ProofOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::ProofOptions".
    
    (*
        fn value_variants<'a>() -> &'a [Self] {
            &[
                Self::Blake3Permutations,
                Self::Poseidon2Permutations,
                Self::KeccakFPermutations,
            ]
        }
    *)
    Definition value_variants (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (* Unsize *)
          (M.pointer_coercion
            (M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Value.Array
                      [
                        Value.StructTuple
                          "p3_examples::parsers::ProofOptions::Blake3Permutations"
                          [];
                        Value.StructTuple
                          "p3_examples::parsers::ProofOptions::Poseidon2Permutations"
                          [];
                        Value.StructTuple
                          "p3_examples::parsers::ProofOptions::KeccakFPermutations"
                          []
                      ]
                  |)
                |)
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn to_possible_value(&self) -> Option<PossibleValue> {
            Some(match self {
                Self::Blake3Permutations => get_aliases(
                    "blake-3-permutations",
                    1,
                    Some(vec![("blake3-permutations", 6), ("b3", 2)]),
                ),
                Self::KeccakFPermutations => get_aliases(
                    "keccak-f-permutations",
                    1,
                    Some(vec![("keccakf-permutations", 7), ("kf", 2)]),
                ),
                Self::Poseidon2Permutations => get_aliases(
                    "poseidon-2-permutations",
                    1,
                    Some(vec![("poseidon2-permutations", 9), ("p2", 2)]),
                ),
            })
        }
    *)
    Definition to_possible_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::option::Option::Some"
            [
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.path "clap_builder::builder::possible_value::PossibleValue" ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::ProofOptions::Blake3Permutations"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "blake-3-permutations" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            mk_str (| "blake3-permutations" |)
                                                          |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 6
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "b3" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::ProofOptions::KeccakFPermutations"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "keccak-f-permutations" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            mk_str (| "keccakf-permutations" |)
                                                          |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 7
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "kf" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::ProofOptions::Poseidon2Permutations"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "poseidon-2-permutations" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            mk_str (| "poseidon2-permutations" |)
                                                          |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 9
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "p2" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "clap_builder::derive::ValueEnum"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_variants", InstanceField.Method value_variants);
          ("to_possible_value", InstanceField.Method to_possible_value)
        ].
  End Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_ProofOptions.
  
  Module Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_DftOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::DftOptions".
    
    (*
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::Radix2DitParallel, Self::RecursiveDft, Self::None]
        }
    *)
    Definition value_variants (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (* Unsize *)
          (M.pointer_coercion
            (M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Value.Array
                      [
                        Value.StructTuple "p3_examples::parsers::DftOptions::Radix2DitParallel" [];
                        Value.StructTuple "p3_examples::parsers::DftOptions::RecursiveDft" [];
                        Value.StructTuple "p3_examples::parsers::DftOptions::None" []
                      ]
                  |)
                |)
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn to_possible_value(&self) -> Option<PossibleValue> {
            Some(match self {
                Self::RecursiveDft => get_aliases("recursive-dft", 2, Some(vec![("recursivedft", 10)])),
                Self::Radix2DitParallel => get_aliases(
                    "radix-2-dit-parallel",
                    2,
                    Some(vec![("radix2ditparallel", 6), ("parallel", 1)]),
                ),
                Self::None => PossibleValue::new(""),
            })
        }
    *)
    Definition to_possible_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::option::Option::Some"
            [
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.path "clap_builder::builder::possible_value::PossibleValue" ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::DftOptions::RecursiveDft"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "recursive-dft" |);
                              Value.Integer IntegerKind.Usize 2;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 1 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 1 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "recursivedft" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 10
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::DftOptions::Radix2DitParallel"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "radix-2-dit-parallel" |);
                              Value.Integer IntegerKind.Usize 2;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            mk_str (| "radix2ditparallel" |)
                                                          |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 6
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "parallel" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 1
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (| γ, "p3_examples::parsers::DftOptions::None" |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_associated_function (|
                              Ty.path "clap_builder::builder::possible_value::PossibleValue",
                              "new",
                              [],
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                            |),
                            [ mk_str (| "" |) ]
                          |)
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "clap_builder::derive::ValueEnum"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_variants", InstanceField.Method value_variants);
          ("to_possible_value", InstanceField.Method to_possible_value)
        ].
  End Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_DftOptions.
  
  Module Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_MerkleHashOptions.
    Definition Self : Ty.t := Ty.path "p3_examples::parsers::MerkleHashOptions".
    
    (*
        fn value_variants<'a>() -> &'a [Self] {
            &[Self::Poseidon2, Self::KeccakF]
        }
    *)
    Definition value_variants (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (* Unsize *)
          (M.pointer_coercion
            (M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Value.Array
                      [
                        Value.StructTuple "p3_examples::parsers::MerkleHashOptions::Poseidon2" [];
                        Value.StructTuple "p3_examples::parsers::MerkleHashOptions::KeccakF" []
                      ]
                  |)
                |)
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn to_possible_value(&self) -> Option<PossibleValue> {
            Some(match self {
                Self::KeccakF => get_aliases("keccak-f", 1, Some(vec![("keccakf", 7), ("kf", 2)])),
                Self::Poseidon2 => {
                    get_aliases("poseidon-2", 1, Some(vec![("poseidon2", 9), ("p2", 2)]))
                }
            })
        }
    *)
    Definition to_possible_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::option::Option::Some"
            [
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.path "clap_builder::builder::possible_value::PossibleValue" ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::MerkleHashOptions::KeccakF"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "keccak-f" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "keccakf" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 7
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "kf" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "p3_examples::parsers::MerkleHashOptions::Poseidon2"
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "clap_builder::builder::possible_value::PossibleValue",
                            M.get_function (| "p3_examples::parsers::get_aliases", [], [] |),
                            [
                              mk_str (| "poseidon-2" |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.path "usize"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                              Ty.path "usize"
                                            ]
                                        ],
                                      "into_vec",
                                      [],
                                      [ Ty.path "alloc::alloc::Global" ]
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "usize"
                                                      ]
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "str" ];
                                                          Ty.path "usize"
                                                        ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "poseidon2" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 9
                                                      ];
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| mk_str (| "p2" |) |)
                                                        |);
                                                        Value.Integer IntegerKind.Usize 2
                                                      ]
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |))
                                    ]
                                  |)
                                ]
                            ]
                          |)
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "clap_builder::derive::ValueEnum"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_variants", InstanceField.Method value_variants);
          ("to_possible_value", InstanceField.Method to_possible_value)
        ].
  End Impl_clap_builder_derive_ValueEnum_for_p3_examples_parsers_MerkleHashOptions.
End parsers.
