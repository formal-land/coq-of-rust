(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module array.
  (* StructTuple
    {
      name := "FieldArray";
      const_params := [ "N" ];
      ty_params := [ "F" ];
      fields := [ Ty.apply (Ty.path "array") [ N ] [ F ] ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (* Clone *)
    Definition clone
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "p3_field::array::FieldArray"
            [ N ]
            [ F ]
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply (Ty.path "array") [ N ] [ F ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::array::FieldArray",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("clone", InstanceField.Method (clone N F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (* Debug *)
    Definition fmt
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FieldArray" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::array::FieldArray",
                            0
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt N F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq N F)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_F_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_marker_StructuralPartialEq_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (* PartialEq *)
    Definition eq
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "array") [ N ] [ F ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_field::array::FieldArray",
                  0
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "p3_field::array::FieldArray",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *) [ ("eq", InstanceField.Method (eq N F)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        pub(crate) fn inverse(&self) -> Self {
            let mut result = Self::default();
            batch_multiplicative_inverse_general(&self.0, &mut result.0, |x| x.inverse());
            result
        }
    *)
    Definition inverse
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ result :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "p3_field::batch_inverse::batch_multiplicative_inverse_general",
                    [],
                    [ F; Ty.function [ Ty.tuple [ F ] ] F ]
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::array::FieldArray",
                              0
                            |)
                          |)
                        |)
                      |));
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_tuple_field (|
                              result,
                              "p3_field::array::FieldArray",
                              0
                            |)
                          |)
                        |)
                      |));
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.function [ Ty.tuple [ F ] ] F ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| γ |) in
                                      M.call_closure (|
                                        F,
                                        M.get_trait_method (|
                                          "p3_field::field::Field",
                                          F,
                                          [],
                                          [],
                                          "inverse",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, x |) ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            result
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inverse :
      forall (N : Value.t) (F : Ty.t),
      M.IsAssociatedFunction.C (Self N F) "inverse" (inverse N F).
    Admitted.
    Global Typeclasses Opaque inverse.
  End Impl_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_default_Default_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn default() -> Self {
            Self::ZERO
        }
    *)
    Definition default
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            get_constant (|
              "p3_field::field::PrimeCharacteristicRing::ZERO",
              Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("default", InstanceField.Method (default N F)) ].
  End Impl_core_default_Default_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_convert_From_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn from(val: F) -> Self {
            [val; N].into()
        }
    *)
    Definition from
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ val ] =>
        ltac:(M.monadic
          (let val := M.alloc (| val |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [ repeat (| M.read (| val |), N |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *) [ ("from", InstanceField.Method (from N F)) ].
  End Impl_core_convert_From_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_convert_From_where_p3_field_field_Field_F_array_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn from(arr: [F; N]) -> Self {
            Self(arr)
        }
    *)
    Definition from
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ arr ] =>
        ltac:(M.monadic
          (let arr := M.alloc (| arr |) in
          Value.StructTuple "p3_field::array::FieldArray" [ N ] [ F ] [ M.read (| arr |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ F ] ]
        (Self N F)
        (* Instance *) [ ("from", InstanceField.Method (from N F)) ].
  End Impl_core_convert_From_where_p3_field_field_Field_F_array_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_p3_field_field_PrimeCharacteristicRing_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type PrimeSubfield = F::PrimeSubfield; *)
    Definition _PrimeSubfield (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_field::field::PrimeCharacteristicRing" [] [] F "PrimeSubfield".
    
    (*     const ZERO: Self = Self([F::ZERO; N]); *)
    (* Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] *)
    Definition value_ZERO
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "p3_field::array::FieldArray"
            [ N ]
            [ F ]
            [
              repeat (|
                M.read (| get_constant (| "p3_field::field::PrimeCharacteristicRing::ZERO", F |) |),
                N
              |)
            ]
        |))).
    
    (*     const ONE: Self = Self([F::ONE; N]); *)
    (* Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] *)
    Definition value_ONE
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "p3_field::array::FieldArray"
            [ N ]
            [ F ]
            [
              repeat (|
                M.read (| get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", F |) |),
                N
              |)
            ]
        |))).
    
    (*     const TWO: Self = Self([F::TWO; N]); *)
    (* Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] *)
    Definition value_TWO
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "p3_field::array::FieldArray"
            [ N ]
            [ F ]
            [
              repeat (|
                M.read (| get_constant (| "p3_field::field::PrimeCharacteristicRing::TWO", F |) |),
                N
              |)
            ]
        |))).
    
    (*     const NEG_ONE: Self = Self([F::NEG_ONE; N]); *)
    (* Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] *)
    Definition value_NEG_ONE
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "p3_field::array::FieldArray"
            [ N ]
            [ F ]
            [
              repeat (|
                M.read (|
                  get_constant (| "p3_field::field::PrimeCharacteristicRing::NEG_ONE", F |)
                |),
                N
              |)
            ]
        |))).
    
    (*
        fn from_prime_subfield(f: Self::PrimeSubfield) -> Self {
            F::from_prime_subfield(f).into()
        }
    *)
    Definition from_prime_subfield
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              F,
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                F,
                M.get_trait_method (|
                  "p3_field::field::PrimeCharacteristicRing",
                  F,
                  [],
                  [],
                  "from_prime_subfield",
                  [],
                  []
                |),
                [ M.read (| f |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "p3_field::field::PrimeCharacteristicRing"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *)
        [
          ("PrimeSubfield", InstanceField.Ty (_PrimeSubfield N F));
          ("value_ZERO", InstanceField.Method (value_ZERO N F));
          ("value_ONE", InstanceField.Method (value_ONE N F));
          ("value_TWO", InstanceField.Method (value_TWO N F));
          ("value_NEG_ONE", InstanceField.Method (value_NEG_ONE N F));
          ("from_prime_subfield", InstanceField.Method (from_prime_subfield N F))
        ].
  End Impl_p3_field_field_PrimeCharacteristicRing_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_p3_field_field_Algebra_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "p3_field::field::Algebra"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *) [].
  End Impl_p3_field_field_Algebra_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_p3_field_packed_PackedValue_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Value = F; *)
    Definition _Value (N : Value.t) (F : Ty.t) : Ty.t := F.
    
    (*     const WIDTH: usize = N; *)
    (* Ty.path "usize" *)
    Definition value_WIDTH
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      ltac:(M.monadic (M.alloc (| N |))).
    
    (*
        fn from_slice(slice: &[Self::Value]) -> &Self {
            assert_eq!(slice.len(), Self::WIDTH);
            unsafe { &*slice.as_ptr().cast() }
        }
    *)
    Definition from_slice
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ F ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind :
                                        Ty.apply
                                          (Ty.path "*")
                                          []
                                          [ Ty.path "core::panicking::AssertKind" ] :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" [] [] []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple
                                            "core::option::Option::None"
                                            []
                                            [ Ty.path "core::fmt::Arguments" ]
                                            []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            M.alloc (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "*const")
                          []
                          [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [] [ F ],
                          "cast",
                          [],
                          [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*const") [] [ F ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ F ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                          |)
                        ]
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_slice_mut(slice: &mut [Self::Value]) -> &mut Self {
            assert_eq!(slice.len(), Self::WIDTH);
            unsafe { &mut *slice.as_mut_ptr().cast() }
        }
    *)
    Definition from_slice_mut
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ F ],
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            get_constant (|
                              "p3_field::packed::PackedValue::WIDTH",
                              Ty.path "usize"
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val := M.copy (| γ0_0 |) in
                          let right_val := M.copy (| γ0_1 |) in
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ kind :
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [ Ty.path "core::panicking::AssertKind" ] :=
                                          M.alloc (|
                                            Value.StructTuple
                                              "core::panicking::AssertKind::Eq"
                                              []
                                              []
                                              []
                                          |) in
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (|
                                              "core::panicking::assert_failed",
                                              [],
                                              [ Ty.path "usize"; Ty.path "usize" ]
                                            |),
                                            [
                                              M.read (| kind |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| left_val |) |)
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| right_val |) |)
                                                  |)
                                                |)
                                              |);
                                              Value.StructTuple
                                                "core::option::Option::None"
                                                []
                                                [ Ty.path "core::fmt::Arguments" ]
                                                []
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [] [ F ],
                                  "cast",
                                  [],
                                  [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*mut") [] [ F ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ F ],
                                      "as_mut_ptr",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| slice |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_fn<Fn>(f: Fn) -> Self
        where
            Fn: FnMut(usize) -> Self::Value,
        {
            Self(array::from_fn(f))
        }
    *)
    Definition from_fn
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [ Fn ], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| f |) in
          Value.StructTuple
            "p3_field::array::FieldArray"
            [ N ]
            [ F ]
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_function (| "core::array::from_fn", [ N ], [ F; Fn ] |),
                [ M.read (| f |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn as_slice(&self) -> &[Self::Value] {
            &self.0
        }
    *)
    Definition as_slice
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          (* Unsize *)
          M.pointer_coercion
            (M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_field::array::FieldArray",
                    0
                  |)
                |)
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn as_slice_mut(&mut self) -> &mut [Self::Value] {
            &mut self.0
        }
    *)
    Definition as_slice_mut
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::array::FieldArray",
                        0
                      |)
                    |)
                  |)
                |))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "p3_field::packed::PackedValue"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *)
        [
          ("Value", InstanceField.Ty (_Value N F));
          ("value_WIDTH", InstanceField.Method (value_WIDTH N F));
          ("from_slice", InstanceField.Method (from_slice N F));
          ("from_slice_mut", InstanceField.Method (from_slice_mut N F));
          ("from_fn", InstanceField.Method (from_fn N F));
          ("as_slice", InstanceField.Method (as_slice N F));
          ("as_slice_mut", InstanceField.Method (as_slice_mut N F))
        ].
  End Impl_p3_field_packed_PackedValue_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Add_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn add(self, rhs: Self) -> Self::Output {
            array::from_fn(|i| self.0[i] + rhs.0[i]).into()
        }
    *)
    Definition add
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_function (|
                  "core::array::from_fn",
                  [ N ],
                  [ F; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] F ]
                |),
                [
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] F ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let i := M.copy (| γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "core::ops::arith::Add",
                                        F,
                                        [],
                                        [ F ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              self,
                                              "p3_field::array::FieldArray",
                                              0
                                            |),
                                            M.read (| i |)
                                          |)
                                        |);
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              rhs,
                                              "p3_field::array::FieldArray",
                                              0
                                            |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("add", InstanceField.Method (add N F)) ].
  End Impl_core_ops_arith_Add_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Add_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn add(self, rhs: F) -> Self::Output {
            self.0.map(|x| x + rhs).into()
        }
    *)
    Definition add
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "array") [ N ] [ F ],
                  "map",
                  [],
                  [ Ty.function [ Ty.tuple [ F ] ] F; F ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "p3_field::array::FieldArray", 0 |)
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.function [ Ty.tuple [ F ] ] F ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let x := M.copy (| γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "core::ops::arith::Add",
                                        F,
                                        [],
                                        [ F ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [ M.read (| x |); M.read (| rhs |) ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("add", InstanceField.Method (add N F)) ].
  End Impl_core_ops_arith_Add_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_AddAssign_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn add_assign(&mut self, rhs: Self) {
            self.0.iter_mut().zip(rhs.0).for_each(|(x, y)| *x += y);
        }
    *)
    Definition add_assign
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                        Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                      ],
                    [],
                    [],
                    "for_each",
                    [],
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ] ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                          Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                        [],
                        [],
                        "zip",
                        [],
                        [ Ty.apply (Ty.path "array") [ N ] [ F ] ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ F ],
                            "iter_mut",
                            [],
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_tuple_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_field::array::FieldArray",
                                  0
                                |)
                              |))
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            rhs,
                            "p3_field::array::FieldArray",
                            0
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ]
                                      ]
                                      (Ty.tuple [])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let x := M.copy (| γ0_0 |) in
                                      let y := M.copy (| γ0_1 |) in
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::ops::arith::AddAssign",
                                          F,
                                          [],
                                          [ F ],
                                          "add_assign",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| x |) |)
                                          |);
                                          M.read (| y |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *) [ ("add_assign", InstanceField.Method (add_assign N F)) ].
  End Impl_core_ops_arith_AddAssign_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_AddAssign_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn add_assign(&mut self, rhs: F) {
            self.0.iter_mut().for_each(|x| *x += rhs);
        }
    *)
    Definition add_assign
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                    [],
                    [],
                    "for_each",
                    [],
                    [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ] (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "iter_mut",
                        [],
                        []
                      |),
                      [
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::array::FieldArray",
                              0
                            |)
                          |))
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ]
                                      (Ty.tuple [])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::ops::arith::AddAssign",
                                          F,
                                          [],
                                          [ F ],
                                          "add_assign",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| x |) |)
                                          |);
                                          M.read (| rhs |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *) [ ("add_assign", InstanceField.Method (add_assign N F)) ].
  End Impl_core_ops_arith_AddAssign_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Sub_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn sub(self, rhs: Self) -> Self::Output {
            array::from_fn(|i| self.0[i] - rhs.0[i]).into()
        }
    *)
    Definition sub
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_function (|
                  "core::array::from_fn",
                  [ N ],
                  [ F; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] F ]
                |),
                [
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] F ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let i := M.copy (| γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "core::ops::arith::Sub",
                                        F,
                                        [],
                                        [ F ],
                                        "sub",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              self,
                                              "p3_field::array::FieldArray",
                                              0
                                            |),
                                            M.read (| i |)
                                          |)
                                        |);
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              rhs,
                                              "p3_field::array::FieldArray",
                                              0
                                            |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("sub", InstanceField.Method (sub N F)) ].
  End Impl_core_ops_arith_Sub_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Sub_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn sub(self, rhs: F) -> Self::Output {
            self.0.map(|x| x - rhs).into()
        }
    *)
    Definition sub
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "array") [ N ] [ F ],
                  "map",
                  [],
                  [ Ty.function [ Ty.tuple [ F ] ] F; F ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "p3_field::array::FieldArray", 0 |)
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.function [ Ty.tuple [ F ] ] F ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let x := M.copy (| γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "core::ops::arith::Sub",
                                        F,
                                        [],
                                        [ F ],
                                        "sub",
                                        [],
                                        []
                                      |),
                                      [ M.read (| x |); M.read (| rhs |) ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("sub", InstanceField.Method (sub N F)) ].
  End Impl_core_ops_arith_Sub_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_SubAssign_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn sub_assign(&mut self, rhs: Self) {
            self.0.iter_mut().zip(rhs.0).for_each(|(x, y)| *x -= y);
        }
    *)
    Definition sub_assign
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                        Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                      ],
                    [],
                    [],
                    "for_each",
                    [],
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ] ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                          Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                        [],
                        [],
                        "zip",
                        [],
                        [ Ty.apply (Ty.path "array") [ N ] [ F ] ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ F ],
                            "iter_mut",
                            [],
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_tuple_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_field::array::FieldArray",
                                  0
                                |)
                              |))
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            rhs,
                            "p3_field::array::FieldArray",
                            0
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ]
                                      ]
                                      (Ty.tuple [])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let x := M.copy (| γ0_0 |) in
                                      let y := M.copy (| γ0_1 |) in
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::ops::arith::SubAssign",
                                          F,
                                          [],
                                          [ F ],
                                          "sub_assign",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| x |) |)
                                          |);
                                          M.read (| y |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::SubAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign N F)) ].
  End Impl_core_ops_arith_SubAssign_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_SubAssign_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn sub_assign(&mut self, rhs: F) {
            self.0.iter_mut().for_each(|x| *x -= rhs);
        }
    *)
    Definition sub_assign
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                    [],
                    [],
                    "for_each",
                    [],
                    [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ] (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "iter_mut",
                        [],
                        []
                      |),
                      [
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::array::FieldArray",
                              0
                            |)
                          |))
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ]
                                      (Ty.tuple [])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::ops::arith::SubAssign",
                                          F,
                                          [],
                                          [ F ],
                                          "sub_assign",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| x |) |)
                                          |);
                                          M.read (| rhs |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::SubAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign N F)) ].
  End Impl_core_ops_arith_SubAssign_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Neg_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn neg(self) -> Self::Output {
            self.0.map(|x| -x).into()
        }
    *)
    Definition neg
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "array") [ N ] [ F ],
                  "map",
                  [],
                  [ Ty.function [ Ty.tuple [ F ] ] F; F ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "p3_field::array::FieldArray", 0 |)
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.function [ Ty.tuple [ F ] ] F ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let x := M.copy (| γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "core::ops::arith::Neg",
                                        F,
                                        [],
                                        [],
                                        "neg",
                                        [],
                                        []
                                      |),
                                      [ M.read (| x |) ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Neg"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("neg", InstanceField.Method (neg N F)) ].
  End Impl_core_ops_arith_Neg_where_p3_field_field_Field_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Mul_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn mul(self, rhs: Self) -> Self::Output {
            array::from_fn(|i| self.0[i] * rhs.0[i]).into()
        }
    *)
    Definition mul
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_function (|
                  "core::array::from_fn",
                  [ N ],
                  [ F; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] F ]
                |),
                [
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] F ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let i := M.copy (| γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "core::ops::arith::Mul",
                                        F,
                                        [],
                                        [ F ],
                                        "mul",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              self,
                                              "p3_field::array::FieldArray",
                                              0
                                            |),
                                            M.read (| i |)
                                          |)
                                        |);
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              rhs,
                                              "p3_field::array::FieldArray",
                                              0
                                            |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("mul", InstanceField.Method (mul N F)) ].
  End Impl_core_ops_arith_Mul_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Mul_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn mul(self, rhs: F) -> Self::Output {
            self.0.map(|x| x * rhs).into()
        }
    *)
    Definition mul
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ N ] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "array") [ N ] [ F ],
                  "map",
                  [],
                  [ Ty.function [ Ty.tuple [ F ] ] F; F ]
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "p3_field::array::FieldArray", 0 |)
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.function [ Ty.tuple [ F ] ] F ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let x := M.copy (| γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "core::ops::arith::Mul",
                                        F,
                                        [],
                                        [ F ],
                                        "mul",
                                        [],
                                        []
                                      |),
                                      [ M.read (| x |); M.read (| rhs |) ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("mul", InstanceField.Method (mul N F)) ].
  End Impl_core_ops_arith_Mul_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_MulAssign_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn mul_assign(&mut self, rhs: Self) {
            self.0.iter_mut().zip(rhs.0).for_each(|(x, y)| *x *= y);
        }
    *)
    Definition mul_assign
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                        Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                      ],
                    [],
                    [],
                    "for_each",
                    [],
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ] ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                          Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                        [],
                        [],
                        "zip",
                        [],
                        [ Ty.apply (Ty.path "array") [ N ] [ F ] ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ F ],
                            "iter_mut",
                            [],
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_tuple_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_field::array::FieldArray",
                                  0
                                |)
                              |))
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            rhs,
                            "p3_field::array::FieldArray",
                            0
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ]
                                      ]
                                      (Ty.tuple [])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let x := M.copy (| γ0_0 |) in
                                      let y := M.copy (| γ0_1 |) in
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::ops::arith::MulAssign",
                                          F,
                                          [],
                                          [ F ],
                                          "mul_assign",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| x |) |)
                                          |);
                                          M.read (| y |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::MulAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign N F)) ].
  End Impl_core_ops_arith_MulAssign_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_MulAssign_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn mul_assign(&mut self, rhs: F) {
            self.0.iter_mut().for_each(|x| *x *= rhs);
        }
    *)
    Definition mul_assign
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                    [],
                    [],
                    "for_each",
                    [],
                    [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ] (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "iter_mut",
                        [],
                        []
                      |),
                      [
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::array::FieldArray",
                              0
                            |)
                          |))
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ]
                                      (Ty.tuple [])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::ops::arith::MulAssign",
                                          F,
                                          [],
                                          [ F ],
                                          "mul_assign",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| x |) |)
                                          |);
                                          M.read (| rhs |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::MulAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign N F)) ].
  End Impl_core_ops_arith_MulAssign_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_ops_arith_Div_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*     type Output = Self; *)
    Definition _Output (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn div(self, rhs: F) -> Self::Output {
            let rhs_inv = rhs.inverse();
            self * rhs_inv
        }
    *)
    Definition div
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ rhs_inv : Ty.apply (Ty.path "*") [] [ F ] :=
              M.alloc (|
                M.call_closure (|
                  F,
                  M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
                M.get_trait_method (|
                  "core::ops::arith::Mul",
                  Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
                  [],
                  [ F ],
                  "mul",
                  [],
                  []
                |),
                [ M.read (| self |); M.read (| rhs_inv |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Div"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F ]
        (Self N F)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output N F)); ("div", InstanceField.Method (div N F)) ].
  End Impl_core_ops_arith_Div_where_p3_field_field_Field_F_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_iter_traits_accum_Sum_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
            iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)
        }
    *)
    Definition sum
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "unwrap_or",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  [],
                  "reduce",
                  [],
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ];
                            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ]
                          ]
                      ]
                      (Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ])
                  ]
                |),
                [
                  M.read (| iter |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "p3_field::array::FieldArray")
                                            [ N ]
                                            [ F ];
                                          Ty.apply
                                            (Ty.path "p3_field::array::FieldArray")
                                            [ N ]
                                            [ F ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let lhs := M.copy (| γ |) in
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_field::array::FieldArray")
                                                    [ N ]
                                                    [ F ];
                                                  Ty.apply
                                                    (Ty.path "p3_field::array::FieldArray")
                                                    [ N ]
                                                    [ F ]
                                                ]
                                            ]
                                            (Ty.apply
                                              (Ty.path "p3_field::array::FieldArray")
                                              [ N ]
                                              [ F ])
                                        ],
                                      M.alloc (| α1 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let rhs := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "p3_field::array::FieldArray")
                                                [ N ]
                                                [ F ],
                                              M.get_trait_method (|
                                                "core::ops::arith::Add",
                                                Ty.apply
                                                  (Ty.path "p3_field::array::FieldArray")
                                                  [ N ]
                                                  [ F ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_field::array::FieldArray")
                                                    [ N ]
                                                    [ F ]
                                                ],
                                                "add",
                                                [],
                                                []
                                              |),
                                              [ M.read (| lhs |); M.read (| rhs |) ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |);
              M.read (|
                get_constant (|
                  "p3_field::field::PrimeCharacteristicRing::ZERO",
                  Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::accum::Sum"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *) [ ("sum", InstanceField.Method (sum N F)) ].
  End Impl_core_iter_traits_accum_Sum_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
  
  Module Impl_core_iter_traits_accum_Product_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ].
    
    (*
        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {
            iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)
        }
    *)
    Definition product
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
              "unwrap_or",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  [],
                  "reduce",
                  [],
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ];
                            Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ]
                          ]
                      ]
                      (Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ])
                  ]
                |),
                [
                  M.read (| iter |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "p3_field::array::FieldArray")
                                            [ N ]
                                            [ F ];
                                          Ty.apply
                                            (Ty.path "p3_field::array::FieldArray")
                                            [ N ]
                                            [ F ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let lhs := M.copy (| γ |) in
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_field::array::FieldArray")
                                                    [ N ]
                                                    [ F ];
                                                  Ty.apply
                                                    (Ty.path "p3_field::array::FieldArray")
                                                    [ N ]
                                                    [ F ]
                                                ]
                                            ]
                                            (Ty.apply
                                              (Ty.path "p3_field::array::FieldArray")
                                              [ N ]
                                              [ F ])
                                        ],
                                      M.alloc (| α1 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let rhs := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "p3_field::array::FieldArray")
                                                [ N ]
                                                [ F ],
                                              M.get_trait_method (|
                                                "core::ops::arith::Mul",
                                                Ty.apply
                                                  (Ty.path "p3_field::array::FieldArray")
                                                  [ N ]
                                                  [ F ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_field::array::FieldArray")
                                                    [ N ]
                                                    [ F ]
                                                ],
                                                "mul",
                                                [],
                                                []
                                              |),
                                              [ M.read (| lhs |); M.read (| rhs |) ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |);
              M.read (|
                get_constant (|
                  "p3_field::field::PrimeCharacteristicRing::ONE",
                  Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::accum::Product"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_field::array::FieldArray") [ N ] [ F ] ]
        (Self N F)
        (* Instance *) [ ("product", InstanceField.Method (product N F)) ].
  End Impl_core_iter_traits_accum_Product_where_p3_field_field_Field_F_p3_field_array_FieldArray_N_F_for_p3_field_array_FieldArray_N_F.
End array.
