(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module extension.
  Module binomial_extension.
    (* StructRecord
      {
        name := "BinomialExtensionField";
        const_params := [ "D" ];
        ty_params := [ "F"; "A" ];
        fields :=
          [
            ("value", Ty.apply (Ty.path "array") [ D ] [ A ]);
            ("_phantom", Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ])
          ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_F_where_core_marker_Copy_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_F_where_core_marker_Copy_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_core_clone_Clone_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (* Clone *)
      Definition clone
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ F; A ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ A ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "array") [ D ] [ A ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "value"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("_phantom",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "_phantom"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *) [ ("clone", InstanceField.Method (clone D F A)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_where_core_clone_Clone_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_F_where_core_cmp_Eq_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            M.match_operator (|
              Ty.tuple [],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.tuple [],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *)
          [
            ("assert_receiver_is_total_eq",
              InstanceField.Method (assert_receiver_is_total_eq D F A))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_F_where_core_cmp_Eq_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_marker_StructuralPartialEq_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_core_cmp_PartialEq_A_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (* PartialEq *)
      Definition eq
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                other
              |) in
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  [],
                  [ Ty.apply (Ty.path "array") [ D ] [ A ] ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::extension::binomial_extension::BinomialExtensionField",
                      "value"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "p3_field::extension::binomial_extension::BinomialExtensionField",
                      "value"
                    |)
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                    [],
                    [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ] ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "_phantom"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "_phantom"
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *) [ ("eq", InstanceField.Method (eq D F A)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_core_cmp_PartialEq_A_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_F_where_core_hash_Hash_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (* Hash *)
      Definition hash
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply (Ty.path "array") [ D ] [ A ],
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |) in
              M.alloc (|
                Ty.tuple [],
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "_phantom"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *) [ ("hash", InstanceField.Method (hash D F A)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_F_where_core_hash_Hash_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_core_fmt_Debug_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (* Debug *)
      Definition fmt
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "BinomialExtensionField" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "value" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "_phantom" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ] ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "_phantom"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt D F A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_core_fmt_Debug_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module underscore.
      Module Impl_serde_ser_Serialize_where_serde_ser_Serialize_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
        Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
            [ D ]
            [ F; A ].
        
        (* Serialize *)
        Definition serialize
            (D : Value.t)
            (F A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self D F A in
          match ε, τ, α with
          | [], [ __S ], [ self; __serializer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; A ]
                    ],
                  self
                |) in
              let __serializer := M.alloc (| __S, __serializer |) in
              M.catch_return
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                  ]) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ __serde_state :
                        Ty.associated_in_trait
                          "serde::ser::Serializer"
                          []
                          []
                          __S
                          "SerializeStruct" :=
                      M.match_operator (|
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct",
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct"
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "SerializeStruct";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  [],
                                  "serialize_struct",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  mk_str (| "BinomialExtensionField" |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [
                                          M.cast (Ty.path "usize") (Value.Bool false);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val :=
                                M.copy (|
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  γ0_0
                                |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::_::serialize::__SerializeWith")
                                      [ D ]
                                      [ F; A ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "value" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::_::serialize::__SerializeWith")
                                            [ D ]
                                            [ F; A ],
                                          Value.mkStructRecord
                                            "p3_field::extension::binomial_extension::_::serialize::__SerializeWith"
                                            [ D ]
                                            [ F; A ]
                                            [
                                              ("values",
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                            "value"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]);
                                              ("phantom",
                                                Value.StructTuple
                                                  "core::marker::PhantomData"
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                      [ D ]
                                                      [ F; A ]
                                                  ]
                                                  [])
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ] ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "_phantom" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                                          "_phantom"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                          ],
                        M.get_trait_method (|
                          "serde::ser::SerializeStruct",
                          Ty.associated_in_trait
                            "serde::ser::Serializer"
                            []
                            []
                            __S
                            "SerializeStruct",
                          [],
                          [],
                          "end",
                          [],
                          []
                        |),
                        [ M.read (| __serde_state |) ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (D : Value.t) (F A : Ty.t),
          M.IsTraitInstance
            "serde::ser::Serialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self D F A)
            (* Instance *) [ ("serialize", InstanceField.Method (serialize D F A)) ].
      End Impl_serde_ser_Serialize_where_serde_ser_Serialize_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Module Impl_serde_de_Deserialize_where_serde_de_Deserialize_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
        Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
            [ D ]
            [ F; A ].
        
        (* Deserialize *)
        Definition deserialize
            (D : Value.t)
            (F A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self D F A in
          match ε, τ, α with
          | [], [ __D ], [ __deserializer ] =>
            ltac:(M.monadic
              (let __deserializer := M.alloc (| __D, __deserializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ];
                    Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                  ],
                M.get_trait_method (|
                  "serde::de::Deserializer",
                  __D,
                  [],
                  [],
                  "deserialize_struct",
                  [],
                  [
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::binomial_extension::_'1::deserialize::__Visitor")
                      [ D ]
                      [ F; A ]
                  ]
                |),
                [
                  M.read (| __deserializer |);
                  mk_str (| "BinomialExtensionField" |);
                  M.read (|
                    get_constant (|
                      "p3_field::extension::binomial_extension::_'1::deserialize::FIELDS",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                        ]
                    |)
                  |);
                  Value.mkStructRecord
                    "p3_field::extension::binomial_extension::_'1::deserialize::__Visitor"
                    [ D ]
                    [ F; A ]
                    [
                      ("marker",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; A ]
                          ]
                          []);
                      ("lifetime",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                          [])
                    ]
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (D : Value.t) (F A : Ty.t),
          M.IsTraitInstance
            "serde::de::Deserialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self D F A)
            (* Instance *) [ ("deserialize", InstanceField.Method (deserialize D F A)) ].
      End Impl_serde_de_Deserialize_where_serde_de_Deserialize_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    End underscore.
    
    
    Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_F_where_core_cmp_PartialOrd_A_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (* PartialOrd *)
      Definition partial_cmp
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                other
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.apply (Ty.path "array") [ D ] [ A ],
                    [],
                    [ Ty.apply (Ty.path "array") [ D ] [ A ] ],
                    "partial_cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "core::cmp::Ordering" ],
                      M.get_trait_method (|
                        "core::cmp::PartialOrd",
                        Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                        [],
                        [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ] ],
                        "partial_cmp",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                "_phantom"
                              |)
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| other |) |),
                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                "_phantom"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        γ
                      |) in
                    M.read (| cmp |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp D F A)) ].
    End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_F_where_core_cmp_PartialOrd_A_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_cmp_Ord_where_core_cmp_Ord_F_where_core_cmp_Ord_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (* Ord *)
      Definition cmp
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                other
              |) in
            M.match_operator (|
              Ty.path "core::cmp::Ordering",
              M.alloc (|
                Ty.path "core::cmp::Ordering",
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "array") [ D ] [ A ],
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.call_closure (|
                      Ty.path "core::cmp::Ordering",
                      M.get_trait_method (|
                        "core::cmp::Ord",
                        Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                        [],
                        [],
                        "cmp",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                "_phantom"
                              |)
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| other |) |),
                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                "_phantom"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| Ty.path "core::cmp::Ordering", γ |) in
                    M.read (| cmp |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp D F A)) ].
    End Impl_core_cmp_Ord_where_core_cmp_Ord_F_where_core_cmp_Ord_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          pub(crate) const fn new(value: [A; D]) -> Self {
              Self {
                  value,
                  _phantom: PhantomData,
              }
          }
      *)
      Definition new
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| Ty.apply (Ty.path "array") [ D ] [ A ], value |) in
            Value.mkStructRecord
              "p3_field::extension::binomial_extension::BinomialExtensionField"
              [ D ]
              [ F; A ]
              [
                ("value", M.read (| value |));
                ("_phantom", Value.StructTuple "core::marker::PhantomData" [] [ F ] [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (D : Value.t) (F A : Ty.t),
        M.IsAssociatedFunction.C (Self D F A) "new" (new D F A).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_default_Default_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn default() -> Self {
              Self::new(array::from_fn(|_| A::ZERO))
          }
      *)
      Definition default
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (|
                    "core::array::from_fn",
                    [ D ],
                    [ A; Ty.function [ Ty.path "usize" ] A ]
                  |),
                  [
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                A,
                                M.alloc (| Ty.path "usize", α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.read (|
                                        get_constant (|
                                          "p3_field::field::PrimeCharacteristicRing::ZERO",
                                          A
                                        |)
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *) [ ("default", InstanceField.Method (default D F A)) ].
    End Impl_core_default_Default_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_convert_From_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn from(x: A) -> Self {
              Self::new(field_to_array(x))
          }
      *)
      Definition from
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| A, x |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ A ] |),
                  [ M.read (| x |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *) [ ("from", InstanceField.Method (from D F A)) ].
    End Impl_core_convert_From_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_p3_field_packed_Packable_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::packed::Packable"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *) [].
    End Impl_p3_field_packed_Packable_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_p3_field_field_BasedVectorSpace_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     const DIMENSION: usize = D; *)
      (* Ty.path "usize" *)
      Definition value_DIMENSION
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        ltac:(M.monadic (M.alloc (| Ty.path "usize", D |))).
      
      (*
          fn as_basis_coefficients_slice(&self) -> &[A] {
              &self.value
          }
      *)
      Definition as_basis_coefficients_slice
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::extension::binomial_extension::BinomialExtensionField",
                      "value"
                    |)
                  |)
                |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_basis_coefficients_fn<Fn: FnMut(usize) -> A>(f: Fn) -> Self {
              Self::new(array::from_fn(f))
          }
      *)
      Definition from_basis_coefficients_fn
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [ Fn ], [ f ] =>
          ltac:(M.monadic
            (let f := M.alloc (| Fn, f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (| "core::array::from_fn", [ D ], [ A; Fn ] |),
                  [ M.read (| f |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_basis_coefficients_iter<I: ExactSizeIterator<Item = A>>(mut iter: I) -> Option<Self> {
              (iter.len() == D).then(|| Self::new(array::from_fn(|_| iter.next().unwrap()))) // The unwrap is safe as we just checked the length of iter.
          }
      *)
      Definition from_basis_coefficients_iter
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ]
                ],
              M.get_associated_function (|
                Ty.path "bool",
                "then",
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ];
                  Ty.function
                    []
                    (Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_trait_method (|
                        "core::iter::traits::exact_size::ExactSizeIterator",
                        I,
                        [],
                        [],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, iter |) ]
                    |);
                    D
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; A ],
                            M.alloc (| Ty.tuple [], α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                      [ D ]
                                      [ F; A ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ F; A ],
                                      "new",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "array") [ D ] [ A ],
                                        M.get_function (|
                                          "core::array::from_fn",
                                          [ D ],
                                          [ A; Ty.function [ Ty.path "usize" ] A ]
                                        |),
                                        [
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      A,
                                                      M.alloc (| Ty.path "usize", α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.call_closure (|
                                                              A,
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [ A ],
                                                                "unwrap",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [ A ],
                                                                  M.get_trait_method (|
                                                                    "core::iter::traits::iterator::Iterator",
                                                                    I,
                                                                    [],
                                                                    [],
                                                                    "next",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      iter
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)))
                                                      ]
                                                    |)))
                                                | _ => M.impossible "wrong number of arguments"
                                                end))
                                        ]
                                      |)
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn flatten_to_base(vec: Vec<Self>) -> Vec<A> {
              unsafe {
                  // Safety:
                  // As `Self` is a `repr(transparent)`, it is stored identically in memory to `[A; D]`
                  flatten_to_base::<A, Self>(vec)
              }
          }
      *)
      Definition flatten_to_base
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ vec ] =>
          ltac:(M.monadic
            (let vec :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ];
                    Ty.path "alloc::alloc::Global"
                  ],
                vec
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ A; Ty.path "alloc::alloc::Global" ],
              M.get_function (|
                "p3_util::flatten_to_base",
                [],
                [
                  A;
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ]
                ]
              |),
              [ M.read (| vec |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn reconstitute_from_base(vec: Vec<A>) -> Vec<Self> {
              unsafe {
                  // Safety:
                  // As `Self` is a `repr(transparent)`, it is stored identically in memory to `[A; D]`
                  reconstitute_from_base::<A, Self>(vec)
              }
          }
      *)
      Definition reconstitute_from_base
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ vec ] =>
          ltac:(M.monadic
            (let vec :=
              M.alloc (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ A; Ty.path "alloc::alloc::Global" ],
                vec
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_function (|
                "p3_util::reconstitute_from_base",
                [],
                [
                  A;
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ]
                ]
              |),
              [ M.read (| vec |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "p3_field::field::BasedVectorSpace"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *)
          [
            ("value_DIMENSION", InstanceField.Method (value_DIMENSION D F A));
            ("as_basis_coefficients_slice",
              InstanceField.Method (as_basis_coefficients_slice D F A));
            ("from_basis_coefficients_fn", InstanceField.Method (from_basis_coefficients_fn D F A));
            ("from_basis_coefficients_iter",
              InstanceField.Method (from_basis_coefficients_iter D F A));
            ("flatten_to_base", InstanceField.Method (flatten_to_base D F A));
            ("reconstitute_from_base", InstanceField.Method (reconstitute_from_base D F A))
          ].
    End Impl_p3_field_field_BasedVectorSpace_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_p3_field_field_ExtensionField_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*     type ExtensionPacking = PackedBinomialExtensionField<F, F::Packing, D>; *)
      Definition _ExtensionPacking (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ].
      
      (*
          fn is_in_basefield(&self) -> bool {
              self.value[1..].iter().all(F::is_zero)
          }
      *)
      Definition is_in_basefield
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                [],
                [],
                "all",
                [],
                [ Ty.function [ Ty.apply (Ty.path "&") [] [ F ] ] (Ty.path "bool") ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.alloc (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "iter",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "array") [ D ] [ F ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                                    "value"
                                  |)
                                |);
                                Value.mkStructRecord
                                  "core::ops::range::RangeFrom"
                                  []
                                  [ Ty.path "usize" ]
                                  [ ("start", Value.Integer IntegerKind.Usize 1) ]
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |);
                M.get_trait_method (| "p3_field::field::Field", F, [], [], "is_zero", [], [] |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn as_base(&self) -> Option<F> {
              <Self as ExtensionField<F>>::is_in_basefield(self).then(|| self.value[0])
          }
      *)
      Definition as_base
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ F ],
              M.get_associated_function (| Ty.path "bool", "then", [], [ F; Ty.function [] F ] |),
              [
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "p3_field::field::ExtensionField",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ],
                    [],
                    [ F ],
                    "is_in_basefield",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            F,
                            M.alloc (| Ty.tuple [], α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    M.SubPointer.get_array_field (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                        "value"
                                      |),
                                      Value.Integer IntegerKind.Usize 0
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::field::ExtensionField"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self D F)
          (* Instance *)
          [
            ("ExtensionPacking", InstanceField.Ty (_ExtensionPacking D F));
            ("is_in_basefield", InstanceField.Method (is_in_basefield D F));
            ("as_base", InstanceField.Method (as_base D F))
          ].
    End Impl_p3_field_field_ExtensionField_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_p3_field_extension_HasFrobenius_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*
          fn frobenius(&self) -> Self {
              self.repeated_frobenius(1)
          }
      *)
      Definition frobenius
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ],
              M.get_trait_method (|
                "p3_field::extension::HasFrobenius",
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                [],
                [ F ],
                "repeated_frobenius",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                Value.Integer IntegerKind.Usize 1
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn repeated_frobenius(&self, count: usize) -> Self {
              if count == 0 {
                  return *self;
              } else if count >= D {
                  // x |-> x^(n^D) is the identity, so x^(n^count) ==
                  // x^(n^(count % D))
                  return self.repeated_frobenius(count % D);
              }
      
              // z0 = DTH_ROOT^count = W^(k * count) where k = floor((n-1)/D)
              let z0 = F::DTH_ROOT.exp_u64(count as u64);
      
              let mut res = Self::ZERO;
              for (i, z) in z0.powers().take(D).enumerate() {
                  res.value[i] = self.value[i] * z;
              }
      
              res
          }
      *)
      Definition repeated_frobenius
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; count ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            let count := M.alloc (| Ty.path "usize", count |) in
            M.catch_return
              (Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| M.read (| M.deref (| M.read (| self |) |) |) |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          Ty.path "bool",
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.ge,
                                            [ M.read (| count |); D ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F; F ],
                                            M.get_trait_method (|
                                              "p3_field::extension::HasFrobenius",
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ F; F ],
                                              [],
                                              [ F ],
                                              "repeated_frobenius",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |);
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.rem,
                                                [ M.read (| count |); D ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |)))
                      ]
                    |) in
                  let~ z0 : F :=
                    M.call_closure (|
                      F,
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        F,
                        [],
                        [],
                        "exp_u64",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          get_constant (|
                            "p3_field::extension::BinomiallyExtendable::DTH_ROOT",
                            F
                          |)
                        |);
                        M.cast (Ty.path "u64") (M.read (| count |))
                      ]
                    |) in
                  let~ res :
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; F ] :=
                    M.read (|
                      get_constant (|
                        "p3_field::field::PrimeCharacteristicRing::ZERO",
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; F ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.read (|
                      M.use
                        (M.alloc (|
                          Ty.tuple [],
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::take::Take")
                                    []
                                    [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                ],
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::take::Take")
                                      []
                                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::take::Take")
                                        []
                                        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                    ],
                                  [],
                                  [],
                                  "into_iter",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::take::Take")
                                          []
                                          [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::take::Take")
                                        []
                                        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                                      [],
                                      [],
                                      "enumerate",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::take::Take")
                                          []
                                          [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                                          [],
                                          [],
                                          "take",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                                            M.get_trait_method (|
                                              "p3_field::field::PrimeCharacteristicRing",
                                              F,
                                              [],
                                              [],
                                              "powers",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, z0 |) ]
                                          |);
                                          D
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter :=
                                    M.copy (|
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::take::Take")
                                            []
                                            [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ]
                                            ]
                                        ],
                                      γ
                                    |) in
                                  M.read (|
                                    M.loop (|
                                      Ty.tuple [],
                                      ltac:(M.monadic
                                        (let~ _ : Ty.tuple [] :=
                                          M.match_operator (|
                                            Ty.tuple [],
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.tuple [ Ty.path "usize"; F ] ],
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.tuple [ Ty.path "usize"; F ] ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::enumerate::Enumerate")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::take::Take")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "p3_field::field::Powers")
                                                            []
                                                            [ F ]
                                                        ]
                                                    ],
                                                  [],
                                                  [],
                                                  "next",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.MutRef, iter |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let _ :=
                                                    M.is_struct_tuple (|
                                                      γ,
                                                      "core::option::Option::None"
                                                    |) in
                                                  M.never_to_any (| M.read (| M.break (||) |) |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let γ1_0 :=
                                                    M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                                  let γ1_1 :=
                                                    M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                                  let i := M.copy (| Ty.path "usize", γ1_0 |) in
                                                  let z := M.copy (| F, γ1_1 |) in
                                                  M.read (|
                                                    let~ _ : Ty.tuple [] :=
                                                      M.write (|
                                                        M.SubPointer.get_array_field (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            res,
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                            "value"
                                                          |),
                                                          M.read (| i |)
                                                        |),
                                                        M.call_closure (|
                                                          F,
                                                          M.get_trait_method (|
                                                            "core::ops::arith::Mul",
                                                            F,
                                                            [],
                                                            [ F ],
                                                            "mul",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.read (|
                                                              M.SubPointer.get_array_field (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.deref (| M.read (| self |) |),
                                                                  "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                                  "value"
                                                                |),
                                                                M.read (| i |)
                                                              |)
                                                            |);
                                                            M.read (| z |)
                                                          ]
                                                        |)
                                                      |) in
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                  |)))
                                            ]
                                          |) in
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                    |)
                                  |)))
                            ]
                          |)
                        |))
                    |) in
                  res
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn frobenius_inv(&self) -> Self {
              // Writing 'a' for self, we need to compute a^(r-1):
              // r = n^D-1/n-1 = n^(D-1)+n^(D-2)+...+n
              let mut f = Self::ONE;
              for _ in 1..D {
                  f = (f * *self).frobenius();
              }
      
              // g = a^r is in the base field, so only compute that
              // coefficient rather than the full product.
              let a = self.value;
              let b = f.value;
              let mut g = F::ZERO;
              for i in 1..D {
                  g += a[i] * b[D - i];
              }
              g *= F::W;
              g += a[0] * b[0];
              debug_assert_eq!(Self::from(g), *self * f);
      
              f * g.inverse()
          }
      *)
      Definition frobenius_inv
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            M.read (|
              let~ f :
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; F ] :=
                M.read (|
                  get_constant (|
                    "p3_field::field::PrimeCharacteristicRing::ONE",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [ ("start", Value.Integer IntegerKind.Usize 1); ("end_", D) ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.write (|
                                                    f,
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                        [ D ]
                                                        [ F; F ],
                                                      M.get_trait_method (|
                                                        "p3_field::extension::HasFrobenius",
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F; F ],
                                                        [],
                                                        [ F ],
                                                        "frobenius",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                              [ D ]
                                                              [ F; F ],
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                [ D ]
                                                                [ F; F ],
                                                              M.get_trait_method (|
                                                                "core::ops::arith::Mul",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                  [ D ]
                                                                  [ F; F ],
                                                                [],
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                    [ D ]
                                                                    [ F; F ]
                                                                ],
                                                                "mul",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (| f |);
                                                                M.read (|
                                                                  M.deref (| M.read (| self |) |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              let~ a : Ty.apply (Ty.path "array") [ D ] [ F ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ b : Ty.apply (Ty.path "array") [ D ] [ F ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    f,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ g : F :=
                M.read (|
                  get_constant (| "p3_field::field::PrimeCharacteristicRing::ZERO", F |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [ ("start", Value.Integer IntegerKind.Usize 1); ("end_", D) ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_trait_method (|
                                                      "core::ops::arith::AddAssign",
                                                      F,
                                                      [],
                                                      [ F ],
                                                      "add_assign",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (| Pointer.Kind.MutRef, g |);
                                                      M.call_closure (|
                                                        F,
                                                        M.get_trait_method (|
                                                          "core::ops::arith::Mul",
                                                          F,
                                                          [],
                                                          [ F ],
                                                          "mul",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (|
                                                            M.SubPointer.get_array_field (|
                                                              a,
                                                              M.read (| i |)
                                                            |)
                                                          |);
                                                          M.read (|
                                                            M.SubPointer.get_array_field (|
                                                              b,
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.sub,
                                                                [ D; M.read (| i |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::MulAssign",
                    F,
                    [],
                    [ F ],
                    "mul_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, g |);
                    M.read (|
                      get_constant (| "p3_field::extension::BinomiallyExtendable::W", F |)
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    F,
                    [],
                    [ F ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, g |);
                    M.call_closure (|
                      F,
                      M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| a, Value.Integer IntegerKind.Usize 0 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| b, Value.Integer IntegerKind.Usize 0 |)
                        |)
                      ]
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F; F ]
                                      ];
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F; F ]
                                      ]
                                  ],
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F; F ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F; F ],
                                          M.get_trait_method (|
                                            "core::convert::From",
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F; F ],
                                            [],
                                            [ F ],
                                            "from",
                                            [],
                                            []
                                          |),
                                          [ M.read (| g |) ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F; F ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F; F ],
                                          M.get_trait_method (|
                                            "core::ops::arith::Mul",
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F; F ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ F; F ]
                                            ],
                                            "mul",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| M.deref (| M.read (| self |) |) |);
                                            M.read (| f |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F; F ]
                                          ],
                                        γ0_0
                                      |) in
                                    let right_val :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F; F ]
                                          ],
                                        γ0_1
                                      |) in
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_trait_method (|
                                                        "core::cmp::PartialEq",
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F; F ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                            [ D ]
                                                            [ F; F ]
                                                        ],
                                                        "eq",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    [] in
                                                M.alloc (|
                                                  Ty.path "never",
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F; F ];
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F; F ]
                                                      ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                        [ Ty.path "core::fmt::Arguments" ]
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; F ],
                  M.get_trait_method (|
                    "core::ops::arith::Mul",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ],
                    [],
                    [ F ],
                    "mul",
                    [],
                    []
                  |),
                  [
                    M.read (| f |);
                    M.call_closure (|
                      F,
                      M.get_trait_method (|
                        "p3_field::field::Field",
                        F,
                        [],
                        [],
                        "inverse",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, g |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::extension::HasFrobenius"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self D F)
          (* Instance *)
          [
            ("frobenius", InstanceField.Method (frobenius D F));
            ("repeated_frobenius", InstanceField.Method (repeated_frobenius D F));
            ("frobenius_inv", InstanceField.Method (frobenius_inv D F))
          ].
    End Impl_p3_field_extension_HasFrobenius_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_p3_field_field_PrimeCharacteristicRing_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type PrimeSubfield = <A as PrimeCharacteristicRing>::PrimeSubfield; *)
      Definition _PrimeSubfield (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.associated_in_trait "p3_field::field::PrimeCharacteristicRing" [] [] A "PrimeSubfield".
      
      (*     const ZERO: Self = Self::new([A::ZERO; D]); *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ F; A ] *)
      Definition value_ZERO
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ],
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                lib.repeat (|
                  M.read (|
                    get_constant (| "p3_field::field::PrimeCharacteristicRing::ZERO", A |)
                  |),
                  D
                |)
              ]
            |)
          |))).
      
      (*     const ONE: Self = Self::new(field_to_array(A::ONE)); *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ F; A ] *)
      Definition value_ONE
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ],
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ A ] |),
                  [
                    M.read (|
                      get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", A |)
                    |)
                  ]
                |)
              ]
            |)
          |))).
      
      (*     const TWO: Self = Self::new(field_to_array(A::TWO)); *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ F; A ] *)
      Definition value_TWO
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ],
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ A ] |),
                  [
                    M.read (|
                      get_constant (| "p3_field::field::PrimeCharacteristicRing::TWO", A |)
                    |)
                  ]
                |)
              ]
            |)
          |))).
      
      (*     const NEG_ONE: Self = Self::new(field_to_array(A::NEG_ONE)); *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ F; A ] *)
      Definition value_NEG_ONE
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ],
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ A ] |),
                  [
                    M.read (|
                      get_constant (| "p3_field::field::PrimeCharacteristicRing::NEG_ONE", A |)
                    |)
                  ]
                |)
              ]
            |)
          |))).
      
      (*
          fn from_prime_subfield(f: Self::PrimeSubfield) -> Self {
              <A as PrimeCharacteristicRing>::from_prime_subfield(f).into()
          }
      *)
      Definition from_prime_subfield
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ f ] =>
          ltac:(M.monadic
            (let f :=
              M.alloc (|
                Ty.associated_in_trait
                  "p3_field::field::PrimeCharacteristicRing"
                  []
                  []
                  (Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ])
                  "PrimeSubfield",
                f
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_trait_method (|
                "core::convert::Into",
                A,
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  A,
                  M.get_trait_method (|
                    "p3_field::field::PrimeCharacteristicRing",
                    A,
                    [],
                    [],
                    "from_prime_subfield",
                    [],
                    []
                  |),
                  [ M.read (| f |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn square(&self) -> Self {
              match D {
                  2 => {
                      let a = self.value.clone();
                      let mut res = Self::default();
                      res.value[0] = a[0].square() + a[1].square() * F::W;
                      res.value[1] = a[0].clone() * a[1].double();
                      res
                  }
                  3 => {
                      let mut res = Self::default();
                      cubic_square(&self.value, &mut res.value);
                      res
                  }
                  _ => <Self as Mul<Self>>::mul(self.clone(), self.clone()),
              }
          }
      *)
      Definition square
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.alloc (| Ty.path "usize", D |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 2
                      |) in
                    M.read (|
                      let~ a : Ty.apply (Ty.path "array") [ D ] [ A ] :=
                        M.call_closure (|
                          Ty.apply (Ty.path "array") [ D ] [ A ],
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply (Ty.path "array") [ D ] [ A ],
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_field::extension::binomial_extension::BinomialExtensionField",
                                "value"
                              |)
                            |)
                          ]
                        |) in
                      let~ res :
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ],
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; A ],
                            [],
                            [],
                            "default",
                            [],
                            []
                          |),
                          []
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (|
                            M.SubPointer.get_struct_record_field (|
                              res,
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "value"
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |),
                          M.call_closure (|
                            A,
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              A,
                              [],
                              [ A ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                A,
                                M.get_trait_method (|
                                  "p3_field::field::PrimeCharacteristicRing",
                                  A,
                                  [],
                                  [],
                                  "square",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 0
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                A,
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  A,
                                  [],
                                  [ F ],
                                  "mul",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    A,
                                    M.get_trait_method (|
                                      "p3_field::field::PrimeCharacteristicRing",
                                      A,
                                      [],
                                      [],
                                      "square",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_array_field (|
                                          a,
                                          Value.Integer IntegerKind.Usize 1
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.read (|
                                    get_constant (|
                                      "p3_field::extension::BinomiallyExtendable::W",
                                      F
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (|
                            M.SubPointer.get_struct_record_field (|
                              res,
                              "p3_field::extension::binomial_extension::BinomialExtensionField",
                              "value"
                            |),
                            Value.Integer IntegerKind.Usize 1
                          |),
                          M.call_closure (|
                            A,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              A,
                              [],
                              [ A ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                A,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  A,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 0
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                A,
                                M.get_trait_method (|
                                  "p3_field::field::PrimeCharacteristicRing",
                                  A,
                                  [],
                                  [],
                                  "double",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 3
                      |) in
                    M.read (|
                      let~ res :
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ],
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; A ],
                            [],
                            [],
                            "default",
                            [],
                            []
                          |),
                          []
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "p3_field::extension::binomial_extension::cubic_square",
                            [ D ],
                            [ F; A ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                                    "value"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    res,
                                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                                    "value"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |) in
                      res
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; A ],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; A ],
                        [],
                        [
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ]
                        ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ],
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; A ],
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |);
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ],
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; A ],
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn mul_2exp_u64(&self, exp: u64) -> Self {
              Self::new(self.value.clone().map(|x| x.mul_2exp_u64(exp)))
          }
      *)
      Definition mul_2exp_u64
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let exp := M.alloc (| Ty.path "u64", exp |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ D ] [ A ],
                    "map",
                    [],
                    [ Ty.function [ A ] A; A ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "array") [ D ] [ A ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "array") [ D ] [ A ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                A,
                                M.alloc (| A, α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| A, γ |) in
                                      M.call_closure (|
                                        A,
                                        M.get_trait_method (|
                                          "p3_field::field::PrimeCharacteristicRing",
                                          A,
                                          [],
                                          [],
                                          "mul_2exp_u64",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, x |); M.read (| exp |) ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn zero_vec(len: usize) -> Vec<Self> {
              // SAFETY: this is a repr(transparent) wrapper around an array.
              unsafe { reconstitute_from_base(F::zero_vec(len * D)) }
          }
      *)
      Definition zero_vec
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ len ] =>
          ltac:(M.monadic
            (let len := M.alloc (| Ty.path "usize", len |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_function (|
                "p3_util::reconstitute_from_base",
                [],
                [
                  F;
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ]
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "p3_field::field::PrimeCharacteristicRing",
                    F,
                    [],
                    [],
                    "zero_vec",
                    [],
                    []
                  |),
                  [ M.call_closure (| Ty.path "usize", BinOp.Wrap.mul, [ M.read (| len |); D ] |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "p3_field::field::PrimeCharacteristicRing"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *)
          [
            ("PrimeSubfield", InstanceField.Ty (_PrimeSubfield D F A));
            ("value_ZERO", InstanceField.Method (value_ZERO D F A));
            ("value_ONE", InstanceField.Method (value_ONE D F A));
            ("value_TWO", InstanceField.Method (value_TWO D F A));
            ("value_NEG_ONE", InstanceField.Method (value_NEG_ONE D F A));
            ("from_prime_subfield", InstanceField.Method (from_prime_subfield D F A));
            ("square", InstanceField.Method (square D F A));
            ("mul_2exp_u64", InstanceField.Method (mul_2exp_u64 D F A));
            ("zero_vec", InstanceField.Method (zero_vec D F A))
          ].
    End Impl_p3_field_field_PrimeCharacteristicRing_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_p3_field_field_Algebra_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::field::Algebra"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self D F)
          (* Instance *) [].
    End Impl_p3_field_field_Algebra_where_p3_field_extension_BinomiallyExtendable_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_p3_field_field_Field_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*     type Packing = Self; *)
      Definition _Packing (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*     const GENERATOR: Self = Self::new(F::EXT_GENERATOR); *)
      (* Ty.apply
        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
        [ D ]
        [ F; F ] *)
      Definition value_GENERATOR
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        ltac:(M.monadic
          (M.alloc (|
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ],
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                "new",
                [],
                []
              |),
              [
                M.read (|
                  get_constant (|
                    "p3_field::extension::BinomiallyExtendable::EXT_GENERATOR",
                    Ty.apply (Ty.path "array") [ D ] [ F ]
                  |)
                |)
              ]
            |)
          |))).
      
      (*
          fn try_inverse(&self) -> Option<Self> {
              if self.is_zero() {
                  return None;
              }
      
              let mut res = Self::default();
      
              match D {
                  2 => quadratic_inv(&self.value, &mut res.value, F::W),
                  3 => cubic_inv(&self.value, &mut res.value, F::W),
                  _ => res = self.frobenius_inv(),
              }
      
              Some(res)
          }
      *)
      Definition try_inverse
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; F ]
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "p3_field::field::Field",
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ F; F ],
                                      [],
                                      [],
                                      "is_zero",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::None"
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ F; F ]
                                    ]
                                    []
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  let~ res :
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; F ] :=
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; F ],
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; F ],
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.path "usize", D |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.Usize 2
                              |) in
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_function (|
                                "p3_field::extension::binomial_extension::quadratic_inv",
                                [ D ],
                                [ F ]
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                        "value"
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        res,
                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                        "value"
                                      |)
                                    |)
                                  |)
                                |);
                                M.read (|
                                  get_constant (|
                                    "p3_field::extension::BinomiallyExtendable::W",
                                    F
                                  |)
                                |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.Usize 3
                              |) in
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_function (|
                                "p3_field::extension::binomial_extension::cubic_inv",
                                [ D ],
                                [ F ]
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                        "value"
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        res,
                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                        "value"
                                      |)
                                    |)
                                  |)
                                |);
                                M.read (|
                                  get_constant (|
                                    "p3_field::extension::BinomiallyExtendable::W",
                                    F
                                  |)
                                |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.write (|
                              res,
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path
                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                  [ D ]
                                  [ F; F ],
                                M.get_trait_method (|
                                  "p3_field::extension::HasFrobenius",
                                  Ty.apply
                                    (Ty.path
                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                    [ D ]
                                    [ F; F ],
                                  [],
                                  [ F ],
                                  "frobenius_inv",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            |)))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; F ]
                      ],
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; F ]
                      ]
                      [ M.read (| res |) ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn halve(&self) -> Self {
              Self::new(self.value.map(|x| x.halve()))
          }
      *)
      Definition halve
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ F ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ D ] [ F ],
                    "map",
                    [],
                    [ Ty.function [ F ] F; F ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                F,
                                M.alloc (| F, α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| F, γ |) in
                                      M.call_closure (|
                                        F,
                                        M.get_trait_method (|
                                          "p3_field::field::Field",
                                          F,
                                          [],
                                          [],
                                          "halve",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, x |) ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn div_2exp_u64(&self, exp: u64) -> Self {
              Self::new(self.value.map(|x| x.div_2exp_u64(exp)))
          }
      *)
      Definition div_2exp_u64
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            let exp := M.alloc (| Ty.path "u64", exp |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ F ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ D ] [ F ],
                    "map",
                    [],
                    [ Ty.function [ F ] F; F ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                F,
                                M.alloc (| F, α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| F, γ |) in
                                      M.call_closure (|
                                        F,
                                        M.get_trait_method (|
                                          "p3_field::field::Field",
                                          F,
                                          [],
                                          [],
                                          "div_2exp_u64",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, x |); M.read (| exp |) ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn order() -> BigUint {
              F::order().pow(D as u32)
          }
      *)
      Definition order
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "num_bigint::biguint::BigUint",
              M.get_associated_function (| Ty.path "num_bigint::biguint::BigUint", "pow", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Ty.path "num_bigint::biguint::BigUint",
                    M.call_closure (|
                      Ty.path "num_bigint::biguint::BigUint",
                      M.get_trait_method (| "p3_field::field::Field", F, [], [], "order", [], [] |),
                      []
                    |)
                  |)
                |);
                M.cast (Ty.path "u32") D
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::field::Field"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *)
          [
            ("Packing", InstanceField.Ty (_Packing D F));
            ("value_GENERATOR", InstanceField.Method (value_GENERATOR D F));
            ("try_inverse", InstanceField.Method (try_inverse D F));
            ("halve", InstanceField.Method (halve D F));
            ("div_2exp_u64", InstanceField.Method (div_2exp_u64 D F));
            ("order", InstanceField.Method (order D F))
          ].
    End Impl_p3_field_field_Field_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_core_fmt_Display_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*
          fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
              if self.is_zero() {
                  write!(f, "0")
              } else {
                  let str = self
                      .value
                      .iter()
                      .enumerate()
                      .filter(|(_, x)| !x.is_zero())
                      .map(|(i, x)| match (i, x.is_one()) {
                          (0, _) => format!("{x}"),
                          (1, true) => "X".to_string(),
                          (1, false) => format!("{x} X"),
                          (_, true) => format!("X^{i}"),
                          (_, false) => format!("{x} X^{i}"),
                      })
                      .join(" + ");
                  write!(f, "{}", str)
              }
          }
      *)
      Definition fmt
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "p3_field::field::Field",
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ F; F ],
                              [],
                              [],
                              "is_zero",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array [ mk_str (| "0" |) ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      let~ str : Ty.path "alloc::string::String" :=
                        M.call_closure (|
                          Ty.path "alloc::string::String",
                          M.get_trait_method (|
                            "itertools::Itertools",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::filter::Filter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                      []
                                      [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ];
                                    Ty.function
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.tuple
                                              [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                          ]
                                      ]
                                      (Ty.path "bool")
                                  ];
                                Ty.function
                                  [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ] ]
                                  (Ty.path "alloc::string::String")
                              ],
                            [],
                            [],
                            "join",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::filter::Filter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                          []
                                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ];
                                        Ty.function
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.tuple
                                                  [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "bool")
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                      ]
                                      (Ty.path "alloc::string::String")
                                  ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::filter::Filter")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            []
                                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                            ];
                                          Ty.function
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                        ]
                                        (Ty.path "alloc::string::String")
                                    ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::filter::Filter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                          []
                                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ];
                                        Ty.function
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.tuple
                                                  [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "bool")
                                      ],
                                    [],
                                    [],
                                    "map",
                                    [],
                                    [
                                      Ty.path "alloc::string::String";
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ]
                                        ]
                                        (Ty.path "alloc::string::String")
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::filter::Filter")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            []
                                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                            ];
                                          Ty.function
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")
                                        ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                          []
                                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ],
                                        [],
                                        [],
                                        "filter",
                                        [],
                                        [
                                          Ty.function
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            []
                                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                            [],
                                            [],
                                            "enumerate",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ F ],
                                                "iter",
                                                [],
                                                []
                                              |),
                                              [
                                                (* Unsize *)
                                                M.pointer_coercion
                                                  (M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                      "value"
                                                    |)
                                                  |))
                                              ]
                                            |)
                                          ]
                                        |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    Ty.path "bool",
                                                    M.alloc (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path "usize";
                                                              Ty.apply (Ty.path "&") [] [ F ]
                                                            ]
                                                        ],
                                                      α0
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ := M.read (| γ |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ1_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let x :=
                                                            M.alloc (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [ Ty.apply (Ty.path "&") [] [ F ] ],
                                                              γ1_1
                                                            |) in
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              M.get_trait_method (|
                                                                "p3_field::field::Field",
                                                                F,
                                                                [],
                                                                [],
                                                                "is_zero",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (|
                                                                      M.deref (| M.read (| x |) |)
                                                                    |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)))
                                                    ]
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end))
                                      ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.path "alloc::string::String",
                                                M.alloc (|
                                                  Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ],
                                                  α0
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                                      let x :=
                                                        M.copy (|
                                                          Ty.apply (Ty.path "&") [] [ F ],
                                                          γ0_1
                                                        |) in
                                                      M.match_operator (|
                                                        Ty.path "alloc::string::String",
                                                        M.alloc (|
                                                          Ty.tuple
                                                            [ Ty.path "usize"; Ty.path "bool" ],
                                                          Value.Tuple
                                                            [
                                                              M.read (| i |);
                                                              M.call_closure (|
                                                                Ty.path "bool",
                                                                M.get_trait_method (|
                                                                  "p3_field::field::Field",
                                                                  F,
                                                                  [],
                                                                  [],
                                                                  "is_one",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| x |) |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_0 |),
                                                                  Value.Integer IntegerKind.Usize 0
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            ""
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  []
                                                                                                  [
                                                                                                    F
                                                                                                  ]
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    x
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_0 |),
                                                                  Value.Integer IntegerKind.Usize 1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_trait_method (|
                                                                  "alloc::string::ToString",
                                                                  Ty.path "str",
                                                                  [],
                                                                  [],
                                                                  "to_string",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| mk_str (| "X" |) |)
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_0 |),
                                                                  Value.Integer IntegerKind.Usize 1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool false
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  2;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            2
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            ""
                                                                                          |);
                                                                                          mk_str (|
                                                                                            " X"
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  []
                                                                                                  [
                                                                                                    F
                                                                                                  ]
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    x
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            "X^"
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            1
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.path
                                                                                                  "usize"
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    i
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ0_1 |),
                                                                  Value.Bool false
                                                                |) in
                                                              M.call_closure (|
                                                                Ty.path "alloc::string::String",
                                                                M.get_function (|
                                                                  "core::hint::must_use",
                                                                  [],
                                                                  [ Ty.path "alloc::string::String"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    let~ res :
                                                                        Ty.path
                                                                          "alloc::string::String" :=
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "alloc::string::String",
                                                                        M.get_function (|
                                                                          "alloc::fmt::format",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_v1",
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  2;
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  2
                                                                              ],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            2
                                                                                        ]
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "str"
                                                                                            ]
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          mk_str (|
                                                                                            ""
                                                                                          |);
                                                                                          mk_str (|
                                                                                            " X^"
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.alloc (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "array")
                                                                                        [
                                                                                          Value.Integer
                                                                                            IntegerKind.Usize
                                                                                            2
                                                                                        ]
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument"
                                                                                        ],
                                                                                      Value.Array
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "&")
                                                                                                  []
                                                                                                  [
                                                                                                    F
                                                                                                  ]
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    x
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |);
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::rt::Argument",
                                                                                              "new_display",
                                                                                              [],
                                                                                              [
                                                                                                Ty.path
                                                                                                  "usize"
                                                                                              ]
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    i
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |) in
                                                                    res
                                                                  |)
                                                                ]
                                                              |)))
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)
                              |)
                            |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| " + " |) |) |)
                          ]
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_fmt",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                [
                                  Value.Integer IntegerKind.Usize 1;
                                  Value.Integer IntegerKind.Usize 1
                                ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 1 ]
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                        Value.Array [ mk_str (| "" |) ]
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 1 ]
                                          [ Ty.path "core::fmt::rt::Argument" ],
                                        Value.Array
                                          [
                                            M.call_closure (|
                                              Ty.path "core::fmt::rt::Argument",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Argument",
                                                "new_display",
                                                [],
                                                [ Ty.path "alloc::string::String" ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.borrow (| Pointer.Kind.Ref, str |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt D F)) ].
    End Impl_core_fmt_Display_where_p3_field_extension_BinomiallyExtendable_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_core_ops_arith_Neg_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn neg(self) -> Self {
              Self::new(self.value.map(A::neg))
          }
      *)
      Definition neg
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ D ] [ A ],
                    "map",
                    [],
                    [
                      Ty.function
                        [ A ]
                        (Ty.associated_in_trait "core::ops::arith::Neg" [] [] A "Output");
                      A
                    ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |);
                    M.get_trait_method (| "core::ops::arith::Neg", A, [], [], "neg", [], [] |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F A)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F A)); ("neg", InstanceField.Method (neg D F A))
          ].
    End Impl_core_ops_arith_Neg_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn add(self, rhs: Self) -> Self {
              let value = vector_add(&self.value, &rhs.value);
              Self::new(value)
          }
      *)
      Definition add
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                rhs
              |) in
            M.read (|
              let~ value : Ty.apply (Ty.path "array") [ D ] [ A ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::vector_add",
                    [ D ],
                    [ A; A ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            rhs,
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F A)); ("add", InstanceField.Method (add D F A))
          ].
    End Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn add(mut self, rhs: A) -> Self {
              self.value[0] += rhs;
              self
          }
      *)
      Definition add
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                self
              |) in
            let rhs := M.alloc (| A, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    A,
                    [],
                    [ A ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              self
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F A)); ("add", InstanceField.Method (add D F A))
          ].
    End Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn add_assign(&mut self, rhs: Self) {
              for i in 0..D {
                  self.value[i] += rhs.value[i].clone();
              }
          }
      *)
      Definition add_assign
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                rhs
              |) in
            M.read (|
              M.use
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", D) ]
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter :=
                            M.copy (|
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              γ
                            |) in
                          M.read (|
                            M.loop (|
                              Ty.tuple [],
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.never_to_any (| M.read (| M.break (||) |) |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                          M.read (|
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "core::ops::arith::AddAssign",
                                                  A,
                                                  [],
                                                  [ A ],
                                                  "add_assign",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_array_field (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                        "value"
                                                      |),
                                                      M.read (| i |)
                                                    |)
                                                  |);
                                                  M.call_closure (|
                                                    A,
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      A,
                                                      [],
                                                      [],
                                                      "clone",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_array_field (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            rhs,
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                            "value"
                                                          |),
                                                          M.read (| i |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |) in
                                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            |)
                          |)))
                    ]
                  |)
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign D F A)) ].
    End Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn add_assign(&mut self, rhs: A) {
              self.value[0] += rhs;
          }
      *)
      Definition add_assign
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let rhs := M.alloc (| A, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    A,
                    [],
                    [ A ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign D F A)) ].
    End Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_iter_traits_accum_Sum_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
              iter.reduce(|acc, x| acc + x).unwrap_or(Self::ZERO)
          }
      *)
      Definition sum
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                "unwrap_or",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; A ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    [],
                    "reduce",
                    [],
                    [
                      Ty.function
                        [
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ];
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ]
                        ]
                        (Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; A ])
                    ]
                  |),
                  [
                    M.read (| iter |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path
                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                  [ D ]
                                  [ F; A ],
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path
                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                    [ D ]
                                    [ F; A ],
                                  α0
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let acc :=
                                        M.copy (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F; A ],
                                          γ
                                        |) in
                                      M.match_operator (|
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F; A ],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F; A ],
                                          α1
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let x :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                    [ D ]
                                                    [ F; A ],
                                                  γ
                                                |) in
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                  [ D ]
                                                  [ F; A ],
                                                M.get_trait_method (|
                                                  "core::ops::arith::Add",
                                                  Ty.apply
                                                    (Ty.path
                                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                    [ D ]
                                                    [ F; A ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                      [ D ]
                                                      [ F; A ]
                                                  ],
                                                  "add",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| acc |); M.read (| x |) ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |);
                M.read (|
                  get_constant (|
                    "p3_field::field::PrimeCharacteristicRing::ZERO",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Sum"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *) [ ("sum", InstanceField.Method (sum D F A)) ].
    End Impl_core_iter_traits_accum_Sum_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn sub(self, rhs: Self) -> Self {
              let value = vector_sub(&self.value, &rhs.value);
              Self::new(value)
          }
      *)
      Definition sub
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                rhs
              |) in
            M.read (|
              let~ value : Ty.apply (Ty.path "array") [ D ] [ A ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::vector_sub",
                    [ D ],
                    [ A; A ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            rhs,
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F A)); ("sub", InstanceField.Method (sub D F A))
          ].
    End Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn sub(self, rhs: A) -> Self {
              let mut res = self.value;
              res[0] -= rhs;
              Self::new(res)
          }
      *)
      Definition sub
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                self
              |) in
            let rhs := M.alloc (| A, rhs |) in
            M.read (|
              let~ res : Ty.apply (Ty.path "array") [ D ] [ A ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::SubAssign",
                    A,
                    [],
                    [ A ],
                    "sub_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (| res, Value.Integer IntegerKind.Usize 0 |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| res |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F A)); ("sub", InstanceField.Method (sub D F A))
          ].
    End Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn sub_assign(&mut self, rhs: Self) {
              for i in 0..D {
                  self.value[i] -= rhs.value[i].clone();
              }
          }
      *)
      Definition sub_assign
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                rhs
              |) in
            M.read (|
              M.use
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", D) ]
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter :=
                            M.copy (|
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              γ
                            |) in
                          M.read (|
                            M.loop (|
                              Ty.tuple [],
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.never_to_any (| M.read (| M.break (||) |) |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                          M.read (|
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "core::ops::arith::SubAssign",
                                                  A,
                                                  [],
                                                  [ A ],
                                                  "sub_assign",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_array_field (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                        "value"
                                                      |),
                                                      M.read (| i |)
                                                    |)
                                                  |);
                                                  M.call_closure (|
                                                    A,
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      A,
                                                      [],
                                                      [],
                                                      "clone",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_array_field (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            rhs,
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                            "value"
                                                          |),
                                                          M.read (| i |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |) in
                                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            |)
                          |)))
                    ]
                  |)
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign D F A)) ].
    End Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn sub_assign(&mut self, rhs: A) {
              self.value[0] -= rhs;
          }
      *)
      Definition sub_assign
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let rhs := M.alloc (| A, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::SubAssign",
                    A,
                    [],
                    [ A ],
                    "sub_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign D F A)) ].
    End Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn mul(self, rhs: Self) -> Self {
              let a = self.value;
              let b = rhs.value;
              let mut res = Self::default();
              let w = F::W;
      
              binomial_mul(&a, &b, &mut res.value, w);
      
              res
          }
      *)
      Definition mul
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                rhs
              |) in
            M.read (|
              let~ a : Ty.apply (Ty.path "array") [ D ] [ A ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ b : Ty.apply (Ty.path "array") [ D ] [ A ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    rhs,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ res :
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; A ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |) in
              let~ w : F :=
                M.read (| get_constant (| "p3_field::extension::BinomiallyExtendable::W", F |) |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::binomial_mul",
                    [ D ],
                    [ F; A; A ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, b |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            res,
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.read (| w |)
                  ]
                |) in
              res
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F A)); ("mul", InstanceField.Method (mul D F A))
          ].
    End Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn mul(self, rhs: A) -> Self {
              Self::new(self.value.map(|x| x * rhs.clone()))
          }
      *)
      Definition mul
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                self
              |) in
            let rhs := M.alloc (| A, rhs |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ D ] [ A ],
                    "map",
                    [],
                    [ Ty.function [ A ] A; A ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "p3_field::extension::binomial_extension::BinomialExtensionField",
                        "value"
                      |)
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                A,
                                M.alloc (| A, α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| A, γ |) in
                                      M.call_closure (|
                                        A,
                                        M.get_trait_method (|
                                          "core::ops::arith::Mul",
                                          A,
                                          [],
                                          [ A ],
                                          "mul",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| x |);
                                          M.call_closure (|
                                            A,
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              A,
                                              [],
                                              [],
                                              "clone",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                          |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F A)); ("mul", InstanceField.Method (mul D F A))
          ].
    End Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn mul_assign(&mut self, rhs: Self) {
              *self = self.clone() * rhs;
          }
      *)
      Definition mul_assign
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; A ],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; A ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; A ]
                      ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; A ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| rhs |)
                    ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign D F A)) ].
    End Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn mul_assign(&mut self, rhs: A) {
              *self = self.clone() * rhs;
          }
      *)
      Definition mul_assign
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                self
              |) in
            let rhs := M.alloc (| A, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; A ],
                      [],
                      [ A ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; A ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| rhs |)
                    ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ A ]
          (Self D F A)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign D F A)) ].
    End Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_iter_traits_accum_Product_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
      Definition Self (D : Value.t) (F A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; A ].
      
      (*
          fn product<I: Iterator<Item = Self>>(iter: I) -> Self {
              iter.reduce(|acc, x| acc * x).unwrap_or(Self::ONE)
          }
      *)
      Definition product
          (D : Value.t)
          (F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F A in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; A ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  ],
                "unwrap_or",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; A ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    [],
                    "reduce",
                    [],
                    [
                      Ty.function
                        [
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ];
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                            [ D ]
                            [ F; A ]
                        ]
                        (Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; A ])
                    ]
                  |),
                  [
                    M.read (| iter |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path
                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                  [ D ]
                                  [ F; A ],
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path
                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                    [ D ]
                                    [ F; A ],
                                  α0
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let acc :=
                                        M.copy (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F; A ],
                                          γ
                                        |) in
                                      M.match_operator (|
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F; A ],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::binomial_extension::BinomialExtensionField")
                                            [ D ]
                                            [ F; A ],
                                          α1
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let x :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                    [ D ]
                                                    [ F; A ],
                                                  γ
                                                |) in
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                  [ D ]
                                                  [ F; A ],
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  Ty.apply
                                                    (Ty.path
                                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                    [ D ]
                                                    [ F; A ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                      [ D ]
                                                      [ F; A ]
                                                  ],
                                                  "mul",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| acc |); M.read (| x |) ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |);
                M.read (|
                  get_constant (|
                    "p3_field::field::PrimeCharacteristicRing::ONE",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; A ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Product"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; A ]
          ]
          (Self D F A)
          (* Instance *) [ ("product", InstanceField.Method (product D F A)) ].
    End Impl_core_iter_traits_accum_Product_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_field_Algebra_A_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_A.
    
    Module Impl_core_ops_arith_Div_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*
          fn div(self, rhs: Self) -> Self::Output {
              self * rhs.inverse()
          }
      *)
      Definition div
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                rhs
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ],
              M.get_trait_method (|
                "core::ops::arith::Mul",
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                [],
                [
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; F ]
                ],
                "mul",
                [],
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                    [ D ]
                    [ F; F ],
                  M.get_trait_method (|
                    "p3_field::field::Field",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ],
                    [],
                    [],
                    "inverse",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output D F)); ("div", InstanceField.Method (div D F)) ].
    End Impl_core_ops_arith_Div_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_core_ops_arith_DivAssign_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*
          fn div_assign(&mut self, rhs: Self) {
              *self = *self / rhs;
          }
      *)
      Definition div_assign
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ]
                  ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ],
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; F ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; F ]
                      ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F)
          (* Instance *) [ ("div_assign", InstanceField.Method (div_assign D F)) ].
    End Impl_core_ops_arith_DivAssign_where_p3_field_extension_BinomiallyExtendable_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    Module Impl_rand_distr_distribution_Distribution_where_p3_field_extension_BinomiallyExtendable_F_where_rand_distr_distribution_Distribution_rand_distr_StandardUniform_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_rand_distr_StandardUniform.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t := Ty.path "rand::distr::StandardUniform".
      
      (*
          fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> BinomialExtensionField<F, D> {
              BinomialExtensionField::new(array::from_fn(|_| self.sample(rng)))
          }
      *)
      Definition sample
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [ R ], [ self; rng ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "rand::distr::StandardUniform" ],
                self
              |) in
            let rng := M.alloc (| Ty.apply (Ty.path "&mut") [] [ R ], rng |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ F ],
                  M.get_function (|
                    "core::array::from_fn",
                    [ D ],
                    [ F; Ty.function [ Ty.path "usize" ] F ]
                  |),
                  [
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                F,
                                M.alloc (| Ty.path "usize", α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        F,
                                        M.get_trait_method (|
                                          "rand::distr::distribution::Distribution",
                                          Ty.path "rand::distr::StandardUniform",
                                          [],
                                          [ F ],
                                          "sample",
                                          [],
                                          [ R ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| rng |) |)
                                          |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "rand::distr::distribution::Distribution"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F)
          (* Instance *) [ ("sample", InstanceField.Method (sample D F)) ].
    End Impl_rand_distr_distribution_Distribution_where_p3_field_extension_BinomiallyExtendable_F_where_rand_distr_distribution_Distribution_rand_distr_StandardUniform_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_rand_distr_StandardUniform.
    
    Module Impl_p3_field_field_TwoAdicField_where_p3_field_field_Field_F_where_p3_field_extension_HasTwoAdicBinomialExtension_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
          [ D ]
          [ F; F ].
      
      (*     const TWO_ADICITY: usize = F::EXT_TWO_ADICITY; *)
      (* Ty.path "usize" *)
      Definition value_TWO_ADICITY
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        ltac:(M.monadic
          (get_constant (|
            "p3_field::extension::HasTwoAdicBinomialExtension::EXT_TWO_ADICITY",
            Ty.path "usize"
          |))).
      
      (*
          fn two_adic_generator(bits: usize) -> Self {
              Self::new(F::ext_two_adic_generator(bits))
          }
      *)
      Definition two_adic_generator
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ bits ] =>
          ltac:(M.monadic
            (let bits := M.alloc (| Ty.path "usize", bits |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                [ D ]
                [ F; F ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                  [ D ]
                  [ F; F ],
                "new",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ F ],
                  M.get_trait_method (|
                    "p3_field::extension::HasTwoAdicBinomialExtension",
                    F,
                    [ D ],
                    [],
                    "ext_two_adic_generator",
                    [],
                    []
                  |),
                  [ M.read (| bits |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::field::TwoAdicField"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F)
          (* Instance *)
          [
            ("value_TWO_ADICITY", InstanceField.Method (value_TWO_ADICITY D F));
            ("two_adic_generator", InstanceField.Method (two_adic_generator D F))
          ].
    End Impl_p3_field_field_TwoAdicField_where_p3_field_field_Field_F_where_p3_field_extension_HasTwoAdicBinomialExtension_F_for_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F.
    
    (*
    pub(crate) fn vector_add<
        R: PrimeCharacteristicRing + Add<R2, Output = R>,
        R2: Clone,
        const D: usize,
    >(
        a: &[R; D],
        b: &[R2; D],
    ) -> [R; D] {
        array::from_fn(|i| a[i].clone() + b[i].clone())
    }
    *)
    Definition vector_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ R; R2 ], [ a; b ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R ] ], a |) in
          let b :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R2 ] ],
              b
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ D ] [ R ],
            M.get_function (|
              "core::array::from_fn",
              [ D ],
              [ R; Ty.function [ Ty.path "usize" ] R ]
            |),
            [
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          R,
                          M.alloc (| Ty.path "usize", α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let i := M.copy (| Ty.path "usize", γ |) in
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    R,
                                    [],
                                    [ R2 ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      R2,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R2,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_vector_add :
      M.IsFunction.C "p3_field::extension::binomial_extension::vector_add" vector_add.
    Admitted.
    Global Typeclasses Opaque vector_add.
    
    (*
    pub(crate) fn vector_sub<
        R: PrimeCharacteristicRing + Sub<R2, Output = R>,
        R2: Clone,
        const D: usize,
    >(
        a: &[R; D],
        b: &[R2; D],
    ) -> [R; D] {
        array::from_fn(|i| a[i].clone() - b[i].clone())
    }
    *)
    Definition vector_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ R; R2 ], [ a; b ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R ] ], a |) in
          let b :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R2 ] ],
              b
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ D ] [ R ],
            M.get_function (|
              "core::array::from_fn",
              [ D ],
              [ R; Ty.function [ Ty.path "usize" ] R ]
            |),
            [
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          R,
                          M.alloc (| Ty.path "usize", α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let i := M.copy (| Ty.path "usize", γ |) in
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::ops::arith::Sub",
                                    R,
                                    [],
                                    [ R2 ],
                                    "sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      R2,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R2,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_vector_sub :
      M.IsFunction.C "p3_field::extension::binomial_extension::vector_sub" vector_sub.
    Admitted.
    Global Typeclasses Opaque vector_sub.
    
    (*
    pub(super) fn binomial_mul<
        F: Field,
        R: Algebra<F> + Mul<R2, Output = R>,
        R2: Add<Output = R2> + Clone,
        const D: usize,
    >(
        a: &[R; D],
        b: &[R2; D],
        res: &mut [R; D],
        w: F,
    ) {
        match D {
            2 => {
                res[0] = a[0].clone() * b[0].clone() + a[1].clone() * w * b[1].clone();
                res[1] = a[0].clone() * b[1].clone() + a[1].clone() * b[0].clone();
            }
            3 => cubic_mul(a, b, res, w),
            _ =>
            {
                #[allow(clippy::needless_range_loop)]
                for i in 0..D {
                    for j in 0..D {
                        if i + j >= D {
                            res[i + j - D] += a[i].clone() * w * b[j].clone();
                        } else {
                            res[i + j] += a[i].clone() * b[j].clone();
                        }
                    }
                }
            }
        }
    }
    *)
    Definition binomial_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ F; R; R2 ], [ a; b; res; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R ] ], a |) in
          let b :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R2 ] ],
              b
            |) in
          let res :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ D ] [ R ] ],
              res
            |) in
          let w := M.alloc (| F, w |) in
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.path "usize", D |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.Usize 2
                    |) in
                  M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.write (|
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| res |) |),
                          Value.Integer IntegerKind.Usize 0
                        |),
                        M.call_closure (|
                          R,
                          M.get_trait_method (|
                            "core::ops::arith::Add",
                            R,
                            [],
                            [ R ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                R,
                                [],
                                [ R2 ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  R2,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R2,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| b |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |);
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                R,
                                [],
                                [ R2 ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    R,
                                    [],
                                    [ F ],
                                    "mul",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 1
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| w |)
                                  ]
                                |);
                                M.call_closure (|
                                  R2,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R2,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| b |) |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.write (|
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| res |) |),
                          Value.Integer IntegerKind.Usize 1
                        |),
                        M.call_closure (|
                          R,
                          M.get_trait_method (|
                            "core::ops::arith::Add",
                            R,
                            [],
                            [ R ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                R,
                                [],
                                [ R2 ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  R2,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R2,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| b |) |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |);
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                R,
                                [],
                                [ R2 ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  R2,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R2,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| b |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    is_constant_or_break_match (|
                      M.read (| γ |),
                      Value.Integer IntegerKind.Usize 3
                    |) in
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "p3_field::extension::binomial_extension::cubic_mul",
                      [ D ],
                      [ F; R; R2 ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| res |) |) |);
                      M.read (| w |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.read (|
                    M.use
                      (M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.call_closure (|
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [
                                Value.mkStructRecord
                                  "core::ops::range::Range"
                                  []
                                  [ Ty.path "usize" ]
                                  [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", D) ]
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    γ
                                  |) in
                                M.read (|
                                  M.loop (|
                                    Ty.tuple [],
                                    ltac:(M.monadic
                                      (let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "usize" ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  []
                                                  [ Ty.path "usize" ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.MutRef, iter |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.never_to_any (| M.read (| M.break (||) |) |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                                M.read (|
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.tuple [],
                                                      M.match_operator (|
                                                        Ty.tuple [],
                                                        M.alloc (|
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::ops::range::Range")
                                                              []
                                                              [ Ty.path "usize" ],
                                                            M.get_trait_method (|
                                                              "core::iter::traits::collect::IntoIterator",
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                []
                                                                [ Ty.path "usize" ],
                                                              [],
                                                              [],
                                                              "into_iter",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              Value.mkStructRecord
                                                                "core::ops::range::Range"
                                                                []
                                                                [ Ty.path "usize" ]
                                                                [
                                                                  ("start",
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      0);
                                                                  ("end_", D)
                                                                ]
                                                            ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let iter :=
                                                                M.copy (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ops::range::Range")
                                                                    []
                                                                    [ Ty.path "usize" ],
                                                                  γ
                                                                |) in
                                                              M.read (|
                                                                M.loop (|
                                                                  Ty.tuple [],
                                                                  ltac:(M.monadic
                                                                    (let~ _ : Ty.tuple [] :=
                                                                      M.match_operator (|
                                                                        Ty.tuple [],
                                                                        M.alloc (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            []
                                                                            [ Ty.path "usize" ],
                                                                          M.call_closure (|
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::option::Option")
                                                                              []
                                                                              [ Ty.path "usize" ],
                                                                            M.get_trait_method (|
                                                                              "core::iter::traits::iterator::Iterator",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::ops::range::Range")
                                                                                []
                                                                                [ Ty.path "usize" ],
                                                                              [],
                                                                              [],
                                                                              "next",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.MutRef,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.MutRef,
                                                                                    iter
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let _ :=
                                                                                M.is_struct_tuple (|
                                                                                  γ,
                                                                                  "core::option::Option::None"
                                                                                |) in
                                                                              M.never_to_any (|
                                                                                M.read (|
                                                                                  M.break (||)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ0_0 :=
                                                                                M.SubPointer.get_struct_tuple_field (|
                                                                                  γ,
                                                                                  "core::option::Option::Some",
                                                                                  0
                                                                                |) in
                                                                              let j :=
                                                                                M.copy (|
                                                                                  Ty.path "usize",
                                                                                  γ0_0
                                                                                |) in
                                                                              M.match_operator (|
                                                                                Ty.tuple [],
                                                                                M.alloc (|
                                                                                  Ty.tuple [],
                                                                                  Value.Tuple []
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ :=
                                                                                        M.use
                                                                                          (M.alloc (|
                                                                                            Ty.path
                                                                                              "bool",
                                                                                            M.call_closure (|
                                                                                              Ty.path
                                                                                                "bool",
                                                                                              BinOp.ge,
                                                                                              [
                                                                                                M.call_closure (|
                                                                                                  Ty.path
                                                                                                    "usize",
                                                                                                  BinOp.Wrap.add,
                                                                                                  [
                                                                                                    M.read (|
                                                                                                      i
                                                                                                    |);
                                                                                                    M.read (|
                                                                                                      j
                                                                                                    |)
                                                                                                  ]
                                                                                                |);
                                                                                                D
                                                                                              ]
                                                                                            |)
                                                                                          |)) in
                                                                                      let _ :=
                                                                                        is_constant_or_break_match (|
                                                                                          M.read (|
                                                                                            γ
                                                                                          |),
                                                                                          Value.Bool
                                                                                            true
                                                                                        |) in
                                                                                      M.read (|
                                                                                        let~ _ :
                                                                                            Ty.tuple
                                                                                              [] :=
                                                                                          M.call_closure (|
                                                                                            Ty.tuple
                                                                                              [],
                                                                                            M.get_trait_method (|
                                                                                              "core::ops::arith::AddAssign",
                                                                                              R,
                                                                                              [],
                                                                                              [ R ],
                                                                                              "add_assign",
                                                                                              [],
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.MutRef,
                                                                                                M.SubPointer.get_array_field (|
                                                                                                  M.deref (|
                                                                                                    M.read (|
                                                                                                      res
                                                                                                    |)
                                                                                                  |),
                                                                                                  M.call_closure (|
                                                                                                    Ty.path
                                                                                                      "usize",
                                                                                                    BinOp.Wrap.sub,
                                                                                                    [
                                                                                                      M.call_closure (|
                                                                                                        Ty.path
                                                                                                          "usize",
                                                                                                        BinOp.Wrap.add,
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            i
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            j
                                                                                                          |)
                                                                                                        ]
                                                                                                      |);
                                                                                                      D
                                                                                                    ]
                                                                                                  |)
                                                                                                |)
                                                                                              |);
                                                                                              M.call_closure (|
                                                                                                R,
                                                                                                M.get_trait_method (|
                                                                                                  "core::ops::arith::Mul",
                                                                                                  R,
                                                                                                  [],
                                                                                                  [
                                                                                                    R2
                                                                                                  ],
                                                                                                  "mul",
                                                                                                  [],
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  M.call_closure (|
                                                                                                    R,
                                                                                                    M.get_trait_method (|
                                                                                                      "core::ops::arith::Mul",
                                                                                                      R,
                                                                                                      [],
                                                                                                      [
                                                                                                        F
                                                                                                      ],
                                                                                                      "mul",
                                                                                                      [],
                                                                                                      []
                                                                                                    |),
                                                                                                    [
                                                                                                      M.call_closure (|
                                                                                                        R,
                                                                                                        M.get_trait_method (|
                                                                                                          "core::clone::Clone",
                                                                                                          R,
                                                                                                          [],
                                                                                                          [],
                                                                                                          "clone",
                                                                                                          [],
                                                                                                          []
                                                                                                        |),
                                                                                                        [
                                                                                                          M.borrow (|
                                                                                                            Pointer.Kind.Ref,
                                                                                                            M.SubPointer.get_array_field (|
                                                                                                              M.deref (|
                                                                                                                M.read (|
                                                                                                                  a
                                                                                                                |)
                                                                                                              |),
                                                                                                              M.read (|
                                                                                                                i
                                                                                                              |)
                                                                                                            |)
                                                                                                          |)
                                                                                                        ]
                                                                                                      |);
                                                                                                      M.read (|
                                                                                                        w
                                                                                                      |)
                                                                                                    ]
                                                                                                  |);
                                                                                                  M.call_closure (|
                                                                                                    R2,
                                                                                                    M.get_trait_method (|
                                                                                                      "core::clone::Clone",
                                                                                                      R2,
                                                                                                      [],
                                                                                                      [],
                                                                                                      "clone",
                                                                                                      [],
                                                                                                      []
                                                                                                    |),
                                                                                                    [
                                                                                                      M.borrow (|
                                                                                                        Pointer.Kind.Ref,
                                                                                                        M.SubPointer.get_array_field (|
                                                                                                          M.deref (|
                                                                                                            M.read (|
                                                                                                              b
                                                                                                            |)
                                                                                                          |),
                                                                                                          M.read (|
                                                                                                            j
                                                                                                          |)
                                                                                                        |)
                                                                                                      |)
                                                                                                    ]
                                                                                                  |)
                                                                                                ]
                                                                                              |)
                                                                                            ]
                                                                                          |) in
                                                                                        M.alloc (|
                                                                                          Ty.tuple
                                                                                            [],
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |)
                                                                                      |)));
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (M.read (|
                                                                                        let~ _ :
                                                                                            Ty.tuple
                                                                                              [] :=
                                                                                          M.call_closure (|
                                                                                            Ty.tuple
                                                                                              [],
                                                                                            M.get_trait_method (|
                                                                                              "core::ops::arith::AddAssign",
                                                                                              R,
                                                                                              [],
                                                                                              [ R ],
                                                                                              "add_assign",
                                                                                              [],
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.MutRef,
                                                                                                M.SubPointer.get_array_field (|
                                                                                                  M.deref (|
                                                                                                    M.read (|
                                                                                                      res
                                                                                                    |)
                                                                                                  |),
                                                                                                  M.call_closure (|
                                                                                                    Ty.path
                                                                                                      "usize",
                                                                                                    BinOp.Wrap.add,
                                                                                                    [
                                                                                                      M.read (|
                                                                                                        i
                                                                                                      |);
                                                                                                      M.read (|
                                                                                                        j
                                                                                                      |)
                                                                                                    ]
                                                                                                  |)
                                                                                                |)
                                                                                              |);
                                                                                              M.call_closure (|
                                                                                                R,
                                                                                                M.get_trait_method (|
                                                                                                  "core::ops::arith::Mul",
                                                                                                  R,
                                                                                                  [],
                                                                                                  [
                                                                                                    R2
                                                                                                  ],
                                                                                                  "mul",
                                                                                                  [],
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  M.call_closure (|
                                                                                                    R,
                                                                                                    M.get_trait_method (|
                                                                                                      "core::clone::Clone",
                                                                                                      R,
                                                                                                      [],
                                                                                                      [],
                                                                                                      "clone",
                                                                                                      [],
                                                                                                      []
                                                                                                    |),
                                                                                                    [
                                                                                                      M.borrow (|
                                                                                                        Pointer.Kind.Ref,
                                                                                                        M.SubPointer.get_array_field (|
                                                                                                          M.deref (|
                                                                                                            M.read (|
                                                                                                              a
                                                                                                            |)
                                                                                                          |),
                                                                                                          M.read (|
                                                                                                            i
                                                                                                          |)
                                                                                                        |)
                                                                                                      |)
                                                                                                    ]
                                                                                                  |);
                                                                                                  M.call_closure (|
                                                                                                    R2,
                                                                                                    M.get_trait_method (|
                                                                                                      "core::clone::Clone",
                                                                                                      R2,
                                                                                                      [],
                                                                                                      [],
                                                                                                      "clone",
                                                                                                      [],
                                                                                                      []
                                                                                                    |),
                                                                                                    [
                                                                                                      M.borrow (|
                                                                                                        Pointer.Kind.Ref,
                                                                                                        M.SubPointer.get_array_field (|
                                                                                                          M.deref (|
                                                                                                            M.read (|
                                                                                                              b
                                                                                                            |)
                                                                                                          |),
                                                                                                          M.read (|
                                                                                                            j
                                                                                                          |)
                                                                                                        |)
                                                                                                      |)
                                                                                                    ]
                                                                                                  |)
                                                                                                ]
                                                                                              |)
                                                                                            ]
                                                                                          |) in
                                                                                        M.alloc (|
                                                                                          Ty.tuple
                                                                                            [],
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |)
                                                                                      |)))
                                                                                ]
                                                                              |)))
                                                                        ]
                                                                      |) in
                                                                    M.alloc (|
                                                                      Ty.tuple [],
                                                                      Value.Tuple []
                                                                    |)))
                                                                |)
                                                              |)))
                                                        ]
                                                      |)
                                                    |))
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                  |)
                                |)))
                          ]
                        |)
                      |))
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_binomial_mul :
      M.IsFunction.C "p3_field::extension::binomial_extension::binomial_mul" binomial_mul.
    Admitted.
    Global Typeclasses Opaque binomial_mul.
    
    (*
    fn quadratic_inv<F: Field, const D: usize>(a: &[F; D], res: &mut [F; D], w: F) {
        assert_eq!(D, 2);
        let scalar = (a[0].square() - w * a[1].square()).inverse();
        res[0] = a[0] * scalar;
        res[1] = -a[1] * scalar;
    }
    *)
    Definition quadratic_inv (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ F ], [ a; res; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ F ] ], a |) in
          let res :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ D ] [ F ] ],
              res
            |) in
          let w := M.alloc (| F, w |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Ty.path "usize", D |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 2 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            let~ scalar : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      F,
                      M.call_closure (|
                        F,
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          F,
                          [],
                          [ F ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "p3_field::field::PrimeCharacteristicRing",
                              F,
                              [],
                              [],
                              "square",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| a |) |),
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              F,
                              [],
                              [ F ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.read (| w |);
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "p3_field::field::PrimeCharacteristicRing",
                                  F,
                                  [],
                                  [],
                                  "square",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      M.deref (| M.read (| a |) |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 0
                |),
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| scalar |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 1
                |),
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                  [
                    M.call_closure (|
                      F,
                      M.get_trait_method (| "core::ops::arith::Neg", F, [], [], "neg", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| a |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      ]
                    |);
                    M.read (| scalar |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_quadratic_inv :
      M.IsFunction.C "p3_field::extension::binomial_extension::quadratic_inv" quadratic_inv.
    Admitted.
    Global Typeclasses Opaque quadratic_inv.
    
    (*
    fn cubic_inv<F: Field, const D: usize>(a: &[F; D], res: &mut [F; D], w: F) {
        assert_eq!(D, 3);
        let a0_square = a[0].square();
        let a1_square = a[1].square();
        let a2_w = w * a[2];
        let a0_a1 = a[0] * a[1];
    
        // scalar = (a0^3+wa1^3+w^2a2^3-3wa0a1a2)^-1
        let scalar = (a0_square * a[0] + w * a[1] * a1_square + a2_w.square() * a[2]
            - (F::ONE + F::TWO) * a2_w * a0_a1)
            .inverse();
    
        //scalar*[a0^2-wa1a2, wa2^2-a0a1, a1^2-a0a2]
        res[0] = scalar * (a0_square - a[1] * a2_w);
        res[1] = scalar * (a2_w * a[2] - a0_a1);
        res[2] = scalar * (a1_square - a[0] * a[2]);
    }
    *)
    Definition cubic_inv (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ F ], [ a; res; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ F ] ], a |) in
          let res :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ D ] [ F ] ],
              res
            |) in
          let w := M.alloc (| F, w |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Ty.path "usize", D |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            let~ a0_square : F :=
              M.call_closure (|
                F,
                M.get_trait_method (|
                  "p3_field::field::PrimeCharacteristicRing",
                  F,
                  [],
                  [],
                  "square",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |)
                ]
              |) in
            let~ a1_square : F :=
              M.call_closure (|
                F,
                M.get_trait_method (|
                  "p3_field::field::PrimeCharacteristicRing",
                  F,
                  [],
                  [],
                  "square",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |)
                ]
              |) in
            let~ a2_w : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                [
                  M.read (| w |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |)
                ]
              |) in
            let~ a0_a1 : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                [
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |)
                ]
              |) in
            let~ scalar : F :=
              M.call_closure (|
                F,
                M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      F,
                      M.call_closure (|
                        F,
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          F,
                          [],
                          [ F ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              F,
                              [],
                              [ F ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "core::ops::arith::Add",
                                  F,
                                  [],
                                  [ F ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      F,
                                      [],
                                      [ F ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (| a0_square |);
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.deref (| M.read (| a |) |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      F,
                                      [],
                                      [ F ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        F,
                                        M.get_trait_method (|
                                          "core::ops::arith::Mul",
                                          F,
                                          [],
                                          [ F ],
                                          "mul",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| w |);
                                          M.read (|
                                            M.SubPointer.get_array_field (|
                                              M.deref (| M.read (| a |) |),
                                              Value.Integer IntegerKind.Usize 1
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.read (| a1_square |)
                                    ]
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  F,
                                  [],
                                  [ F ],
                                  "mul",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "p3_field::field::PrimeCharacteristicRing",
                                      F,
                                      [],
                                      [],
                                      "square",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, a2_w |) ]
                                  |);
                                  M.read (|
                                    M.SubPointer.get_array_field (|
                                      M.deref (| M.read (| a |) |),
                                      Value.Integer IntegerKind.Usize 2
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.call_closure (|
                            F,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              F,
                              [],
                              [ F ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                F,
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  F,
                                  [],
                                  [ F ],
                                  "mul",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Add",
                                      F,
                                      [],
                                      [ F ],
                                      "add",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        get_constant (|
                                          "p3_field::field::PrimeCharacteristicRing::ONE",
                                          F
                                        |)
                                      |);
                                      M.read (|
                                        get_constant (|
                                          "p3_field::field::PrimeCharacteristicRing::TWO",
                                          F
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.read (| a2_w |)
                                ]
                              |);
                              M.read (| a0_a1 |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 0
                |),
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                  [
                    M.read (| scalar |);
                    M.call_closure (|
                      F,
                      M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
                      [
                        M.read (| a0_square |);
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "core::ops::arith::Mul",
                            F,
                            [],
                            [ F ],
                            "mul",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| a |) |),
                                Value.Integer IntegerKind.Usize 1
                              |)
                            |);
                            M.read (| a2_w |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 1
                |),
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                  [
                    M.read (| scalar |);
                    M.call_closure (|
                      F,
                      M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
                      [
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "core::ops::arith::Mul",
                            F,
                            [],
                            [ F ],
                            "mul",
                            [],
                            []
                          |),
                          [
                            M.read (| a2_w |);
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| a |) |),
                                Value.Integer IntegerKind.Usize 2
                              |)
                            |)
                          ]
                        |);
                        M.read (| a0_a1 |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 2
                |),
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                  [
                    M.read (| scalar |);
                    M.call_closure (|
                      F,
                      M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
                      [
                        M.read (| a1_square |);
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "core::ops::arith::Mul",
                            F,
                            [],
                            [ F ],
                            "mul",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| a |) |),
                                Value.Integer IntegerKind.Usize 0
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| a |) |),
                                Value.Integer IntegerKind.Usize 2
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_cubic_inv :
      M.IsFunction.C "p3_field::extension::binomial_extension::cubic_inv" cubic_inv.
    Admitted.
    Global Typeclasses Opaque cubic_inv.
    
    (*
    pub(crate) fn cubic_mul<
        F: Field,
        R: Algebra<F> + Mul<R2, Output = R>,
        R2: Add<Output = R2> + Clone,
        const D: usize,
    >(
        a: &[R; D],
        b: &[R2; D],
        res: &mut [R; D],
        w: F,
    ) {
        assert_eq!(D, 3);
    
        let a0_b0 = a[0].clone() * b[0].clone();
        let a1_b1 = a[1].clone() * b[1].clone();
        let a2_b2 = a[2].clone() * b[2].clone();
    
        res[0] = a0_b0.clone()
            + ((a[1].clone() + a[2].clone()) * (b[1].clone() + b[2].clone())
                - a1_b1.clone()
                - a2_b2.clone())
                * w;
        res[1] = (a[0].clone() + a[1].clone()) * (b[0].clone() + b[1].clone())
            - a0_b0.clone()
            - a1_b1.clone()
            + a2_b2.clone() * w;
        res[2] = (a[0].clone() + a[2].clone()) * (b[0].clone() + b[2].clone()) - a0_b0 - a2_b2 + a1_b1;
    }
    *)
    Definition cubic_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ F; R; R2 ], [ a; b; res; w ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R ] ], a |) in
          let b :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ R2 ] ],
              b
            |) in
          let res :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ D ] [ R ] ],
              res
            |) in
          let w := M.alloc (| F, w |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Ty.path "usize", D |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            let~ a0_b0 : R :=
              M.call_closure (|
                R,
                M.get_trait_method (| "core::ops::arith::Mul", R, [], [ R2 ], "mul", [], [] |),
                [
                  M.call_closure (|
                    R,
                    M.get_trait_method (| "core::clone::Clone", R, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    R2,
                    M.get_trait_method (| "core::clone::Clone", R2, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| b |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ a1_b1 : R :=
              M.call_closure (|
                R,
                M.get_trait_method (| "core::ops::arith::Mul", R, [], [ R2 ], "mul", [], [] |),
                [
                  M.call_closure (|
                    R,
                    M.get_trait_method (| "core::clone::Clone", R, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    R2,
                    M.get_trait_method (| "core::clone::Clone", R2, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| b |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ a2_b2 : R :=
              M.call_closure (|
                R,
                M.get_trait_method (| "core::ops::arith::Mul", R, [], [ R2 ], "mul", [], [] |),
                [
                  M.call_closure (|
                    R,
                    M.get_trait_method (| "core::clone::Clone", R, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    R2,
                    M.get_trait_method (| "core::clone::Clone", R2, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| b |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 0
                |),
                M.call_closure (|
                  R,
                  M.get_trait_method (| "core::ops::arith::Add", R, [], [ R ], "add", [], [] |),
                  [
                    M.call_closure (|
                      R,
                      M.get_trait_method (| "core::clone::Clone", R, [], [], "clone", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, a0_b0 |) ]
                    |);
                    M.call_closure (|
                      R,
                      M.get_trait_method (| "core::ops::arith::Mul", R, [], [ F ], "mul", [], [] |),
                      [
                        M.call_closure (|
                          R,
                          M.get_trait_method (|
                            "core::ops::arith::Sub",
                            R,
                            [],
                            [ R ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::ops::arith::Sub",
                                R,
                                [],
                                [ R ],
                                "sub",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    R,
                                    [],
                                    [ R2 ],
                                    "mul",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::ops::arith::Add",
                                        R,
                                        [],
                                        [ R ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          R,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            R,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| a |) |),
                                                Value.Integer IntegerKind.Usize 1
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          R,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            R,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| a |) |),
                                                Value.Integer IntegerKind.Usize 2
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      R2,
                                      M.get_trait_method (|
                                        "core::ops::arith::Add",
                                        R2,
                                        [],
                                        [ R2 ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          R2,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            R2,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| b |) |),
                                                Value.Integer IntegerKind.Usize 1
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          R2,
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            R2,
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| b |) |),
                                                Value.Integer IntegerKind.Usize 2
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    R,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, a1_b1 |) ]
                                |)
                              ]
                            |);
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                R,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, a2_b2 |) ]
                            |)
                          ]
                        |);
                        M.read (| w |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 1
                |),
                M.call_closure (|
                  R,
                  M.get_trait_method (| "core::ops::arith::Add", R, [], [ R ], "add", [], [] |),
                  [
                    M.call_closure (|
                      R,
                      M.get_trait_method (| "core::ops::arith::Sub", R, [], [ R ], "sub", [], [] |),
                      [
                        M.call_closure (|
                          R,
                          M.get_trait_method (|
                            "core::ops::arith::Sub",
                            R,
                            [],
                            [ R ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                R,
                                [],
                                [ R2 ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    R,
                                    [],
                                    [ R ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 1
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  R2,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    R2,
                                    [],
                                    [ R2 ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R2,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R2,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      R2,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R2,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 1
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |);
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                R,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, a0_b0 |) ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          R,
                          M.get_trait_method (| "core::clone::Clone", R, [], [], "clone", [], [] |),
                          [ M.borrow (| Pointer.Kind.Ref, a1_b1 |) ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      R,
                      M.get_trait_method (| "core::ops::arith::Mul", R, [], [ F ], "mul", [], [] |),
                      [
                        M.call_closure (|
                          R,
                          M.get_trait_method (| "core::clone::Clone", R, [], [], "clone", [], [] |),
                          [ M.borrow (| Pointer.Kind.Ref, a2_b2 |) ]
                        |);
                        M.read (| w |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 2
                |),
                M.call_closure (|
                  R,
                  M.get_trait_method (| "core::ops::arith::Add", R, [], [ R ], "add", [], [] |),
                  [
                    M.call_closure (|
                      R,
                      M.get_trait_method (| "core::ops::arith::Sub", R, [], [ R ], "sub", [], [] |),
                      [
                        M.call_closure (|
                          R,
                          M.get_trait_method (|
                            "core::ops::arith::Sub",
                            R,
                            [],
                            [ R ],
                            "sub",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              R,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                R,
                                [],
                                [ R2 ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  R,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    R,
                                    [],
                                    [ R ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| a |) |),
                                            Value.Integer IntegerKind.Usize 2
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  R2,
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    R2,
                                    [],
                                    [ R2 ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      R2,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R2,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      R2,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        R2,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| b |) |),
                                            Value.Integer IntegerKind.Usize 2
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |);
                            M.read (| a0_b0 |)
                          ]
                        |);
                        M.read (| a2_b2 |)
                      ]
                    |);
                    M.read (| a1_b1 |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_cubic_mul :
      M.IsFunction.C "p3_field::extension::binomial_extension::cubic_mul" cubic_mul.
    Admitted.
    Global Typeclasses Opaque cubic_mul.
    
    (*
    pub(crate) fn cubic_square<F: BinomiallyExtendable<D>, A: Algebra<F>, const D: usize>(
        a: &[A; D],
        res: &mut [A; D],
    ) {
        assert_eq!(D, 3);
    
        let w_a2 = a[2].clone() * F::W;
    
        res[0] = a[0].square() + (a[1].clone() * w_a2.clone()).double();
        res[1] = w_a2 * a[2].clone() + (a[0].clone() * a[1].clone()).double();
        res[2] = a[1].square() + (a[0].clone() * a[2].clone()).double();
    }
    *)
    Definition cubic_square (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ D ], [ F; A ], [ a; res ] =>
        ltac:(M.monadic
          (let a :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ D ] [ A ] ], a |) in
          let res :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ D ] [ A ] ],
              res
            |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Ty.path "usize", D |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            let~ w_a2 : A :=
              M.call_closure (|
                A,
                M.get_trait_method (| "core::ops::arith::Mul", A, [], [ F ], "mul", [], [] |),
                [
                  M.call_closure (|
                    A,
                    M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| a |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    ]
                  |);
                  M.read (| get_constant (| "p3_field::extension::BinomiallyExtendable::W", F |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 0
                |),
                M.call_closure (|
                  A,
                  M.get_trait_method (| "core::ops::arith::Add", A, [], [ A ], "add", [], [] |),
                  [
                    M.call_closure (|
                      A,
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        A,
                        [],
                        [],
                        "square",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| a |) |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      A,
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        A,
                        [],
                        [],
                        "double",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            A,
                            M.call_closure (|
                              A,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                A,
                                [],
                                [ A ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, w_a2 |) ]
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 1
                |),
                M.call_closure (|
                  A,
                  M.get_trait_method (| "core::ops::arith::Add", A, [], [ A ], "add", [], [] |),
                  [
                    M.call_closure (|
                      A,
                      M.get_trait_method (| "core::ops::arith::Mul", A, [], [ A ], "mul", [], [] |),
                      [
                        M.read (| w_a2 |);
                        M.call_closure (|
                          A,
                          M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_array_field (|
                                M.deref (| M.read (| a |) |),
                                Value.Integer IntegerKind.Usize 2
                              |)
                            |)
                          ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      A,
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        A,
                        [],
                        [],
                        "double",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            A,
                            M.call_closure (|
                              A,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                A,
                                [],
                                [ A ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| res |) |),
                  Value.Integer IntegerKind.Usize 2
                |),
                M.call_closure (|
                  A,
                  M.get_trait_method (| "core::ops::arith::Add", A, [], [ A ], "add", [], [] |),
                  [
                    M.call_closure (|
                      A,
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        A,
                        [],
                        [],
                        "square",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| a |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      A,
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        A,
                        [],
                        [],
                        "double",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            A,
                            M.call_closure (|
                              A,
                              M.get_trait_method (|
                                "core::ops::arith::Mul",
                                A,
                                [],
                                [ A ],
                                "mul",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| a |) |),
                                        Value.Integer IntegerKind.Usize 2
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_cubic_square :
      M.IsFunction.C "p3_field::extension::binomial_extension::cubic_square" cubic_square.
    Admitted.
    Global Typeclasses Opaque cubic_square.
  End binomial_extension.
End extension.
