(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module extension.
  (* Trait *)
  (* Empty module 'BinomiallyExtendable' *)
  
  (* Trait *)
  Module HasFrobenius.
    Definition galois_orbit
        (F Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Self, self |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ Self; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::iter::adapters::take::Take")
                []
                [
                  Ty.apply
                    (Ty.path "core::iter::sources::successors::Successors")
                    []
                    [
                      Self;
                      Ty.function
                        [ Ty.apply (Ty.path "&") [] [ Self ] ]
                        (Ty.apply (Ty.path "core::option::Option") [] [ Self ])
                    ]
                ],
              [],
              [],
              "collect",
              [],
              [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ Self; Ty.path "alloc::alloc::Global" ] ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::take::Take")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::iter::sources::successors::Successors")
                      []
                      [
                        Self;
                        Ty.function
                          [ Ty.apply (Ty.path "&") [] [ Self ] ]
                          (Ty.apply (Ty.path "core::option::Option") [] [ Self ])
                      ]
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::sources::successors::Successors")
                    []
                    [
                      Self;
                      Ty.function
                        [ Ty.apply (Ty.path "&") [] [ Self ] ]
                        (Ty.apply (Ty.path "core::option::Option") [] [ Self ])
                    ],
                  [],
                  [],
                  "take",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::sources::successors::Successors")
                      []
                      [
                        Self;
                        Ty.function
                          [ Ty.apply (Ty.path "&") [] [ Self ] ]
                          (Ty.apply (Ty.path "core::option::Option") [] [ Self ])
                      ],
                    M.get_function (|
                      "core::iter::sources::successors::successors",
                      [],
                      [
                        Self;
                        Ty.function
                          [ Ty.apply (Ty.path "&") [] [ Self ] ]
                          (Ty.apply (Ty.path "core::option::Option") [] [ Self ])
                      ]
                    |),
                    [
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Self ]
                        [ M.read (| self |) ];
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                                  M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x :=
                                          M.copy (| Ty.apply (Ty.path "&") [] [ Self ], γ |) in
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          []
                                          [ Self ]
                                          [
                                            M.call_closure (|
                                              Self,
                                              M.get_trait_method (|
                                                "p3_field::extension::HasFrobenius",
                                                Self,
                                                [],
                                                [ F ],
                                                "frobenius",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| x |) |)
                                                |)
                                              ]
                                            |)
                                          ]))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |);
                  M.read (|
                    get_constant (|
                      "p3_field::field::BasedVectorSpace::DIMENSION",
                      Ty.path "usize"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_galois_orbit :
      forall (F : Ty.t),
      M.IsProvidedMethod "p3_field::extension::HasFrobenius" "galois_orbit" (galois_orbit F).
  End HasFrobenius.
  
  (* Trait *)
  (* Empty module 'HasTwoAdicBinomialExtension' *)
End extension.
