(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module extension.
  Module packed_binomial_extension.
    (* StructRecord
      {
        name := "PackedBinomialExtensionField";
        const_params := [ "D" ];
        ty_params := [ "F"; "PF" ];
        fields := [ ("value", Ty.apply (Ty.path "array") [ D ] [ PF ]) ];
      } *)
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_F_where_p3_field_field_Field_F_where_core_marker_Copy_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_F_where_p3_field_field_Field_F_where_core_marker_Copy_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_Field_F_where_core_clone_Clone_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (* Clone *)
      Definition clone
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "array") [ D ] [ PF ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                              "value"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *) [ ("clone", InstanceField.Method (clone D F PF)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_Field_F_where_core_clone_Clone_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_F_where_p3_field_field_Field_F_where_core_cmp_Eq_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.tuple [],
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *)
          [
            ("assert_receiver_is_total_eq",
              InstanceField.Method (assert_receiver_is_total_eq D F PF))
          ].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_F_where_p3_field_field_Field_F_where_core_cmp_Eq_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_marker_StructuralPartialEq_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_p3_field_field_Field_F_where_core_cmp_PartialEq_PF_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (* PartialEq *)
      Definition eq
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ D ] [ PF ],
                [],
                [ Ty.apply (Ty.path "array") [ D ] [ PF ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                    "value"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                    "value"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *) [ ("eq", InstanceField.Method (eq D F PF)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_where_p3_field_field_Field_F_where_core_cmp_PartialEq_PF_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_F_where_p3_field_field_Field_F_where_core_hash_Hash_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (* Hash *)
      Definition hash
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply (Ty.path "array") [ D ] [ PF ],
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *) [ ("hash", InstanceField.Method (hash D F PF)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_F_where_p3_field_field_Field_F_where_core_hash_Hash_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_Field_F_where_core_fmt_Debug_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (* Debug *)
      Definition fmt
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "PackedBinomialExtensionField" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "value" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                              "value"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt D F PF)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_Field_F_where_core_fmt_Debug_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module underscore.
      Module Impl_serde_ser_Serialize_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_where_serde_ser_Serialize_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
        Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
            [ D ]
            [ F; PF ].
        
        (* Serialize *)
        Definition serialize
            (D : Value.t)
            (F PF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self D F PF in
          match ε, τ, α with
          | [], [ __S ], [ self; __serializer ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let __serializer := M.alloc (| __serializer |) in
              M.read (|
                M.catch_return
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                      Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                    ]) (|
                  ltac:(M.monadic
                    (M.alloc (|
                      M.read (|
                        let~ __serde_state :
                            Ty.associated_in_trait
                              "serde::ser::Serializer"
                              []
                              []
                              __S
                              "SerializeStruct" :=
                          M.read (|
                            M.match_operator (|
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct",
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::control_flow::ControlFlow")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ];
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "SerializeStruct"
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "serde::ser::Serializer"
                                          []
                                          []
                                          __S
                                          "SerializeStruct";
                                        Ty.associated_in_trait
                                          "serde::ser::Serializer"
                                          []
                                          []
                                          __S
                                          "Error"
                                      ],
                                    [],
                                    [],
                                    "branch",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "SerializeStruct";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "serde::ser::Serializer",
                                        __S,
                                        [],
                                        [],
                                        "serialize_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (| __serializer |);
                                        mk_str (| "PackedBinomialExtensionField" |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [
                                            M.cast (Ty.path "usize") (Value.Bool false);
                                            Value.Integer IntegerKind.Usize 1
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "serde::ser::Serializer"
                                                    []
                                                    []
                                                    __S
                                                    "Ok";
                                                  Ty.associated_in_trait
                                                    "serde::ser::Serializer"
                                                    []
                                                    []
                                                    __S
                                                    "Error"
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.associated_in_trait
                                                      "serde::ser::Serializer"
                                                      []
                                                      []
                                                      __S
                                                      "Ok";
                                                    Ty.associated_in_trait
                                                      "serde::ser::Serializer"
                                                      []
                                                      []
                                                      __S
                                                      "Error"
                                                  ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.associated_in_trait
                                                        "serde::ser::Serializer"
                                                        []
                                                        []
                                                        __S
                                                        "Error"
                                                    ]
                                                ],
                                                "from_residual",
                                                [],
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |)
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::control_flow::ControlFlow")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ];
                                      Ty.tuple []
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.tuple [];
                                        Ty.associated_in_trait
                                          "serde::ser::Serializer"
                                          []
                                          []
                                          __S
                                          "Error"
                                      ],
                                    [],
                                    [],
                                    "branch",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.tuple [];
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "serde::ser::SerializeStruct",
                                        Ty.associated_in_trait
                                          "serde::ser::Serializer"
                                          []
                                          []
                                          __S
                                          "SerializeStruct",
                                        [],
                                        [],
                                        "serialize_field",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "p3_field::extension::packed_binomial_extension::_::serialize::__SerializeWith")
                                            [ D ]
                                            [ F; PF ]
                                        ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (| Pointer.Kind.MutRef, __serde_state |)
                                          |)
                                        |);
                                        mk_str (| "value" |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.StructRecord
                                                  "p3_field::extension::packed_binomial_extension::_::serialize::__SerializeWith"
                                                  [ D ]
                                                  [ F; PF ]
                                                  [
                                                    ("values",
                                                      Value.Tuple
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.deref (| M.read (| self |) |),
                                                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                                                                  "value"
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]);
                                                    ("phantom",
                                                      Value.StructTuple
                                                        "core::marker::PhantomData"
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                            [ D ]
                                                            [ F; PF ]
                                                        ]
                                                        [])
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "serde::ser::Serializer"
                                                    []
                                                    []
                                                    __S
                                                    "Ok";
                                                  Ty.associated_in_trait
                                                    "serde::ser::Serializer"
                                                    []
                                                    []
                                                    __S
                                                    "Error"
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.associated_in_trait
                                                      "serde::ser::Serializer"
                                                      []
                                                      []
                                                      __S
                                                      "Ok";
                                                    Ty.associated_in_trait
                                                      "serde::ser::Serializer"
                                                      []
                                                      []
                                                      __S
                                                      "Error"
                                                  ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.associated_in_trait
                                                        "serde::ser::Serializer"
                                                        []
                                                        []
                                                        __S
                                                        "Error"
                                                    ]
                                                ],
                                                "from_residual",
                                                [],
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |)
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                                Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                              ],
                            M.get_trait_method (|
                              "serde::ser::SerializeStruct",
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct",
                              [],
                              [],
                              "end",
                              [],
                              []
                            |),
                            [ M.read (| __serde_state |) ]
                          |)
                        |)
                      |)
                    |)))
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (D : Value.t) (F PF : Ty.t),
          M.IsTraitInstance
            "serde::ser::Serialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self D F PF)
            (* Instance *) [ ("serialize", InstanceField.Method (serialize D F PF)) ].
      End Impl_serde_ser_Serialize_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_where_serde_ser_Serialize_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Module Impl_serde_de_Deserialize_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_where_serde_de_Deserialize_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
        Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
            [ D ]
            [ F; PF ].
        
        (* Deserialize *)
        Definition deserialize
            (D : Value.t)
            (F PF : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self D F PF in
          match ε, τ, α with
          | [], [ __D ], [ __deserializer ] =>
            ltac:(M.monadic
              (let __deserializer := M.alloc (| __deserializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ];
                    Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                  ],
                M.get_trait_method (|
                  "serde::de::Deserializer",
                  __D,
                  [],
                  [],
                  "deserialize_struct",
                  [],
                  [
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::_'1::deserialize::__Visitor")
                      [ D ]
                      [ F; PF ]
                  ]
                |),
                [
                  M.read (| __deserializer |);
                  mk_str (| "PackedBinomialExtensionField" |);
                  M.read (|
                    get_constant (|
                      "p3_field::extension::packed_binomial_extension::_'1::deserialize::FIELDS",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                        ]
                    |)
                  |);
                  Value.StructRecord
                    "p3_field::extension::packed_binomial_extension::_'1::deserialize::__Visitor"
                    [ D ]
                    [ F; PF ]
                    [
                      ("marker",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                              [ D ]
                              [ F; PF ]
                          ]
                          []);
                      ("lifetime",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                          [])
                    ]
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (D : Value.t) (F PF : Ty.t),
          M.IsTraitInstance
            "serde::de::Deserialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self D F PF)
            (* Instance *) [ ("deserialize", InstanceField.Method (deserialize D F PF)) ].
      End Impl_serde_de_Deserialize_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_where_serde_de_Deserialize_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    End underscore.
    
    
    Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_F_where_p3_field_field_Field_F_where_core_cmp_PartialOrd_PF_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (* PartialOrd *)
      Definition partial_cmp
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "array") [ D ] [ PF ],
                [],
                [ Ty.apply (Ty.path "array") [ D ] [ PF ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp D F PF)) ].
    End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_F_where_p3_field_field_Field_F_where_core_cmp_PartialOrd_PF_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_cmp_Ord_where_core_cmp_Ord_F_where_p3_field_field_Field_F_where_core_cmp_Ord_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (* Ord *)
      Definition cmp
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::cmp::Ord",
                Ty.apply (Ty.path "array") [ D ] [ PF ],
                [],
                [],
                "cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                        "value"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp D F PF)) ].
    End Impl_core_cmp_Ord_where_core_cmp_Ord_F_where_p3_field_field_Field_F_where_core_cmp_Ord_PF_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          const fn new(value: [PF; D]) -> Self {
              Self { value }
          }
      *)
      Definition new
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [ ("value", M.read (| value |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsAssociatedFunction.C (Self D F PF) "new" (new D F PF).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_default_Default_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn default() -> Self {
              Self {
                  value: array::from_fn(|_| PF::ZERO),
              }
          }
      *)
      Definition default
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ D ],
                      [ PF; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] PF ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.function [ Ty.tuple [ Ty.path "usize" ] ] PF,
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.read (|
                                          get_constant (|
                                            "p3_field::field::PrimeCharacteristicRing::ZERO",
                                            PF
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *) [ ("default", InstanceField.Method (default D F PF)) ].
    End Impl_core_default_Default_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_convert_From_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn from(x: BinomialExtensionField<F, D>) -> Self {
              Self {
                  value: x.value.map(Into::into),
              }
          }
      *)
      Definition from
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "array") [ D ] [ F ],
                      "map",
                      [],
                      [ Ty.function [ F ] PF; PF ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          x,
                          "p3_field::extension::binomial_extension::BinomialExtensionField",
                          "value"
                        |)
                      |);
                      M.get_trait_method (| "core::convert::Into", F, [], [ PF ], "into", [], [] |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *) [ ("from", InstanceField.Method (from D F PF)) ].
    End Impl_core_convert_From_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_convert_From_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn from(x: PF) -> Self {
              Self {
                  value: field_to_array(x),
              }
          }
      *)
      Definition from
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ PF ] |),
                    [ M.read (| x |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *) [ ("from", InstanceField.Method (from D F PF)) ].
    End Impl_core_convert_From_where_p3_field_field_Field_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_p3_field_field_Algebra_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "p3_field::field::Algebra"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *) [].
    End Impl_p3_field_field_Algebra_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_p3_field_field_Algebra_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "p3_field::field::Algebra"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *) [].
    End Impl_p3_field_field_Algebra_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_p3_field_field_PrimeCharacteristicRing_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type PrimeSubfield = PF::PrimeSubfield; *)
      Definition _PrimeSubfield (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.associated_in_trait "p3_field::field::PrimeCharacteristicRing" [] [] PF "PrimeSubfield".
      
      (*
          const ZERO: Self = Self {
              value: [PF::ZERO; D],
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
        [ D ]
        [ F; PF ] *)
      Definition value_ZERO
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        ltac:(M.monadic
          (M.alloc (|
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  lib.repeat (|
                    M.read (|
                      get_constant (| "p3_field::field::PrimeCharacteristicRing::ZERO", PF |)
                    |),
                    D
                  |))
              ]
          |))).
      
      (*
          const ONE: Self = Self {
              value: field_to_array(PF::ONE),
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
        [ D ]
        [ F; PF ] *)
      Definition value_ONE
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        ltac:(M.monadic
          (M.alloc (|
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ PF ] |),
                    [
                      M.read (|
                        get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", PF |)
                      |)
                    ]
                  |))
              ]
          |))).
      
      (*
          const TWO: Self = Self {
              value: field_to_array(PF::TWO),
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
        [ D ]
        [ F; PF ] *)
      Definition value_TWO
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        ltac:(M.monadic
          (M.alloc (|
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ PF ] |),
                    [
                      M.read (|
                        get_constant (| "p3_field::field::PrimeCharacteristicRing::TWO", PF |)
                      |)
                    ]
                  |))
              ]
          |))).
      
      (*
          const NEG_ONE: Self = Self {
              value: field_to_array(PF::NEG_ONE),
          };
      *)
      (* Ty.apply
        (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
        [ D ]
        [ F; PF ] *)
      Definition value_NEG_ONE
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        ltac:(M.monadic
          (M.alloc (|
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_function (| "p3_field::helpers::field_to_array", [ D ], [ PF ] |),
                    [
                      M.read (|
                        get_constant (| "p3_field::field::PrimeCharacteristicRing::NEG_ONE", PF |)
                      |)
                    ]
                  |))
              ]
          |))).
      
      (*
          fn from_prime_subfield(val: Self::PrimeSubfield) -> Self {
              PF::from_prime_subfield(val).into()
          }
      *)
      Definition from_prime_subfield
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ val ] =>
          ltac:(M.monadic
            (let val := M.alloc (| val |) in
            M.call_closure (|
              Ty.apply
                (Ty.path
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                [ D ]
                [ F; PF ],
              M.get_trait_method (|
                "core::convert::Into",
                PF,
                [],
                [
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  PF,
                  M.get_trait_method (|
                    "p3_field::field::PrimeCharacteristicRing",
                    PF,
                    [],
                    [],
                    "from_prime_subfield",
                    [],
                    []
                  |),
                  [ M.read (| val |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_bool(b: bool) -> Self {
              PF::from_bool(b).into()
          }
      *)
      Definition from_bool
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ b ] =>
          ltac:(M.monadic
            (let b := M.alloc (| b |) in
            M.call_closure (|
              Ty.apply
                (Ty.path
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                [ D ]
                [ F; PF ],
              M.get_trait_method (|
                "core::convert::Into",
                PF,
                [],
                [
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  PF,
                  M.get_trait_method (|
                    "p3_field::field::PrimeCharacteristicRing",
                    PF,
                    [],
                    [],
                    "from_bool",
                    [],
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn square(&self) -> Self {
              match D {
                  2 => {
                      let a = self.value;
                      let mut res = Self::default();
                      res.value[0] = a[0].square() + a[1].square() * F::W;
                      res.value[1] = a[0] * a[1].double();
                      res
                  }
                  3 => {
                      let mut res = Self::default();
                      cubic_square(&self.value, &mut res.value);
                      res
                  }
                  _ => *self * *self,
              }
          }
      *)
      Definition square
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path
                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                  [ D ]
                  [ F; PF ],
                M.alloc (| D |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (|
                          M.read (| γ |),
                          Value.Integer IntegerKind.Usize 2
                        |) in
                      let~ a : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |) in
                      let~ res :
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                            [ D ]
                            [ F; PF ] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                            [ D ]
                            [ F; PF ],
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                              [ D ]
                              [ F; PF ],
                            [],
                            [],
                            "default",
                            [],
                            []
                          |),
                          []
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (|
                            M.SubPointer.get_struct_record_field (|
                              res,
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                              "value"
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |),
                          M.call_closure (|
                            PF,
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              PF,
                              [],
                              [ PF ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                PF,
                                M.get_trait_method (|
                                  "p3_field::field::PrimeCharacteristicRing",
                                  PF,
                                  [],
                                  [],
                                  "square",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 0
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                PF,
                                M.get_trait_method (|
                                  "core::ops::arith::Mul",
                                  PF,
                                  [],
                                  [ F ],
                                  "mul",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    PF,
                                    M.get_trait_method (|
                                      "p3_field::field::PrimeCharacteristicRing",
                                      PF,
                                      [],
                                      [],
                                      "square",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_array_field (|
                                          a,
                                          Value.Integer IntegerKind.Usize 1
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.read (|
                                    get_constant (|
                                      "p3_field::extension::BinomiallyExtendable::W",
                                      F
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (|
                            M.SubPointer.get_struct_record_field (|
                              res,
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                              "value"
                            |),
                            Value.Integer IntegerKind.Usize 1
                          |),
                          M.call_closure (|
                            PF,
                            M.get_trait_method (|
                              "core::ops::arith::Mul",
                              PF,
                              [],
                              [ PF ],
                              "mul",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  a,
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |);
                              M.call_closure (|
                                PF,
                                M.get_trait_method (|
                                  "p3_field::field::PrimeCharacteristicRing",
                                  PF,
                                  [],
                                  [],
                                  "double",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_array_field (|
                                      a,
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (|
                          M.read (| γ |),
                          Value.Integer IntegerKind.Usize 3
                        |) in
                      let~ res :
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                            [ D ]
                            [ F; PF ] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                            [ D ]
                            [ F; PF ],
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                              [ D ]
                              [ F; PF ],
                            [],
                            [],
                            "default",
                            [],
                            []
                          |),
                          []
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "p3_field::extension::binomial_extension::cubic_square",
                            [ D ],
                            [ F; PF ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                                    "value"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    res,
                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                                    "value"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |) in
                      res));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path
                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                            [ D ]
                            [ F; PF ],
                          M.get_trait_method (|
                            "core::ops::arith::Mul",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                              [ D ]
                              [ F; PF ],
                            [],
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [ F; PF ]
                            ],
                            "mul",
                            [],
                            []
                          |),
                          [
                            M.read (| M.deref (| M.read (| self |) |) |);
                            M.read (| M.deref (| M.read (| self |) |) |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn zero_vec(len: usize) -> Vec<Self> {
              // SAFETY: this is a repr(transparent) wrapper around an array.
              unsafe { reconstitute_from_base(PF::zero_vec(len * D)) }
          }
      *)
      Definition zero_vec
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ len ] =>
          ltac:(M.monadic
            (let len := M.alloc (| len |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_function (|
                "p3_util::reconstitute_from_base",
                [],
                [
                  PF;
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ]
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ PF; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "p3_field::field::PrimeCharacteristicRing",
                    PF,
                    [],
                    [],
                    "zero_vec",
                    [],
                    []
                  |),
                  [ M.call_closure (| Ty.path "usize", BinOp.Wrap.mul, [ M.read (| len |); D ] |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "p3_field::field::PrimeCharacteristicRing"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *)
          [
            ("PrimeSubfield", InstanceField.Ty (_PrimeSubfield D F PF));
            ("value_ZERO", InstanceField.Method (value_ZERO D F PF));
            ("value_ONE", InstanceField.Method (value_ONE D F PF));
            ("value_TWO", InstanceField.Method (value_TWO D F PF));
            ("value_NEG_ONE", InstanceField.Method (value_NEG_ONE D F PF));
            ("from_prime_subfield", InstanceField.Method (from_prime_subfield D F PF));
            ("from_bool", InstanceField.Method (from_bool D F PF));
            ("square", InstanceField.Method (square D F PF));
            ("zero_vec", InstanceField.Method (zero_vec D F PF))
          ].
    End Impl_p3_field_field_PrimeCharacteristicRing_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_p3_field_field_BasedVectorSpace_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     const DIMENSION: usize = D; *)
      (* Ty.path "usize" *)
      Definition value_DIMENSION
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        ltac:(M.monadic (M.alloc (| D |))).
      
      (*
          fn as_basis_coefficients_slice(&self) -> &[PF] {
              &self.value
          }
      *)
      Definition as_basis_coefficients_slice
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                      "value"
                    |)
                  |)
                |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_basis_coefficients_fn<Fn: FnMut(usize) -> PF>(f: Fn) -> Self {
              Self {
                  value: array::from_fn(f),
              }
          }
      *)
      Definition from_basis_coefficients_fn
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [ Fn ], [ f ] =>
          ltac:(M.monadic
            (let f := M.alloc (| f |) in
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_function (| "core::array::from_fn", [ D ], [ PF; Fn ] |),
                    [ M.read (| f |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn from_basis_coefficients_iter<I: ExactSizeIterator<Item = PF>>(mut iter: I) -> Option<Self> {
              (iter.len() == D).then(|| Self::new(array::from_fn(|_| iter.next().unwrap()))) // The unwrap is safe as we just checked the length of iter.
          }
      *)
      Definition from_basis_coefficients_iter
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ]
                ],
              M.get_associated_function (|
                Ty.path "bool",
                "then",
                [],
                [
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ];
                  Ty.function
                    [ Ty.tuple [] ]
                    (Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_trait_method (|
                        "core::iter::traits::exact_size::ExactSizeIterator",
                        I,
                        [],
                        [],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, iter |) ]
                    |);
                    D
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.function
                              [ Ty.tuple [] ]
                              (Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [ F; PF ]),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                      [ D ]
                                      [ F; PF ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                        [ D ]
                                        [ F; PF ],
                                      "new",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "array") [ D ] [ PF ],
                                        M.get_function (|
                                          "core::array::from_fn",
                                          [ D ],
                                          [ PF; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] PF ]
                                        |),
                                        [
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.function
                                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                                        PF,
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.call_closure (|
                                                              PF,
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [ PF ],
                                                                "unwrap",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [ PF ],
                                                                  M.get_trait_method (|
                                                                    "core::iter::traits::iterator::Iterator",
                                                                    I,
                                                                    [],
                                                                    [],
                                                                    "next",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      iter
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)))
                                                      ]
                                                    |)))
                                                | _ => M.impossible "wrong number of arguments"
                                                end))
                                        ]
                                      |)
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn flatten_to_base(vec: Vec<Self>) -> Vec<PF> {
              unsafe {
                  // Safety:
                  // As `Self` is a `repr(transparent)`, it is stored identically in memory to `[PF; D]`
                  flatten_to_base::<PF, Self>(vec)
              }
          }
      *)
      Definition flatten_to_base
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ vec ] =>
          ltac:(M.monadic
            (let vec := M.alloc (| vec |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ PF; Ty.path "alloc::alloc::Global" ],
              M.get_function (|
                "p3_util::flatten_to_base",
                [],
                [
                  PF;
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ]
                ]
              |),
              [ M.read (| vec |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn reconstitute_from_base(vec: Vec<PF>) -> Vec<Self> {
              unsafe {
                  // Safety:
                  // As `Self` is a `repr(transparent)`, it is stored identically in memory to `[PF; D]`
                  reconstitute_from_base::<PF, Self>(vec)
              }
          }
      *)
      Definition reconstitute_from_base
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ vec ] =>
          ltac:(M.monadic
            (let vec := M.alloc (| vec |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_function (|
                "p3_util::reconstitute_from_base",
                [],
                [
                  PF;
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ]
                ]
              |),
              [ M.read (| vec |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "p3_field::field::BasedVectorSpace"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *)
          [
            ("value_DIMENSION", InstanceField.Method (value_DIMENSION D F PF));
            ("as_basis_coefficients_slice",
              InstanceField.Method (as_basis_coefficients_slice D F PF));
            ("from_basis_coefficients_fn",
              InstanceField.Method (from_basis_coefficients_fn D F PF));
            ("from_basis_coefficients_iter",
              InstanceField.Method (from_basis_coefficients_iter D F PF));
            ("flatten_to_base", InstanceField.Method (flatten_to_base D F PF));
            ("reconstitute_from_base", InstanceField.Method (reconstitute_from_base D F PF))
          ].
    End Impl_p3_field_field_BasedVectorSpace_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_p3_field_packed_PackedFieldExtension_where_p3_field_extension_BinomiallyExtendable_F_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_associated_in_trait_p3_field_field_Field___F_Packing.
      Definition Self (D : Value.t) (F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ].
      
      (*
          fn from_ext_slice(ext_slice: &[BinomialExtensionField<F, D>]) -> Self {
              let width = F::Packing::WIDTH;
              assert_eq!(ext_slice.len(), width);
      
              let res = array::from_fn(|i| F::Packing::from_fn(|j| ext_slice[j].value[i]));
              Self::new(res)
          }
      *)
      Definition from_ext_slice
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ ext_slice ] =>
          ltac:(M.monadic
            (let ext_slice := M.alloc (| ext_slice |) in
            M.read (|
              let~ width : Ty.path "usize" :=
                M.read (|
                  get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ F; F ]
                                    ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| ext_slice |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, width |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val := M.copy (| γ0_0 |) in
                          let right_val := M.copy (| γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ kind : Ty.path "core::panicking::AssertKind" :=
                                          Value.StructTuple
                                            "core::panicking::AssertKind::Eq"
                                            []
                                            []
                                            [] in
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (|
                                              "core::panicking::assert_failed",
                                              [],
                                              [ Ty.path "usize"; Ty.path "usize" ]
                                            |),
                                            [
                                              M.read (| kind |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| left_val |) |)
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| right_val |) |)
                                                  |)
                                                |)
                                              |);
                                              Value.StructTuple
                                                "core::option::Option::None"
                                                []
                                                [ Ty.path "core::fmt::Arguments" ]
                                                []
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |)
                |) in
              let~ res :
                  Ty.apply
                    (Ty.path "array")
                    [ D ]
                    [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ D ]
                    [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                  M.get_function (|
                    "core::array::from_fn",
                    [ D ],
                    [
                      Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing";
                      Ty.function
                        [ Ty.tuple [ Ty.path "usize" ] ]
                        (Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing")
                    ]
                  |),
                  [
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.function
                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                  (Ty.associated_in_trait
                                    "p3_field::field::Field"
                                    []
                                    []
                                    F
                                    "Packing"),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let i := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.associated_in_trait
                                          "p3_field::field::Field"
                                          []
                                          []
                                          F
                                          "Packing",
                                        M.get_trait_method (|
                                          "p3_field::packed::PackedValue",
                                          Ty.associated_in_trait
                                            "p3_field::field::Field"
                                            []
                                            []
                                            F
                                            "Packing",
                                          [],
                                          [],
                                          "from_fn",
                                          [],
                                          [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] F ]
                                        |),
                                        [
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.function
                                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                                        F,
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let j := M.copy (| γ |) in
                                                            M.read (|
                                                              M.SubPointer.get_array_field (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.SubPointer.get_array_field (|
                                                                    M.deref (|
                                                                      M.read (| ext_slice |)
                                                                    |),
                                                                    M.read (| j |)
                                                                  |),
                                                                  "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                                  "value"
                                                                |),
                                                                M.read (| i |)
                                                              |)
                                                            |)))
                                                      ]
                                                    |)))
                                                | _ => M.impossible "wrong number of arguments"
                                                end))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| res |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn to_ext_iter(
              iter: impl IntoIterator<Item = Self>,
          ) -> impl Iterator<Item = BinomialExtensionField<F, D>> {
              let width = F::Packing::WIDTH;
              iter.into_iter().flat_map(move |x| {
                  (0..width).map(move |i| {
                      let values = array::from_fn(|j| x.value[j].as_slice()[i]);
                      BinomialExtensionField::new(values)
                  })
              })
          }
      *)
      Definition to_ext_iter
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [ impl_IntoIterator_Item___Self_ ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.read (|
              let~ width : Ty.path "usize" :=
                M.read (|
                  get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::flatten::FlatMap")
                    []
                    [
                      Ty.associated_in_trait
                        "core::iter::traits::collect::IntoIterator"
                        []
                        []
                        impl_IntoIterator_Item___Self_
                        "IntoIter";
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                          Ty.function
                            [ Ty.tuple [ Ty.path "usize" ] ]
                            (Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; F ])
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [
                                  F;
                                  Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing"
                                ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          []
                          [
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                            Ty.function
                              [ Ty.tuple [ Ty.path "usize" ] ]
                              (Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ F; F ])
                          ])
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      impl_IntoIterator_Item___Self_
                      "IntoIter",
                    [],
                    [],
                    "flat_map",
                    [],
                    [
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                          Ty.function
                            [ Ty.tuple [ Ty.path "usize" ] ]
                            (Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; F ])
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [
                                  F;
                                  Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing"
                                ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          []
                          [
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                            Ty.function
                              [ Ty.tuple [ Ty.path "usize" ] ]
                              (Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ F; F ])
                          ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.associated_in_trait
                        "core::iter::traits::collect::IntoIterator"
                        []
                        []
                        impl_IntoIterator_Item___Self_
                        "IntoIter",
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        impl_IntoIterator_Item___Self_,
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [ M.read (| iter |) ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                          [ D ]
                                          [
                                            F;
                                            Ty.associated_in_trait
                                              "p3_field::field::Field"
                                              []
                                              []
                                              F
                                              "Packing"
                                          ]
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                        (Ty.apply
                                          (Ty.path
                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                          [ D ]
                                          [ F; F ])
                                    ]),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let x := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::map::Map")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ];
                                            Ty.function
                                              [ Ty.tuple [ Ty.path "usize" ] ]
                                              (Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ F; F ])
                                          ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "map",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                                              [ D ]
                                              [ F; F ];
                                            Ty.function
                                              [ Ty.tuple [ Ty.path "usize" ] ]
                                              (Ty.apply
                                                (Ty.path
                                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                [ D ]
                                                [ F; F ])
                                          ]
                                        |),
                                        [
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            []
                                            [ Ty.path "usize" ]
                                            [
                                              ("start", Value.Integer IntegerKind.Usize 0);
                                              ("end_", M.read (| width |))
                                            ];
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.function
                                                        [ Ty.tuple [ Ty.path "usize" ] ]
                                                        (Ty.apply
                                                          (Ty.path
                                                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                          [ D ]
                                                          [ F; F ]),
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let i := M.copy (| γ |) in
                                                            M.read (|
                                                              let~ values :
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [ D ]
                                                                    [ F ] :=
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [ D ]
                                                                    [ F ],
                                                                  M.get_function (|
                                                                    "core::array::from_fn",
                                                                    [ D ],
                                                                    [
                                                                      F;
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                        F
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.closure
                                                                      (fun γ =>
                                                                        ltac:(M.monadic
                                                                          match γ with
                                                                          | [ α0 ] =>
                                                                            ltac:(M.monadic
                                                                              (M.match_operator (|
                                                                                Ty.function
                                                                                  [
                                                                                    Ty.tuple
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ]
                                                                                  ]
                                                                                  F,
                                                                                M.alloc (| α0 |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let j :=
                                                                                        M.copy (|
                                                                                          γ
                                                                                        |) in
                                                                                      M.read (|
                                                                                        M.SubPointer.get_array_field (|
                                                                                          M.deref (|
                                                                                            M.call_closure (|
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "&")
                                                                                                []
                                                                                                [
                                                                                                  Ty.apply
                                                                                                    (Ty.path
                                                                                                      "slice")
                                                                                                    []
                                                                                                    [
                                                                                                      F
                                                                                                    ]
                                                                                                ],
                                                                                              M.get_trait_method (|
                                                                                                "p3_field::packed::PackedValue",
                                                                                                Ty.associated_in_trait
                                                                                                  "p3_field::field::Field"
                                                                                                  []
                                                                                                  []
                                                                                                  F
                                                                                                  "Packing",
                                                                                                [],
                                                                                                [],
                                                                                                "as_slice",
                                                                                                [],
                                                                                                []
                                                                                              |),
                                                                                              [
                                                                                                M.borrow (|
                                                                                                  Pointer.Kind.Ref,
                                                                                                  M.SubPointer.get_array_field (|
                                                                                                    M.SubPointer.get_struct_record_field (|
                                                                                                      x,
                                                                                                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                                                                                                      "value"
                                                                                                    |),
                                                                                                    M.read (|
                                                                                                      j
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              ]
                                                                                            |)
                                                                                          |),
                                                                                          M.read (|
                                                                                            i
                                                                                          |)
                                                                                        |)
                                                                                      |)))
                                                                                ]
                                                                              |)))
                                                                          | _ =>
                                                                            M.impossible
                                                                              "wrong number of arguments"
                                                                          end))
                                                                  ]
                                                                |) in
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                    [ D ]
                                                                    [ F; F ],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                                                      [ D ]
                                                                      [ F; F ],
                                                                    "new",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [ M.read (| values |) ]
                                                                |)
                                                              |)
                                                            |)))
                                                      ]
                                                    |)))
                                                | _ => M.impossible "wrong number of arguments"
                                                end))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn packed_ext_powers(base: BinomialExtensionField<F, D>) -> crate::Powers<Self> {
              let width = F::Packing::WIDTH;
              let powers = base.powers().take(width + 1).collect_vec();
              // Transpose first WIDTH powers
              let current = Self::from_ext_slice(&powers[..width]);
      
              // Broadcast self^WIDTH
              let multiplier = powers[width].into();
      
              Powers {
                  base: multiplier,
                  current,
              }
          }
      *)
      Definition packed_ext_powers
          (D : Value.t)
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F in
        match ε, τ, α with
        | [], [], [ base ] =>
          ltac:(M.monadic
            (let base := M.alloc (| base |) in
            M.read (|
              let~ width : Ty.path "usize" :=
                M.read (|
                  get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                |) in
              let~ powers :
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; F ];
                      Ty.path "alloc::alloc::Global"
                    ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; F ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "itertools::Itertools",
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [
                        Ty.apply
                          (Ty.path "p3_field::field::Powers")
                          []
                          [
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; F ]
                          ]
                      ],
                    [],
                    [],
                    "collect_vec",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [
                          Ty.apply
                            (Ty.path "p3_field::field::Powers")
                            []
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ F; F ]
                            ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "p3_field::field::Powers")
                          []
                          [
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; F ]
                          ],
                        [],
                        [],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "p3_field::field::Powers")
                            []
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ F; F ]
                            ],
                          M.get_trait_method (|
                            "p3_field::field::PrimeCharacteristicRing",
                            Ty.apply
                              (Ty.path
                                "p3_field::extension::binomial_extension::BinomialExtensionField")
                              [ D ]
                              [ F; F ],
                            [],
                            [],
                            "powers",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, base |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| width |); Value.Integer IntegerKind.Usize 1 ]
                        |)
                      ]
                    |)
                  ]
                |) in
              let~ current :
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                  M.get_trait_method (|
                    "p3_field::packed::PackedFieldExtension",
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                    [],
                    [
                      F;
                      Ty.apply
                        (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                        [ D ]
                        [ F; F ]
                    ],
                    "from_ext_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "p3_field::extension::binomial_extension::BinomialExtensionField")
                                        [ D ]
                                        [ F; F ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "p3_field::extension::binomial_extension::BinomialExtensionField")
                                      [ D ]
                                      [ F; F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeTo")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, powers |);
                                Value.StructRecord
                                  "core::ops::range::RangeTo"
                                  []
                                  [ Ty.path "usize" ]
                                  [ ("end_", M.read (| width |)) ]
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              let~ multiplier :
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.apply
                      (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
                      [ D ]
                      [ F; F ],
                    [],
                    [
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ]
                    ],
                    "into",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::binomial_extension::BinomialExtensionField")
                                [ D ]
                                [ F; F ]
                            ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "p3_field::extension::binomial_extension::BinomialExtensionField")
                                  [ D ]
                                  [ F; F ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [ Ty.path "usize" ],
                            "index",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, powers |); M.read (| width |) ]
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "p3_field::field::Powers"
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ]
                  ]
                  [ ("base", M.read (| multiplier |)); ("current", M.read (| current |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F : Ty.t),
        M.IsTraitInstance
          "p3_field::packed::PackedFieldExtension"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            F;
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F)
          (* Instance *)
          [
            ("from_ext_slice", InstanceField.Method (from_ext_slice D F));
            ("to_ext_iter", InstanceField.Method (to_ext_iter D F));
            ("packed_ext_powers", InstanceField.Method (packed_ext_powers D F))
          ].
    End Impl_p3_field_packed_PackedFieldExtension_where_p3_field_extension_BinomiallyExtendable_F_F_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_associated_in_trait_p3_field_field_Field___F_Packing.
    
    Module Impl_core_ops_arith_Neg_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn neg(self) -> Self {
              Self {
                  value: self.value.map(PF::neg),
              }
          }
      *)
      Definition neg
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "array") [ D ] [ PF ],
                      "map",
                      [],
                      [
                        Ty.function
                          [ PF ]
                          (Ty.associated_in_trait "core::ops::arith::Neg" [] [] PF "Output");
                        PF
                      ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                          "value"
                        |)
                      |);
                      M.get_trait_method (| "core::ops::arith::Neg", PF, [], [], "neg", [], [] |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("neg", InstanceField.Method (neg D F PF))
          ].
    End Impl_core_ops_arith_Neg_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn add(self, rhs: Self) -> Self {
              let value = vector_add(&self.value, &rhs.value);
              Self { value }
          }
      *)
      Definition add
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ value : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ PF ],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::vector_add",
                    [ D ],
                    [ PF; PF ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            rhs,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
                  [ D ]
                  [ F; PF ]
                  [ ("value", M.read (| value |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("add", InstanceField.Method (add D F PF))
          ].
    End Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn add(self, rhs: BinomialExtensionField<F, D>) -> Self {
              let value = vector_add(&self.value, &rhs.value);
              Self { value }
          }
      *)
      Definition add
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ value : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ PF ],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::vector_add",
                    [ D ],
                    [ PF; F ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            rhs,
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
                  [ D ]
                  [ F; PF ]
                  [ ("value", M.read (| value |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("add", InstanceField.Method (add D F PF))
          ].
    End Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn add(mut self, rhs: PF) -> Self {
              self.value[0] += rhs;
              self
          }
      *)
      Definition add
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    PF,
                    [],
                    [ PF ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                          "value"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              self
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("add", InstanceField.Method (add D F PF))
          ].
    End Impl_core_ops_arith_Add_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn add_assign(&mut self, rhs: Self) {
              for i in 0..D {
                  self.value[i] += rhs.value[i];
              }
          }
      *)
      Definition add_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.use
                (M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          []
                          [ Ty.path "usize" ]
                          [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", D) ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.read (|
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ],
                                        [],
                                        [],
                                        "next",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let i := M.copy (| γ0_0 |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::ops::arith::AddAssign",
                                              PF,
                                              [],
                                              [ PF ],
                                              "add_assign",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.SubPointer.get_array_field (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                                                    "value"
                                                  |),
                                                  M.read (| i |)
                                                |)
                                              |);
                                              M.read (|
                                                M.SubPointer.get_array_field (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    rhs,
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                                                    "value"
                                                  |),
                                                  M.read (| i |)
                                                |)
                                              |)
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign D F PF)) ].
    End Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn add_assign(&mut self, rhs: BinomialExtensionField<F, D>) {
              for i in 0..D {
                  self.value[i] += rhs.value[i];
              }
          }
      *)
      Definition add_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.use
                (M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          []
                          [ Ty.path "usize" ]
                          [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", D) ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.read (|
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ],
                                        [],
                                        [],
                                        "next",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let i := M.copy (| γ0_0 |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::ops::arith::AddAssign",
                                              PF,
                                              [],
                                              [ F ],
                                              "add_assign",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.SubPointer.get_array_field (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                                                    "value"
                                                  |),
                                                  M.read (| i |)
                                                |)
                                              |);
                                              M.read (|
                                                M.SubPointer.get_array_field (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    rhs,
                                                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                                                    "value"
                                                  |),
                                                  M.read (| i |)
                                                |)
                                              |)
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign D F PF)) ].
    End Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn add_assign(&mut self, rhs: PF) {
              self.value[0] += rhs;
          }
      *)
      Definition add_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    PF,
                    [],
                    [ PF ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                          "value"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign D F PF)) ].
    End Impl_core_ops_arith_AddAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_iter_traits_accum_Sum_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
              iter.reduce(|acc, x| acc + x).unwrap_or(Self::ZERO)
          }
      *)
      Definition sum
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                [ D ]
                [ F; PF ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ]
                  ],
                "unwrap_or",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    [],
                    "reduce",
                    [],
                    [
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [ F; PF ];
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [ F; PF ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                          [ D ]
                          [ F; PF ])
                    ]
                  |),
                  [
                    M.read (| iter |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                          [ D ]
                                          [ F; PF ];
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                          [ D ]
                                          [ F; PF ]
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path
                                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                    [ D ]
                                    [ F; PF ]),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let acc := M.copy (| γ |) in
                                      M.match_operator (|
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                  [ D ]
                                                  [ F; PF ];
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                  [ D ]
                                                  [ F; PF ]
                                              ]
                                          ]
                                          (Ty.apply
                                            (Ty.path
                                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                            [ D ]
                                            [ F; PF ]),
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let x := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                  [ D ]
                                                  [ F; PF ],
                                                M.get_trait_method (|
                                                  "core::ops::arith::Add",
                                                  Ty.apply
                                                    (Ty.path
                                                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                    [ D ]
                                                    [ F; PF ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                      [ D ]
                                                      [ F; PF ]
                                                  ],
                                                  "add",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| acc |); M.read (| x |) ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |);
                M.read (|
                  get_constant (|
                    "p3_field::field::PrimeCharacteristicRing::ZERO",
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Sum"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *) [ ("sum", InstanceField.Method (sum D F PF)) ].
    End Impl_core_iter_traits_accum_Sum_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn sub(self, rhs: Self) -> Self {
              let value = vector_sub(&self.value, &rhs.value);
              Self { value }
          }
      *)
      Definition sub
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ value : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ PF ],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::vector_sub",
                    [ D ],
                    [ PF; PF ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            rhs,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
                  [ D ]
                  [ F; PF ]
                  [ ("value", M.read (| value |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("sub", InstanceField.Method (sub D F PF))
          ].
    End Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn sub(self, rhs: BinomialExtensionField<F, D>) -> Self {
              let value = vector_sub(&self.value, &rhs.value);
              Self { value }
          }
      *)
      Definition sub
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ value : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ D ] [ PF ],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::vector_sub",
                    [ D ],
                    [ PF; F ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            rhs,
                            "p3_field::extension::binomial_extension::BinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
                  [ D ]
                  [ F; PF ]
                  [ ("value", M.read (| value |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("sub", InstanceField.Method (sub D F PF))
          ].
    End Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn sub(self, rhs: PF) -> Self {
              let mut res = self.value;
              res[0] -= rhs;
              Self { value: res }
          }
      *)
      Definition sub
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ res : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::SubAssign",
                    PF,
                    [],
                    [ PF ],
                    "sub_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (| res, Value.Integer IntegerKind.Usize 0 |)
                    |);
                    M.read (| rhs |)
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
                  [ D ]
                  [ F; PF ]
                  [ ("value", M.read (| res |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("sub", InstanceField.Method (sub D F PF))
          ].
    End Impl_core_ops_arith_Sub_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn sub_assign(&mut self, rhs: Self) {
              *self = *self - rhs;
          }
      *)
      Definition sub_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                          [ D ]
                          [ F; PF ]
                      ],
                      "sub",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign D F PF)) ].
    End Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn sub_assign(&mut self, rhs: BinomialExtensionField<F, D>) {
              *self = *self - rhs;
          }
      *)
      Definition sub_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; F ]
                      ],
                      "sub",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign D F PF)) ].
    End Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn sub_assign(&mut self, rhs: PF) {
              *self = *self - rhs;
          }
      *)
      Definition sub_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ],
                      [],
                      [ PF ],
                      "sub",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign D F PF)) ].
    End Impl_core_ops_arith_SubAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn mul(self, rhs: Self) -> Self {
              let a = self.value;
              let b = rhs.value;
              let mut res = Self::default();
              let w = F::W;
      
              binomial_mul(&a, &b, &mut res.value, w);
      
              res
          }
      *)
      Definition mul
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ a : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ b : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    rhs,
                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ res :
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |) in
              let~ w : F :=
                M.read (| get_constant (| "p3_field::extension::BinomiallyExtendable::W", F |) |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::binomial_mul",
                    [ D ],
                    [ F; PF; PF ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, b |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            res,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.read (| w |)
                  ]
                |) in
              res
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("mul", InstanceField.Method (mul D F PF))
          ].
    End Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn mul(self, rhs: BinomialExtensionField<F, D>) -> Self {
              let a = self.value;
              let b = rhs.value;
              let mut res = Self::default();
              let w = F::W;
      
              binomial_mul(&a, &b, &mut res.value, w);
      
              res
          }
      *)
      Definition mul
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ a : Ty.apply (Ty.path "array") [ D ] [ PF ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ b : Ty.apply (Ty.path "array") [ D ] [ F ] :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    rhs,
                    "p3_field::extension::binomial_extension::BinomialExtensionField",
                    "value"
                  |)
                |) in
              let~ res :
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path
                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                    [ D ]
                    [ F; PF ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |) in
              let~ w : F :=
                M.read (| get_constant (| "p3_field::extension::BinomiallyExtendable::W", F |) |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "p3_field::extension::binomial_extension::binomial_mul",
                    [ D ],
                    [ F; PF; F ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, b |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            res,
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                            "value"
                          |)
                        |)
                      |)
                    |);
                    M.read (| w |)
                  ]
                |) in
              res
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("mul", InstanceField.Method (mul D F PF))
          ].
    End Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*     type Output = Self; *)
      Definition _Output (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn mul(self, rhs: PF) -> Self {
              Self {
                  value: self.value.map(|x| x * rhs),
              }
          }
      *)
      Definition mul
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructRecord
              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField"
              [ D ]
              [ F; PF ]
              [
                ("value",
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ D ] [ PF ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "array") [ D ] [ PF ],
                      "map",
                      [],
                      [ Ty.function [ Ty.tuple [ PF ] ] PF; PF ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField",
                          "value"
                        |)
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.function [ Ty.tuple [ PF ] ] PF,
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let x := M.copy (| γ |) in
                                        M.call_closure (|
                                          PF,
                                          M.get_trait_method (|
                                            "core::ops::arith::Mul",
                                            PF,
                                            [],
                                            [ PF ],
                                            "mul",
                                            [],
                                            []
                                          |),
                                          [ M.read (| x |); M.read (| rhs |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output D F PF));
            ("mul", InstanceField.Method (mul D F PF))
          ].
    End Impl_core_ops_arith_Mul_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_iter_traits_accum_Product_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn product<I: Iterator<Item = Self>>(iter: I) -> Self {
              iter.reduce(|acc, x| acc * x).unwrap_or(Self::ZERO)
          }
      *)
      Definition product
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path
                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                [ D ]
                [ F; PF ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ]
                  ],
                "unwrap_or",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    [],
                    "reduce",
                    [],
                    [
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [ F; PF ];
                              Ty.apply
                                (Ty.path
                                  "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                [ D ]
                                [ F; PF ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                          [ D ]
                          [ F; PF ])
                    ]
                  |),
                  [
                    M.read (| iter |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                          [ D ]
                                          [ F; PF ];
                                        Ty.apply
                                          (Ty.path
                                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                          [ D ]
                                          [ F; PF ]
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path
                                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                    [ D ]
                                    [ F; PF ]),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let acc := M.copy (| γ |) in
                                      M.match_operator (|
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                  [ D ]
                                                  [ F; PF ];
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                  [ D ]
                                                  [ F; PF ]
                                              ]
                                          ]
                                          (Ty.apply
                                            (Ty.path
                                              "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                            [ D ]
                                            [ F; PF ]),
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let x := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path
                                                    "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                  [ D ]
                                                  [ F; PF ],
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  Ty.apply
                                                    (Ty.path
                                                      "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                    [ D ]
                                                    [ F; PF ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                                                      [ D ]
                                                      [ F; PF ]
                                                  ],
                                                  "mul",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| acc |); M.read (| x |) ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |);
                M.read (|
                  get_constant (|
                    "p3_field::field::PrimeCharacteristicRing::ZERO",
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Product"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *) [ ("product", InstanceField.Method (product D F PF)) ].
    End Impl_core_iter_traits_accum_Product_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn mul_assign(&mut self, rhs: Self) {
              *self = *self * rhs;
          }
      *)
      Definition mul_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                          [ D ]
                          [ F; PF ]
                      ],
                      "mul",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path
                "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
              [ D ]
              [ F; PF ]
          ]
          (Self D F PF)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign D F PF)) ].
    End Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn mul_assign(&mut self, rhs: BinomialExtensionField<F, D>) {
              *self = *self * rhs;
          }
      *)
      Definition mul_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ],
                      [],
                      [
                        Ty.apply
                          (Ty.path
                            "p3_field::extension::binomial_extension::BinomialExtensionField")
                          [ D ]
                          [ F; F ]
                      ],
                      "mul",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "p3_field::extension::binomial_extension::BinomialExtensionField")
              [ D ]
              [ F; F ]
          ]
          (Self D F PF)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign D F PF)) ].
    End Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_p3_field_extension_binomial_extension_BinomialExtensionField_D_F_F_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
    
    Module Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
      Definition Self (D : Value.t) (F PF : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
          [ D ]
          [ F; PF ].
      
      (*
          fn mul_assign(&mut self, rhs: PF) {
              *self = *self * rhs;
          }
      *)
      Definition mul_assign
          (D : Value.t)
          (F PF : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self D F PF in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path
                        "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                      [ D ]
                      [ F; PF ],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply
                        (Ty.path
                          "p3_field::extension::packed_binomial_extension::PackedBinomialExtensionField")
                        [ D ]
                        [ F; PF ],
                      [],
                      [ PF ],
                      "mul",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (D : Value.t) (F PF : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ PF ]
          (Self D F PF)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign D F PF)) ].
    End Impl_core_ops_arith_MulAssign_where_p3_field_extension_BinomiallyExtendable_F_where_p3_field_packed_PackedField_PF_PF_for_p3_field_extension_packed_binomial_extension_PackedBinomialExtensionField_D_F_PF.
  End packed_binomial_extension.
End extension.
