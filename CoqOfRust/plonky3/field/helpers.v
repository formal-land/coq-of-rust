(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module helpers.
  (*
  pub fn two_adic_subgroup_vanishing_polynomial<F: TwoAdicField>(log_n: usize, x: F) -> F {
      x.exp_power_of_2(log_n) - F::ONE
  }
  *)
  Definition two_adic_subgroup_vanishing_polynomial
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ log_n; x ] =>
      ltac:(M.monadic
        (let log_n := M.alloc (| Ty.path "usize", log_n |) in
        let x := M.alloc (| F, x |) in
        M.call_closure (|
          F,
          M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
          [
            M.call_closure (|
              F,
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "exp_power_of_2",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, x |); M.read (| log_n |) ]
            |);
            M.read (| get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", F |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_two_adic_subgroup_vanishing_polynomial :
    M.IsFunction.C
      "p3_field::helpers::two_adic_subgroup_vanishing_polynomial"
      two_adic_subgroup_vanishing_polynomial.
  Admitted.
  Global Typeclasses Opaque two_adic_subgroup_vanishing_polynomial.
  
  (*
  pub fn two_adic_coset_vanishing_polynomial<F: TwoAdicField>(log_n: usize, shift: F, x: F) -> F {
      x.exp_power_of_2(log_n) - shift.exp_power_of_2(log_n)
  }
  *)
  Definition two_adic_coset_vanishing_polynomial
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ log_n; shift; x ] =>
      ltac:(M.monadic
        (let log_n := M.alloc (| Ty.path "usize", log_n |) in
        let shift := M.alloc (| F, shift |) in
        let x := M.alloc (| F, x |) in
        M.call_closure (|
          F,
          M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
          [
            M.call_closure (|
              F,
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "exp_power_of_2",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, x |); M.read (| log_n |) ]
            |);
            M.call_closure (|
              F,
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "exp_power_of_2",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, shift |); M.read (| log_n |) ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_two_adic_coset_vanishing_polynomial :
    M.IsFunction.C
      "p3_field::helpers::two_adic_coset_vanishing_polynomial"
      two_adic_coset_vanishing_polynomial.
  Admitted.
  Global Typeclasses Opaque two_adic_coset_vanishing_polynomial.
  
  (*
  pub fn cyclic_subgroup_known_order<F: Field>(
      generator: F,
      order: usize,
  ) -> impl Iterator<Item = F> + Clone {
      generator.powers().take(order)
  }
  *)
  Definition cyclic_subgroup_known_order
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ generator; order ] =>
      ltac:(M.monadic
        (let generator := M.alloc (| F, generator |) in
        let order := M.alloc (| Ty.path "usize", order |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            []
            [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
            [],
            [],
            "take",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "powers",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, generator |) ]
            |);
            M.read (| order |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cyclic_subgroup_known_order :
    M.IsFunction.C "p3_field::helpers::cyclic_subgroup_known_order" cyclic_subgroup_known_order.
  Admitted.
  Global Typeclasses Opaque cyclic_subgroup_known_order.
  
  (*
  pub fn cyclic_subgroup_coset_known_order<F: Field>(
      generator: F,
      shift: F,
      order: usize,
  ) -> impl Iterator<Item = F> + Clone {
      generator.shifted_powers(shift).take(order)
  }
  *)
  Definition cyclic_subgroup_coset_known_order
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ generator; shift; order ] =>
      ltac:(M.monadic
        (let generator := M.alloc (| F, generator |) in
        let shift := M.alloc (| F, shift |) in
        let order := M.alloc (| Ty.path "usize", order |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            []
            [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
            [],
            [],
            "take",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "shifted_powers",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, generator |); M.read (| shift |) ]
            |);
            M.read (| order |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cyclic_subgroup_coset_known_order :
    M.IsFunction.C
      "p3_field::helpers::cyclic_subgroup_coset_known_order"
      cyclic_subgroup_coset_known_order.
  Admitted.
  Global Typeclasses Opaque cyclic_subgroup_coset_known_order.
  
  (*
  pub fn scale_vec<F: Field>(s: F, vec: Vec<F>) -> Vec<F> {
      vec.into_iter().map(|x| s * x).collect()
  }
  *)
  Definition scale_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F ], [ s; vec ] =>
      ltac:(M.monadic
        (let s := M.alloc (| F, s |) in
        let vec :=
          M.alloc (|
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
            vec
          |) in
        M.call_closure (|
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              []
              [
                Ty.apply
                  (Ty.path "alloc::vec::into_iter::IntoIter")
                  []
                  [ F; Ty.path "alloc::alloc::Global" ];
                Ty.function [ Ty.tuple [ F ] ] F
              ],
            [],
            [],
            "collect",
            [],
            [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::vec::into_iter::IntoIter")
                    []
                    [ F; Ty.path "alloc::alloc::Global" ];
                  Ty.function [ Ty.tuple [ F ] ] F
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "alloc::vec::into_iter::IntoIter")
                  []
                  [ F; Ty.path "alloc::alloc::Global" ],
                [],
                [],
                "map",
                [],
                [ F; Ty.function [ Ty.tuple [ F ] ] F ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::into_iter::IntoIter")
                    []
                    [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [ M.read (| vec |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.function [ Ty.tuple [ F ] ] F,
                            M.alloc (| F, α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let x := M.copy (| F, γ |) in
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      F,
                                      [],
                                      [ F ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [ M.read (| s |); M.read (| x |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_scale_vec :
    M.IsFunction.C "p3_field::helpers::scale_vec" scale_vec.
  Admitted.
  Global Typeclasses Opaque scale_vec.
  
  (*
  pub fn scale_slice_in_place<F: Field>(s: F, slice: &mut [F]) {
      let (packed, sfx) = F::Packing::pack_slice_with_suffix_mut(slice);
      let packed_s: F::Packing = s.into();
      packed.par_iter_mut().for_each(|x| *x *= packed_s);
      sfx.iter_mut().for_each(|x| *x *= s);
  }
  *)
  Definition scale_slice_in_place (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F ], [ s; slice ] =>
      ltac:(M.monadic
        (let s := M.alloc (| F, s |) in
        let slice :=
          M.alloc (|
            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
            slice
          |) in
        M.read (|
          M.match_operator (|
            Ty.tuple [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ]
                    ];
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                ],
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ]
                      ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                  ],
                M.get_trait_method (|
                  "p3_field::packed::PackedValue",
                  Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing",
                  [],
                  [],
                  "pack_slice_with_suffix_mut",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let packed :=
                    M.copy (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ]
                        ],
                      γ0_0
                    |) in
                  let sfx :=
                    M.copy (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                      γ0_1
                    |) in
                  let~ packed_s :
                      Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" :=
                    M.call_closure (|
                      Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing",
                      M.get_trait_method (|
                        "core::convert::Into",
                        F,
                        [],
                        [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| s |) ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::slice::iter::IterMut")
                          []
                          [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                        [],
                        [],
                        "for_each",
                        [],
                        [
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_field::field::Field"
                                        []
                                        []
                                        F
                                        "Packing"
                                    ]
                                ]
                            ]
                            (Ty.tuple [])
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::slice::iter::IterMut")
                            []
                            [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                          M.get_trait_method (|
                            "p3_maybe_rayon::serial::IntoParallelRefMutIterator",
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                            [],
                            [],
                            "par_iter_mut",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| packed |) |) |) ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "p3_field::field::Field"
                                                  []
                                                  []
                                                  F
                                                  "Packing"
                                              ]
                                          ]
                                      ]
                                      (Ty.tuple []),
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_field::field::Field"
                                            []
                                            []
                                            F
                                            "Packing"
                                        ],
                                      α0
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x :=
                                            M.copy (|
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_field::field::Field"
                                                    []
                                                    []
                                                    F
                                                    "Packing"
                                                ],
                                              γ
                                            |) in
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::ops::arith::MulAssign",
                                              Ty.associated_in_trait
                                                "p3_field::field::Field"
                                                []
                                                []
                                                F
                                                "Packing",
                                              [],
                                              [
                                                Ty.associated_in_trait
                                                  "p3_field::field::Field"
                                                  []
                                                  []
                                                  F
                                                  "Packing"
                                              ],
                                              "mul_assign",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| x |) |)
                                              |);
                                              M.read (| packed_s |)
                                            ]
                                          |)))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                        [],
                        [],
                        "for_each",
                        [],
                        [
                          Ty.function
                            [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ]
                            (Ty.tuple [])
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ F ],
                            "iter_mut",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| sfx |) |) |) ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ]
                                      (Ty.tuple []),
                                    M.alloc (| Ty.apply (Ty.path "&mut") [] [ F ], α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x :=
                                            M.copy (| Ty.apply (Ty.path "&mut") [] [ F ], γ |) in
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::ops::arith::MulAssign",
                                              F,
                                              [],
                                              [ F ],
                                              "mul_assign",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| x |) |)
                                              |);
                                              M.read (| s |)
                                            ]
                                          |)))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |) in
                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_scale_slice_in_place :
    M.IsFunction.C "p3_field::helpers::scale_slice_in_place" scale_slice_in_place.
  Admitted.
  Global Typeclasses Opaque scale_slice_in_place.
  
  (*
  pub fn add_scaled_slice_in_place<F, Y>(x: &mut [F], y: Y, s: F)
  where
      F: Field,
      Y: Iterator<Item = F>,
  {
      // TODO: Use PackedField
      x.iter_mut().zip(y).for_each(|(x_i, y_i)| *x_i += y_i * s);
  }
  *)
  Definition add_scaled_slice_in_place (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; Y ], [ x; y; s ] =>
      ltac:(M.monadic
        (let x :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ], x |) in
        let y := M.alloc (| Y, y |) in
        let s := M.alloc (| F, s |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::zip::Zip")
                  []
                  [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ]; Y ],
                [],
                [],
                "for_each",
                [],
                [
                  Ty.function
                    [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ] ]
                    (Ty.tuple [])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ]; Y ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                    [],
                    [],
                    "zip",
                    [],
                    [ Y ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "iter_mut",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| x |) |) |) ]
                    |);
                    M.read (| y |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.function
                              [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ] ]
                              (Ty.tuple []),
                            M.alloc (| Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ], α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let x_i :=
                                    M.copy (| Ty.apply (Ty.path "&mut") [] [ F ], γ0_0 |) in
                                  let y_i := M.copy (| F, γ0_1 |) in
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::ops::arith::AddAssign",
                                      F,
                                      [],
                                      [ F ],
                                      "add_assign",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| x_i |) |)
                                      |);
                                      M.call_closure (|
                                        F,
                                        M.get_trait_method (|
                                          "core::ops::arith::Mul",
                                          F,
                                          [],
                                          [ F ],
                                          "mul",
                                          [],
                                          []
                                        |),
                                        [ M.read (| y_i |); M.read (| s |) ]
                                      |)
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_add_scaled_slice_in_place :
    M.IsFunction.C "p3_field::helpers::add_scaled_slice_in_place" add_scaled_slice_in_place.
  Admitted.
  Global Typeclasses Opaque add_scaled_slice_in_place.
  
  (*
  pub const fn field_to_array<R: PrimeCharacteristicRing, const D: usize>(x: R) -> [R; D] {
      let mut arr: [_; D] = [const { MaybeUninit::uninit() }; D];
      arr[0] = MaybeUninit::new(x);
      let mut i = 1;
      while i < D {
          arr[i] = MaybeUninit::new(R::ZERO);
          i += 1;
      }
      unsafe { core::mem::transmute_copy::<_, [R; D]>(&arr) }
  }
  *)
  Definition field_to_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ D ], [ R ], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| R, x |) in
        M.read (|
          let~ arr :
              Ty.apply
                (Ty.path "array")
                [ D ]
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ] ] :=
            lib.repeat (|
              M.read (|
                get_constant (|
                  "p3_field::helpers::field_to_array_discriminant",
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ]
                |)
              |),
              D
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| arr, Value.Integer IntegerKind.Usize 0 |),
              M.call_closure (|
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ],
                  "new",
                  [],
                  []
                |),
                [ M.read (| x |) ]
              |)
            |) in
          let~ i : Ty.path "usize" := Value.Integer IntegerKind.Usize 1 in
          let~ _ : Ty.tuple [] :=
            M.read (|
              M.loop (|
                Ty.tuple [],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (| Ty.path "bool", BinOp.lt, [ M.read (| i |); D ] |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            M.write (|
                              M.SubPointer.get_array_field (| arr, M.read (| i |) |),
                              M.call_closure (|
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ R ],
                                  "new",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    get_constant (|
                                      "p3_field::field::PrimeCharacteristicRing::ZERO",
                                      R
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            let β := i in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            Ty.tuple [],
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.never_to_any (| M.read (| M.break (||) |) |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |) in
          M.alloc (|
            Ty.apply (Ty.path "array") [ D ] [ R ],
            M.call_closure (|
              Ty.apply (Ty.path "array") [ D ] [ R ],
              M.get_function (|
                "core::mem::transmute_copy",
                [],
                [
                  Ty.apply
                    (Ty.path "array")
                    [ D ]
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ] ];
                  Ty.apply (Ty.path "array") [ D ] [ R ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, arr |) |) |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_field_to_array :
    M.IsFunction.C "p3_field::helpers::field_to_array" field_to_array.
  Admitted.
  Global Typeclasses Opaque field_to_array.
  
  (*
  pub const fn halve_u32<const P: u32>(x: u32) -> u32 {
      let shift = (P + 1) >> 1;
      let half = x >> 1;
      if x & 1 == 0 { half } else { half + shift }
  }
  *)
  Definition halve_u32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ P ], [], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| Ty.path "u32", x |) in
        M.read (|
          let~ shift : Ty.path "u32" :=
            M.call_closure (|
              Ty.path "u32",
              BinOp.Wrap.shr,
              [
                M.call_closure (|
                  Ty.path "u32",
                  BinOp.Wrap.add,
                  [ P; Value.Integer IntegerKind.U32 1 ]
                |);
                Value.Integer IntegerKind.I32 1
              ]
            |) in
          let~ half : Ty.path "u32" :=
            M.call_closure (|
              Ty.path "u32",
              BinOp.Wrap.shr,
              [ M.read (| x |); Value.Integer IntegerKind.I32 1 ]
            |) in
          M.match_operator (|
            Ty.path "u32",
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "u32",
                              BinOp.Wrap.bit_and,
                              [ M.read (| x |); Value.Integer IntegerKind.U32 1 ]
                            |);
                            Value.Integer IntegerKind.U32 0
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  half));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    Ty.path "u32",
                    M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.add,
                      [ M.read (| half |); M.read (| shift |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_halve_u32 :
    M.IsFunction.C "p3_field::helpers::halve_u32" halve_u32.
  Admitted.
  Global Typeclasses Opaque halve_u32.
  
  (*
  pub const fn halve_u64<const P: u64>(x: u64) -> u64 {
      let shift = (P + 1) >> 1;
      let half = x >> 1;
      if x & 1 == 0 { half } else { half + shift }
  }
  *)
  Definition halve_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ P ], [], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| Ty.path "u64", x |) in
        M.read (|
          let~ shift : Ty.path "u64" :=
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.shr,
              [
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.add,
                  [ P; Value.Integer IntegerKind.U64 1 ]
                |);
                Value.Integer IntegerKind.I32 1
              ]
            |) in
          let~ half : Ty.path "u64" :=
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.shr,
              [ M.read (| x |); Value.Integer IntegerKind.I32 1 ]
            |) in
          M.match_operator (|
            Ty.path "u64",
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.bit_and,
                              [ M.read (| x |); Value.Integer IntegerKind.U64 1 ]
                            |);
                            Value.Integer IntegerKind.U64 0
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  half));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    Ty.path "u64",
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.add,
                      [ M.read (| half |); M.read (| shift |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_halve_u64 :
    M.IsFunction.C "p3_field::helpers::halve_u64" halve_u64.
  Admitted.
  Global Typeclasses Opaque halve_u64.
  
  (*
  pub fn reduce_32<SF: PrimeField32, TF: PrimeField>(vals: &[SF]) -> TF {
      // If the characteristic of TF is > 2^64, from_int and from_canonical_unchecked act identically
      let base = TF::from_int(1u64 << 32);
      vals.iter().rev().fold(TF::ZERO, |acc, val| {
          acc * base + TF::from_int(val.as_canonical_u32())
      })
  }
  *)
  Definition reduce_32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ SF; TF ], [ vals ] =>
      ltac:(M.monadic
        (let vals :=
          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ SF ] ], vals |) in
        M.read (|
          let~ base : TF :=
            M.call_closure (|
              TF,
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                TF,
                [],
                [ Ty.path "u64" ],
                "from_int",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.shl,
                  [ Value.Integer IntegerKind.U64 1; Value.Integer IntegerKind.I32 32 ]
                |)
              ]
            |) in
          M.alloc (|
            TF,
            M.call_closure (|
              TF,
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::rev::Rev")
                  []
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ] ],
                [],
                [],
                "fold",
                [],
                [ TF; Ty.function [ Ty.tuple [ TF; Ty.apply (Ty.path "&") [] [ SF ] ] ] TF ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::rev::Rev")
                    []
                    [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ] ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ],
                    [],
                    [],
                    "rev",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ SF ],
                        "iter",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| vals |) |) |) ]
                    |)
                  ]
                |);
                M.read (|
                  get_constant (| "p3_field::field::PrimeCharacteristicRing::ZERO", TF |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.function [ Ty.tuple [ TF; Ty.apply (Ty.path "&") [] [ SF ] ] ] TF,
                            M.alloc (| TF, α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc := M.copy (| TF, γ |) in
                                  M.match_operator (|
                                    Ty.function
                                      [ Ty.tuple [ TF; Ty.apply (Ty.path "&") [] [ SF ] ] ]
                                      TF,
                                    M.alloc (| Ty.apply (Ty.path "&") [] [ SF ], α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let val :=
                                            M.copy (| Ty.apply (Ty.path "&") [] [ SF ], γ |) in
                                          M.call_closure (|
                                            TF,
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              TF,
                                              [],
                                              [ TF ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                TF,
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  TF,
                                                  [],
                                                  [ TF ],
                                                  "mul",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| acc |); M.read (| base |) ]
                                              |);
                                              M.call_closure (|
                                                TF,
                                                M.get_trait_method (|
                                                  "p3_field::integers::QuotientMap",
                                                  TF,
                                                  [],
                                                  [ Ty.path "u32" ],
                                                  "from_int",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.path "u32",
                                                    M.get_trait_method (|
                                                      "p3_field::field::PrimeField32",
                                                      SF,
                                                      [],
                                                      [],
                                                      "as_canonical_u32",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| val |) |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_reduce_32 :
    M.IsFunction.C "p3_field::helpers::reduce_32" reduce_32.
  Admitted.
  Global Typeclasses Opaque reduce_32.
  
  (*
  pub fn split_32<SF: PrimeField, TF: PrimeField32>(val: SF, n: usize) -> Vec<TF> {
      let mut result: Vec<TF> = val
          .as_canonical_biguint()
          .to_u64_digits()
          .iter()
          .take(n)
          .map(|d| TF::from_u64( *d))
          .collect();
  
      // Pad with zeros if needed
      result.resize_with(n, || TF::ZERO);
      result
  }
  *)
  Definition split_32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ SF; TF ], [ val; n ] =>
      ltac:(M.monadic
        (let val := M.alloc (| SF, val |) in
        let n := M.alloc (| Ty.path "usize", n |) in
        M.read (|
          let~ result :
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ] :=
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ];
                    Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ] TF
                  ],
                [],
                [],
                "collect",
                [],
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ] ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ];
                      Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ] TF
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ],
                    [],
                    [],
                    "map",
                    [],
                    [
                      TF;
                      Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ] TF
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                        [],
                        [],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                            "iter",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u64"; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ Ty.path "u64"; Ty.path "alloc::alloc::Global" ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u64"; Ty.path "alloc::alloc::Global" ],
                                          M.get_associated_function (|
                                            Ty.path "num_bigint::biguint::BigUint",
                                            "to_u64_digits",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Ty.path "num_bigint::biguint::BigUint",
                                                M.call_closure (|
                                                  Ty.path "num_bigint::biguint::BigUint",
                                                  M.get_trait_method (|
                                                    "p3_field::field::PrimeField",
                                                    SF,
                                                    [],
                                                    [],
                                                    "as_canonical_biguint",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.borrow (| Pointer.Kind.Ref, val |) ]
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |);
                        M.read (| n |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.function
                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ]
                                  TF,
                                M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let d :=
                                        M.copy (|
                                          Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                          γ
                                        |) in
                                      M.call_closure (|
                                        TF,
                                        M.get_trait_method (|
                                          "p3_field::field::PrimeCharacteristicRing",
                                          TF,
                                          [],
                                          [],
                                          "from_u64",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| d |) |) |) ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ],
                "resize_with",
                [],
                [ Ty.function [ Ty.tuple [] ] TF ]
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, result |);
                M.read (| n |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.function [ Ty.tuple [] ] TF,
                            M.alloc (| Ty.tuple [], α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    get_constant (|
                                      "p3_field::field::PrimeCharacteristicRing::ZERO",
                                      TF
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |) in
          result
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_split_32 :
    M.IsFunction.C "p3_field::helpers::split_32" split_32.
  Admitted.
  Global Typeclasses Opaque split_32.
  
  (*
  pub fn dot_product<S, LI, RI>(li: LI, ri: RI) -> S
  where
      LI: Iterator,
      RI: Iterator,
      LI::Item: Mul<RI::Item>,
      S: Sum<<LI::Item as Mul<RI::Item>>::Output>,
  {
      li.zip(ri).map(|(l, r)| l * r).sum()
  }
  *)
  Definition dot_product (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ _ as S; LI; RI ], [ li; ri ] =>
      ltac:(M.monadic
        (let li := M.alloc (| LI, li |) in
        let ri := M.alloc (| RI, ri |) in
        M.call_closure (|
          S,
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              []
              [
                Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.associated_in_trait
                              "core::iter::traits::iterator::Iterator"
                              []
                              []
                              LI
                              "Item";
                            Ty.associated_in_trait
                              "core::iter::traits::iterator::Iterator"
                              []
                              []
                              RI
                              "Item"
                          ]
                      ]
                  ]
                  (Ty.associated_in_trait
                    "core::ops::arith::Mul"
                    []
                    [
                      Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        RI
                        "Item"
                    ]
                    (Ty.associated_in_trait
                      "core::iter::traits::iterator::Iterator"
                      []
                      []
                      LI
                      "Item")
                    "Output")
              ],
            [],
            [],
            "sum",
            [],
            [ S ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.tuple
                            [
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                LI
                                "Item";
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                RI
                                "Item"
                            ]
                        ]
                    ]
                    (Ty.associated_in_trait
                      "core::ops::arith::Mul"
                      []
                      [
                        Ty.associated_in_trait
                          "core::iter::traits::iterator::Iterator"
                          []
                          []
                          RI
                          "Item"
                      ]
                      (Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        LI
                        "Item")
                      "Output")
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ],
                [],
                [],
                "map",
                [],
                [
                  Ty.associated_in_trait
                    "core::ops::arith::Mul"
                    []
                    [
                      Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        RI
                        "Item"
                    ]
                    (Ty.associated_in_trait
                      "core::iter::traits::iterator::Iterator"
                      []
                      []
                      LI
                      "Item")
                    "Output";
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.tuple
                            [
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                LI
                                "Item";
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                RI
                                "Item"
                            ]
                        ]
                    ]
                    (Ty.associated_in_trait
                      "core::ops::arith::Mul"
                      []
                      [
                        Ty.associated_in_trait
                          "core::iter::traits::iterator::Iterator"
                          []
                          []
                          RI
                          "Item"
                      ]
                      (Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        LI
                        "Item")
                      "Output")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    LI,
                    [],
                    [],
                    "zip",
                    [],
                    [ RI ]
                  |),
                  [ M.read (| li |); M.read (| ri |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple
                                      [
                                        Ty.associated_in_trait
                                          "core::iter::traits::iterator::Iterator"
                                          []
                                          []
                                          LI
                                          "Item";
                                        Ty.associated_in_trait
                                          "core::iter::traits::iterator::Iterator"
                                          []
                                          []
                                          RI
                                          "Item"
                                      ]
                                  ]
                              ]
                              (Ty.associated_in_trait
                                "core::ops::arith::Mul"
                                []
                                [
                                  Ty.associated_in_trait
                                    "core::iter::traits::iterator::Iterator"
                                    []
                                    []
                                    RI
                                    "Item"
                                ]
                                (Ty.associated_in_trait
                                  "core::iter::traits::iterator::Iterator"
                                  []
                                  []
                                  LI
                                  "Item")
                                "Output"),
                            M.alloc (|
                              Ty.tuple
                                [
                                  Ty.associated_in_trait
                                    "core::iter::traits::iterator::Iterator"
                                    []
                                    []
                                    LI
                                    "Item";
                                  Ty.associated_in_trait
                                    "core::iter::traits::iterator::Iterator"
                                    []
                                    []
                                    RI
                                    "Item"
                                ],
                              α0
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let l :=
                                    M.copy (|
                                      Ty.associated_in_trait
                                        "core::iter::traits::iterator::Iterator"
                                        []
                                        []
                                        LI
                                        "Item",
                                      γ0_0
                                    |) in
                                  let r :=
                                    M.copy (|
                                      Ty.associated_in_trait
                                        "core::iter::traits::iterator::Iterator"
                                        []
                                        []
                                        RI
                                        "Item",
                                      γ0_1
                                    |) in
                                  M.call_closure (|
                                    Ty.associated_in_trait
                                      "core::ops::arith::Mul"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "core::iter::traits::iterator::Iterator"
                                          []
                                          []
                                          RI
                                          "Item"
                                      ]
                                      (Ty.associated_in_trait
                                        "core::iter::traits::iterator::Iterator"
                                        []
                                        []
                                        LI
                                        "Item")
                                      "Output",
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      Ty.associated_in_trait
                                        "core::iter::traits::iterator::Iterator"
                                        []
                                        []
                                        LI
                                        "Item",
                                      [],
                                      [
                                        Ty.associated_in_trait
                                          "core::iter::traits::iterator::Iterator"
                                          []
                                          []
                                          RI
                                          "Item"
                                      ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [ M.read (| l |); M.read (| r |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_dot_product :
    M.IsFunction.C "p3_field::helpers::dot_product" dot_product.
  Admitted.
  Global Typeclasses Opaque dot_product.
End helpers.
