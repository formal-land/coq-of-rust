(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module packed.
  (* Trait *)
  (* Empty module 'Packable' *)
  
  (* Trait *)
  Module PackedValue.
    Definition pack_slice (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ buf ] =>
        ltac:(M.monadic
          (let buf := M.alloc (| buf |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_function (| "core::mem::align_of", [], [ Self ] |),
                                      []
                                    |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_function (|
                                        "core::mem::align_of",
                                        [],
                                        [
                                          Ty.associated_in_trait
                                            "p3_field::packed::PackedValue"
                                            []
                                            []
                                            Self
                                            "Value"
                                        ]
                                      |),
                                      []
                                    |)
                                  ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic", [], [] |),
                              [
                                mk_str (|
                                  "assertion failed: align_of::<Self>() <= align_of::<Self::Value>()"
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.rem,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "p3_field::packed::PackedValue"
                                                  []
                                                  []
                                                  Self
                                                  "Value"
                                              ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| buf |) |)
                                            |)
                                          ]
                                        |);
                                        M.read (|
                                          get_constant (|
                                            "p3_field::packed::PackedValue::WIDTH",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 0
                                  ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_v1",
                                    [
                                      Value.Integer IntegerKind.Usize 3;
                                      Value.Integer IntegerKind.Usize 2
                                    ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                mk_str (| "Slice length (got " |);
                                                mk_str (|
                                                  ") must be a multiple of packed field width ("
                                                |);
                                                mk_str (| ")." |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.associated_in_trait
                                                                      "p3_field::packed::PackedValue"
                                                                      []
                                                                      []
                                                                      Self
                                                                      "Value"
                                                                  ],
                                                                "len",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| M.read (| buf |) |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          get_constant (|
                                                            "p3_field::packed::PackedValue::WIDTH",
                                                            Ty.path "usize"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ buf_ptr : Ty.apply (Ty.path "*const") [] [ Self ] :=
              M.call_closure (|
                Ty.apply (Ty.path "*const") [] [ Self ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "*const")
                    []
                    [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ],
                  "cast",
                  [],
                  [ Self ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "*const")
                      []
                      [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value"
                        ],
                      "as_ptr",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                  |)
                ]
              |) in
            let~ n : Ty.path "usize" :=
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.div,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value"
                        ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                  |);
                  M.read (|
                    get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                  |)
                ]
              |) in
            M.alloc (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ],
                    M.get_function (| "core::slice::raw::from_raw_parts", [], [ Self ] |),
                    [ M.read (| buf_ptr |); M.read (| n |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_pack_slice :
      M.IsProvidedMethod "p3_field::packed::PackedValue" "pack_slice" pack_slice.
    Definition pack_slice_with_suffix
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ buf ] =>
        ltac:(M.monadic
          (let buf := M.alloc (| buf |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ];
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ]
                        ]
                    ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ]
                        ];
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ],
                    "split_at",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |);
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_field::packed::PackedValue"
                                  []
                                  []
                                  Self
                                  "Value"
                              ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.rem,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_field::packed::PackedValue"
                                      []
                                      []
                                      Self
                                      "Value"
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                            |);
                            M.read (|
                              get_constant (|
                                "p3_field::packed::PackedValue::WIDTH",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let packed := M.copy (| γ0_0 |) in
                    let suffix := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Self ] ],
                                M.get_trait_method (|
                                  "p3_field::packed::PackedValue",
                                  Self,
                                  [],
                                  [],
                                  "pack_slice",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| packed |) |) |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| suffix |) |) |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_pack_slice_with_suffix :
      M.IsProvidedMethod
        "p3_field::packed::PackedValue"
        "pack_slice_with_suffix"
        pack_slice_with_suffix.
    Definition pack_slice_mut
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ buf ] =>
        ltac:(M.monadic
          (let buf := M.alloc (| buf |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_function (| "core::mem::align_of", [], [ Self ] |),
                                          []
                                        |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_function (|
                                            "core::mem::align_of",
                                            [],
                                            [
                                              Ty.associated_in_trait
                                                "p3_field::packed::PackedValue"
                                                []
                                                []
                                                Self
                                                "Value"
                                            ]
                                          |),
                                          []
                                        |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic", [], [] |),
                                  [
                                    mk_str (|
                                      "assertion failed: align_of::<Self>() <= align_of::<Self::Value>()"
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.rem,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.associated_in_trait
                                                      "p3_field::packed::PackedValue"
                                                      []
                                                      []
                                                      Self
                                                      "Value"
                                                  ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| buf |) |)
                                                |)
                                              ]
                                            |);
                                            M.read (|
                                              get_constant (|
                                                "p3_field::packed::PackedValue::WIDTH",
                                                Ty.path "usize"
                                              |)
                                            |)
                                          ]
                                        |);
                                        Value.Integer IntegerKind.Usize 0
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::Arguments",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_v1",
                                        [
                                          Value.Integer IntegerKind.Usize 3;
                                          Value.Integer IntegerKind.Usize 2
                                        ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    mk_str (| "Slice length (got " |);
                                                    mk_str (|
                                                      ") must be a multiple of packed field width ("
                                                    |);
                                                    mk_str (| ")." |)
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        "new_display",
                                                        [],
                                                        [ Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [
                                                                        Ty.associated_in_trait
                                                                          "p3_field::packed::PackedValue"
                                                                          []
                                                                          []
                                                                          Self
                                                                          "Value"
                                                                      ],
                                                                    "len",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (| M.read (| buf |) |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |);
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        "new_display",
                                                        [],
                                                        [ Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              get_constant (|
                                                                "p3_field::packed::PackedValue::WIDTH",
                                                                Ty.path "usize"
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ buf_ptr : Ty.apply (Ty.path "*mut") [] [ Self ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Self ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value"
                        ],
                      "cast",
                      [],
                      [ Self ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_field::packed::PackedValue"
                              []
                              []
                              Self
                              "Value"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ],
                          "as_mut_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |) ]
                      |)
                    ]
                  |) in
                let~ n : Ty.path "usize" :=
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.div,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                      |);
                      M.read (|
                        get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ],
                            M.get_function (|
                              "core::slice::raw::from_raw_parts_mut",
                              [],
                              [ Self ]
                            |),
                            [ M.read (| buf_ptr |); M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_pack_slice_mut :
      M.IsProvidedMethod "p3_field::packed::PackedValue" "pack_slice_mut" pack_slice_mut.
    Definition pack_maybe_uninit_slice_mut
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ buf ] =>
        ltac:(M.monadic
          (let buf := M.alloc (| buf |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_function (| "core::mem::align_of", [], [ Self ] |),
                                          []
                                        |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_function (|
                                            "core::mem::align_of",
                                            [],
                                            [
                                              Ty.associated_in_trait
                                                "p3_field::packed::PackedValue"
                                                []
                                                []
                                                Self
                                                "Value"
                                            ]
                                          |),
                                          []
                                        |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic", [], [] |),
                                  [
                                    mk_str (|
                                      "assertion failed: align_of::<Self>() <= align_of::<Self::Value>()"
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.rem,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "p3_field::packed::PackedValue"
                                                          []
                                                          []
                                                          Self
                                                          "Value"
                                                      ]
                                                  ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| buf |) |)
                                                |)
                                              ]
                                            |);
                                            M.read (|
                                              get_constant (|
                                                "p3_field::packed::PackedValue::WIDTH",
                                                Ty.path "usize"
                                              |)
                                            |)
                                          ]
                                        |);
                                        Value.Integer IntegerKind.Usize 0
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::Arguments",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_v1",
                                        [
                                          Value.Integer IntegerKind.Usize 3;
                                          Value.Integer IntegerKind.Usize 2
                                        ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    mk_str (| "Slice length (got " |);
                                                    mk_str (|
                                                      ") must be a multiple of packed field width ("
                                                    |);
                                                    mk_str (| ")." |)
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        "new_display",
                                                        [],
                                                        [ Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::mem::maybe_uninit::MaybeUninit")
                                                                          []
                                                                          [
                                                                            Ty.associated_in_trait
                                                                              "p3_field::packed::PackedValue"
                                                                              []
                                                                              []
                                                                              Self
                                                                              "Value"
                                                                          ]
                                                                      ],
                                                                    "len",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (| M.read (| buf |) |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |);
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        "new_display",
                                                        [],
                                                        [ Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              get_constant (|
                                                                "p3_field::packed::PackedValue::WIDTH",
                                                                Ty.path "usize"
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ buf_ptr :
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Self ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Self ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ]
                        ],
                      "cast",
                      [],
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Self ] ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_field::packed::PackedValue"
                                  []
                                  []
                                  Self
                                  "Value"
                              ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_field::packed::PackedValue"
                                    []
                                    []
                                    Self
                                    "Value"
                                ]
                            ],
                          "as_mut_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |) ]
                      |)
                    ]
                  |) in
                let~ n : Ty.path "usize" :=
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.div,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_field::packed::PackedValue"
                                    []
                                    []
                                    Self
                                    "Value"
                                ]
                            ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                      |);
                      M.read (|
                        get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Self ]
                                  ]
                              ],
                            M.get_function (|
                              "core::slice::raw::from_raw_parts_mut",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Self ]
                              ]
                            |),
                            [ M.read (| buf_ptr |); M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_pack_maybe_uninit_slice_mut :
      M.IsProvidedMethod
        "p3_field::packed::PackedValue"
        "pack_maybe_uninit_slice_mut"
        pack_maybe_uninit_slice_mut.
    Definition pack_slice_with_suffix_mut
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ buf ] =>
        ltac:(M.monadic
          (let buf := M.alloc (| buf |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ];
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ]
                        ]
                    ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ]
                        ];
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_field::packed::PackedValue"
                                []
                                []
                                Self
                                "Value"
                            ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ],
                    "split_at_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |);
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_field::packed::PackedValue"
                                  []
                                  []
                                  Self
                                  "Value"
                              ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.rem,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_field::packed::PackedValue"
                                      []
                                      []
                                      Self
                                      "Value"
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                            |);
                            M.read (|
                              get_constant (|
                                "p3_field::packed::PackedValue::WIDTH",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let packed := M.copy (| γ0_0 |) in
                    let suffix := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Self ] ],
                                M.get_trait_method (|
                                  "p3_field::packed::PackedValue",
                                  Self,
                                  [],
                                  [],
                                  "pack_slice_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| packed |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| suffix |) |) |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_pack_slice_with_suffix_mut :
      M.IsProvidedMethod
        "p3_field::packed::PackedValue"
        "pack_slice_with_suffix_mut"
        pack_slice_with_suffix_mut.
    Definition pack_maybe_uninit_slice_with_suffix_mut
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ buf ] =>
        ltac:(M.monadic
          (let buf := M.alloc (| buf |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Self ]
                            ]
                        ];
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_field::packed::PackedValue"
                                    []
                                    []
                                    Self
                                    "Value"
                                ]
                            ]
                        ]
                    ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_field::packed::PackedValue"
                                    []
                                    []
                                    Self
                                    "Value"
                                ]
                            ]
                        ];
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_field::packed::PackedValue"
                                    []
                                    []
                                    Self
                                    "Value"
                                ]
                            ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_field::packed::PackedValue"
                              []
                              []
                              Self
                              "Value"
                          ]
                      ],
                    "split_at_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |);
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_field::packed::PackedValue"
                                      []
                                      []
                                      Self
                                      "Value"
                                  ]
                              ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.rem,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_field::packed::PackedValue"
                                          []
                                          []
                                          Self
                                          "Value"
                                      ]
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                            |);
                            M.read (|
                              get_constant (|
                                "p3_field::packed::PackedValue::WIDTH",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let packed := M.copy (| γ0_0 |) in
                    let suffix := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Self ]
                                      ]
                                  ],
                                M.get_trait_method (|
                                  "p3_field::packed::PackedValue",
                                  Self,
                                  [],
                                  [],
                                  "pack_maybe_uninit_slice_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| packed |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| suffix |) |) |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_pack_maybe_uninit_slice_with_suffix_mut :
      M.IsProvidedMethod
        "p3_field::packed::PackedValue"
        "pack_maybe_uninit_slice_with_suffix_mut"
        pack_maybe_uninit_slice_with_suffix_mut.
    Definition unpack_slice
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ buf ] =>
        ltac:(M.monadic
          (let buf := M.alloc (| buf |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ge,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_function (| "core::mem::align_of", [], [ Self ] |),
                                      []
                                    |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_function (|
                                        "core::mem::align_of",
                                        [],
                                        [
                                          Ty.associated_in_trait
                                            "p3_field::packed::PackedValue"
                                            []
                                            []
                                            Self
                                            "Value"
                                        ]
                                      |),
                                      []
                                    |)
                                  ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic", [], [] |),
                              [
                                mk_str (|
                                  "assertion failed: align_of::<Self>() >= align_of::<Self::Value>()"
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ buf_ptr :
                Ty.apply
                  (Ty.path "*const")
                  []
                  [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "*const")
                  []
                  [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*const") [] [ Self ],
                  "cast",
                  [],
                  [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ]
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*const") [] [ Self ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Self ],
                      "as_ptr",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                  |)
                ]
              |) in
            let~ n : Ty.path "usize" :=
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.mul,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Self ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                  |);
                  M.read (|
                    get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                  |)
                ]
              |) in
            M.alloc (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_field::packed::PackedValue"
                              []
                              []
                              Self
                              "Value"
                          ]
                      ],
                    M.get_function (|
                      "core::slice::raw::from_raw_parts",
                      [],
                      [ Ty.associated_in_trait "p3_field::packed::PackedValue" [] [] Self "Value" ]
                    |),
                    [ M.read (| buf_ptr |); M.read (| n |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_unpack_slice :
      M.IsProvidedMethod "p3_field::packed::PackedValue" "unpack_slice" unpack_slice.
  End PackedValue.
  
  Module Impl_p3_field_packed_PackedValue_where_p3_field_packed_Packable_T_for_array_WIDTH_T.
    Definition Self (WIDTH : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "array") [ WIDTH ] [ T ].
    
    (*     type Value = T; *)
    Definition _Value (WIDTH : Value.t) (T : Ty.t) : Ty.t := T.
    
    (*     const WIDTH: usize = WIDTH; *)
    (* Ty.path "usize" *)
    Definition value_WIDTH
        (WIDTH : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIDTH T in
      ltac:(M.monadic (M.alloc (| WIDTH |))).
    
    (*
        fn from_slice(slice: &[Self::Value]) -> &Self {
            assert_eq!(slice.len(), Self::WIDTH);
            slice.try_into().unwrap()
        }
    *)
    Definition from_slice
        (WIDTH : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIDTH T in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ];
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    M.get_trait_method (|
                      "core::convert::TryInto",
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ] ],
                      "try_into",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_slice_mut(slice: &mut [Self::Value]) -> &mut Self {
            assert_eq!(slice.len(), Self::WIDTH);
            slice.try_into().unwrap()
        }
    *)
    Definition from_slice_mut
        (WIDTH : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIDTH T in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        Value.Tuple
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| slice |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              get_constant (|
                                "p3_field::packed::PackedValue::WIDTH",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let left_val := M.copy (| γ0_0 |) in
                            let right_val := M.copy (| γ0_1 |) in
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.eq,
                                              [
                                                M.read (| M.deref (| M.read (| left_val |) |) |);
                                                M.read (| M.deref (| M.read (| right_val |) |) |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ kind : Ty.path "core::panicking::AssertKind" :=
                                            Value.StructTuple
                                              "core::panicking::AssertKind::Eq"
                                              []
                                              []
                                              [] in
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "never",
                                              M.get_function (|
                                                "core::panicking::assert_failed",
                                                [],
                                                [ Ty.path "usize"; Ty.path "usize" ]
                                              |),
                                              [
                                                M.read (| kind |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| left_val |) |)
                                                    |)
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  |)
                                                |);
                                                Value.StructTuple
                                                  "core::option::Option::None"
                                                  []
                                                  [ Ty.path "core::fmt::Arguments" ]
                                                  []
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ];
                          Ty.path "core::array::TryFromSliceError"
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ];
                            Ty.path "core::array::TryFromSliceError"
                          ],
                        M.get_trait_method (|
                          "core::convert::TryInto",
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                          [],
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "array") [ WIDTH ] [ T ] ]
                          ],
                          "try_into",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_fn<F>(f: F) -> Self
        where
            F: FnMut(usize) -> Self::Value,
        {
            core::array::from_fn(f)
        }
    *)
    Definition from_fn
        (WIDTH : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIDTH T in
      match ε, τ, α with
      | [], [ F ], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ WIDTH ] [ T ],
            M.get_function (| "core::array::from_fn", [ WIDTH ], [ T; F ] |),
            [ M.read (| f |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn as_slice(&self) -> &[Self::Value] {
            self
        }
    *)
    Definition as_slice
        (WIDTH : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIDTH T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          (* Unsize *)
          M.pointer_coercion (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn as_slice_mut(&mut self) -> &mut [Self::Value] {
            self
        }
    *)
    Definition as_slice_mut
        (WIDTH : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIDTH T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (WIDTH : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "p3_field::packed::PackedValue"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self WIDTH T)
        (* Instance *)
        [
          ("Value", InstanceField.Ty (_Value WIDTH T));
          ("value_WIDTH", InstanceField.Method (value_WIDTH WIDTH T));
          ("from_slice", InstanceField.Method (from_slice WIDTH T));
          ("from_slice_mut", InstanceField.Method (from_slice_mut WIDTH T));
          ("from_fn", InstanceField.Method (from_fn WIDTH T));
          ("as_slice", InstanceField.Method (as_slice WIDTH T));
          ("as_slice_mut", InstanceField.Method (as_slice_mut WIDTH T))
        ].
  End Impl_p3_field_packed_PackedValue_where_p3_field_packed_Packable_T_for_array_WIDTH_T.
  
  (* Trait *)
  Module PackedField.
    Definition packed_powers
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ base ] =>
        ltac:(M.monadic
          (let base := M.alloc (| base |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ],
            M.get_trait_method (|
              "p3_field::packed::PackedField",
              Self,
              [],
              [],
              "packed_shifted_powers",
              [],
              []
            |),
            [
              M.read (| base |);
              M.read (|
                get_constant (|
                  "p3_field::field::PrimeCharacteristicRing::ONE",
                  Ty.associated_in_trait "p3_field::packed::PackedField" [] [] Self "Scalar"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_packed_powers :
      M.IsProvidedMethod "p3_field::packed::PackedField" "packed_powers" packed_powers.
    Definition packed_shifted_powers
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ base; start ] =>
        ltac:(M.monadic
          (let base := M.alloc (| base |) in
          let start := M.alloc (| start |) in
          M.read (|
            let~ current : Self :=
              M.call_closure (|
                Self,
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.associated_in_trait "p3_field::packed::PackedField" [] [] Self "Scalar",
                  [],
                  [ Self ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| start |) ]
              |) in
            let~ slice :
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.associated_in_trait "p3_field::packed::PackedField" [] [] Self "Scalar" ]
                  ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.associated_in_trait "p3_field::packed::PackedField" [] [] Self "Scalar" ]
                  ],
                M.get_trait_method (|
                  "p3_field::packed::PackedValue",
                  Self,
                  [],
                  [],
                  "as_slice_mut",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, current |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          Value.StructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [
                              ("start", Value.Integer IntegerKind.Usize 1);
                              ("end_",
                                M.read (|
                                  get_constant (|
                                    "p3_field::packed::PackedValue::WIDTH",
                                    Ty.path "usize"
                                  |)
                                |))
                            ]
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            ltac:(M.monadic
                              (let~ _ : Ty.tuple [] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let i := M.copy (| γ0_0 |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.write (|
                                              M.SubPointer.get_array_field (|
                                                M.deref (| M.read (| slice |) |),
                                                M.read (| i |)
                                              |),
                                              M.call_closure (|
                                                Ty.associated_in_trait
                                                  "p3_field::packed::PackedField"
                                                  []
                                                  []
                                                  Self
                                                  "Scalar",
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  Ty.associated_in_trait
                                                    "p3_field::packed::PackedField"
                                                    []
                                                    []
                                                    Self
                                                    "Scalar",
                                                  [],
                                                  [
                                                    Ty.associated_in_trait
                                                      "p3_field::packed::PackedField"
                                                      []
                                                      []
                                                      Self
                                                      "Scalar"
                                                  ],
                                                  "mul",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_array_field (|
                                                      M.deref (| M.read (| slice |) |),
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [
                                                          M.read (| i |);
                                                          Value.Integer IntegerKind.Usize 1
                                                        ]
                                                      |)
                                                    |)
                                                  |);
                                                  M.read (| base |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |))
              |) in
            M.alloc (|
              Value.StructRecord
                "p3_field::field::Powers"
                []
                [ Self ]
                [
                  ("base",
                    M.call_closure (|
                      Self,
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.associated_in_trait "p3_field::packed::PackedField" [] [] Self "Scalar",
                        [],
                        [ Self ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.associated_in_trait
                            "p3_field::packed::PackedField"
                            []
                            []
                            Self
                            "Scalar",
                          M.get_trait_method (|
                            "p3_field::field::PrimeCharacteristicRing",
                            Ty.associated_in_trait
                              "p3_field::packed::PackedField"
                              []
                              []
                              Self
                              "Scalar",
                            [],
                            [],
                            "exp_u64",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, base |);
                            M.cast
                              (Ty.path "u64")
                              (M.read (|
                                get_constant (|
                                  "p3_field::packed::PackedValue::WIDTH",
                                  Ty.path "usize"
                                |)
                              |))
                          ]
                        |)
                      ]
                    |));
                  ("current", M.read (| current |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_packed_shifted_powers :
      M.IsProvidedMethod
        "p3_field::packed::PackedField"
        "packed_shifted_powers"
        packed_shifted_powers.
    Definition packed_linear_combination
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [ N ], [], [ coeffs; vecs ] =>
        ltac:(M.monadic
          (let coeffs := M.alloc (| coeffs |) in
          let vecs := M.alloc (| vecs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_field::packed::PackedField"
                                      []
                                      []
                                      Self
                                      "Scalar"
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| coeffs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Self ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| vecs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ combined : Ty.apply (Ty.path "array") [ N ] [ Self ] :=
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ Self ],
                M.get_function (|
                  "core::array::from_fn",
                  [ N ],
                  [ Self; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] Self ]
                |),
                [
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] Self ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let i := M.copy (| γ |) in
                                    M.call_closure (|
                                      Self,
                                      M.get_trait_method (|
                                        "core::ops::arith::Mul",
                                        Self,
                                        [],
                                        [
                                          Ty.associated_in_trait
                                            "p3_field::packed::PackedField"
                                            []
                                            []
                                            Self
                                            "Scalar"
                                        ],
                                        "mul",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| vecs |) |),
                                            M.read (| i |)
                                          |)
                                        |);
                                        M.read (|
                                          M.SubPointer.get_array_field (|
                                            M.deref (| M.read (| coeffs |) |),
                                            M.read (| i |)
                                          |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Self,
                M.get_trait_method (|
                  "p3_field::field::PrimeCharacteristicRing",
                  Self,
                  [],
                  [],
                  "sum_array",
                  [ N ],
                  []
                |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, combined |) |)
                    |))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_packed_linear_combination :
      M.IsProvidedMethod
        "p3_field::packed::PackedField"
        "packed_linear_combination"
        packed_linear_combination.
  End PackedField.
  
  (* Trait *)
  (* Empty module 'PackedFieldPow2' *)
  
  (* Trait *)
  Module PackedFieldExtension.
    Definition to_ext_iter
        (BaseField ExtField Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ impl_IntoIterator_Item___Self_ ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::iter::adapters::flatten::FlatMap")
              []
              [
                Ty.associated_in_trait
                  "core::iter::traits::collect::IntoIterator"
                  []
                  []
                  impl_IntoIterator_Item___Self_
                  "IntoIter";
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ ExtField; Ty.path "alloc::alloc::Global" ];
                Ty.function
                  [ Ty.tuple [ Self ] ]
                  (Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ ExtField; Ty.path "alloc::alloc::Global" ])
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                impl_IntoIterator_Item___Self_
                "IntoIter",
              [],
              [],
              "flat_map",
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ ExtField; Ty.path "alloc::alloc::Global" ];
                Ty.function
                  [ Ty.tuple [ Self ] ]
                  (Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ ExtField; Ty.path "alloc::alloc::Global" ])
              ]
            |),
            [
              M.call_closure (|
                Ty.associated_in_trait
                  "core::iter::traits::collect::IntoIterator"
                  []
                  []
                  impl_IntoIterator_Item___Self_
                  "IntoIter",
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  impl_IntoIterator_Item___Self_,
                  [],
                  [],
                  "into_iter",
                  [],
                  []
                |),
                [ M.read (| iter |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Self ] ]
                                (Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ ExtField; Ty.path "alloc::alloc::Global" ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let x := M.copy (| γ |) in
                                M.read (|
                                  let~ packed_coeffs :
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "p3_field::field::Field"
                                                []
                                                []
                                                BaseField
                                                "Packing"
                                            ]
                                        ] :=
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "p3_field::field::Field"
                                                []
                                                []
                                                BaseField
                                                "Packing"
                                            ]
                                        ],
                                      M.get_trait_method (|
                                        "p3_field::field::BasedVectorSpace",
                                        Self,
                                        [],
                                        [
                                          Ty.associated_in_trait
                                            "p3_field::field::Field"
                                            []
                                            []
                                            BaseField
                                            "Packing"
                                        ],
                                        "as_basis_coefficients_slice",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, x |) ]
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ ExtField; Ty.path "alloc::alloc::Global" ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::map::Map")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ];
                                            Ty.function [ Ty.tuple [ Ty.path "usize" ] ] ExtField
                                          ],
                                        [],
                                        [],
                                        "collect",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ ExtField; Ty.path "alloc::alloc::Global" ]
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::map::Map")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ];
                                              Ty.function [ Ty.tuple [ Ty.path "usize" ] ] ExtField
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "map",
                                            [],
                                            [
                                              ExtField;
                                              Ty.function [ Ty.tuple [ Ty.path "usize" ] ] ExtField
                                            ]
                                          |),
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              []
                                              [ Ty.path "usize" ]
                                              [
                                                ("start", Value.Integer IntegerKind.Usize 0);
                                                ("end_",
                                                  M.read (|
                                                    get_constant (|
                                                      "p3_field::packed::PackedValue::WIDTH",
                                                      Ty.path "usize"
                                                    |)
                                                  |))
                                              ];
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    ltac:(M.monadic
                                                      (M.match_operator (|
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [
                                                            Ty.function
                                                              [ Ty.tuple [ Ty.path "usize" ] ]
                                                              ExtField
                                                          ],
                                                        M.alloc (| α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let i := M.copy (| γ |) in
                                                              M.call_closure (|
                                                                ExtField,
                                                                M.get_trait_method (|
                                                                  "p3_field::field::BasedVectorSpace",
                                                                  ExtField,
                                                                  [],
                                                                  [ BaseField ],
                                                                  "from_basis_coefficients_fn",
                                                                  [],
                                                                  [
                                                                    Ty.function
                                                                      [ Ty.tuple [ Ty.path "usize" ]
                                                                      ]
                                                                      BaseField
                                                                  ]
                                                                |),
                                                                [
                                                                  M.closure
                                                                    (fun γ =>
                                                                      ltac:(M.monadic
                                                                        match γ with
                                                                        | [ α0 ] =>
                                                                          ltac:(M.monadic
                                                                            (M.match_operator (|
                                                                              Ty.apply
                                                                                (Ty.path "*")
                                                                                []
                                                                                [
                                                                                  Ty.function
                                                                                    [
                                                                                      Ty.tuple
                                                                                        [
                                                                                          Ty.path
                                                                                            "usize"
                                                                                        ]
                                                                                    ]
                                                                                    BaseField
                                                                                ],
                                                                              M.alloc (| α0 |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let j :=
                                                                                      M.copy (|
                                                                                        γ
                                                                                      |) in
                                                                                    M.read (|
                                                                                      M.SubPointer.get_array_field (|
                                                                                        M.deref (|
                                                                                          M.call_closure (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "&")
                                                                                              []
                                                                                              [
                                                                                                Ty.apply
                                                                                                  (Ty.path
                                                                                                    "slice")
                                                                                                  []
                                                                                                  [
                                                                                                    BaseField
                                                                                                  ]
                                                                                              ],
                                                                                            M.get_trait_method (|
                                                                                              "p3_field::packed::PackedValue",
                                                                                              Ty.associated_in_trait
                                                                                                "p3_field::field::Field"
                                                                                                []
                                                                                                []
                                                                                                BaseField
                                                                                                "Packing",
                                                                                              [],
                                                                                              [],
                                                                                              "as_slice",
                                                                                              [],
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.SubPointer.get_array_field (|
                                                                                                  M.deref (|
                                                                                                    M.read (|
                                                                                                      packed_coeffs
                                                                                                    |)
                                                                                                  |),
                                                                                                  M.read (|
                                                                                                    j
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        |),
                                                                                        M.read (|
                                                                                          i
                                                                                        |)
                                                                                      |)
                                                                                    |)))
                                                                              ]
                                                                            |)))
                                                                        | _ =>
                                                                          M.impossible
                                                                            "wrong number of arguments"
                                                                        end))
                                                                ]
                                                              |)))
                                                        ]
                                                      |)))
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end))
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_to_ext_iter :
      forall (BaseField ExtField : Ty.t),
      M.IsProvidedMethod
        "p3_field::packed::PackedFieldExtension"
        "to_ext_iter"
        (to_ext_iter BaseField ExtField).
    Definition packed_ext_powers_capped
        (BaseField ExtField Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ base; unpacked_len ] =>
        ltac:(M.monadic
          (let base := M.alloc (| base |) in
          let unpacked_len := M.alloc (| unpacked_len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::iter::adapters::take::Take")
              []
              [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ],
              [],
              [],
              "take",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "p3_field::field::Powers") [] [ Self ],
                M.get_trait_method (|
                  "p3_field::packed::PackedFieldExtension",
                  Self,
                  [],
                  [ BaseField; ExtField ],
                  "packed_ext_powers",
                  [],
                  []
                |),
                [ M.read (| base |) ]
              |);
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (| Ty.path "usize", "div_ceil", [], [] |),
                [
                  M.read (| unpacked_len |);
                  M.read (|
                    get_constant (| "p3_field::packed::PackedValue::WIDTH", Ty.path "usize" |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_packed_ext_powers_capped :
      forall (BaseField ExtField : Ty.t),
      M.IsProvidedMethod
        "p3_field::packed::PackedFieldExtension"
        "packed_ext_powers_capped"
        (packed_ext_powers_capped BaseField ExtField).
  End PackedFieldExtension.
  
  Module Impl_p3_field_packed_PackedValue_where_p3_field_packed_Packable_T_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    (*     type Value = Self; *)
    Definition _Value (T : Ty.t) : Ty.t := T.
    
    (*     const WIDTH: usize = 1; *)
    (* Ty.path "usize" *)
    Definition value_WIDTH (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1 |))).
    
    (*
        fn from_slice(slice: &[Self::Value]) -> &Self {
            &slice[0]
        }
    *)
    Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| slice |) |),
                  Value.Integer IntegerKind.Usize 0
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_slice_mut(slice: &mut [Self::Value]) -> &mut Self {
            &mut slice[0]
        }
    *)
    Definition from_slice_mut
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| slice |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_fn<Fn>(mut f: Fn) -> Self
        where
            Fn: FnMut(usize) -> Self::Value,
        {
            f(0)
        }
    *)
    Definition from_fn (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ Fn ], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| f |) in
          M.call_closure (|
            T,
            M.get_trait_method (|
              "core::ops::function::FnMut",
              Fn,
              [],
              [ Ty.tuple [ Ty.path "usize" ] ],
              "call_mut",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, f |);
              Value.Tuple [ Value.Integer IntegerKind.Usize 0 ]
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn as_slice(&self) -> &[Self::Value] {
            slice::from_ref(self)
        }
    *)
    Definition as_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                M.get_function (| "core::slice::raw::from_ref", [], [ T ] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn as_slice_mut(&mut self) -> &mut [Self::Value] {
            slice::from_mut(self)
        }
    *)
    Definition as_slice_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_function (| "core::slice::raw::from_mut", [], [ T ] |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "p3_field::packed::PackedValue"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("Value", InstanceField.Ty (_Value T));
          ("value_WIDTH", InstanceField.Method (value_WIDTH T));
          ("from_slice", InstanceField.Method (from_slice T));
          ("from_slice_mut", InstanceField.Method (from_slice_mut T));
          ("from_fn", InstanceField.Method (from_fn T));
          ("as_slice", InstanceField.Method (as_slice T));
          ("as_slice_mut", InstanceField.Method (as_slice_mut T))
        ].
  End Impl_p3_field_packed_PackedValue_where_p3_field_packed_Packable_T_for_T.
  
  Module Impl_p3_field_packed_PackedField_where_p3_field_field_Field_F_for_F.
    Definition Self (F : Ty.t) : Ty.t := F.
    
    (*     type Scalar = Self; *)
    Definition _Scalar (F : Ty.t) : Ty.t := F.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "p3_field::packed::PackedField"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("Scalar", InstanceField.Ty (_Scalar F)) ].
  End Impl_p3_field_packed_PackedField_where_p3_field_field_Field_F_for_F.
  
  Module Impl_p3_field_packed_PackedFieldPow2_where_p3_field_field_Field_F_for_F.
    Definition Self (F : Ty.t) : Ty.t := F.
    
    (*
        fn interleave(&self, other: Self, block_len: usize) -> (Self, Self) {
            match block_len {
                1 => ( *self, other),
                _ => panic!("unsupported block length"),
            }
        }
    *)
    Definition interleave (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; other; block_len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          let block_len := M.alloc (| block_len |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [ F; F ] ],
              block_len,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 1
                      |) in
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| other |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [ Value.Integer IntegerKind.Usize 1 ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array [ mk_str (| "unsupported block length" |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "p3_field::packed::PackedFieldPow2"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("interleave", InstanceField.Method (interleave F)) ].
  End Impl_p3_field_packed_PackedFieldPow2_where_p3_field_field_Field_F_for_F.
  
  Module Impl_p3_field_packed_PackedFieldExtension_where_p3_field_field_Field_F_F_F_for_associated_in_trait_p3_field_field_Field___F_Packing.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing".
    
    (*
        fn from_ext_slice(ext_slice: &[F]) -> Self {
            ext_slice[0].into()
        }
    *)
    Definition from_ext_slice
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ ext_slice ] =>
        ltac:(M.monadic
          (let ext_slice := M.alloc (| ext_slice |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing",
            M.get_trait_method (|
              "core::convert::Into",
              F,
              [],
              [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
              "into",
              [],
              []
            |),
            [
              M.read (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| ext_slice |) |),
                  Value.Integer IntegerKind.Usize 0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn packed_ext_powers(base: F) -> Powers<Self> {
            F::Packing::packed_powers(base)
        }
    *)
    Definition packed_ext_powers
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ base ] =>
        ltac:(M.monadic
          (let base := M.alloc (| base |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "p3_field::field::Powers")
              []
              [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
            M.get_trait_method (|
              "p3_field::packed::PackedField",
              Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing",
              [],
              [],
              "packed_powers",
              [],
              []
            |),
            [ M.read (| base |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "p3_field::packed::PackedFieldExtension"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ F; F ]
        (Self F)
        (* Instance *)
        [
          ("from_ext_slice", InstanceField.Method (from_ext_slice F));
          ("packed_ext_powers", InstanceField.Method (packed_ext_powers F))
        ].
  End Impl_p3_field_packed_PackedFieldExtension_where_p3_field_field_Field_F_F_F_for_associated_in_trait_p3_field_field_Field___F_Packing.
  
  Module Impl_p3_field_packed_Packable_for_u8.
    Definition Self : Ty.t := Ty.path "u8".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::packed::Packable"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_field_packed_Packable_for_u8.
  
  Module Impl_p3_field_packed_Packable_for_u16.
    Definition Self : Ty.t := Ty.path "u16".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::packed::Packable"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_field_packed_Packable_for_u16.
  
  Module Impl_p3_field_packed_Packable_for_u32.
    Definition Self : Ty.t := Ty.path "u32".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::packed::Packable"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_field_packed_Packable_for_u32.
  
  Module Impl_p3_field_packed_Packable_for_u64.
    Definition Self : Ty.t := Ty.path "u64".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::packed::Packable"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_field_packed_Packable_for_u64.
  
  Module Impl_p3_field_packed_Packable_for_u128.
    Definition Self : Ty.t := Ty.path "u128".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::packed::Packable"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_field_packed_Packable_for_u128.
End packed.
