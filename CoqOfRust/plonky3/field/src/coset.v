(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module coset.
  (* StructRecord
    {
      name := "TwoAdicMultiplicativeCoset";
      const_params := [];
      ty_params := [ "F" ];
      fields := [ ("shift", F); ("log_size", Ty.path "usize") ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ].
    
    (* Clone *)
    Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "p3_field::coset::TwoAdicMultiplicativeCoset"
            [
              ("shift",
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::clone::Clone", F, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::coset::TwoAdicMultiplicativeCoset",
                            "shift"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("log_size",
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "usize",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::coset::TwoAdicMultiplicativeCoset",
                            "log_size"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_F_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ].
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_F_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| mk_str (| "TwoAdicMultiplicativeCoset" |) |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "shift" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::coset::TwoAdicMultiplicativeCoset",
                        "shift"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "log_size" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::coset::TwoAdicMultiplicativeCoset",
                            "log_size"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
  
  Module Impl_p3_field_coset_TwoAdicMultiplicativeCoset_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ].
    
    (*
        pub fn new(shift: F, log_size: usize) -> Option<Self> {
            if log_size <= F::TWO_ADICITY {
                Some(Self { shift, log_size })
            } else {
                None
            }
        }
    *)
    Definition new (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ shift; log_size ] =>
        ltac:(M.monadic
          (let shift := M.alloc (| shift |) in
          let log_size := M.alloc (| log_size |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ] ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.le,
                            [
                              M.read (| log_size |);
                              M.read (|
                                get_constant (|
                                  "p3_field::field::TwoAdicField::TWO_ADICITY",
                                  Ty.path "usize"
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          Value.StructRecord
                            "p3_field::coset::TwoAdicMultiplicativeCoset"
                            [ ("shift", M.read (| shift |)); ("log_size", M.read (| log_size |)) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "new" (new F).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn subgroup_generator(&self) -> F {
            F::two_adic_generator(self.log_size)
        }
    *)
    Definition subgroup_generator
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            F,
            M.get_trait_method (|
              "p3_field::field::TwoAdicField",
              F,
              [],
              [],
              "two_adic_generator",
              [],
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_field::coset::TwoAdicMultiplicativeCoset",
                  "log_size"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_subgroup_generator :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "subgroup_generator" (subgroup_generator F).
    Admitted.
    Global Typeclasses Opaque subgroup_generator.
    
    (*
        pub fn shift(&self) -> F {
            self.shift
        }
    *)
    Definition shift (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "p3_field::coset::TwoAdicMultiplicativeCoset",
              "shift"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_shift :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "shift" (shift F).
    Admitted.
    Global Typeclasses Opaque shift.
    
    (*
        pub fn log_size(&self) -> usize {
            self.log_size
        }
    *)
    Definition log_size (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "p3_field::coset::TwoAdicMultiplicativeCoset",
              "log_size"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_log_size :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "log_size" (log_size F).
    Admitted.
    Global Typeclasses Opaque log_size.
    
    (*
        pub fn size(&self) -> usize {
            1 << self.log_size
        }
    *)
    Definition size (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.shl,
            [
              Value.Integer IntegerKind.Usize 1;
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_field::coset::TwoAdicMultiplicativeCoset",
                  "log_size"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_size :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "size" (size F).
    Admitted.
    Global Typeclasses Opaque size.
    
    (*
        pub fn shrink_coset(&self, log_scale_factor: usize) -> Option<Self> {
            self.log_size
                .checked_sub(log_scale_factor)
                .map(|new_log_size| TwoAdicMultiplicativeCoset {
                    shift: self.shift,
                    log_size: new_log_size,
                })
        }
    *)
    Definition shrink_coset (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; log_scale_factor ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let log_scale_factor := M.alloc (| log_scale_factor |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
              "map",
              [],
              [
                Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ];
                Ty.function
                  [ Ty.tuple [ Ty.path "usize" ] ]
                  (Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::coset::TwoAdicMultiplicativeCoset",
                      "log_size"
                    |)
                  |);
                  M.read (| log_scale_factor |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.path "usize" ] ]
                                (Ty.apply
                                  (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset")
                                  []
                                  [ F ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let new_log_size := M.copy (| γ |) in
                                Value.StructRecord
                                  "p3_field::coset::TwoAdicMultiplicativeCoset"
                                  [
                                    ("shift",
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "p3_field::coset::TwoAdicMultiplicativeCoset",
                                          "shift"
                                        |)
                                      |));
                                    ("log_size", M.read (| new_log_size |))
                                  ]))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_shrink_coset :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "shrink_coset" (shrink_coset F).
    Admitted.
    Global Typeclasses Opaque shrink_coset.
    
    (*
        pub fn exp_power_of_2(&self, log_scale_factor: usize) -> Option<Self> {
            self.shrink_coset(log_scale_factor).map(|mut coset| {
                coset.shift = self.shift.exp_power_of_2(log_scale_factor);
                coset
            })
        }
    *)
    Definition exp_power_of_2
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; log_scale_factor ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let log_scale_factor := M.alloc (| log_scale_factor |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ] ],
              "map",
              [],
              [
                Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ];
                Ty.function
                  [
                    Ty.tuple
                      [ Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ] ]
                  ]
                  (Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ],
                  "shrink_coset",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.read (| log_scale_factor |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset")
                                        []
                                        [ F ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset")
                                  []
                                  [ F ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let coset := M.copy (| γ |) in
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          coset,
                                          "p3_field::coset::TwoAdicMultiplicativeCoset",
                                          "shift"
                                        |),
                                        M.call_closure (|
                                          F,
                                          M.get_trait_method (|
                                            "p3_field::field::PrimeCharacteristicRing",
                                            F,
                                            [],
                                            [],
                                            "exp_power_of_2",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "p3_field::coset::TwoAdicMultiplicativeCoset",
                                                "shift"
                                              |)
                                            |);
                                            M.read (| log_scale_factor |)
                                          ]
                                        |)
                                      |)
                                    |) in
                                  coset
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_exp_power_of_2 :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "exp_power_of_2" (exp_power_of_2 F).
    Admitted.
    Global Typeclasses Opaque exp_power_of_2.
    
    (*
        pub fn shift_by(&self, scale: F) -> TwoAdicMultiplicativeCoset<F> {
            TwoAdicMultiplicativeCoset {
                shift: self.shift * scale,
                log_size: self.log_size,
            }
        }
    *)
    Definition shift_by (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; scale ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let scale := M.alloc (| scale |) in
          Value.StructRecord
            "p3_field::coset::TwoAdicMultiplicativeCoset"
            [
              ("shift",
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_field::coset::TwoAdicMultiplicativeCoset",
                        "shift"
                      |)
                    |);
                    M.read (| scale |)
                  ]
                |));
              ("log_size",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_field::coset::TwoAdicMultiplicativeCoset",
                    "log_size"
                  |)
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_shift_by :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "shift_by" (shift_by F).
    Admitted.
    Global Typeclasses Opaque shift_by.
    
    (*
        pub fn set_shift(&self, shift: F) -> TwoAdicMultiplicativeCoset<F> {
            TwoAdicMultiplicativeCoset {
                shift,
                log_size: self.log_size,
            }
        }
    *)
    Definition set_shift (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; shift ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let shift := M.alloc (| shift |) in
          Value.StructRecord
            "p3_field::coset::TwoAdicMultiplicativeCoset"
            [
              ("shift", M.read (| shift |));
              ("log_size",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_field::coset::TwoAdicMultiplicativeCoset",
                    "log_size"
                  |)
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_set_shift :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "set_shift" (set_shift F).
    Admitted.
    Global Typeclasses Opaque set_shift.
    
    (*
        pub fn contains(&self, element: F) -> bool {
            // Note that, in a finite field F (this is not true of a general finite
            // commutative ring), there is exactly one subgroup of |F^*| of order n
            // for each divisor n of |F| - 1, and its elements e are uniquely
            // caracterised by the condition e^n = 1.
    
            // We check (shift^{-1} * element)^(2^log_size) = 1, which is equivalent
            // to checking shift^(2^log_size) = element^(2^log_size) - this avoids
            // inversion at the cost of a few squarings. The loop terminates early
            // if possible.
            let (mut shift, mut element) = (self.shift, element);
    
            for _ in 0..self.log_size {
                if element == shift {
                    return true;
                }
                element = element.square();
                shift = shift.square();
            }
    
            element == shift
        }
    *)
    Definition contains (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; element ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let element := M.alloc (| element |) in
          M.catch_return (Ty.path "bool") (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_field::coset::TwoAdicMultiplicativeCoset",
                            "shift"
                          |)
                        |);
                        M.read (| element |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let shift := M.copy (| γ0_0 |) in
                        let element := M.copy (| γ0_1 |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.use
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::collect::IntoIterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "into_iter",
                                    [],
                                    []
                                  |),
                                  [
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start", Value.Integer IntegerKind.Usize 0);
                                        ("end_",
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "p3_field::coset::TwoAdicMultiplicativeCoset",
                                              "log_size"
                                            |)
                                          |))
                                      ]
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let iter := M.copy (| γ |) in
                                    M.loop (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      ltac:(M.monadic
                                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                          M.match_operator (|
                                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.path "usize" ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  [],
                                                  [],
                                                  "next",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.MutRef, iter |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let _ :=
                                                    M.is_struct_tuple (|
                                                      γ,
                                                      "core::option::Option::None"
                                                    |) in
                                                  M.alloc (|
                                                    M.never_to_any (| M.read (| M.break (||) |) |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let~ _ :
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                    M.match_operator (|
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  M.call_closure (|
                                                                    Ty.path "bool",
                                                                    M.get_trait_method (|
                                                                      "core::cmp::PartialEq",
                                                                      F,
                                                                      [],
                                                                      [ F ],
                                                                      "eq",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        element
                                                                      |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        shift
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.read (|
                                                                  M.return_ (| Value.Bool true |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |) in
                                                  let~ _ :
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                    M.alloc (|
                                                      M.write (|
                                                        element,
                                                        M.call_closure (|
                                                          F,
                                                          M.get_trait_method (|
                                                            "p3_field::field::PrimeCharacteristicRing",
                                                            F,
                                                            [],
                                                            [],
                                                            "square",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.borrow (| Pointer.Kind.Ref, element |)
                                                          ]
                                                        |)
                                                      |)
                                                    |) in
                                                  let~ _ :
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                    M.alloc (|
                                                      M.write (|
                                                        shift,
                                                        M.call_closure (|
                                                          F,
                                                          M.get_trait_method (|
                                                            "p3_field::field::PrimeCharacteristicRing",
                                                            F,
                                                            [],
                                                            [],
                                                            "square",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.borrow (| Pointer.Kind.Ref, shift |) ]
                                                        |)
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                    |)))
                              ]
                            |)) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              F,
                              [],
                              [ F ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, element |);
                              M.borrow (| Pointer.Kind.Ref, shift |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_contains :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "contains" (contains F).
    Admitted.
    Global Typeclasses Opaque contains.
    
    (*
        pub fn element(&mut self, index: usize) -> F {
            self.shift * self.generator_exp(index)
        }
    *)
    Definition element (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            F,
            M.get_trait_method (| "core::ops::arith::Mul", F, [], [ F ], "mul", [], [] |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_field::coset::TwoAdicMultiplicativeCoset",
                  "shift"
                |)
              |);
              M.call_closure (|
                F,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ],
                  "generator_exp",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.read (| index |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_element :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "element" (element F).
    Admitted.
    Global Typeclasses Opaque element.
    
    (*
        fn generator_exp(&self, exp: usize) -> F {
            let mut gen_power = F::ONE;
            // As `generator` satisfies `generator^{self.size()} == 1` we can replace `exp` by `exp mod self.size()`.
            // As `self.size()` is a power of `2` this can be done with an `&` instead of a `%`.
            let mut exp = exp & (self.size() - 1);
            let mut i = self.log_size();
    
            while exp > 0 {
                if exp & 1 != 0 {
                    gen_power *= F::two_adic_generator(i);
                }
                exp >>= 1;
    
                i -= 1;
            }
    
            gen_power
        }
    *)
    Definition generator_exp (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            let~ gen_power : Ty.apply (Ty.path "*") [] [ F ] :=
              M.copy (| get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", F |) |) in
            let~ exp : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (| exp |);
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset")
                              []
                              [ F ],
                            "size",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |);
                        Value.Integer IntegerKind.Usize 1
                      ]
                    |)
                  ]
                |)
              |) in
            let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ],
                    "log_size",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.loop (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| exp |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.ne,
                                            [
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.bit_and,
                                                [
                                                  M.read (| exp |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 0
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_trait_method (|
                                            "core::ops::arith::MulAssign",
                                            F,
                                            [],
                                            [ F ],
                                            "mul_assign",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.MutRef, gen_power |);
                                            M.call_closure (|
                                              F,
                                              M.get_trait_method (|
                                                "p3_field::field::TwoAdicField",
                                                F,
                                                [],
                                                [],
                                                "two_adic_generator",
                                                [],
                                                []
                                              |),
                                              [ M.read (| i |) ]
                                            |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              let β := exp in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.shr,
                                  [ M.read (| β |); Value.Integer IntegerKind.I32 1 ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              let β := i in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |) in
            gen_power
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_generator_exp :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "generator_exp" (generator_exp F).
    Admitted.
    Global Typeclasses Opaque generator_exp.
    
    (*
        pub fn iter(&self) -> Take<Powers<F>> {
            self.subgroup_generator()
                .shifted_powers(self.shift)
                .take(1 << self.log_size)
        }
    *)
    Definition iter (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::iter::adapters::take::Take")
              []
              [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
              [],
              [],
              "take",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                M.get_trait_method (|
                  "p3_field::field::PrimeCharacteristicRing",
                  F,
                  [],
                  [],
                  "shifted_powers",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        F,
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ],
                          "subgroup_generator",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::coset::TwoAdicMultiplicativeCoset",
                      "shift"
                    |)
                  |)
                ]
              |);
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shl,
                [
                  Value.Integer IntegerKind.Usize 1;
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_field::coset::TwoAdicMultiplicativeCoset",
                      "log_size"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_iter :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "iter" (iter F).
    Admitted.
    Global Typeclasses Opaque iter.
  End Impl_p3_field_coset_TwoAdicMultiplicativeCoset_F.
  
  Module Impl_core_iter_traits_collect_IntoIterator_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ].
    
    (*     type Item = F; *)
    Definition _Item (F : Ty.t) : Ty.t := F.
    
    (*     type IntoIter = Take<Powers<F>>; *)
    Definition _IntoIter (F : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "core::iter::adapters::take::Take")
        []
        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ].
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            self.iter()
        }
    *)
    Definition into_iter (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::iter::adapters::take::Take")
              []
              [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "p3_field::coset::TwoAdicMultiplicativeCoset") [] [ F ],
              "iter",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item F));
          ("IntoIter", InstanceField.Ty (_IntoIter F));
          ("into_iter", InstanceField.Method (into_iter F))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_where_p3_field_field_TwoAdicField_F_for_p3_field_coset_TwoAdicMultiplicativeCoset_F.
End coset.
