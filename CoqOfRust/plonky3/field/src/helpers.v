(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module helpers.
  (*
  pub fn two_adic_subgroup_vanishing_polynomial<F: TwoAdicField>(log_n: usize, x: F) -> F {
      x.exp_power_of_2(log_n) - F::ONE
  }
  *)
  Definition two_adic_subgroup_vanishing_polynomial
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ log_n; x ] =>
      ltac:(M.monadic
        (let log_n := M.alloc (| log_n |) in
        let x := M.alloc (| x |) in
        M.call_closure (|
          F,
          M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
          [
            M.call_closure (|
              F,
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "exp_power_of_2",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, x |); M.read (| log_n |) ]
            |);
            M.read (| get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", F |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_two_adic_subgroup_vanishing_polynomial :
    M.IsFunction.C
      "p3_field::helpers::two_adic_subgroup_vanishing_polynomial"
      two_adic_subgroup_vanishing_polynomial.
  Admitted.
  Global Typeclasses Opaque two_adic_subgroup_vanishing_polynomial.
  
  (*
  pub fn two_adic_coset_vanishing_polynomial<F: TwoAdicField>(log_n: usize, shift: F, x: F) -> F {
      x.exp_power_of_2(log_n) - shift.exp_power_of_2(log_n)
  }
  *)
  Definition two_adic_coset_vanishing_polynomial
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ log_n; shift; x ] =>
      ltac:(M.monadic
        (let log_n := M.alloc (| log_n |) in
        let shift := M.alloc (| shift |) in
        let x := M.alloc (| x |) in
        M.call_closure (|
          F,
          M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
          [
            M.call_closure (|
              F,
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "exp_power_of_2",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, x |); M.read (| log_n |) ]
            |);
            M.call_closure (|
              F,
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "exp_power_of_2",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, shift |); M.read (| log_n |) ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_two_adic_coset_vanishing_polynomial :
    M.IsFunction.C
      "p3_field::helpers::two_adic_coset_vanishing_polynomial"
      two_adic_coset_vanishing_polynomial.
  Admitted.
  Global Typeclasses Opaque two_adic_coset_vanishing_polynomial.
  
  (*
  pub fn cyclic_subgroup_known_order<F: Field>(
      generator: F,
      order: usize,
  ) -> impl Iterator<Item = F> + Clone {
      generator.powers().take(order)
  }
  *)
  Definition cyclic_subgroup_known_order
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ generator; order ] =>
      ltac:(M.monadic
        (let generator := M.alloc (| generator |) in
        let order := M.alloc (| order |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            []
            [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
            [],
            [],
            "take",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "powers",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, generator |) ]
            |);
            M.read (| order |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cyclic_subgroup_known_order :
    M.IsFunction.C "p3_field::helpers::cyclic_subgroup_known_order" cyclic_subgroup_known_order.
  Admitted.
  Global Typeclasses Opaque cyclic_subgroup_known_order.
  
  (*
  pub fn cyclic_subgroup_coset_known_order<F: Field>(
      generator: F,
      shift: F,
      order: usize,
  ) -> impl Iterator<Item = F> + Clone {
      generator.shifted_powers(shift).take(order)
  }
  *)
  Definition cyclic_subgroup_coset_known_order
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ F ], [ generator; shift; order ] =>
      ltac:(M.monadic
        (let generator := M.alloc (| generator |) in
        let shift := M.alloc (| shift |) in
        let order := M.alloc (| order |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::iter::adapters::take::Take")
            []
            [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
            [],
            [],
            "take",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "shifted_powers",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, generator |); M.read (| shift |) ]
            |);
            M.read (| order |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cyclic_subgroup_coset_known_order :
    M.IsFunction.C
      "p3_field::helpers::cyclic_subgroup_coset_known_order"
      cyclic_subgroup_coset_known_order.
  Admitted.
  Global Typeclasses Opaque cyclic_subgroup_coset_known_order.
  
  (*
  pub fn scale_vec<F: Field>(s: F, vec: Vec<F>) -> Vec<F> {
      vec.into_iter().map(|x| s * x).collect()
  }
  *)
  Definition scale_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F ], [ s; vec ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        let vec := M.alloc (| vec |) in
        M.call_closure (|
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              []
              [
                Ty.apply
                  (Ty.path "alloc::vec::into_iter::IntoIter")
                  []
                  [ F; Ty.path "alloc::alloc::Global" ];
                Ty.function [ Ty.tuple [ F ] ] F
              ],
            [],
            [],
            "collect",
            [],
            [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::vec::into_iter::IntoIter")
                    []
                    [ F; Ty.path "alloc::alloc::Global" ];
                  Ty.function [ Ty.tuple [ F ] ] F
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "alloc::vec::into_iter::IntoIter")
                  []
                  [ F; Ty.path "alloc::alloc::Global" ],
                [],
                [],
                "map",
                [],
                [ F; Ty.function [ Ty.tuple [ F ] ] F ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::into_iter::IntoIter")
                    []
                    [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [ M.read (| vec |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.function [ Ty.tuple [ F ] ] F ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let x := M.copy (| γ |) in
                                  M.call_closure (|
                                    F,
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      F,
                                      [],
                                      [ F ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [ M.read (| s |); M.read (| x |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_scale_vec :
    M.IsFunction.C "p3_field::helpers::scale_vec" scale_vec.
  Admitted.
  Global Typeclasses Opaque scale_vec.
  
  (*
  pub fn scale_slice_in_place<F: Field>(s: F, slice: &mut [F]) {
      let (packed, sfx) = F::Packing::pack_slice_with_suffix_mut(slice);
      let packed_s: F::Packing = s.into();
      packed.par_iter_mut().for_each(|x| *x *= packed_s);
      sfx.iter_mut().for_each(|x| *x *= s);
  }
  *)
  Definition scale_slice_in_place (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F ], [ s; slice ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        let slice := M.alloc (| slice |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
            M.alloc (|
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ]
                      ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                  ],
                M.get_trait_method (|
                  "p3_field::packed::PackedValue",
                  Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing",
                  [],
                  [],
                  "pack_slice_with_suffix_mut",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let packed := M.copy (| γ0_0 |) in
                  let sfx := M.copy (| γ0_1 |) in
                  let~ packed_s :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing",
                        M.get_trait_method (|
                          "core::convert::Into",
                          F,
                          [],
                          [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::slice::iter::IterMut")
                            []
                            [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                          [],
                          [],
                          "for_each",
                          [],
                          [
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_field::field::Field"
                                          []
                                          []
                                          F
                                          "Packing"
                                      ]
                                  ]
                              ]
                              (Ty.tuple [])
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::slice::iter::IterMut")
                              []
                              [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing" ],
                            M.get_trait_method (|
                              "p3_maybe_rayon::serial::IntoParallelRefMutIterator",
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.associated_in_trait "p3_field::field::Field" [] [] F "Packing"
                                ],
                              [],
                              [],
                              "par_iter_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| packed |) |) |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.associated_in_trait
                                                        "p3_field::field::Field"
                                                        []
                                                        []
                                                        F
                                                        "Packing"
                                                    ]
                                                ]
                                            ]
                                            (Ty.tuple [])
                                        ],
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.tuple [],
                                              M.get_trait_method (|
                                                "core::ops::arith::MulAssign",
                                                Ty.associated_in_trait
                                                  "p3_field::field::Field"
                                                  []
                                                  []
                                                  F
                                                  "Packing",
                                                [],
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_field::field::Field"
                                                    []
                                                    []
                                                    F
                                                    "Packing"
                                                ],
                                                "mul_assign",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (| M.read (| x |) |)
                                                |);
                                                M.read (| packed_s |)
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                          [],
                          [],
                          "for_each",
                          [],
                          [
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ]
                              (Ty.tuple [])
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ F ],
                              "iter_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| sfx |) |) |) ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ] ] ]
                                            (Ty.tuple [])
                                        ],
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.tuple [],
                                              M.get_trait_method (|
                                                "core::ops::arith::MulAssign",
                                                F,
                                                [],
                                                [ F ],
                                                "mul_assign",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (| M.read (| x |) |)
                                                |);
                                                M.read (| s |)
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_scale_slice_in_place :
    M.IsFunction.C "p3_field::helpers::scale_slice_in_place" scale_slice_in_place.
  Admitted.
  Global Typeclasses Opaque scale_slice_in_place.
  
  (*
  pub fn add_scaled_slice_in_place<F, Y>(x: &mut [F], y: Y, s: F)
  where
      F: Field,
      Y: Iterator<Item = F>,
  {
      // TODO: Use PackedField
      x.iter_mut().zip(y).for_each(|(x_i, y_i)| *x_i += y_i * s);
  }
  *)
  Definition add_scaled_slice_in_place (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; Y ], [ x; y; s ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        let y := M.alloc (| y |) in
        let s := M.alloc (| s |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ]; Y ],
                  [],
                  [],
                  "for_each",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ] ]
                      (Ty.tuple [])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ]; Y ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                      [],
                      [],
                      "zip",
                      [],
                      [ Y ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ F ],
                          "iter_mut",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| x |) |) |) ]
                      |);
                      M.read (| y |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ F ]; F ] ]
                                    ]
                                    (Ty.tuple [])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let x_i := M.copy (| γ0_0 |) in
                                    let y_i := M.copy (| γ0_1 |) in
                                    M.call_closure (|
                                      Ty.tuple [],
                                      M.get_trait_method (|
                                        "core::ops::arith::AddAssign",
                                        F,
                                        [],
                                        [ F ],
                                        "add_assign",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| x_i |) |)
                                        |);
                                        M.call_closure (|
                                          F,
                                          M.get_trait_method (|
                                            "core::ops::arith::Mul",
                                            F,
                                            [],
                                            [ F ],
                                            "mul",
                                            [],
                                            []
                                          |),
                                          [ M.read (| y_i |); M.read (| s |) ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_add_scaled_slice_in_place :
    M.IsFunction.C "p3_field::helpers::add_scaled_slice_in_place" add_scaled_slice_in_place.
  Admitted.
  Global Typeclasses Opaque add_scaled_slice_in_place.
  
  (*
  pub const fn field_to_array<R: PrimeCharacteristicRing, const D: usize>(x: R) -> [R; D] {
      let mut arr: [_; D] = [const { MaybeUninit::uninit() }; D];
      arr[0] = MaybeUninit::new(x);
      let mut i = 1;
      while i < D {
          arr[i] = MaybeUninit::new(R::ZERO);
          i += 1;
      }
      unsafe { core::mem::transmute_copy::<_, [R; D]>(&arr) }
  }
  *)
  Definition field_to_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ D ], [ R ], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        M.read (|
          let~ arr :
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "array")
                    [ D ]
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ] ]
                ] :=
            M.alloc (|
              repeat (|
                M.read (|
                  get_constant (|
                    "p3_field::helpers::field_to_array_discriminant",
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ]
                  |)
                |),
                D
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| arr, Value.Integer IntegerKind.Usize 0 |),
                M.call_closure (|
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| x |) ]
                |)
              |)
            |) in
          let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (| Value.Integer IntegerKind.Usize 1 |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.loop (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              ltac:(M.monadic
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (| Ty.path "bool", BinOp.lt, [ M.read (| i |); D ] |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_array_field (| arr, M.read (| i |) |),
                              M.call_closure (|
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ R ],
                                  "new",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    get_constant (|
                                      "p3_field::field::PrimeCharacteristicRing::ZERO",
                                      R
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            let β := i in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                              |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                              M.alloc (| Value.Tuple [] |)
                            |)
                          |)
                        |)))
                  ]
                |)))
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "array") [ D ] [ R ],
              M.get_function (|
                "core::mem::transmute_copy",
                [],
                [
                  Ty.apply
                    (Ty.path "array")
                    [ D ]
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ R ] ];
                  Ty.apply (Ty.path "array") [ D ] [ R ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, arr |) |) |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_field_to_array :
    M.IsFunction.C "p3_field::helpers::field_to_array" field_to_array.
  Admitted.
  Global Typeclasses Opaque field_to_array.
  
  (*
  pub const fn halve_u32<const P: u32>(x: u32) -> u32 {
      let shift = (P + 1) >> 1;
      let half = x >> 1;
      if x & 1 == 0 { half } else { half + shift }
  }
  *)
  Definition halve_u32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ P ], [], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        M.read (|
          let~ shift : Ty.apply (Ty.path "*") [] [ Ty.path "u32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "u32",
                BinOp.Wrap.shr,
                [
                  M.call_closure (|
                    Ty.path "u32",
                    BinOp.Wrap.add,
                    [ P; Value.Integer IntegerKind.U32 1 ]
                  |);
                  Value.Integer IntegerKind.I32 1
                ]
              |)
            |) in
          let~ half : Ty.apply (Ty.path "*") [] [ Ty.path "u32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "u32",
                BinOp.Wrap.shr,
                [ M.read (| x |); Value.Integer IntegerKind.I32 1 ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "u32",
                              BinOp.Wrap.bit_and,
                              [ M.read (| x |); Value.Integer IntegerKind.U32 1 ]
                            |);
                            Value.Integer IntegerKind.U32 0
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  half));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.add,
                      [ M.read (| half |); M.read (| shift |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_halve_u32 :
    M.IsFunction.C "p3_field::helpers::halve_u32" halve_u32.
  Admitted.
  Global Typeclasses Opaque halve_u32.
  
  (*
  pub const fn halve_u64<const P: u64>(x: u64) -> u64 {
      let shift = (P + 1) >> 1;
      let half = x >> 1;
      if x & 1 == 0 { half } else { half + shift }
  }
  *)
  Definition halve_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ P ], [], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        M.read (|
          let~ shift : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.shr,
                [
                  M.call_closure (|
                    Ty.path "u64",
                    BinOp.Wrap.add,
                    [ P; Value.Integer IntegerKind.U64 1 ]
                  |);
                  Value.Integer IntegerKind.I32 1
                ]
              |)
            |) in
          let~ half : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.shr,
                [ M.read (| x |); Value.Integer IntegerKind.I32 1 ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.bit_and,
                              [ M.read (| x |); Value.Integer IntegerKind.U64 1 ]
                            |);
                            Value.Integer IntegerKind.U64 0
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  half));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.add,
                      [ M.read (| half |); M.read (| shift |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_halve_u64 :
    M.IsFunction.C "p3_field::helpers::halve_u64" halve_u64.
  Admitted.
  Global Typeclasses Opaque halve_u64.
  
  (*
  pub fn reduce_32<SF: PrimeField32, TF: PrimeField>(vals: &[SF]) -> TF {
      // If the characteristic of TF is > 2^64, from_int and from_canonical_unchecked act identically
      let base = TF::from_int(1u64 << 32);
      vals.iter().rev().fold(TF::ZERO, |acc, val| {
          acc * base + TF::from_int(val.as_canonical_u32())
      })
  }
  *)
  Definition reduce_32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ SF; TF ], [ vals ] =>
      ltac:(M.monadic
        (let vals := M.alloc (| vals |) in
        M.read (|
          let~ base : Ty.apply (Ty.path "*") [] [ TF ] :=
            M.alloc (|
              M.call_closure (|
                TF,
                M.get_trait_method (|
                  "p3_field::integers::QuotientMap",
                  TF,
                  [],
                  [ Ty.path "u64" ],
                  "from_int",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.path "u64",
                    BinOp.Wrap.shl,
                    [ Value.Integer IntegerKind.U64 1; Value.Integer IntegerKind.I32 32 ]
                  |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              TF,
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::rev::Rev")
                  []
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ] ],
                [],
                [],
                "fold",
                [],
                [ TF; Ty.function [ Ty.tuple [ TF; Ty.apply (Ty.path "&") [] [ SF ] ] ] TF ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::rev::Rev")
                    []
                    [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ] ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ],
                    [],
                    [],
                    "rev",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ SF ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ SF ],
                        "iter",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| vals |) |) |) ]
                    |)
                  ]
                |);
                M.read (|
                  get_constant (| "p3_field::field::PrimeCharacteristicRing::ZERO", TF |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "*")
                              []
                              [ Ty.function [ Ty.tuple [ TF; Ty.apply (Ty.path "&") [] [ SF ] ] ] TF
                              ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc := M.copy (| γ |) in
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.function
                                          [ Ty.tuple [ TF; Ty.apply (Ty.path "&") [] [ SF ] ] ]
                                          TF
                                      ],
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let val := M.copy (| γ |) in
                                          M.call_closure (|
                                            TF,
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              TF,
                                              [],
                                              [ TF ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                TF,
                                                M.get_trait_method (|
                                                  "core::ops::arith::Mul",
                                                  TF,
                                                  [],
                                                  [ TF ],
                                                  "mul",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| acc |); M.read (| base |) ]
                                              |);
                                              M.call_closure (|
                                                TF,
                                                M.get_trait_method (|
                                                  "p3_field::integers::QuotientMap",
                                                  TF,
                                                  [],
                                                  [ Ty.path "u32" ],
                                                  "from_int",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.path "u32",
                                                    M.get_trait_method (|
                                                      "p3_field::field::PrimeField32",
                                                      SF,
                                                      [],
                                                      [],
                                                      "as_canonical_u32",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| val |) |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_reduce_32 :
    M.IsFunction.C "p3_field::helpers::reduce_32" reduce_32.
  Admitted.
  Global Typeclasses Opaque reduce_32.
  
  (*
  pub fn split_32<SF: PrimeField, TF: PrimeField32>(val: SF, n: usize) -> Vec<TF> {
      let mut result: Vec<TF> = val
          .as_canonical_biguint()
          .to_u64_digits()
          .iter()
          .take(n)
          .map(|d| TF::from_u64( *d))
          .collect();
  
      // Pad with zeros if needed
      result.resize_with(n, || TF::ZERO);
      result
  }
  *)
  Definition split_32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ SF; TF ], [ val; n ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        let n := M.alloc (| n |) in
        M.read (|
          let~ result :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ];
                      Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ] TF
                    ],
                  [],
                  [],
                  "collect",
                  [],
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ] ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::take::Take")
                          []
                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ];
                        Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ] TF
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ],
                      [],
                      [],
                      "map",
                      [],
                      [
                        TF;
                        Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ] TF
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::take::Take")
                          []
                          [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                          [],
                          [],
                          "take",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "iter",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ Ty.path "u64"; Ty.path "alloc::alloc::Global" ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ Ty.path "u64"; Ty.path "alloc::alloc::Global" ],
                                            M.get_associated_function (|
                                              Ty.path "num_bigint::biguint::BigUint",
                                              "to_u64_digits",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "num_bigint::biguint::BigUint",
                                                    M.get_trait_method (|
                                                      "p3_field::field::PrimeField",
                                                      SF,
                                                      [],
                                                      [],
                                                      "as_canonical_biguint",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, val |) ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |);
                          M.read (| n |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ]
                                        TF
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let d := M.copy (| γ |) in
                                        M.call_closure (|
                                          TF,
                                          M.get_trait_method (|
                                            "p3_field::field::PrimeCharacteristicRing",
                                            TF,
                                            [],
                                            [],
                                            "from_u64",
                                            [],
                                            []
                                          |),
                                          [ M.read (| M.deref (| M.read (| d |) |) |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ TF; Ty.path "alloc::alloc::Global" ],
                  "resize_with",
                  [],
                  [ Ty.function [ Ty.tuple [] ] TF ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, result |);
                  M.read (| n |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.function [ Ty.tuple [] ] TF ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.read (|
                                      get_constant (|
                                        "p3_field::field::PrimeCharacteristicRing::ZERO",
                                        TF
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |) in
          result
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_split_32 :
    M.IsFunction.C "p3_field::helpers::split_32" split_32.
  Admitted.
  Global Typeclasses Opaque split_32.
  
  (*
  pub fn dot_product<S, LI, RI>(li: LI, ri: RI) -> S
  where
      LI: Iterator,
      RI: Iterator,
      LI::Item: Mul<RI::Item>,
      S: Sum<<LI::Item as Mul<RI::Item>>::Output>,
  {
      li.zip(ri).map(|(l, r)| l * r).sum()
  }
  *)
  Definition dot_product (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ _ as S; LI; RI ], [ li; ri ] =>
      ltac:(M.monadic
        (let li := M.alloc (| li |) in
        let ri := M.alloc (| ri |) in
        M.call_closure (|
          S,
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              []
              [
                Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.associated_in_trait
                              "core::iter::traits::iterator::Iterator"
                              []
                              []
                              LI
                              "Item";
                            Ty.associated_in_trait
                              "core::iter::traits::iterator::Iterator"
                              []
                              []
                              RI
                              "Item"
                          ]
                      ]
                  ]
                  (Ty.associated_in_trait
                    "core::ops::arith::Mul"
                    []
                    [
                      Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        RI
                        "Item"
                    ]
                    (Ty.associated_in_trait
                      "core::iter::traits::iterator::Iterator"
                      []
                      []
                      LI
                      "Item")
                    "Output")
              ],
            [],
            [],
            "sum",
            [],
            [ S ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.tuple
                            [
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                LI
                                "Item";
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                RI
                                "Item"
                            ]
                        ]
                    ]
                    (Ty.associated_in_trait
                      "core::ops::arith::Mul"
                      []
                      [
                        Ty.associated_in_trait
                          "core::iter::traits::iterator::Iterator"
                          []
                          []
                          RI
                          "Item"
                      ]
                      (Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        LI
                        "Item")
                      "Output")
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ],
                [],
                [],
                "map",
                [],
                [
                  Ty.associated_in_trait
                    "core::ops::arith::Mul"
                    []
                    [
                      Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        RI
                        "Item"
                    ]
                    (Ty.associated_in_trait
                      "core::iter::traits::iterator::Iterator"
                      []
                      []
                      LI
                      "Item")
                    "Output";
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.tuple
                            [
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                LI
                                "Item";
                              Ty.associated_in_trait
                                "core::iter::traits::iterator::Iterator"
                                []
                                []
                                RI
                                "Item"
                            ]
                        ]
                    ]
                    (Ty.associated_in_trait
                      "core::ops::arith::Mul"
                      []
                      [
                        Ty.associated_in_trait
                          "core::iter::traits::iterator::Iterator"
                          []
                          []
                          RI
                          "Item"
                      ]
                      (Ty.associated_in_trait
                        "core::iter::traits::iterator::Iterator"
                        []
                        []
                        LI
                        "Item")
                      "Output")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::iter::adapters::zip::Zip") [] [ LI; RI ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    LI,
                    [],
                    [],
                    "zip",
                    [],
                    [ RI ]
                  |),
                  [ M.read (| li |); M.read (| ri |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.associated_in_trait
                                              "core::iter::traits::iterator::Iterator"
                                              []
                                              []
                                              LI
                                              "Item";
                                            Ty.associated_in_trait
                                              "core::iter::traits::iterator::Iterator"
                                              []
                                              []
                                              RI
                                              "Item"
                                          ]
                                      ]
                                  ]
                                  (Ty.associated_in_trait
                                    "core::ops::arith::Mul"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "core::iter::traits::iterator::Iterator"
                                        []
                                        []
                                        RI
                                        "Item"
                                    ]
                                    (Ty.associated_in_trait
                                      "core::iter::traits::iterator::Iterator"
                                      []
                                      []
                                      LI
                                      "Item")
                                    "Output")
                              ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let l := M.copy (| γ0_0 |) in
                                  let r := M.copy (| γ0_1 |) in
                                  M.call_closure (|
                                    Ty.associated_in_trait
                                      "core::ops::arith::Mul"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "core::iter::traits::iterator::Iterator"
                                          []
                                          []
                                          RI
                                          "Item"
                                      ]
                                      (Ty.associated_in_trait
                                        "core::iter::traits::iterator::Iterator"
                                        []
                                        []
                                        LI
                                        "Item")
                                      "Output",
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      Ty.associated_in_trait
                                        "core::iter::traits::iterator::Iterator"
                                        []
                                        []
                                        LI
                                        "Item",
                                      [],
                                      [
                                        Ty.associated_in_trait
                                          "core::iter::traits::iterator::Iterator"
                                          []
                                          []
                                          RI
                                          "Item"
                                      ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [ M.read (| l |); M.read (| r |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_dot_product :
    M.IsFunction.C "p3_field::helpers::dot_product" dot_product.
  Admitted.
  Global Typeclasses Opaque dot_product.
End helpers.
