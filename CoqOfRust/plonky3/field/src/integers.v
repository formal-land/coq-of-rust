(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module Impl_p3_field_integers_QuotientMap_u8_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u8" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u8>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u8" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u8>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "u128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "u128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u8" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<u8>() < size_of::<u128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "u8" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_u8_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_u16_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u16" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u16>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u16" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u16>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "u128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "u128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u16" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<u16>() < size_of::<u128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "u16" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_u16_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_u32_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u32" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u32>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u32" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u32>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "u128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "u128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u32" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<u32>() < size_of::<u128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "u32" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_u32_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_u64_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u64" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u64>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u64" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "u128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<u64>() < size_of::<u128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "u128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "u128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u64" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "u128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<u64>() < size_of::<u128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "u128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "u64" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_u64_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_i8_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i8" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i8>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i8" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i8>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "i128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "i128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i8" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<i8>() < size_of::<i128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "i8" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_i8_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_i16_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i16" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i16>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i16" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i16>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "i128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "i128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i16" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<i16>() < size_of::<i128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "i16" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_i16_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_i32_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i32" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i32>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i32" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i32>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "i128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "i128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i32" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<i32>() < size_of::<i128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "i32" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_i32_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_i64_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
          fn from_int(int: $small_int) -> Self {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i64" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i64>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          fn from_canonical_checked(int: $small_int) -> Option<Self> {
              // Should be removed by the compiler.
              assert!(size_of::<$small_int>() < size_of::<$field_size>());
              Some(unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              })
          }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i64" ] |),
                                  []
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_function (| "core::mem::size_of", [], [ Ty.path "i128" ] |),
                                  []
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic", [], [] |),
                          [ mk_str (| "assertion failed: size_of::<i64>() < size_of::<i128>()" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "p3_bn254_fr::Bn254Fr",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_bn254_fr::Bn254Fr",
                    [],
                    [ Ty.path "i128" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [ M.cast (Ty.path "i128") (M.read (| int |)) ]
                |)
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
          unsafe fn from_canonical_unchecked(int: $small_int) -> Self {
              // We use debug_assert to ensure this is removed by the compiler in release mode.
              debug_assert!(size_of::<$small_int>() < size_of::<$field_size>());
              unsafe {
                  Self::from_canonical_unchecked(int as $field_size)
              }
          }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i64" ]
                                            |),
                                            []
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::size_of",
                                              [],
                                              [ Ty.path "i128" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "assertion failed: size_of::<i64>() < size_of::<i128>()"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_canonical_unchecked",
                [],
                []
              |),
              [ M.cast (Ty.path "i128") (M.read (| int |)) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "i64" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_i64_for_p3_bn254_fr_Bn254Fr.
