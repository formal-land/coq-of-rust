(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module config.
  (* StructRecord
    {
      name := "FriConfig";
      const_params := [];
      ty_params := [ "M_" ];
      fields :=
        [
          ("log_blowup", Ty.path "usize");
          ("log_final_poly_len", Ty.path "usize");
          ("num_queries", Ty.path "usize");
          ("proof_of_work_bits", Ty.path "usize");
          ("mmcs", M_)
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_M__for_p3_fri_config_FriConfig_M_.
    Definition Self (M_ : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_fri::config::FriConfig") [] [ M_ ].
    
    (* Debug *)
    Definition fmt (M_ : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self M_ in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field5_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FriConfig" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "log_blowup" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_fri::config::FriConfig",
                        "log_blowup"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "log_final_poly_len" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_fri::config::FriConfig",
                        "log_final_poly_len"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "num_queries" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_fri::config::FriConfig",
                        "num_queries"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "proof_of_work_bits" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_fri::config::FriConfig",
                        "proof_of_work_bits"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "mmcs" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_fri::config::FriConfig",
                            "mmcs"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (M_ : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self M_)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt M_)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_M__for_p3_fri_config_FriConfig_M_.
  
  Module Impl_p3_fri_config_FriConfig_M_.
    Definition Self (M_ : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_fri::config::FriConfig") [] [ M_ ].
    
    (*
        pub const fn blowup(&self) -> usize {
            1 << self.log_blowup
        }
    *)
    Definition blowup (M_ : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self M_ in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.shl,
            [
              Value.Integer IntegerKind.Usize 1;
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_fri::config::FriConfig",
                  "log_blowup"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_blowup :
      forall (M_ : Ty.t),
      M.IsAssociatedFunction.C (Self M_) "blowup" (blowup M_).
    Admitted.
    Global Typeclasses Opaque blowup.
    
    (*
        pub const fn final_poly_len(&self) -> usize {
            1 << self.log_final_poly_len
        }
    *)
    Definition final_poly_len
        (M_ : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self M_ in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.shl,
            [
              Value.Integer IntegerKind.Usize 1;
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_fri::config::FriConfig",
                  "log_final_poly_len"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_final_poly_len :
      forall (M_ : Ty.t),
      M.IsAssociatedFunction.C (Self M_) "final_poly_len" (final_poly_len M_).
    Admitted.
    Global Typeclasses Opaque final_poly_len.
    
    (*
        pub const fn conjectured_soundness_bits(&self) -> usize {
            self.log_blowup * self.num_queries + self.proof_of_work_bits
        }
    *)
    Definition conjectured_soundness_bits
        (M_ : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self M_ in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.add,
            [
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.mul,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_fri::config::FriConfig",
                      "log_blowup"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_fri::config::FriConfig",
                      "num_queries"
                    |)
                  |)
                ]
              |);
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_fri::config::FriConfig",
                  "proof_of_work_bits"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_conjectured_soundness_bits :
      forall (M_ : Ty.t),
      M.IsAssociatedFunction.C
        (Self M_)
        "conjectured_soundness_bits"
        (conjectured_soundness_bits M_).
    Admitted.
    Global Typeclasses Opaque conjectured_soundness_bits.
  End Impl_p3_fri_config_FriConfig_M_.
  
  (* Trait *)
  (* Empty module 'FriGenericConfig' *)
  
  (*
  pub const fn create_test_fri_config<Mmcs>(
      mmcs: Mmcs,
      log_final_poly_len: usize,
  ) -> FriConfig<Mmcs> {
      FriConfig {
          log_blowup: 2,
          log_final_poly_len,
          num_queries: 2,
          proof_of_work_bits: 1,
          mmcs,
      }
  }
  *)
  Definition create_test_fri_config (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ Mmcs ], [ mmcs; log_final_poly_len ] =>
      ltac:(M.monadic
        (let mmcs := M.alloc (| mmcs |) in
        let log_final_poly_len := M.alloc (| log_final_poly_len |) in
        Value.StructRecord
          "p3_fri::config::FriConfig"
          [
            ("log_blowup", Value.Integer IntegerKind.Usize 2);
            ("log_final_poly_len", M.read (| log_final_poly_len |));
            ("num_queries", Value.Integer IntegerKind.Usize 2);
            ("proof_of_work_bits", Value.Integer IntegerKind.Usize 1);
            ("mmcs", M.read (| mmcs |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_create_test_fri_config :
    M.IsFunction.C "p3_fri::config::create_test_fri_config" create_test_fri_config.
  Admitted.
  Global Typeclasses Opaque create_test_fri_config.
  
  (*
  pub const fn create_benchmark_fri_config<Mmcs>(mmcs: Mmcs) -> FriConfig<Mmcs> {
      FriConfig {
          log_blowup: 1,
          log_final_poly_len: 0,
          num_queries: 100,
          proof_of_work_bits: 16,
          mmcs,
      }
  }
  *)
  Definition create_benchmark_fri_config
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ Mmcs ], [ mmcs ] =>
      ltac:(M.monadic
        (let mmcs := M.alloc (| mmcs |) in
        Value.StructRecord
          "p3_fri::config::FriConfig"
          [
            ("log_blowup", Value.Integer IntegerKind.Usize 1);
            ("log_final_poly_len", Value.Integer IntegerKind.Usize 0);
            ("num_queries", Value.Integer IntegerKind.Usize 100);
            ("proof_of_work_bits", Value.Integer IntegerKind.Usize 16);
            ("mmcs", M.read (| mmcs |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_create_benchmark_fri_config :
    M.IsFunction.C "p3_fri::config::create_benchmark_fri_config" create_benchmark_fri_config.
  Admitted.
  Global Typeclasses Opaque create_benchmark_fri_config.
End config.
