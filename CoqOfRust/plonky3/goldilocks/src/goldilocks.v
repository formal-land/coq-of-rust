(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module goldilocks.
  Definition value_P (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U64 18446744069414584321 |))).
  
  Global Instance Instance_IsConstant_value_P :
    M.IsFunction.C "p3_goldilocks::goldilocks::P" value_P.
  Admitted.
  Global Typeclasses Opaque value_P.
  
  (* StructRecord
    {
      name := "Goldilocks";
      const_params := [];
      ty_params := [];
      fields := [ ("value", Ty.path "u64") ];
    } *)
  
  Module Impl_core_marker_Copy_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_clone_Clone_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_default_Default_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "p3_goldilocks::goldilocks::Goldilocks"
            [
              ("value",
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_p3_goldilocks_goldilocks_Goldilocks.
      Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
      
      (* Serialize *)
      Definition serialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ __serde_state :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.associated_in_trait
                            "serde::ser::Serializer"
                            []
                            []
                            __S
                            "SerializeStruct"
                        ] :=
                    M.copy (|
                      M.match_operator (|
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.associated_in_trait
                              "serde::ser::Serializer"
                              []
                              []
                              __S
                              "SerializeStruct"
                          ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "SerializeStruct";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  [],
                                  "serialize_struct",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  mk_str (| "Goldilocks" |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.cast (Ty.path "usize") (Value.Bool false);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Ok";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.associated_in_trait
                                                  "serde::ser::Serializer"
                                                  []
                                                  []
                                                  __S
                                                  "Error"
                                              ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.tuple [];
                                Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              M.get_trait_method (|
                                "serde::ser::SerializeStruct",
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct",
                                [],
                                [],
                                "serialize_field",
                                [],
                                [ Ty.path "u64" ]
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                |);
                                mk_str (| "value" |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "p3_goldilocks::goldilocks::Goldilocks",
                                        "value"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                        ],
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct",
                        [],
                        [],
                        "end",
                        [],
                        []
                      |),
                      [ M.read (| __serde_state |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_p3_goldilocks_goldilocks_Goldilocks.
    Module Impl_serde_de_Deserialize_for_p3_goldilocks_goldilocks_Goldilocks.
      Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
      
      (* Deserialize *)
      Definition deserialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "p3_goldilocks::goldilocks::Goldilocks";
                  Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                ],
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                [],
                "deserialize_struct",
                [],
                [ Ty.path "p3_goldilocks::goldilocks::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                mk_str (| "Goldilocks" |);
                M.read (|
                  get_constant (|
                    "p3_goldilocks::goldilocks::_'1::deserialize::FIELDS",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                      ]
                  |)
                |);
                Value.StructRecord
                  "p3_goldilocks::goldilocks::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_p3_goldilocks_goldilocks_Goldilocks.
  End underscore.
  
  
  Module Impl_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        pub(crate) const fn new(value: u64) -> Self {
            Self { value }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructRecord
            "p3_goldilocks::goldilocks::Goldilocks"
            [ ("value", M.read (| value |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub(crate) const fn new_array<const N: usize>(input: [u64; N]) -> [Self; N] {
            let mut output = [Self::ZERO; N];
            let mut i = 0;
            while i < N {
                output[i].value = input[i];
                i += 1;
            }
            output
        }
    *)
    Definition new_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ N ], [], [ input ] =>
        ltac:(M.monadic
          (let input := M.alloc (| input |) in
          M.read (|
            let~ output :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ N ]
                      [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
                  ] :=
              M.alloc (|
                repeat (|
                  M.read (|
                    get_constant (|
                      "p3_field::field::PrimeCharacteristicRing::ZERO",
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks"
                    |)
                  |),
                  N
                |)
              |) in
            let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.loop (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (| Ty.path "bool", BinOp.lt, [ M.read (| i |); N ] |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.SubPointer.get_array_field (| output, M.read (| i |) |),
                                  "p3_goldilocks::goldilocks::Goldilocks",
                                  "value"
                                |),
                                M.read (|
                                  M.SubPointer.get_array_field (| input, M.read (| i |) |)
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              let β := i in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |) in
            output
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_array :
      M.IsAssociatedFunction.C Self "new_array" new_array.
    Admitted.
    Global Typeclasses Opaque new_array.
    
    (*     const NEG_ORDER: u64 = Self::ORDER_U64.wrapping_neg(); *)
    (* Ty.path "u64" *)
    Definition value_NEG_ORDER (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "u64",
            M.get_associated_function (| Ty.path "u64", "wrapping_neg", [], [] |),
            [
              M.read (|
                get_constant (| "p3_field::field::PrimeField64::ORDER_U64", Ty.path "u64" |)
              |)
            ]
          |)
        |))).
    
    Global Instance AssociatedConstant_value_NEG_ORDER :
      M.IsAssociatedFunction.C Self "NEG_ORDER" value_NEG_ORDER.
    Admitted.
    Global Typeclasses Opaque value_NEG_ORDER.
    
    (*
        pub const TWO_ADIC_GENERATORS: [Goldilocks; 33] = Goldilocks::new_array([
            0x0000000000000001,
            0xffffffff00000000,
            0x0001000000000000,
            0xfffffffeff000001,
            0xefffffff00000001,
            0x00003fffffffc000,
            0x0000008000000000,
            0xf80007ff08000001,
            0xbf79143ce60ca966,
            0x1905d02a5c411f4e,
            0x9d8f2ad78bfed972,
            0x0653b4801da1c8cf,
            0xf2c35199959dfcb6,
            0x1544ef2335d17997,
            0xe0ee099310bba1e2,
            0xf6b2cffe2306baac,
            0x54df9630bf79450e,
            0xabd0a6e8aa3d8a0e,
            0x81281a7b05f9beac,
            0xfbd41c6b8caa3302,
            0x30ba2ecd5e93e76d,
            0xf502aef532322654,
            0x4b2a18ade67246b5,
            0xea9d5a1336fbc98b,
            0x86cdcc31c307e171,
            0x4bbaf5976ecfefd8,
            0xed41d05b78d6e286,
            0x10d78dd8915a171d,
            0x59049500004a4485,
            0xdfa8c93ba46d2666,
            0x7e9bd009b86a0845,
            0x400a7f755588e659,
            0x185629dcda58878c,
        ]);
    *)
    (* Ty.apply
      (Ty.path "array")
      [ Value.Integer IntegerKind.Usize 33 ]
      [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] *)
    Definition value_TWO_ADIC_GENERATORS
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 33 ]
              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new_array",
              [ Value.Integer IntegerKind.Usize 33 ],
              []
            |),
            [
              Value.Array
                [
                  Value.Integer IntegerKind.U64 1;
                  Value.Integer IntegerKind.U64 18446744069414584320;
                  Value.Integer IntegerKind.U64 281474976710656;
                  Value.Integer IntegerKind.U64 18446744069397807105;
                  Value.Integer IntegerKind.U64 17293822564807737345;
                  Value.Integer IntegerKind.U64 70368744161280;
                  Value.Integer IntegerKind.U64 549755813888;
                  Value.Integer IntegerKind.U64 17870292113338400769;
                  Value.Integer IntegerKind.U64 13797081185216407910;
                  Value.Integer IntegerKind.U64 1803076106186727246;
                  Value.Integer IntegerKind.U64 11353340290879379826;
                  Value.Integer IntegerKind.U64 455906449640507599;
                  Value.Integer IntegerKind.U64 17492915097719143606;
                  Value.Integer IntegerKind.U64 1532612707718625687;
                  Value.Integer IntegerKind.U64 16207902636198568418;
                  Value.Integer IntegerKind.U64 17776499369601055404;
                  Value.Integer IntegerKind.U64 6115771955107415310;
                  Value.Integer IntegerKind.U64 12380578893860276750;
                  Value.Integer IntegerKind.U64 9306717745644682924;
                  Value.Integer IntegerKind.U64 18146160046829613826;
                  Value.Integer IntegerKind.U64 3511170319078647661;
                  Value.Integer IntegerKind.U64 17654865857378133588;
                  Value.Integer IntegerKind.U64 5416168637041100469;
                  Value.Integer IntegerKind.U64 16905767614792059275;
                  Value.Integer IntegerKind.U64 9713644485405565297;
                  Value.Integer IntegerKind.U64 5456943929260765144;
                  Value.Integer IntegerKind.U64 17096174751763063430;
                  Value.Integer IntegerKind.U64 1213594585890690845;
                  Value.Integer IntegerKind.U64 6414415596519834757;
                  Value.Integer IntegerKind.U64 16116352524544190054;
                  Value.Integer IntegerKind.U64 9123114210336311365;
                  Value.Integer IntegerKind.U64 4614640910117430873;
                  Value.Integer IntegerKind.U64 1753635133440165772
                ]
            ]
          |)
        |))).
    
    Global Instance AssociatedConstant_value_TWO_ADIC_GENERATORS :
      M.IsAssociatedFunction.C Self "TWO_ADIC_GENERATORS" value_TWO_ADIC_GENERATORS.
    Admitted.
    Global Typeclasses Opaque value_TWO_ADIC_GENERATORS.
  End Impl_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_cmp_PartialEq_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn eq(&self, other: &Self) -> bool {
            self.as_canonical_u64() == other.as_canonical_u64()
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "p3_field::field::PrimeField64",
                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                  [],
                  [],
                  "as_canonical_u64",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "p3_field::field::PrimeField64",
                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                  [],
                  [],
                  "as_canonical_u64",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_cmp_Eq_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_cmp_Eq_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_packed_Packable_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::packed::Packable"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_field_packed_Packable_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_hash_Hash_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            state.write_u64(self.as_canonical_u64());
        }
    *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u64", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_trait_method (|
                        "p3_field::field::PrimeField64",
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        [],
                        [],
                        "as_canonical_u64",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_cmp_Ord_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn cmp(&self, other: &Self) -> core::cmp::Ordering {
            self.as_canonical_u64().cmp(&other.as_canonical_u64())
        }
    *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u64", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_trait_method (|
                      "p3_field::field::PrimeField64",
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      [],
                      [],
                      "as_canonical_u64",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_trait_method (|
                          "p3_field::field::PrimeField64",
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          [],
                          [],
                          "as_canonical_u64",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_cmp_PartialOrd_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
            Some(self.cmp(other))
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          Value.StructTuple
            "core::option::Option::Some"
            [
              M.call_closure (|
                Ty.path "core::cmp::Ordering",
                M.get_trait_method (|
                  "core::cmp::Ord",
                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                  [],
                  [],
                  "cmp",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_fmt_Display_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
            Display::fmt(&self.value, f)
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Display", Ty.path "u64", [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_goldilocks::goldilocks::Goldilocks",
                      "value"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_fmt_Debug_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
            Debug::fmt(&self.value, f)
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Debug", Ty.path "u64", [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_goldilocks::goldilocks::Goldilocks",
                      "value"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_rand_distr_distribution_Distribution_p3_goldilocks_goldilocks_Goldilocks_for_rand_distr_StandardUniform.
    Definition Self : Ty.t := Ty.path "rand::distr::StandardUniform".
    
    (*
        fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Goldilocks {
            loop {
                let next_u64 = rng.next_u64();
                let is_canonical = next_u64 < Goldilocks::ORDER_U64;
                if is_canonical {
                    return Goldilocks::new(next_u64);
                }
            }
        }
    *)
    Definition sample (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ R ], [ self; rng ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rng := M.alloc (| rng |) in
          M.catch_return (Ty.path "p3_goldilocks::goldilocks::Goldilocks") (|
            ltac:(M.monadic
              (M.never_to_any (|
                M.read (|
                  M.loop (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "never" ],
                    ltac:(M.monadic
                      (let~ next_u64 : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "u64",
                            M.get_trait_method (|
                              "rand_core::RngCore",
                              R,
                              [],
                              [],
                              "next_u64",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rng |) |) |) ]
                          |)
                        |) in
                      let~ is_canonical : Ty.apply (Ty.path "*") [] [ Ty.path "bool" ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.lt,
                            [
                              M.read (| next_u64 |);
                              M.read (|
                                get_constant (|
                                  "p3_field::field::PrimeField64::ORDER_U64",
                                  Ty.path "u64"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use is_canonical in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                        M.get_associated_function (|
                                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.read (| next_u64 |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "rand::distr::distribution::Distribution"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("sample", InstanceField.Method sample) ].
  End Impl_rand_distr_distribution_Distribution_p3_goldilocks_goldilocks_Goldilocks_for_rand_distr_StandardUniform.
  
  Module Impl_p3_field_field_PrimeCharacteristicRing_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     type PrimeSubfield = Self; *)
    Definition _PrimeSubfield : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     const ZERO: Self = Self::new(0); *)
    (* Ty.path "p3_goldilocks::goldilocks::Goldilocks" *)
    Definition value_ZERO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [ Value.Integer IntegerKind.U64 0 ]
          |)
        |))).
    
    (*     const ONE: Self = Self::new(1); *)
    (* Ty.path "p3_goldilocks::goldilocks::Goldilocks" *)
    Definition value_ONE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [ Value.Integer IntegerKind.U64 1 ]
          |)
        |))).
    
    (*     const TWO: Self = Self::new(2); *)
    (* Ty.path "p3_goldilocks::goldilocks::Goldilocks" *)
    Definition value_TWO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [ Value.Integer IntegerKind.U64 2 ]
          |)
        |))).
    
    (*     const NEG_ONE: Self = Self::new(Self::ORDER_U64 - 1); *)
    (* Ty.path "p3_goldilocks::goldilocks::Goldilocks" *)
    Definition value_NEG_ONE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.sub,
                [
                  M.read (|
                    get_constant (| "p3_field::field::PrimeField64::ORDER_U64", Ty.path "u64" |)
                  |);
                  Value.Integer IntegerKind.U64 1
                ]
              |)
            ]
          |)
        |))).
    
    (*
        fn from_prime_subfield(f: Self::PrimeSubfield) -> Self {
            f
        }
    *)
    Definition from_prime_subfield (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| f |) in
          M.read (| f |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_bool(b: bool) -> Self {
            Self::new(b.into())
        }
    *)
    Definition from_bool (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.path "bool",
                  [],
                  [ Ty.path "u64" ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| b |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn sum_array<const N: usize>(input: &[Self]) -> Self {
            assert_eq!(N, input.len());
            // Benchmarking shows that for N <= 3 it's faster to sum the elements directly
            // but for N > 3 it's faster to use the .sum() methods which passes through u128's
            // allowing for delayed reductions.
            match N {
                0 => Self::ZERO,
                1 => input[0],
                2 => input[0] + input[1],
                3 => input[0] + input[1] + input[2],
                _ => input.iter().copied().sum(),
            }
        }
    *)
    Definition sum_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ N ], [], [ input ] =>
        ltac:(M.monadic
          (let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind :
                                        Ty.apply
                                          (Ty.path "*")
                                          []
                                          [ Ty.path "core::panicking::AssertKind" ] :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
              M.alloc (| N |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 0
                      |) in
                    get_constant (|
                      "p3_field::field::PrimeCharacteristicRing::ZERO",
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks"
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 1
                      |) in
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| input |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 2
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          [],
                          [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| input |) |),
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| input |) |),
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 3
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          [],
                          [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                              [],
                              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| input |) |),
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| input |) |),
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              |)
                            ]
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| input |) |),
                              Value.Integer IntegerKind.Usize 2
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::copied::Copied")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                []
                                [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
                            ],
                          [],
                          [],
                          "sum",
                          [],
                          [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                []
                                [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                              [],
                              [],
                              "copied",
                              [],
                              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                                  "iter",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input |) |) |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn zero_vec(len: usize) -> Vec<Self> {
            // SAFETY:
            // Due to `#[repr(transparent)]`, Goldilocks and u64 have the same size, alignment
            // and memory layout making `flatten_to_base` safe. This this will create
            // a vector Goldilocks elements with value set to 0.
            unsafe { flatten_to_base(vec![0u64; len]) }
        }
    *)
    Definition zero_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks"; Ty.path "alloc::alloc::Global" ],
            M.get_function (|
              "p3_util::flatten_to_base",
              [],
              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks"; Ty.path "u64" ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u64"; Ty.path "alloc::alloc::Global" ],
                M.get_function (| "alloc::vec::from_elem", [], [ Ty.path "u64" ] |),
                [ Value.Integer IntegerKind.U64 0; M.read (| len |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::field::PrimeCharacteristicRing"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("PrimeSubfield", InstanceField.Ty _PrimeSubfield);
          ("value_ZERO", InstanceField.Method value_ZERO);
          ("value_ONE", InstanceField.Method value_ONE);
          ("value_TWO", InstanceField.Method value_TWO);
          ("value_NEG_ONE", InstanceField.Method value_NEG_ONE);
          ("from_prime_subfield", InstanceField.Method from_prime_subfield);
          ("from_bool", InstanceField.Method from_bool);
          ("sum_array", InstanceField.Method sum_array);
          ("zero_vec", InstanceField.Method zero_vec)
        ].
  End Impl_p3_field_field_PrimeCharacteristicRing_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_field_InjectiveMonomial_U64_7_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::field::InjectiveMonomial"
        (* Trait polymorphic consts *) [ Value.Integer IntegerKind.U64 7 ]
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_field_field_InjectiveMonomial_U64_7_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_field_PermutationMonomial_U64_7_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn injective_exp_root_n(&self) -> Self {
            exp_10540996611094048183( *self)
        }
    *)
    Definition injective_exp_root_n (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_function (|
              "p3_field::exponentiation::exp_10540996611094048183",
              [],
              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::field::PermutationMonomial"
        (* Trait polymorphic consts *) [ Value.Integer IntegerKind.U64 7 ]
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("injective_exp_root_n", InstanceField.Method injective_exp_root_n) ].
  End Impl_p3_field_field_PermutationMonomial_U64_7_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_field_Field_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     type Packing = Self; *)
    Definition _Packing : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     const GENERATOR: Self = Self::new(7); *)
    (* Ty.path "p3_goldilocks::goldilocks::Goldilocks" *)
    Definition value_GENERATOR (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [ Value.Integer IntegerKind.U64 7 ]
          |)
        |))).
    
    (*
        fn is_zero(&self) -> bool {
            self.value == 0 || self.value == Self::ORDER_U64
        }
    *)
    Definition is_zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          LogicalOp.or (|
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_goldilocks::goldilocks::Goldilocks",
                    "value"
                  |)
                |);
                Value.Integer IntegerKind.U64 0
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_goldilocks::goldilocks::Goldilocks",
                      "value"
                    |)
                  |);
                  M.read (|
                    get_constant (| "p3_field::field::PrimeField64::ORDER_U64", Ty.path "u64" |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn try_inverse(&self) -> Option<Self> {
            if self.is_zero() {
                return None;
            }
    
            // From Fermat's little theorem, in a prime field `F_p`, the inverse of `a` is `a^(p-2)`.
            //
            // compute a^(p - 2) using 72 multiplications
            // The exponent p - 2 is represented in binary as:
            // 0b1111111111111111111111111111111011111111111111111111111111111111
            // Adapted from: https://github.com/facebook/winterfell/blob/d238a1/math/src/field/f64/mod.rs#L136-L164
    
            // compute base^11
            let t2 = self.square() * *self;
    
            // compute base^111
            let t3 = t2.square() * *self;
    
            // compute base^111111 (6 ones)
            // repeatedly square t3 3 times and multiply by t3
            let t6 = exp_acc::<3>(t3, t3);
            let t60 = t6.square();
            let t7 = t60 * *self;
    
            // compute base^111111111111 (12 ones)
            // repeatedly square t6 6 times and multiply by t6
            let t12 = exp_acc::<5>(t60, t6);
    
            // compute base^111111111111111111111111 (24 ones)
            // repeatedly square t12 12 times and multiply by t12
            let t24 = exp_acc::<12>(t12, t12);
    
            // compute base^1111111111111111111111111111111 (31 ones)
            // repeatedly square t24 6 times and multiply by t6 first. then square t30 and
            // multiply by base
            let t31 = exp_acc::<7>(t24, t7);
    
            // compute base^111111111111111111111111111111101111111111111111111111111111111
            // repeatedly square t31 32 times and multiply by t31
            let t63 = exp_acc::<32>(t31, t31);
    
            // compute base^1111111111111111111111111111111011111111111111111111111111111111
            Some(t63.square() * *self)
        }
    *)
    Definition try_inverse (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "p3_field::field::Field",
                                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                    [],
                                    [],
                                    "is_zero",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ t2 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        [],
                        [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          M.get_trait_method (|
                            "p3_field::field::PrimeCharacteristicRing",
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                            [],
                            [],
                            "square",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |);
                        M.read (| M.deref (| M.read (| self |) |) |)
                      ]
                    |)
                  |) in
                let~ t3 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        [],
                        [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          M.get_trait_method (|
                            "p3_field::field::PrimeCharacteristicRing",
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                            [],
                            [],
                            "square",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, t2 |) ]
                        |);
                        M.read (| M.deref (| M.read (| self |) |) |)
                      ]
                    |)
                  |) in
                let~ t6 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_function (|
                        "p3_goldilocks::goldilocks::exp_acc",
                        [ Value.Integer IntegerKind.Usize 3 ],
                        []
                      |),
                      [ M.read (| t3 |); M.read (| t3 |) ]
                    |)
                  |) in
                let~ t60 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        [],
                        [],
                        "square",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, t6 |) ]
                    |)
                  |) in
                let~ t7 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        [],
                        [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| t60 |); M.read (| M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ t12 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_function (|
                        "p3_goldilocks::goldilocks::exp_acc",
                        [ Value.Integer IntegerKind.Usize 5 ],
                        []
                      |),
                      [ M.read (| t60 |); M.read (| t6 |) ]
                    |)
                  |) in
                let~ t24 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_function (|
                        "p3_goldilocks::goldilocks::exp_acc",
                        [ Value.Integer IntegerKind.Usize 12 ],
                        []
                      |),
                      [ M.read (| t12 |); M.read (| t12 |) ]
                    |)
                  |) in
                let~ t31 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_function (|
                        "p3_goldilocks::goldilocks::exp_acc",
                        [ Value.Integer IntegerKind.Usize 7 ],
                        []
                      |),
                      [ M.read (| t24 |); M.read (| t7 |) ]
                    |)
                  |) in
                let~ t63 :
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      M.get_function (|
                        "p3_goldilocks::goldilocks::exp_acc",
                        [ Value.Integer IntegerKind.Usize 32 ],
                        []
                      |),
                      [ M.read (| t31 |); M.read (| t31 |) ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      M.call_closure (|
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        M.get_trait_method (|
                          "core::ops::arith::Mul",
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          [],
                          [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                          "mul",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                            M.get_trait_method (|
                              "p3_field::field::PrimeCharacteristicRing",
                              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                              [],
                              [],
                              "square",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, t63 |) ]
                          |);
                          M.read (| M.deref (| M.read (| self |) |) |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn halve(&self) -> Self {
            Self::new(halve_u64::<P>(self.value))
        }
    *)
    Definition halve (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_function (|
                  "p3_field::helpers::halve_u64",
                  [ Value.Integer IntegerKind.U64 18446744069414584321 ],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_goldilocks::goldilocks::Goldilocks",
                      "value"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn order() -> BigUint {
            P.into()
        }
    *)
    Definition order (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.path "num_bigint::biguint::BigUint",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.path "u64",
              [],
              [ Ty.path "num_bigint::biguint::BigUint" ],
              "into",
              [],
              []
            |),
            [ M.read (| get_constant (| "p3_goldilocks::goldilocks::P", Ty.path "u64" |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::field::Field"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("Packing", InstanceField.Ty _Packing);
          ("value_GENERATOR", InstanceField.Method value_GENERATOR);
          ("is_zero", InstanceField.Method is_zero);
          ("try_inverse", InstanceField.Method try_inverse);
          ("halve", InstanceField.Method halve);
          ("order", InstanceField.Method order)
        ].
  End Impl_p3_field_field_Field_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_integers_QuotientMap_u64_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn from_int(int: u64) -> Self {
            Self::new(int)
        }
    *)
    Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ int ] =>
        ltac:(M.monadic
          (let int := M.alloc (| int |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [ M.read (| int |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_canonical_checked(int: u64) -> Option<Self> {
            (int < Self::ORDER_U64).then(|| Self::new(int))
        }
    *)
    Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ int ] =>
        ltac:(M.monadic
          (let int := M.alloc (| int |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
            M.get_associated_function (|
              Ty.path "bool",
              "then",
              [],
              [
                Ty.path "p3_goldilocks::goldilocks::Goldilocks";
                Ty.function [ Ty.tuple [] ] (Ty.path "p3_goldilocks::goldilocks::Goldilocks")
              ]
            |),
            [
              M.call_closure (|
                Ty.path "bool",
                BinOp.lt,
                [
                  M.read (| int |);
                  M.read (|
                    get_constant (| "p3_field::field::PrimeField64::ORDER_U64", Ty.path "u64" |)
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [] ]
                                (Ty.path "p3_goldilocks::goldilocks::Goldilocks")
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                  M.get_associated_function (|
                                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                    "new",
                                    [],
                                    []
                                  |),
                                  [ M.read (| int |) ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        unsafe fn from_canonical_unchecked(int: u64) -> Self {
            Self::new(int)
        }
    *)
    Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ int ] =>
        ltac:(M.monadic
          (let int := M.alloc (| int |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [ M.read (| int |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::integers::QuotientMap"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u64" ]
        Self
        (* Instance *)
        [
          ("from_int", InstanceField.Method from_int);
          ("from_canonical_checked", InstanceField.Method from_canonical_checked);
          ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
        ].
  End Impl_p3_field_integers_QuotientMap_u64_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_integers_QuotientMap_i64_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn from_int(int: i64) -> Self {
            if int >= 0 {
                Self::new(int as u64)
            } else {
                Self::new(Self::ORDER_U64.wrapping_add_signed(int))
            }
        }
    *)
    Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ int ] =>
        ltac:(M.monadic
          (let int := M.alloc (| int |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.ge,
                            [ M.read (| int |); Value.Integer IntegerKind.I64 0 ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        M.get_associated_function (|
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          "new",
                          [],
                          []
                        |),
                        [ M.cast (Ty.path "u64") (M.read (| int |)) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                        M.get_associated_function (|
                          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                          "new",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.path "u64",
                            M.get_associated_function (|
                              Ty.path "u64",
                              "wrapping_add_signed",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                get_constant (|
                                  "p3_field::field::PrimeField64::ORDER_U64",
                                  Ty.path "u64"
                                |)
                              |);
                              M.read (| int |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn from_canonical_checked(int: i64) -> Option<Self> {
            const POS_BOUND: i64 = (P >> 1) as i64;
            const NEG_BOUND: i64 = -POS_BOUND;
            match int {
                0..=POS_BOUND => Some(Self::new(int as u64)),
                NEG_BOUND..0 => Some(Self::new(Self::ORDER_U64.wrapping_add_signed(int))),
                _ => None,
            }
        }
    *)
    Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ int ] =>
        ltac:(M.monadic
          (let int := M.alloc (| int |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
                ],
              int,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                            M.get_associated_function (|
                              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                              "new",
                              [],
                              []
                            |),
                            [ M.cast (Ty.path "u64") (M.read (| int |)) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                            M.get_associated_function (|
                              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                              "new",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.path "u64",
                                M.get_associated_function (|
                                  Ty.path "u64",
                                  "wrapping_add_signed",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    get_constant (|
                                      "p3_field::field::PrimeField64::ORDER_U64",
                                      Ty.path "u64"
                                    |)
                                  |);
                                  M.read (| int |)
                                ]
                              |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        unsafe fn from_canonical_unchecked(int: i64) -> Self {
            Self::from_int(int)
        }
    *)
    Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ int ] =>
        ltac:(M.monadic
          (let int := M.alloc (| int |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_trait_method (|
              "p3_field::integers::QuotientMap",
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              [],
              [ Ty.path "i64" ],
              "from_int",
              [],
              []
            |),
            [ M.read (| int |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::integers::QuotientMap"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "i64" ]
        Self
        (* Instance *)
        [
          ("from_int", InstanceField.Method from_int);
          ("from_canonical_checked", InstanceField.Method from_canonical_checked);
          ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
        ].
  End Impl_p3_field_integers_QuotientMap_i64_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_field_PrimeField_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn as_canonical_biguint(&self) -> BigUint {
            self.as_canonical_u64().into()
        }
    *)
    Definition as_canonical_biguint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "num_bigint::biguint::BigUint",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.path "u64",
              [],
              [ Ty.path "num_bigint::biguint::BigUint" ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "p3_field::field::PrimeField64",
                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                  [],
                  [],
                  "as_canonical_u64",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::field::PrimeField"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("as_canonical_biguint", InstanceField.Method as_canonical_biguint) ].
  End Impl_p3_field_field_PrimeField_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_field_PrimeField64_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     const ORDER_U64: u64 = P; *)
    (* Ty.path "u64" *)
    Definition value_ORDER_U64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (get_constant (| "p3_goldilocks::goldilocks::P", Ty.path "u64" |))).
    
    (*
        fn as_canonical_u64(&self) -> u64 {
            let mut c = self.value;
            // We only need one condition subtraction, since 2 * ORDER would not fit in a u64.
            if c >= Self::ORDER_U64 {
                c -= Self::ORDER_U64;
            }
            c
        }
    *)
    Definition as_canonical_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ c : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
              M.copy (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_goldilocks::goldilocks::Goldilocks",
                  "value"
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [
                                M.read (| c |);
                                M.read (|
                                  get_constant (|
                                    "p3_field::field::PrimeField64::ORDER_U64",
                                    Ty.path "u64"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.alloc (|
                          let β := c in
                          M.write (|
                            β,
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.sub,
                              [
                                M.read (| β |);
                                M.read (|
                                  get_constant (|
                                    "p3_field::field::PrimeField64::ORDER_U64",
                                    Ty.path "u64"
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            c
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::field::PrimeField64"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_ORDER_U64", InstanceField.Method value_ORDER_U64);
          ("as_canonical_u64", InstanceField.Method as_canonical_u64)
        ].
  End Impl_p3_field_field_PrimeField64_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_p3_field_field_TwoAdicField_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     const TWO_ADICITY: usize = 32; *)
    (* Ty.path "usize" *)
    Definition value_TWO_ADICITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 32 |))).
    
    (*
        fn two_adic_generator(bits: usize) -> Self {
            assert!(bits <= Self::TWO_ADICITY);
            Self::TWO_ADIC_GENERATORS[bits]
        }
    *)
    Definition two_adic_generator (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bits ] =>
        ltac:(M.monadic
          (let bits := M.alloc (| bits |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.le,
                                [
                                  M.read (| bits |);
                                  M.read (|
                                    get_constant (|
                                      "p3_field::field::TwoAdicField::TWO_ADICITY",
                                      Ty.path "usize"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic", [], [] |),
                            [ mk_str (| "assertion failed: bits <= Self::TWO_ADICITY" |) ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.SubPointer.get_array_field (|
              get_associated_constant (|
                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                "TWO_ADIC_GENERATORS",
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 33 ]
                  [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
              |),
              M.read (| bits |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_field::field::TwoAdicField"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_TWO_ADICITY", InstanceField.Method value_TWO_ADICITY);
          ("two_adic_generator", InstanceField.Method two_adic_generator)
        ].
  End Impl_p3_field_field_TwoAdicField_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_Add_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn add(self, rhs: Self) -> Self {
            let (sum, over) = self.value.overflowing_add(rhs.value);
            let (mut sum, over) = sum.overflowing_add(u64::from(over) * Self::NEG_ORDER);
            if over {
                // NB: self.value > Self::ORDER && rhs.value > Self::ORDER is necessary but not
                // sufficient for double-overflow.
                // This assume does two things:
                //  1. If compiler knows that either self.value or rhs.value <= ORDER, then it can skip
                //     this check.
                //  2. Hints to the compiler how rare this double-overflow is (thus handled better with
                //     a branch).
                assume(self.value > Self::ORDER_U64 && rhs.value > Self::ORDER_U64);
                branch_hint();
                sum += Self::NEG_ORDER; // Cannot overflow.
            }
            Self::new(sum)
        }
    *)
    Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.path "u64"; Ty.path "bool" ],
                  M.get_associated_function (| Ty.path "u64", "overflowing_add", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "p3_goldilocks::goldilocks::Goldilocks",
                        "value"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        rhs,
                        "p3_goldilocks::goldilocks::Goldilocks",
                        "value"
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let sum := M.copy (| γ0_0 |) in
                    let over := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ Ty.path "u64"; Ty.path "bool" ],
                          M.get_associated_function (| Ty.path "u64", "overflowing_add", [], [] |),
                          [
                            M.read (| sum |);
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.mul,
                              [
                                M.call_closure (|
                                  Ty.path "u64",
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.path "u64",
                                    [],
                                    [ Ty.path "bool" ],
                                    "from",
                                    [],
                                    []
                                  |),
                                  [ M.read (| over |) ]
                                |);
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                    "NEG_ORDER",
                                    Ty.path "u64"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let sum := M.copy (| γ0_0 |) in
                            let over := M.copy (| γ0_1 |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use over in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (| "p3_util::assume", [], [] |),
                                            [
                                              LogicalOp.and (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.gt,
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        self,
                                                        "p3_goldilocks::goldilocks::Goldilocks",
                                                        "value"
                                                      |)
                                                    |);
                                                    M.read (|
                                                      get_constant (|
                                                        "p3_field::field::PrimeField64::ORDER_U64",
                                                        Ty.path "u64"
                                                      |)
                                                    |)
                                                  ]
                                                |),
                                                ltac:(M.monadic
                                                  (M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.gt,
                                                    [
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          rhs,
                                                          "p3_goldilocks::goldilocks::Goldilocks",
                                                          "value"
                                                        |)
                                                      |);
                                                      M.read (|
                                                        get_constant (|
                                                          "p3_field::field::PrimeField64::ORDER_U64",
                                                          Ty.path "u64"
                                                        |)
                                                      |)
                                                    ]
                                                  |)))
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (| "p3_util::branch_hint", [], [] |),
                                            []
                                          |)
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          let β := sum in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "u64",
                                              BinOp.Wrap.add,
                                              [
                                                M.read (| β |);
                                                M.read (|
                                                  get_associated_constant (|
                                                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                                    "NEG_ORDER",
                                                    Ty.path "u64"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                M.get_associated_function (|
                                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                  "new",
                                  [],
                                  []
                                |),
                                [ M.read (| sum |) ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
  End Impl_core_ops_arith_Add_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_AddAssign_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn add_assign(&mut self, rhs: Self) {
            *self = *self + rhs;
        }
    *)
    Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      [],
                      [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                      "add",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
  End Impl_core_ops_arith_AddAssign_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_iter_traits_accum_Sum_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
            // This is faster than iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO) for iterators of length > 2.
    
            // This sum will not overflow so long as iter.len() < 2^64.
            let sum = iter.map(|x| x.value as u128).sum::<u128>();
            reduce128(sum)
        }
    *)
    Definition sum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.read (|
            let~ sum : Ty.apply (Ty.path "*") [] [ Ty.path "u128" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        I;
                        Ty.function
                          [ Ty.tuple [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] ]
                          (Ty.path "u128")
                      ],
                    [],
                    [],
                    "sum",
                    [],
                    [ Ty.path "u128" ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          I;
                          Ty.function
                            [ Ty.tuple [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] ]
                            (Ty.path "u128")
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        I,
                        [],
                        [],
                        "map",
                        [],
                        [
                          Ty.path "u128";
                          Ty.function
                            [ Ty.tuple [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ] ]
                            (Ty.path "u128")
                        ]
                      |),
                      [
                        M.read (| iter |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
                                          ]
                                          (Ty.path "u128")
                                      ],
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| γ |) in
                                          M.cast
                                            (Ty.path "u128")
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                x,
                                                "p3_goldilocks::goldilocks::Goldilocks",
                                                "value"
                                              |)
                                            |))))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                M.get_function (| "p3_goldilocks::goldilocks::reduce128", [], [] |),
                [ M.read (| sum |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::accum::Sum"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("sum", InstanceField.Method sum) ].
  End Impl_core_iter_traits_accum_Sum_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_Sub_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn sub(self, rhs: Self) -> Self {
            let (diff, under) = self.value.overflowing_sub(rhs.value);
            let (mut diff, under) = diff.overflowing_sub(u64::from(under) * Self::NEG_ORDER);
            if under {
                // NB: self.value < NEG_ORDER - 1 && rhs.value > ORDER is necessary but not
                // sufficient for double-underflow.
                // This assume does two things:
                //  1. If compiler knows that either self.value >= NEG_ORDER - 1 or rhs.value <= ORDER,
                //     then it can skip this check.
                //  2. Hints to the compiler how rare this double-underflow is (thus handled better
                //     with a branch).
                assume(self.value < Self::NEG_ORDER - 1 && rhs.value > Self::ORDER_U64);
                branch_hint();
                diff -= Self::NEG_ORDER; // Cannot underflow.
            }
            Self::new(diff)
        }
    *)
    Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.path "u64"; Ty.path "bool" ],
                  M.get_associated_function (| Ty.path "u64", "overflowing_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "p3_goldilocks::goldilocks::Goldilocks",
                        "value"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        rhs,
                        "p3_goldilocks::goldilocks::Goldilocks",
                        "value"
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let diff := M.copy (| γ0_0 |) in
                    let under := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ Ty.path "u64"; Ty.path "bool" ],
                          M.get_associated_function (| Ty.path "u64", "overflowing_sub", [], [] |),
                          [
                            M.read (| diff |);
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.mul,
                              [
                                M.call_closure (|
                                  Ty.path "u64",
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.path "u64",
                                    [],
                                    [ Ty.path "bool" ],
                                    "from",
                                    [],
                                    []
                                  |),
                                  [ M.read (| under |) ]
                                |);
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                    "NEG_ORDER",
                                    Ty.path "u64"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let diff := M.copy (| γ0_0 |) in
                            let under := M.copy (| γ0_1 |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use under in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (| "p3_util::assume", [], [] |),
                                            [
                                              LogicalOp.and (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.lt,
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        self,
                                                        "p3_goldilocks::goldilocks::Goldilocks",
                                                        "value"
                                                      |)
                                                    |);
                                                    M.call_closure (|
                                                      Ty.path "u64",
                                                      BinOp.Wrap.sub,
                                                      [
                                                        M.read (|
                                                          get_associated_constant (|
                                                            Ty.path
                                                              "p3_goldilocks::goldilocks::Goldilocks",
                                                            "NEG_ORDER",
                                                            Ty.path "u64"
                                                          |)
                                                        |);
                                                        Value.Integer IntegerKind.U64 1
                                                      ]
                                                    |)
                                                  ]
                                                |),
                                                ltac:(M.monadic
                                                  (M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.gt,
                                                    [
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          rhs,
                                                          "p3_goldilocks::goldilocks::Goldilocks",
                                                          "value"
                                                        |)
                                                      |);
                                                      M.read (|
                                                        get_constant (|
                                                          "p3_field::field::PrimeField64::ORDER_U64",
                                                          Ty.path "u64"
                                                        |)
                                                      |)
                                                    ]
                                                  |)))
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (| "p3_util::branch_hint", [], [] |),
                                            []
                                          |)
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          let β := diff in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "u64",
                                              BinOp.Wrap.sub,
                                              [
                                                M.read (| β |);
                                                M.read (|
                                                  get_associated_constant (|
                                                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                                    "NEG_ORDER",
                                                    Ty.path "u64"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                M.get_associated_function (|
                                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                  "new",
                                  [],
                                  []
                                |),
                                [ M.read (| diff |) ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
  End Impl_core_ops_arith_Sub_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_SubAssign_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn sub_assign(&mut self, rhs: Self) {
            *self = *self - rhs;
        }
    *)
    Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      [],
                      [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                      "sub",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::SubAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
  End Impl_core_ops_arith_SubAssign_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_Neg_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn neg(self) -> Self::Output {
            Self::new(Self::ORDER_U64 - self.as_canonical_u64())
        }
    *)
    Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              "new",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.sub,
                [
                  M.read (|
                    get_constant (| "p3_field::field::PrimeField64::ORDER_U64", Ty.path "u64" |)
                  |);
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_trait_method (|
                      "p3_field::field::PrimeField64",
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      [],
                      [],
                      "as_canonical_u64",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Neg"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
  End Impl_core_ops_arith_Neg_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_Mul_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn mul(self, rhs: Self) -> Self {
            reduce128(u128::from(self.value) * u128::from(rhs.value))
        }
    *)
    Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_function (| "p3_goldilocks::goldilocks::reduce128", [], [] |),
            [
              M.call_closure (|
                Ty.path "u128",
                BinOp.Wrap.mul,
                [
                  M.call_closure (|
                    Ty.path "u128",
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.path "u128",
                      [],
                      [ Ty.path "u64" ],
                      "from",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "p3_goldilocks::goldilocks::Goldilocks",
                          "value"
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    Ty.path "u128",
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.path "u128",
                      [],
                      [ Ty.path "u64" ],
                      "from",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          rhs,
                          "p3_goldilocks::goldilocks::Goldilocks",
                          "value"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
  End Impl_core_ops_arith_Mul_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_MulAssign_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn mul_assign(&mut self, rhs: Self) {
            *self = *self * rhs;
        }
    *)
    Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                      [],
                      [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                      "mul",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::MulAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
  End Impl_core_ops_arith_MulAssign_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_iter_traits_accum_Product_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {
            iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)
        }
    *)
    Definition product (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
              "unwrap_or",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  [],
                  "reduce",
                  [],
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks";
                            Ty.path "p3_goldilocks::goldilocks::Goldilocks"
                          ]
                      ]
                      (Ty.path "p3_goldilocks::goldilocks::Goldilocks")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "p3_goldilocks::goldilocks::Goldilocks";
                                          Ty.path "p3_goldilocks::goldilocks::Goldilocks"
                                        ]
                                    ]
                                    (Ty.path "p3_goldilocks::goldilocks::Goldilocks")
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let x := M.copy (| γ |) in
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "p3_goldilocks::goldilocks::Goldilocks";
                                                  Ty.path "p3_goldilocks::goldilocks::Goldilocks"
                                                ]
                                            ]
                                            (Ty.path "p3_goldilocks::goldilocks::Goldilocks")
                                        ],
                                      M.alloc (| α1 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let y := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                              M.get_trait_method (|
                                                "core::ops::arith::Mul",
                                                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                                [],
                                                [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                                                "mul",
                                                [],
                                                []
                                              |),
                                              [ M.read (| x |); M.read (| y |) ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |);
              M.read (|
                get_constant (|
                  "p3_field::field::PrimeCharacteristicRing::ONE",
                  Ty.path "p3_goldilocks::goldilocks::Goldilocks"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::accum::Product"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("product", InstanceField.Method product) ].
  End Impl_core_iter_traits_accum_Product_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  Module Impl_core_ops_arith_Div_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
    Definition Self : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "p3_goldilocks::goldilocks::Goldilocks".
    
    (*
        fn div(self, rhs: Self) -> Self {
            self * rhs.inverse()
        }
    *)
    Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            M.get_trait_method (|
              "core::ops::arith::Mul",
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              [],
              [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
              "mul",
              [],
              []
            |),
            [
              M.read (| self |);
              M.call_closure (|
                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                M.get_trait_method (|
                  "p3_field::field::Field",
                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                  [],
                  [],
                  "inverse",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Div"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
  End Impl_core_ops_arith_Div_p3_goldilocks_goldilocks_Goldilocks_for_p3_goldilocks_goldilocks_Goldilocks.
  
  (*
  fn exp_acc<const N: usize>(base: Goldilocks, tail: Goldilocks) -> Goldilocks {
      base.exp_power_of_2(N) * tail
  }
  *)
  Definition exp_acc (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ base; tail ] =>
      ltac:(M.monadic
        (let base := M.alloc (| base |) in
        let tail := M.alloc (| tail |) in
        M.call_closure (|
          Ty.path "p3_goldilocks::goldilocks::Goldilocks",
          M.get_trait_method (|
            "core::ops::arith::Mul",
            Ty.path "p3_goldilocks::goldilocks::Goldilocks",
            [],
            [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
            "mul",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                [],
                [],
                "exp_power_of_2",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, base |); N ]
            |);
            M.read (| tail |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_exp_acc :
    M.IsFunction.C "p3_goldilocks::goldilocks::exp_acc" exp_acc.
  Admitted.
  Global Typeclasses Opaque exp_acc.
  
  (*
  pub(crate) fn reduce128(x: u128) -> Goldilocks {
      let (x_lo, x_hi) = split(x); // This is a no-op
      let x_hi_hi = x_hi >> 32;
      let x_hi_lo = x_hi & Goldilocks::NEG_ORDER;
  
      let (mut t0, borrow) = x_lo.overflowing_sub(x_hi_hi);
      if borrow {
          branch_hint(); // A borrow is exceedingly rare. It is faster to branch.
          t0 -= Goldilocks::NEG_ORDER; // Cannot underflow.
      }
      let t1 = x_hi_lo * Goldilocks::NEG_ORDER;
      let t2 = unsafe { add_no_canonicalize_trashing_input(t0, t1) };
      Goldilocks::new(t2)
  }
  *)
  Definition reduce128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
            M.alloc (|
              M.call_closure (|
                Ty.tuple [ Ty.path "u64"; Ty.path "u64" ],
                M.get_function (| "p3_goldilocks::goldilocks::split", [], [] |),
                [ M.read (| x |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let x_lo := M.copy (| γ0_0 |) in
                  let x_hi := M.copy (| γ0_1 |) in
                  let~ x_hi_hi : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.shr,
                        [ M.read (| x_hi |); Value.Integer IntegerKind.I32 32 ]
                      |)
                    |) in
                  let~ x_hi_lo : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.bit_and,
                        [
                          M.read (| x_hi |);
                          M.read (|
                            get_associated_constant (|
                              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                              "NEG_ORDER",
                              Ty.path "u64"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "p3_goldilocks::goldilocks::Goldilocks" ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [ Ty.path "u64"; Ty.path "bool" ],
                        M.get_associated_function (| Ty.path "u64", "overflowing_sub", [], [] |),
                        [ M.read (| x_lo |); M.read (| x_hi_hi |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let t0 := M.copy (| γ0_0 |) in
                          let borrow := M.copy (| γ0_1 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use borrow in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_function (| "p3_util::branch_hint", [], [] |),
                                          []
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        let β := t0 in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.sub,
                                            [
                                              M.read (| β |);
                                              M.read (|
                                                get_associated_constant (|
                                                  Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                                  "NEG_ORDER",
                                                  Ty.path "u64"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let~ t1 : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.mul,
                                [
                                  M.read (| x_hi_lo |);
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                      "NEG_ORDER",
                                      Ty.path "u64"
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ t2 : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "u64",
                                M.get_function (|
                                  "p3_goldilocks::goldilocks::add_no_canonicalize_trashing_input",
                                  [],
                                  []
                                |),
                                [ M.read (| t0 |); M.read (| t1 |) ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                              M.get_associated_function (|
                                Ty.path "p3_goldilocks::goldilocks::Goldilocks",
                                "new",
                                [],
                                []
                              |),
                              [ M.read (| t2 |) ]
                            |)
                          |)))
                    ]
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_reduce128 :
    M.IsFunction.C "p3_goldilocks::goldilocks::reduce128" reduce128.
  Admitted.
  Global Typeclasses Opaque reduce128.
  
  (*
  const fn split(x: u128) -> (u64, u64) {
      (x as u64, (x >> 64) as u64)
  }
  *)
  Definition split (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        Value.Tuple
          [
            M.cast (Ty.path "u64") (M.read (| x |));
            M.cast
              (Ty.path "u64")
              (M.call_closure (|
                Ty.path "u128",
                BinOp.Wrap.shr,
                [ M.read (| x |); Value.Integer IntegerKind.I32 64 ]
              |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_split :
    M.IsFunction.C "p3_goldilocks::goldilocks::split" split.
  Admitted.
  Global Typeclasses Opaque split.
  
  (*
  unsafe fn add_no_canonicalize_trashing_input(x: u64, y: u64) -> u64 {
      unsafe {
          let res_wrapped: u64;
          let adjustment: u64;
          core::arch::asm!(
              "add {0}, {1}",
              // Trick. The carry flag is set iff the addition overflowed.
              // sbb x, y does x := x - y - CF. In our case, x and y are both {1:e}, so it simply does
              // {1:e} := 0xffffffff on overflow and {1:e} := 0 otherwise. {1:e} is the low 32 bits of
              // {1}; the high 32-bits are zeroed on write. In the end, we end up with 0xffffffff in {1}
              // on overflow; this happens be NEG_ORDER.
              // Note that the CPU does not realize that the result of sbb x, x does not actually depend
              // on x. We must write the result to a register that we know to be ready. We have a
              // dependency on {1} anyway, so let's use it.
              "sbb {1:e}, {1:e}",
              inlateout(reg) x => res_wrapped,
              inlateout(reg) y => adjustment,
              options(pure, nomem, nostack),
          );
          assume(x != 0 || (res_wrapped == y && adjustment == 0));
          assume(y != 0 || (res_wrapped == x && adjustment == 0));
          // Add NEG_ORDER == subtract ORDER.
          // Cannot overflow unless the assumption if x + y < 2**64 + ORDER is incorrect.
          res_wrapped + adjustment
      }
  }
  *)
  Definition add_no_canonicalize_trashing_input
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ x; y ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        let y := M.alloc (| y |) in
        M.read (|
          let res_wrapped := M.copy (| Value.DeclaredButUndefined |) in
          let adjustment := M.copy (| Value.DeclaredButUndefined |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] := InlineAssembly in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_function (| "p3_util::assume", [], [] |),
                [
                  LogicalOp.or (|
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.ne,
                      [ M.read (| x |); Value.Integer IntegerKind.U64 0 ]
                    |),
                    ltac:(M.monadic
                      (LogicalOp.and (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [ M.read (| res_wrapped |); M.read (| y |) ]
                        |),
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [ M.read (| adjustment |); Value.Integer IntegerKind.U64 0 ]
                          |)))
                      |)))
                  |)
                ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_function (| "p3_util::assume", [], [] |),
                [
                  LogicalOp.or (|
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.ne,
                      [ M.read (| y |); Value.Integer IntegerKind.U64 0 ]
                    |),
                    ltac:(M.monadic
                      (LogicalOp.and (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [ M.read (| res_wrapped |); M.read (| x |) ]
                        |),
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [ M.read (| adjustment |); Value.Integer IntegerKind.U64 0 ]
                          |)))
                      |)))
                  |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ M.read (| res_wrapped |); M.read (| adjustment |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_add_no_canonicalize_trashing_input :
    M.IsFunction.C
      "p3_goldilocks::goldilocks::add_no_canonicalize_trashing_input"
      add_no_canonicalize_trashing_input.
  Admitted.
  Global Typeclasses Opaque add_no_canonicalize_trashing_input.
End goldilocks.
