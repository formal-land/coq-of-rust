(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
pub fn interpolate_subgroup<F, EF, Mat>(subgroup_evals: &Mat, point: EF) -> Vec<EF>
where
    F: TwoAdicField,
    EF: ExtensionField<F> + TwoAdicField,
    Mat: Matrix<F>,
{
    interpolate_coset(subgroup_evals, F::ONE, point, None)
}
*)
Definition interpolate_subgroup (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [ F; EF; Mat ], [ subgroup_evals; point ] =>
    ltac:(M.monadic
      (let subgroup_evals := M.alloc (| subgroup_evals |) in
      let point := M.alloc (| point |) in
      M.call_closure (|
        Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
        M.get_function (| "p3_interpolation::interpolate_coset", [], [ F; EF; Mat ] |),
        [
          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| subgroup_evals |) |) |);
          M.read (| get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", F |) |);
          M.read (| point |);
          Value.StructTuple "core::option::Option::None" []
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_interpolate_subgroup :
  M.IsFunction.C "p3_interpolation::interpolate_subgroup" interpolate_subgroup.
Admitted.
Global Typeclasses Opaque interpolate_subgroup.

(*
pub fn interpolate_coset<F, EF, Mat>(
    coset_evals: &Mat,
    shift: F,
    point: EF,
    diff_invs: Option<&[EF]>,
) -> Vec<EF>
where
    F: TwoAdicField,
    EF: ExtensionField<F> + TwoAdicField,
    Mat: Matrix<F>,
{
    // Slight variation of this approach: https://hackmd.io/@vbuterin/barycentric_evaluation

    let height = coset_evals.height();
    let log_height = log2_strict_usize(height);

    let g = F::two_adic_generator(log_height).powers().take(height);
    let col_scale: Vec<_> = if let Some(diff_invs) = diff_invs {
        g.zip(diff_invs)
            .map(|(sg, &diff_inv)| diff_inv * sg)
            .collect()
    } else {
        let subgroup = g.collect::<Vec<_>>();
        let diffs: Vec<EF> = subgroup
            .par_iter()
            .map(|&subgroup_i| point - subgroup_i * shift)
            .collect();
        let diff_invs = batch_multiplicative_inverse(&diffs);
        subgroup
            .par_iter()
            .zip(diff_invs)
            .map(|(&sg, diff_inv)| diff_inv * sg)
            .collect()
    };
    let sum = coset_evals.columnwise_dot_product(&col_scale);

    let vanishing_polynomial =
        two_adic_coset_vanishing_polynomial::<EF>(log_height, shift.into(), point);

    // In principle, height could be bigger than the characteristic of F.
    let denominator = shift
        .exp_u64(height as u64 - 1)
        .mul_2exp_u64(log_height as u64);
    scale_vec(vanishing_polynomial * denominator.inverse(), sum)
}
*)
Definition interpolate_coset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [ F; EF; Mat ], [ coset_evals; shift; point; diff_invs ] =>
    ltac:(M.monadic
      (let coset_evals := M.alloc (| coset_evals |) in
      let shift := M.alloc (| shift |) in
      let point := M.alloc (| point |) in
      let diff_invs := M.alloc (| diff_invs |) in
      M.read (|
        let~ height : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
          M.alloc (|
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (| "p3_matrix::Matrix", Mat, [], [ F ], "height", [], [] |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| coset_evals |) |) |) ]
            |)
          |) in
        let~ log_height : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
          M.alloc (|
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "p3_util::log2_strict_usize", [], [] |),
              [ M.read (| height |) ]
            |)
          |) in
        let~ g :
            Ty.apply
              (Ty.path "*")
              []
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::take::Take")
                  []
                  [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ]
              ] :=
          M.alloc (|
            M.call_closure (|
              Ty.apply
                (Ty.path "core::iter::adapters::take::Take")
                []
                [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                [],
                [],
                "take",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                  M.get_trait_method (|
                    "p3_field::field::PrimeCharacteristicRing",
                    F,
                    [],
                    [],
                    "powers",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "p3_field::field::TwoAdicField",
                            F,
                            [],
                            [],
                            "two_adic_generator",
                            [],
                            []
                          |),
                          [ M.read (| log_height |) ]
                        |)
                      |)
                    |)
                  ]
                |);
                M.read (| height |)
              ]
            |)
          |) in
        let~ col_scale :
            Ty.apply
              (Ty.path "*")
              []
              [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ] ] :=
          M.copy (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := diff_invs in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let diff_invs := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ EF; Ty.path "alloc::alloc::Global" ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::take::Take")
                                    []
                                    [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ];
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ EF ]
                                ];
                              Ty.function
                                [ Ty.tuple [ Ty.tuple [ F; Ty.apply (Ty.path "&") [] [ EF ] ] ] ]
                                EF
                            ],
                          [],
                          [],
                          "collect",
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ EF; Ty.path "alloc::alloc::Global" ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::take::Take")
                                      []
                                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ];
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ EF ]
                                  ];
                                Ty.function
                                  [ Ty.tuple [ Ty.tuple [ F; Ty.apply (Ty.path "&") [] [ EF ] ] ] ]
                                  EF
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::take::Take")
                                    []
                                    [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ];
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ EF ]
                                ],
                              [],
                              [],
                              "map",
                              [],
                              [
                                EF;
                                Ty.function
                                  [ Ty.tuple [ Ty.tuple [ F; Ty.apply (Ty.path "&") [] [ EF ] ] ] ]
                                  EF
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::take::Take")
                                      []
                                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ];
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ EF ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::take::Take")
                                    []
                                    [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                                  [],
                                  [],
                                  "zip",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ EF ] ]
                                  ]
                                |),
                                [ M.read (| g |); M.read (| diff_invs |) ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          Ty.apply
                                            (Ty.path "*")
                                            []
                                            [
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.tuple
                                                        [ F; Ty.apply (Ty.path "&") [] [ EF ] ]
                                                    ]
                                                ]
                                                EF
                                            ],
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let sg := M.copy (| γ0_0 |) in
                                                let γ0_1 := M.read (| γ0_1 |) in
                                                let diff_inv := M.copy (| γ0_1 |) in
                                                M.call_closure (|
                                                  EF,
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Mul",
                                                    EF,
                                                    [],
                                                    [ F ],
                                                    "mul",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| diff_inv |); M.read (| sg |) ]
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ subgroup :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::take::Take")
                              []
                              [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [ M.read (| g |) ]
                        |)
                      |) in
                    let~ diffs :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ EF; Ty.path "alloc::alloc::Global" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ EF; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ F ] ] ] EF
                              ],
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ EF; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                  Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ F ] ] ] EF
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                [],
                                [],
                                "map",
                                [],
                                [
                                  EF;
                                  Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ F ] ] ] EF
                                ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                  M.get_trait_method (|
                                    "p3_maybe_rayon::serial::IntoParallelRefIterator",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ F; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [],
                                    "par_iter",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, subgroup |) ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ F ] ] ]
                                                  EF
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ := M.read (| γ |) in
                                                  let subgroup_i := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    EF,
                                                    M.get_trait_method (|
                                                      "core::ops::arith::Sub",
                                                      EF,
                                                      [],
                                                      [ F ],
                                                      "sub",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.read (| point |);
                                                      M.call_closure (|
                                                        F,
                                                        M.get_trait_method (|
                                                          "core::ops::arith::Mul",
                                                          F,
                                                          [],
                                                          [ F ],
                                                          "mul",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (| subgroup_i |);
                                                          M.read (| shift |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let~ diff_invs :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ EF; Ty.path "alloc::alloc::Global" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ EF; Ty.path "alloc::alloc::Global" ],
                          M.get_function (|
                            "p3_field::batch_inverse::batch_multiplicative_inverse",
                            [],
                            [ EF ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ EF ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ EF; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.borrow (| Pointer.Kind.Ref, diffs |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ EF; Ty.path "alloc::alloc::Global" ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    []
                                    [ EF; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.function
                                [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ F ]; EF ] ] ]
                                EF
                            ],
                          [],
                          [],
                          "collect",
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ EF; Ty.path "alloc::alloc::Global" ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      []
                                      [ EF; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.function
                                  [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ F ]; EF ] ] ]
                                  EF
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    []
                                    [ EF; Ty.path "alloc::alloc::Global" ]
                                ],
                              [],
                              [],
                              "map",
                              [],
                              [
                                EF;
                                Ty.function
                                  [ Ty.tuple [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ F ]; EF ] ] ]
                                  EF
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      []
                                      [ EF; Ty.path "alloc::alloc::Global" ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                  [],
                                  [],
                                  "zip",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ EF; Ty.path "alloc::alloc::Global" ]
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                                    M.get_trait_method (|
                                      "p3_maybe_rayon::serial::IntoParallelRefIterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ F; Ty.path "alloc::alloc::Global" ],
                                      [],
                                      [],
                                      "par_iter",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, subgroup |) ]
                                  |);
                                  M.read (| diff_invs |)
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          Ty.apply
                                            (Ty.path "*")
                                            []
                                            [
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.tuple
                                                        [ Ty.apply (Ty.path "&") [] [ F ]; EF ]
                                                    ]
                                                ]
                                                EF
                                            ],
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let γ0_0 := M.read (| γ0_0 |) in
                                                let sg := M.copy (| γ0_0 |) in
                                                let diff_inv := M.copy (| γ0_1 |) in
                                                M.call_closure (|
                                                  EF,
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Mul",
                                                    EF,
                                                    [],
                                                    [ F ],
                                                    "mul",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| diff_inv |); M.read (| sg |) ]
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |) in
        let~ sum :
            Ty.apply
              (Ty.path "*")
              []
              [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ] ] :=
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "p3_matrix::Matrix",
                Mat,
                [],
                [ F ],
                "columnwise_dot_product",
                [],
                [ EF ]
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| coset_evals |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ EF ] ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ EF; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, col_scale |) |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)
          |) in
        let~ vanishing_polynomial : Ty.apply (Ty.path "*") [] [ EF ] :=
          M.alloc (|
            M.call_closure (|
              EF,
              M.get_function (|
                "p3_field::helpers::two_adic_coset_vanishing_polynomial",
                [],
                [ EF ]
              |),
              [
                M.read (| log_height |);
                M.call_closure (|
                  EF,
                  M.get_trait_method (| "core::convert::Into", F, [], [ EF ], "into", [], [] |),
                  [ M.read (| shift |) ]
                |);
                M.read (| point |)
              ]
            |)
          |) in
        let~ denominator : Ty.apply (Ty.path "*") [] [ F ] :=
          M.alloc (|
            M.call_closure (|
              F,
              M.get_trait_method (|
                "p3_field::field::PrimeCharacteristicRing",
                F,
                [],
                [],
                "mul_2exp_u64",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      F,
                      M.get_trait_method (|
                        "p3_field::field::PrimeCharacteristicRing",
                        F,
                        [],
                        [],
                        "exp_u64",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, shift |);
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.sub,
                          [
                            M.cast (Ty.path "u64") (M.read (| height |));
                            Value.Integer IntegerKind.U64 1
                          ]
                        |)
                      ]
                    |)
                  |)
                |);
                M.cast (Ty.path "u64") (M.read (| log_height |))
              ]
            |)
          |) in
        M.alloc (|
          M.call_closure (|
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
            M.get_function (| "p3_field::helpers::scale_vec", [], [ EF ] |),
            [
              M.call_closure (|
                EF,
                M.get_trait_method (| "core::ops::arith::Mul", EF, [], [ F ], "mul", [], [] |),
                [
                  M.read (| vanishing_polynomial |);
                  M.call_closure (|
                    F,
                    M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, denominator |) ]
                  |)
                ]
              |);
              M.read (| sum |)
            ]
          |)
        |)
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_interpolate_coset :
  M.IsFunction.C "p3_interpolation::interpolate_coset" interpolate_coset.
Admitted.
Global Typeclasses Opaque interpolate_coset.
