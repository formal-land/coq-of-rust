(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module columns.
  (* StructRecord
    {
      name := "KeccakCols";
      const_params := [];
      ty_params := [ "T" ];
      fields :=
        [
          ("step_flags",
            Ty.apply
              (Ty.path "array")
              [
                M.unevaluated_const
                  (mk_str (| "p3_keccak_air_columns_KeccakCols_step_flags_discriminant" |))
              ]
              [ T ]);
          ("export", T);
          ("preimage",
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 5 ]
              [
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 5 ]
                  [
                    Ty.apply
                      (Ty.path "array")
                      [
                        M.unevaluated_const
                          (mk_str (| "p3_keccak_air_columns_KeccakCols_preimage_discriminant" |))
                      ]
                      [ T ]
                  ]
              ]);
          ("a",
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 5 ]
              [
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 5 ]
                  [
                    Ty.apply
                      (Ty.path "array")
                      [
                        M.unevaluated_const
                          (mk_str (| "p3_keccak_air_columns_KeccakCols_a_discriminant" |))
                      ]
                      [ T ]
                  ]
              ]);
          ("c",
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 5 ]
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 64 ] [ T ] ]);
          ("c_prime",
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 5 ]
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 64 ] [ T ] ]);
          ("a_prime",
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 5 ]
              [
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 5 ]
                  [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 64 ] [ T ] ]
              ]);
          ("a_prime_prime",
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 5 ]
              [
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 5 ]
                  [
                    Ty.apply
                      (Ty.path "array")
                      [
                        M.unevaluated_const
                          (mk_str (|
                            "p3_keccak_air_columns_KeccakCols_a_prime_prime_discriminant"
                          |))
                      ]
                      [ T ]
                  ]
              ]);
          ("a_prime_prime_0_0_bits",
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 64 ] [ T ]);
          ("a_prime_prime_prime_0_0_limbs",
            Ty.apply
              (Ty.path "array")
              [
                M.unevaluated_const
                  (mk_str (|
                    "p3_keccak_air_columns_KeccakCols_a_prime_prime_prime_0_0_limbs_discriminant"
                  |))
              ]
              [ T ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_p3_keccak_air_columns_KeccakCols_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ names :
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 10 ]
                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                  ] :=
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      Value.Array
                        [
                          mk_str (| "step_flags" |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "export" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "preimage" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "a" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "c" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "c_prime" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "a_prime" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "a_prime_prime" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "a_prime_prime_0_0_bits" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "a_prime_prime_prime_0_0_limbs" |) |)
                          |)
                        ]
                    |)
                  |)
                |)
              |) in
            let~ values :
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ] ]
                  ] :=
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Value.Array
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "step_flags"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "export"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "preimage"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "a"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "c"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "c_prime"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "a_prime"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "a_prime_prime"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_keccak_air::columns::KeccakCols",
                                      "a_prime_prime_0_0_bits"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "p3_keccak_air::columns::KeccakCols",
                                          "a_prime_prime_prime_0_0_limbs"
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              |))
                          ]
                      |)
                    |)
                  |)
                |)) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_fields_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "KeccakCols" |) |) |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| names |) |) |));
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| values |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_p3_keccak_air_columns_KeccakCols_T.
  
  Module Impl_p3_keccak_air_columns_KeccakCols_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ].
    
    (*
        pub fn b(&self, x: usize, y: usize, z: usize) -> T {
            debug_assert!(x < 5);
            debug_assert!(y < 5);
            debug_assert!(z < 64);
    
            // B is just a rotation of A', so these are aliases for A' registers.
            // From the spec,
            //     B[y, (2x + 3y) % 5] = ROT(A'[x, y], r[x, y])
            // So,
            //     B[x, y] = f((x + 3y) % 5, x)
            // where f(a, b) = ROT(A'[a, b], r[a, b])
            let a = (x + 3 * y) % 5;
            let b = x;
            let rot = R[a][b] as usize;
            self.a_prime[b][a][(z + 64 - rot) % 64]
        }
    *)
    Definition b (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; x; y; z ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          let z := M.alloc (| z |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [ M.read (| x |); Value.Integer IntegerKind.Usize 5 ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "assertion failed: x < 5" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [ M.read (| y |); Value.Integer IntegerKind.Usize 5 ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "assertion failed: y < 5" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [ M.read (| z |); Value.Integer IntegerKind.Usize 64 ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "assertion failed: z < 64" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ a : Ty.path "usize" :=
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.rem,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.add,
                    [
                      M.read (| x |);
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.mul,
                        [ Value.Integer IntegerKind.Usize 3; M.read (| y |) ]
                      |)
                    ]
                  |);
                  Value.Integer IntegerKind.Usize 5
                ]
              |) in
            let~ b : Ty.path "usize" := M.read (| x |) in
            let~ rot : Ty.path "usize" :=
              M.cast
                (Ty.path "usize")
                (M.read (|
                  M.SubPointer.get_array_field (|
                    M.SubPointer.get_array_field (|
                      get_constant (|
                        "p3_keccak_air::constants::R",
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 5 ]
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 5 ]
                              [ Ty.path "u8" ]
                          ]
                      |),
                      M.read (| a |)
                    |),
                    M.read (| b |)
                  |)
                |)) in
            M.SubPointer.get_array_field (|
              M.SubPointer.get_array_field (|
                M.SubPointer.get_array_field (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_keccak_air::columns::KeccakCols",
                    "a_prime"
                  |),
                  M.read (| b |)
                |),
                M.read (| a |)
              |),
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.rem,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.sub,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [ M.read (| z |); Value.Integer IntegerKind.Usize 64 ]
                      |);
                      M.read (| rot |)
                    ]
                  |);
                  Value.Integer IntegerKind.Usize 64
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_b :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "b" (b T).
    Admitted.
    Global Typeclasses Opaque b.
    
    (*
        pub fn a_prime_prime_prime(&self, y: usize, x: usize, limb: usize) -> T {
            debug_assert!(y < 5);
            debug_assert!(x < 5);
            debug_assert!(limb < U64_LIMBS);
    
            if y == 0 && x == 0 {
                self.a_prime_prime_prime_0_0_limbs[limb]
            } else {
                self.a_prime_prime[y][x][limb]
            }
        }
    *)
    Definition a_prime_prime_prime
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; y; x; limb ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let y := M.alloc (| y |) in
          let x := M.alloc (| x |) in
          let limb := M.alloc (| limb |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [ M.read (| y |); Value.Integer IntegerKind.Usize 5 ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "assertion failed: y < 5" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [ M.read (| x |); Value.Integer IntegerKind.Usize 5 ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "assertion failed: x < 5" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.read (| limb |);
                                                M.read (|
                                                  get_constant (|
                                                    "p3_keccak_air::U64_LIMBS",
                                                    Ty.path "usize"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "assertion failed: limb < U64_LIMBS" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.match_operator (|
              T,
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [ M.read (| y |); Value.Integer IntegerKind.Usize 0 ]
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [ M.read (| x |); Value.Integer IntegerKind.Usize 0 ]
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.SubPointer.get_array_field (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_keccak_air::columns::KeccakCols",
                        "a_prime_prime_prime_0_0_limbs"
                      |),
                      M.read (| limb |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.SubPointer.get_array_field (|
                      M.SubPointer.get_array_field (|
                        M.SubPointer.get_array_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_keccak_air::columns::KeccakCols",
                            "a_prime_prime"
                          |),
                          M.read (| y |)
                        |),
                        M.read (| x |)
                      |),
                      M.read (| limb |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_a_prime_prime_prime :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "a_prime_prime_prime" (a_prime_prime_prime T).
    Admitted.
    Global Typeclasses Opaque a_prime_prime_prime.
  End Impl_p3_keccak_air_columns_KeccakCols_T.
  
  (*
  pub fn input_limb(i: usize) -> usize {
      debug_assert!(i < RATE_LIMBS);
  
      let i_u64 = i / U64_LIMBS;
      let limb_index = i % U64_LIMBS;
  
      // The 5x5 state is treated as y-major, as per the Keccak spec.
      let y = i_u64 / 5;
      let x = i_u64 % 5;
  
      KECCAK_COL_MAP.preimage[y][x][limb_index]
  }
  *)
  Definition input_limb (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ i ] =>
      ltac:(M.monadic
        (let i := M.alloc (| i |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.read (|
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.read (|
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.lt,
                                            [
                                              M.read (| i |);
                                              M.read (|
                                                get_constant (|
                                                  "p3_keccak_air::RATE_LIMBS",
                                                  Ty.path "usize"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic", [], [] |),
                                        [ mk_str (| "assertion failed: i < RATE_LIMBS" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |) in
          let~ i_u64 : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.div,
              [
                M.read (| i |);
                M.read (| get_constant (| "p3_keccak_air::U64_LIMBS", Ty.path "usize" |) |)
              ]
            |) in
          let~ limb_index : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.rem,
              [
                M.read (| i |);
                M.read (| get_constant (| "p3_keccak_air::U64_LIMBS", Ty.path "usize" |) |)
              ]
            |) in
          let~ y : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.div,
              [ M.read (| i_u64 |); Value.Integer IntegerKind.Usize 5 ]
            |) in
          let~ x : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.rem,
              [ M.read (| i_u64 |); Value.Integer IntegerKind.Usize 5 ]
            |) in
          M.SubPointer.get_array_field (|
            M.SubPointer.get_array_field (|
              M.SubPointer.get_array_field (|
                M.SubPointer.get_struct_record_field (|
                  get_constant (|
                    "p3_keccak_air::columns::KECCAK_COL_MAP",
                    Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ Ty.path "usize" ]
                  |),
                  "p3_keccak_air::columns::KeccakCols",
                  "preimage"
                |),
                M.read (| y |)
              |),
              M.read (| x |)
            |),
            M.read (| limb_index |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_input_limb :
    M.IsFunction.C "p3_keccak_air::columns::input_limb" input_limb.
  Admitted.
  Global Typeclasses Opaque input_limb.
  
  (*
  pub fn output_limb(i: usize) -> usize {
      debug_assert!(i < RATE_LIMBS);
  
      let i_u64 = i / U64_LIMBS;
      let limb_index = i % U64_LIMBS;
  
      // The 5x5 state is treated as y-major, as per the Keccak spec.
      let y = i_u64 / 5;
      let x = i_u64 % 5;
  
      KECCAK_COL_MAP.a_prime_prime_prime(y, x, limb_index)
  }
  *)
  Definition output_limb (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ i ] =>
      ltac:(M.monadic
        (let i := M.alloc (| i |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.read (|
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.read (|
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.lt,
                                            [
                                              M.read (| i |);
                                              M.read (|
                                                get_constant (|
                                                  "p3_keccak_air::RATE_LIMBS",
                                                  Ty.path "usize"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic", [], [] |),
                                        [ mk_str (| "assertion failed: i < RATE_LIMBS" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |) in
          let~ i_u64 : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.div,
              [
                M.read (| i |);
                M.read (| get_constant (| "p3_keccak_air::U64_LIMBS", Ty.path "usize" |) |)
              ]
            |) in
          let~ limb_index : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.rem,
              [
                M.read (| i |);
                M.read (| get_constant (| "p3_keccak_air::U64_LIMBS", Ty.path "usize" |) |)
              ]
            |) in
          let~ y : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.div,
              [ M.read (| i_u64 |); Value.Integer IntegerKind.Usize 5 ]
            |) in
          let~ x : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.rem,
              [ M.read (| i_u64 |); Value.Integer IntegerKind.Usize 5 ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ Ty.path "usize" ],
                "a_prime_prime_prime",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  get_constant (|
                    "p3_keccak_air::columns::KECCAK_COL_MAP",
                    Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ Ty.path "usize" ]
                  |)
                |);
                M.read (| y |);
                M.read (| x |);
                M.read (| limb_index |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_output_limb :
    M.IsFunction.C "p3_keccak_air::columns::output_limb" output_limb.
  Admitted.
  Global Typeclasses Opaque output_limb.
  
  Definition value_NUM_KECCAK_COLS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "usize",
          M.get_function (|
            "core::mem::size_of",
            [],
            [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ Ty.path "u8" ] ]
          |),
          []
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_NUM_KECCAK_COLS :
    M.IsFunction.C "p3_keccak_air::columns::NUM_KECCAK_COLS" value_NUM_KECCAK_COLS.
  Admitted.
  Global Typeclasses Opaque value_NUM_KECCAK_COLS.
  
  Definition value_KECCAK_COL_MAP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ Ty.path "usize" ],
          M.get_function (| "p3_keccak_air::columns::make_col_map", [], [] |),
          []
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_KECCAK_COL_MAP :
    M.IsFunction.C "p3_keccak_air::columns::KECCAK_COL_MAP" value_KECCAK_COL_MAP.
  Admitted.
  Global Typeclasses Opaque value_KECCAK_COL_MAP.
  
  (*
  const fn make_col_map() -> KeccakCols<usize> {
      let indices_arr = indices_arr::<NUM_KECCAK_COLS>();
      unsafe { transmute::<[usize; NUM_KECCAK_COLS], KeccakCols<usize>>(indices_arr) }
  }
  *)
  Definition make_col_map (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.read (|
          let~ indices_arr :
              Ty.apply
                (Ty.path "array")
                [ Value.Integer IntegerKind.Usize 2633 ]
                [ Ty.path "usize" ] :=
            M.call_closure (|
              Ty.apply
                (Ty.path "array")
                [ Value.Integer IntegerKind.Usize 2633 ]
                [ Ty.path "usize" ],
              M.get_function (|
                "p3_util::indices_arr",
                [ Value.Integer IntegerKind.Usize 2633 ],
                []
              |),
              []
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ Ty.path "usize" ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 2633 ]
                    [ Ty.path "usize" ];
                  Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ Ty.path "usize" ]
                ]
              |),
              [ M.read (| indices_arr |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_make_col_map :
    M.IsFunction.C "p3_keccak_air::columns::make_col_map" make_col_map.
  Admitted.
  Global Typeclasses Opaque make_col_map.
  
  Module Impl_core_borrow_Borrow_p3_keccak_air_columns_KeccakCols_T_for_slice_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
    
    (*
        fn borrow(&self) -> &KeccakCols<T> {
            debug_assert_eq!(self.len(), NUM_KECCAK_COLS);
            let (prefix, shorts, suffix) = unsafe { self.align_to::<KeccakCols<T>>() };
            debug_assert!(prefix.is_empty(), "Alignment should match");
            debug_assert!(suffix.is_empty(), "Alignment should match");
            debug_assert_eq!(shorts.len(), 1);
            &shorts[0]
        }
    *)
    Definition borrow (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_constant (|
                                        "p3_keccak_air::columns::NUM_KECCAK_COLS",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val := M.copy (| γ0_0 |) in
                                    let right_val := M.copy (| γ0_1 |) in
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.read (|
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let~ kind :
                                                      Ty.path "core::panicking::AssertKind" :=
                                                    Value.StructTuple
                                                      "core::panicking::AssertKind::Eq"
                                                      []
                                                      []
                                                      [] in
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "never",
                                                      M.get_function (|
                                                        "core::panicking::assert_failed",
                                                        [],
                                                        [ Ty.path "usize"; Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.read (| kind |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| left_val |) |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          |)
                                                        |);
                                                        Value.StructTuple
                                                          "core::option::Option::None"
                                                          []
                                                          [ Ty.path "core::fmt::Arguments" ]
                                                          []
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ]
                        ];
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ T ],
                    "align_to",
                    [],
                    [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                    let prefix := M.copy (| γ0_0 |) in
                    let shorts := M.copy (| γ0_1 |) in
                    let suffix := M.copy (| γ0_2 |) in
                    let~ _ : Ty.tuple [] :=
                      M.read (|
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.read (|
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_associated_function (|
                                                        Ty.apply (Ty.path "slice") [] [ T ],
                                                        "is_empty",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| prefix |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::panic_fmt",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::Arguments",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_const",
                                                        [ Value.Integer IntegerKind.Usize 1 ],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Value.Array
                                                                  [
                                                                    mk_str (|
                                                                      "Alignment should match"
                                                                    |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.read (|
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.read (|
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_associated_function (|
                                                        Ty.apply (Ty.path "slice") [] [ T ],
                                                        "is_empty",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| suffix |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::panic_fmt",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::Arguments",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_const",
                                                        [ Value.Integer IntegerKind.Usize 1 ],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Value.Array
                                                                  [
                                                                    mk_str (|
                                                                      "Alignment should match"
                                                                    |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.read (|
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.read (|
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "slice")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_keccak_air::columns::KeccakCols")
                                                          []
                                                          [ T ]
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| shorts |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                                            |)
                                          ]
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let left_val := M.copy (| γ0_0 |) in
                                            let right_val := M.copy (| γ0_1 |) in
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              BinOp.eq,
                                                              [
                                                                M.read (|
                                                                  M.deref (|
                                                                    M.read (| left_val |)
                                                                  |)
                                                                |);
                                                                M.read (|
                                                                  M.deref (|
                                                                    M.read (| right_val |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          let~ kind :
                                                              Ty.path
                                                                "core::panicking::AssertKind" :=
                                                            Value.StructTuple
                                                              "core::panicking::AssertKind::Eq"
                                                              []
                                                              []
                                                              [] in
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.path "never",
                                                              M.get_function (|
                                                                "core::panicking::assert_failed",
                                                                [],
                                                                [ Ty.path "usize"; Ty.path "usize" ]
                                                              |),
                                                              [
                                                                M.read (| kind |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |);
                                                                Value.StructTuple
                                                                  "core::option::Option::None"
                                                                  []
                                                                  [ Ty.path "core::fmt::Arguments" ]
                                                                  []
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| shorts |) |),
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |)
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T)) ].
  End Impl_core_borrow_Borrow_p3_keccak_air_columns_KeccakCols_T_for_slice_T.
  
  Module Impl_core_borrow_BorrowMut_p3_keccak_air_columns_KeccakCols_T_for_slice_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
    
    (*
        fn borrow_mut(&mut self) -> &mut KeccakCols<T> {
            debug_assert_eq!(self.len(), NUM_KECCAK_COLS);
            let (prefix, shorts, suffix) = unsafe { self.align_to_mut::<KeccakCols<T>>() };
            debug_assert!(prefix.is_empty(), "Alignment should match");
            debug_assert!(suffix.is_empty(), "Alignment should match");
            debug_assert_eq!(shorts.len(), 1);
            &mut shorts[0]
        }
    *)
    Definition borrow_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.read (|
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    Value.Tuple
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_constant (|
                                            "p3_keccak_air::columns::NUM_KECCAK_COLS",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val := M.copy (| γ0_0 |) in
                                        let right_val := M.copy (| γ0_1 |) in
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (|
                                                              M.deref (| M.read (| left_val |) |)
                                                            |);
                                                            M.read (|
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      let~ kind :
                                                          Ty.path "core::panicking::AssertKind" :=
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                          []
                                                          [] in
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "never",
                                                          M.get_function (|
                                                            "core::panicking::assert_failed",
                                                            [],
                                                            [ Ty.path "usize"; Ty.path "usize" ]
                                                          |),
                                                          [
                                                            M.read (| kind |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| left_val |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| right_val |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            Value.StructTuple
                                                              "core::option::Option::None"
                                                              []
                                                              [ Ty.path "core::fmt::Arguments" ]
                                                              []
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ]
                            ];
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                        ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "align_to_mut",
                        [],
                        [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ]
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let prefix := M.copy (| γ0_0 |) in
                        let shorts := M.copy (| γ0_1 |) in
                        let suffix := M.copy (| γ0_2 |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.read (|
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "is_empty",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| prefix |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.call_closure (|
                                                      Ty.path "never",
                                                      M.get_function (|
                                                        "core::panicking::panic_fmt",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          Ty.path "core::fmt::Arguments",
                                                          M.get_associated_function (|
                                                            Ty.path "core::fmt::Arguments",
                                                            "new_const",
                                                            [ Value.Integer IntegerKind.Usize 1 ],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        mk_str (|
                                                                          "Alignment should match"
                                                                        |)
                                                                      ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.read (|
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "is_empty",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| suffix |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.call_closure (|
                                                      Ty.path "never",
                                                      M.get_function (|
                                                        "core::panicking::panic_fmt",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          Ty.path "core::fmt::Arguments",
                                                          M.get_associated_function (|
                                                            Ty.path "core::fmt::Arguments",
                                                            "new_const",
                                                            [ Value.Integer IntegerKind.Usize 1 ],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        mk_str (|
                                                                          "Alignment should match"
                                                                        |)
                                                                      ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.read (|
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Value.Tuple
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_keccak_air::columns::KeccakCols")
                                                              []
                                                              [ T ]
                                                          ],
                                                        "len",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| shorts |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                                                |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val := M.copy (| γ0_0 |) in
                                                let right_val := M.copy (| γ0_1 |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              UnOp.not (|
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |);
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              let~ kind :
                                                                  Ty.path
                                                                    "core::panicking::AssertKind" :=
                                                                Value.StructTuple
                                                                  "core::panicking::AssertKind::Eq"
                                                                  []
                                                                  []
                                                                  [] in
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path "never",
                                                                  M.get_function (|
                                                                    "core::panicking::assert_failed",
                                                                    [],
                                                                    [
                                                                      Ty.path "usize";
                                                                      Ty.path "usize"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (| kind |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| left_val |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| right_val |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    Value.StructTuple
                                                                      "core::option::Option::None"
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "core::fmt::Arguments"
                                                                      ]
                                                                      []
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |)))
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| shorts |) |),
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::borrow::BorrowMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_keccak_air::columns::KeccakCols") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T)) ].
  End Impl_core_borrow_BorrowMut_p3_keccak_air_columns_KeccakCols_T_for_slice_T.
End columns.
