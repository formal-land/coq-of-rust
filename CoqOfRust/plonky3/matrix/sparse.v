(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sparse.
  (* StructRecord
    {
      name := "CsrMatrix";
      const_params := [];
      ty_params := [ "T" ];
      fields :=
        [
          ("width", Ty.path "usize");
          ("nonzero_values",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ]);
          ("row_indices",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_p3_matrix_sparse_CsrMatrix_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CsrMatrix" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "width" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_matrix::sparse::CsrMatrix",
                        "width"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "nonzero_values" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_matrix::sparse::CsrMatrix",
                        "nonzero_values"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "row_indices" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_matrix::sparse::CsrMatrix",
                            "row_indices"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_p3_matrix_sparse_CsrMatrix_T.
  
  Module Impl_p3_matrix_sparse_CsrMatrix_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ].
    
    (*
        fn row_index_range(&self, r: usize) -> Range<usize> {
            debug_assert!(r < self.height());
            self.row_indices[r]..self.row_indices[r + 1]
        }
    *)
    Definition row_index_range
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let r := M.alloc (| r |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [
                                            M.read (| r |);
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_trait_method (|
                                                "p3_matrix::Matrix",
                                                Ty.apply
                                                  (Ty.path "p3_matrix::sparse::CsrMatrix")
                                                  []
                                                  [ T ],
                                                [],
                                                [ T ],
                                                "height",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: r < self.height()" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "core::ops::range::Range"
                []
                [ Ty.path "usize" ]
                [
                  ("start",
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [ Ty.path "usize" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_matrix::sparse::CsrMatrix",
                                "row_indices"
                              |)
                            |);
                            M.read (| r |)
                          ]
                        |)
                      |)
                    |));
                  ("end_",
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [ Ty.path "usize" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_matrix::sparse::CsrMatrix",
                                "row_indices"
                              |)
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| r |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          ]
                        |)
                      |)
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_row_index_range :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "row_index_range" (row_index_range T).
    Admitted.
    Global Typeclasses Opaque row_index_range.
    
    (*
        pub fn sparse_row(&self, r: usize) -> &[(usize, T)] {
            &self.nonzero_values[self.row_index_range(r)]
        }
    *)
    Definition sparse_row (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let r := M.alloc (| r |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_matrix::sparse::CsrMatrix",
                          "nonzero_values"
                        |)
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                          "row_index_range",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| r |)
                        ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_sparse_row :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "sparse_row" (sparse_row T).
    Admitted.
    Global Typeclasses Opaque sparse_row.
    
    (*
        pub fn sparse_row_mut(&mut self, r: usize) -> &mut [(usize, T)] {
            let range = self.row_index_range(r);
            &mut self.nonzero_values[range]
        }
    *)
    Definition sparse_row_mut
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let r := M.alloc (| r |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ range :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                        "row_index_range",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                        M.read (| r |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                            M.get_trait_method (|
                              "core::ops::index::IndexMut",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ],
                              "index_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_matrix::sparse::CsrMatrix",
                                  "nonzero_values"
                                |)
                              |);
                              M.read (| range |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_sparse_row_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "sparse_row_mut" (sparse_row_mut T).
    Admitted.
    Global Typeclasses Opaque sparse_row_mut.
    
    (*
        pub fn rand_fixed_row_weight<R: Rng>(
            rng: &mut R,
            rows: usize,
            cols: usize,
            row_weight: usize,
        ) -> Self
        where
            T: Default,
            StandardUniform: Distribution<T>,
        {
            let nonzero_values = iter::repeat_with(|| (rng.random_range(0..cols), rng.random()))
                .take(rows * row_weight)
                .collect();
            let row_indices = (0..=rows).map(|r| r * row_weight).collect();
            Self {
                width: cols,
                nonzero_values,
                row_indices,
            }
        }
    *)
    Definition rand_fixed_row_weight
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ R ], [ rng; rows; cols; row_weight ] =>
        ltac:(M.monadic
          (let rng := M.alloc (| rng |) in
          let rows := M.alloc (| rows |) in
          let cols := M.alloc (| cols |) in
          let row_weight := M.alloc (| row_weight |) in
          M.read (|
            let~ nonzero_values :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                          []
                          [ Ty.function [ Ty.tuple [] ] (Ty.tuple [ Ty.path "usize"; T ]) ]
                      ],
                    [],
                    [],
                    "collect",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.tuple [ Ty.path "usize"; T ]; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                            []
                            [ Ty.function [ Ty.tuple [] ] (Ty.tuple [ Ty.path "usize"; T ]) ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                          []
                          [ Ty.function [ Ty.tuple [] ] (Ty.tuple [ Ty.path "usize"; T ]) ],
                        [],
                        [],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                            []
                            [ Ty.function [ Ty.tuple [] ] (Ty.tuple [ Ty.path "usize"; T ]) ],
                          M.get_function (|
                            "core::iter::sources::repeat_with::repeat_with",
                            [],
                            [
                              Ty.tuple [ Ty.path "usize"; T ];
                              Ty.function [ Ty.tuple [] ] (Ty.tuple [ Ty.path "usize"; T ])
                            ]
                          |),
                          [
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Ty.apply
                                          (Ty.path "*")
                                          []
                                          [
                                            Ty.function
                                              [ Ty.tuple [] ]
                                              (Ty.tuple [ Ty.path "usize"; T ])
                                          ],
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (Value.Tuple
                                                [
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_trait_method (|
                                                      "rand::rng::Rng",
                                                      R,
                                                      [],
                                                      [],
                                                      "random_range",
                                                      [],
                                                      [
                                                        Ty.path "usize";
                                                        Ty.apply
                                                          (Ty.path "core::ops::range::Range")
                                                          []
                                                          [ Ty.path "usize" ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| rng |) |)
                                                      |);
                                                      Value.StructRecord
                                                        "core::ops::range::Range"
                                                        []
                                                        [ Ty.path "usize" ]
                                                        [
                                                          ("start",
                                                            Value.Integer IntegerKind.Usize 0);
                                                          ("end_", M.read (| cols |))
                                                        ]
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    T,
                                                    M.get_trait_method (|
                                                      "rand::rng::Rng",
                                                      R,
                                                      [],
                                                      [],
                                                      "random",
                                                      [],
                                                      [ T ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| rng |) |)
                                                      |)
                                                    ]
                                                  |)
                                                ]))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.mul,
                          [ M.read (| rows |); M.read (| row_weight |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ row_indices :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ops::range::RangeInclusive")
                          []
                          [ Ty.path "usize" ];
                        Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                      ],
                    [],
                    [],
                    "collect",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ops::range::RangeInclusive")
                            []
                            [ Ty.path "usize" ];
                          Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::ops::range::RangeInclusive")
                          []
                          [ Ty.path "usize" ],
                        [],
                        [],
                        "map",
                        [],
                        [
                          Ty.path "usize";
                          Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::range::RangeInclusive")
                            []
                            [ Ty.path "usize" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ops::range::RangeInclusive")
                              []
                              [ Ty.path "usize" ],
                            "new",
                            [],
                            []
                          |),
                          [ Value.Integer IntegerKind.Usize 0; M.read (| rows |) ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.path "usize")
                                      ],
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let r := M.copy (| γ |) in
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.mul,
                                            [ M.read (| r |); M.read (| row_weight |) ]
                                          |)))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "p3_matrix::sparse::CsrMatrix"
                []
                [ T ]
                [
                  ("width", M.read (| cols |));
                  ("nonzero_values", M.read (| nonzero_values |));
                  ("row_indices", M.read (| row_indices |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_rand_fixed_row_weight :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "rand_fixed_row_weight" (rand_fixed_row_weight T).
    Admitted.
    Global Typeclasses Opaque rand_fixed_row_weight.
  End Impl_p3_matrix_sparse_CsrMatrix_T.
  
  Module Impl_p3_matrix_Matrix_where_core_clone_Clone_T_where_core_default_Default_T_where_core_marker_Send_T_where_core_marker_Sync_T_T_for_p3_matrix_sparse_CsrMatrix_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ].
    
    (*
        fn width(&self) -> usize {
            self.width
        }
    *)
    Definition width (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "p3_matrix::sparse::CsrMatrix",
              "width"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn height(&self) -> usize {
            self.row_indices.len() - 1
        }
    *)
    Definition height (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.sub,
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                  "len",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::sparse::CsrMatrix",
                      "row_indices"
                    |)
                  |)
                ]
              |);
              Value.Integer IntegerKind.Usize 1
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn get(&self, r: usize, c: usize) -> T {
            self.sparse_row(r)
                .iter()
                .find(|(col, _)| *col == c)
                .map(|(_, val)| val.clone())
                .unwrap_or_default()
        }
    *)
    Definition get (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r; c ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let r := M.alloc (| r |) in
          let c := M.alloc (| c |) in
          M.call_closure (|
            T,
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              "unwrap_or_default",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ] ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.tuple [ Ty.path "usize"; T ] ],
                      [],
                      [],
                      "find",
                      [],
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ]
                              ]
                          ]
                          (Ty.path "bool")
                      ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              []
                              [ Ty.tuple [ Ty.path "usize"; T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ],
                              "iter",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          []
                                          [ Ty.tuple [ Ty.path "usize"; T ] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                                      "sparse_row",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      M.read (| r |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.tuple [ Ty.path "usize"; T ] ]
                                                ]
                                            ]
                                        ]
                                        (Ty.path "bool")
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ := M.read (| γ |) in
                                        let γ2_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ2_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let col := M.alloc (| γ2_0 |) in
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| col |) |) |);
                                            M.read (| c |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.tuple [ Ty.path "usize"; T ] ]
                                        ]
                                    ]
                                    T
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.read (| γ |) in
                                    let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let val := M.alloc (| γ1_1 |) in
                                    M.call_closure (|
                                      T,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        T,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| val |) |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        type Row<'a>
            = <Vec<T> as IntoIterator>::IntoIter
        where
            Self: 'a;
    *)
    Definition _Row (T : Ty.t) : Ty.t :=
      Ty.associated_in_trait
        "core::iter::traits::collect::IntoIterator"
        []
        []
        (Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ])
        "IntoIter".
    
    (*
        fn row(&self, r: usize) -> Self::Row<'_> {
            let mut row = vec![T::default(); self.width()];
            for (c, v) in self.sparse_row(r) {
                row[*c] = v.clone();
            }
            row.into_iter()
        }
    *)
    Definition row (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let r := M.alloc (| r |) in
          M.read (|
            let~ row :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_function (| "alloc::vec::from_elem", [], [ T ] |),
                  [
                    M.call_closure (|
                      T,
                      M.get_trait_method (|
                        "core::default::Default",
                        T,
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |);
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_trait_method (|
                        "p3_matrix::Matrix",
                        Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                        [],
                        [ T ],
                        "width",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.use
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.tuple [ Ty.path "usize"; T ] ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ Ty.path "usize"; T ] ] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "p3_matrix::sparse::CsrMatrix") [] [ T ],
                            "sparse_row",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            M.read (| r |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.tuple [ Ty.path "usize"; T ] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [ Ty.tuple [ Ty.path "usize"; T ] ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ0_0 := M.read (| γ0_0 |) in
                                      let γ2_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ2_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let c := M.alloc (| γ2_0 |) in
                                      let v := M.alloc (| γ2_1 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.write (|
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply (Ty.path "&mut") [] [ T ],
                                                M.get_trait_method (|
                                                  "core::ops::index::IndexMut",
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ T; Ty.path "alloc::alloc::Global" ],
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "index_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (| Pointer.Kind.MutRef, row |);
                                                  M.read (| M.deref (| M.read (| c |) |) |)
                                                ]
                                              |)
                                            |),
                                            M.call_closure (|
                                              T,
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                T,
                                                [],
                                                [],
                                                "clone",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| v |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::into_iter::IntoIter")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  [],
                  "into_iter",
                  [],
                  []
                |),
                [ M.read (| row |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "p3_matrix::Matrix"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *)
        [
          ("width", InstanceField.Method (width T));
          ("height", InstanceField.Method (height T));
          ("get", InstanceField.Method (get T));
          ("Row", InstanceField.Ty (_Row T));
          ("row", InstanceField.Method (row T))
        ].
  End Impl_p3_matrix_Matrix_where_core_clone_Clone_T_where_core_default_Default_T_where_core_marker_Send_T_where_core_marker_Sync_T_T_for_p3_matrix_sparse_CsrMatrix_T.
End sparse.
