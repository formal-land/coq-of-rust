(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module stack.
  (* StructRecord
    {
      name := "VerticalPair";
      const_params := [];
      ty_params := [ "First"; "Second" ];
      fields := [ ("first", First); ("second", Second) ];
    } *)
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_First_where_core_marker_Copy_Second_for_p3_matrix_stack_VerticalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ].
    
    Axiom Implements :
      forall (First Second : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self First Second)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_First_where_core_marker_Copy_Second_for_p3_matrix_stack_VerticalPair_First_Second.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_First_where_core_clone_Clone_Second_for_p3_matrix_stack_VerticalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ].
    
    (* Clone *)
    Definition clone
        (First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self First Second in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ] ],
              self
            |) in
          Value.mkStructRecord
            "p3_matrix::stack::VerticalPair"
            []
            [ First; Second ]
            [
              ("first",
                M.call_closure (|
                  First,
                  M.get_trait_method (| "core::clone::Clone", First, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_matrix::stack::VerticalPair",
                            "first"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("second",
                M.call_closure (|
                  Second,
                  M.get_trait_method (| "core::clone::Clone", Second, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_matrix::stack::VerticalPair",
                            "second"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (First Second : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self First Second)
        (* Instance *) [ ("clone", InstanceField.Method (clone First Second)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_First_where_core_clone_Clone_Second_for_p3_matrix_stack_VerticalPair_First_Second.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_First_where_core_fmt_Debug_Second_for_p3_matrix_stack_VerticalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ].
    
    (* Debug *)
    Definition fmt
        (First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self First Second in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "VerticalPair" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "first" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_matrix::stack::VerticalPair",
                        "first"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "second" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply (Ty.path "&") [] [ Second ],
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_matrix::stack::VerticalPair",
                            "second"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (First Second : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self First Second)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt First Second)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_First_where_core_fmt_Debug_Second_for_p3_matrix_stack_VerticalPair_First_Second.
  
  (* StructRecord
    {
      name := "HorizontalPair";
      const_params := [];
      ty_params := [ "First"; "Second" ];
      fields := [ ("first", First); ("second", Second) ];
    } *)
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_First_where_core_marker_Copy_Second_for_p3_matrix_stack_HorizontalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ].
    
    Axiom Implements :
      forall (First Second : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self First Second)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_First_where_core_marker_Copy_Second_for_p3_matrix_stack_HorizontalPair_First_Second.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_First_where_core_clone_Clone_Second_for_p3_matrix_stack_HorizontalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ].
    
    (* Clone *)
    Definition clone
        (First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self First Second in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ] ],
              self
            |) in
          Value.mkStructRecord
            "p3_matrix::stack::HorizontalPair"
            []
            [ First; Second ]
            [
              ("first",
                M.call_closure (|
                  First,
                  M.get_trait_method (| "core::clone::Clone", First, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_matrix::stack::HorizontalPair",
                            "first"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("second",
                M.call_closure (|
                  Second,
                  M.get_trait_method (| "core::clone::Clone", Second, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_matrix::stack::HorizontalPair",
                            "second"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (First Second : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self First Second)
        (* Instance *) [ ("clone", InstanceField.Method (clone First Second)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_First_where_core_clone_Clone_Second_for_p3_matrix_stack_HorizontalPair_First_Second.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_First_where_core_fmt_Debug_Second_for_p3_matrix_stack_HorizontalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ].
    
    (* Debug *)
    Definition fmt
        (First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self First Second in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "HorizontalPair" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "first" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_matrix::stack::HorizontalPair",
                        "first"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "second" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply (Ty.path "&") [] [ Second ],
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_matrix::stack::HorizontalPair",
                            "second"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (First Second : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self First Second)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt First Second)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_First_where_core_fmt_Debug_Second_for_p3_matrix_stack_HorizontalPair_First_Second.
  
  Module Impl_p3_matrix_stack_VerticalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ].
    
    (*
        pub fn new<T>(first: First, second: Second) -> Self
        where
            T: Send + Sync,
            First: Matrix<T>,
            Second: Matrix<T>,
        {
            assert_eq!(first.width(), second.width());
            Self { first, second }
        }
    *)
    Definition new
        (First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self First Second in
      match ε, τ, α with
      | [], [ T ], [ first; second ] =>
        ltac:(M.monadic
          (let first := M.alloc (| First, first |) in
          let second := M.alloc (| Second, second |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                      ],
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "usize",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "p3_matrix::Matrix",
                                First,
                                [],
                                [ T ],
                                "width",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, first |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "usize",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "p3_matrix::Matrix",
                                Second,
                                [],
                                [ T ],
                                "width",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, second |) ]
                            |)
                          |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val :=
                          M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                        let right_val :=
                          M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  Ty.tuple [],
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ],
              Value.mkStructRecord
                "p3_matrix::stack::VerticalPair"
                []
                [ First; Second ]
                [ ("first", M.read (| first |)); ("second", M.read (| second |)) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (First Second : Ty.t),
      M.IsAssociatedFunction.C (Self First Second) "new" (new First Second).
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_p3_matrix_stack_VerticalPair_First_Second.
  
  Module Impl_p3_matrix_stack_HorizontalPair_First_Second.
    Definition Self (First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ].
    
    (*
        pub fn new<T>(first: First, second: Second) -> Self
        where
            T: Send + Sync,
            First: Matrix<T>,
            Second: Matrix<T>,
        {
            assert_eq!(first.height(), second.height());
            Self { first, second }
        }
    *)
    Definition new
        (First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self First Second in
      match ε, τ, α with
      | [], [ T ], [ first; second ] =>
        ltac:(M.monadic
          (let first := M.alloc (| First, first |) in
          let second := M.alloc (| Second, second |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                      ],
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "usize",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "p3_matrix::Matrix",
                                First,
                                [],
                                [ T ],
                                "height",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, first |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "usize",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "p3_matrix::Matrix",
                                Second,
                                [],
                                [ T ],
                                "height",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, second |) ]
                            |)
                          |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val :=
                          M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                        let right_val :=
                          M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  Ty.tuple [],
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ],
              Value.mkStructRecord
                "p3_matrix::stack::HorizontalPair"
                []
                [ First; Second ]
                [ ("first", M.read (| first |)); ("second", M.read (| second |)) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (First Second : Ty.t),
      M.IsAssociatedFunction.C (Self First Second) "new" (new First Second).
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_p3_matrix_stack_HorizontalPair_First_Second.
  
  Module Impl_p3_matrix_Matrix_where_core_marker_Send_T_where_core_marker_Sync_T_where_p3_matrix_Matrix_First_T_where_p3_matrix_Matrix_Second_T_T_for_p3_matrix_stack_VerticalPair_First_Second.
    Definition Self (T First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ].
    
    (*
        fn width(&self) -> usize {
            self.first.width()
        }
    *)
    Definition width
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (| "p3_matrix::Matrix", First, [], [ T ], "width", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_matrix::stack::VerticalPair",
                  "first"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn height(&self) -> usize {
            self.first.height() + self.second.height()
        }
    *)
    Definition height
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.add,
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (| "p3_matrix::Matrix", First, [], [ T ], "height", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::stack::VerticalPair",
                      "first"
                    |)
                  |)
                ]
              |);
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (| "p3_matrix::Matrix", Second, [], [ T ], "height", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::stack::VerticalPair",
                      "second"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn get(&self, r: usize, c: usize) -> T {
            if r < self.first.height() {
                self.first.get(r, c)
            } else {
                self.second.get(r - self.first.height(), c)
            }
        }
    *)
    Definition get
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self; r; c ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          let c := M.alloc (| Ty.path "usize", c |) in
          M.read (|
            M.match_operator (|
              T,
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.lt,
                            [
                              M.read (| r |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "p3_matrix::Matrix",
                                  First,
                                  [],
                                  [ T ],
                                  "height",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_matrix::stack::VerticalPair",
                                      "first"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      T,
                      M.call_closure (|
                        T,
                        M.get_trait_method (|
                          "p3_matrix::Matrix",
                          First,
                          [],
                          [ T ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_matrix::stack::VerticalPair",
                              "first"
                            |)
                          |);
                          M.read (| r |);
                          M.read (| c |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      T,
                      M.call_closure (|
                        T,
                        M.get_trait_method (|
                          "p3_matrix::Matrix",
                          Second,
                          [],
                          [ T ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_matrix::stack::VerticalPair",
                              "second"
                            |)
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.sub,
                            [
                              M.read (| r |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "p3_matrix::Matrix",
                                  First,
                                  [],
                                  [ T ],
                                  "height",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_matrix::stack::VerticalPair",
                                      "first"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.read (| c |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        type Row<'a>
            = EitherRow<First::Row<'a>, Second::Row<'a>>
        where
            Self: 'a;
    *)
    Definition _Row (T First Second : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "p3_matrix::stack::EitherRow")
        []
        [
          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
        ].
    
    (*
        fn row(&self, r: usize) -> Self::Row<'_> {
            if r < self.first.height() {
                EitherRow::Left(self.first.row(r))
            } else {
                EitherRow::Right(self.second.row(r - self.first.height()))
            }
        }
    *)
    Definition row
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "p3_matrix::stack::EitherRow")
                []
                [
                  Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
                  Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.lt,
                            [
                              M.read (| r |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "p3_matrix::Matrix",
                                  First,
                                  [],
                                  [ T ],
                                  "height",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_matrix::stack::VerticalPair",
                                      "first"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "p3_matrix::stack::EitherRow")
                        []
                        [
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
                        ],
                      Value.StructTuple
                        "p3_matrix::stack::EitherRow::Left"
                        []
                        [
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
                        ]
                        [
                          M.call_closure (|
                            Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row",
                            M.get_trait_method (|
                              "p3_matrix::Matrix",
                              First,
                              [],
                              [ T ],
                              "row",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_matrix::stack::VerticalPair",
                                  "first"
                                |)
                              |);
                              M.read (| r |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.apply
                        (Ty.path "p3_matrix::stack::EitherRow")
                        []
                        [
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
                        ],
                      Value.StructTuple
                        "p3_matrix::stack::EitherRow::Right"
                        []
                        [
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
                          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
                        ]
                        [
                          M.call_closure (|
                            Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row",
                            M.get_trait_method (|
                              "p3_matrix::Matrix",
                              Second,
                              [],
                              [ T ],
                              "row",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_matrix::stack::VerticalPair",
                                  "second"
                                |)
                              |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.sub,
                                [
                                  M.read (| r |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "p3_matrix::Matrix",
                                      First,
                                      [],
                                      [ T ],
                                      "height",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "p3_matrix::stack::VerticalPair",
                                          "first"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn row_slice(&self, r: usize) -> impl Deref<Target = [T]> {
            if r < self.first.height() {
                EitherRow::Left(self.first.row_slice(r))
            } else {
                EitherRow::Right(self.second.row_slice(r - self.first.height()))
            }
        }
    *)
    Definition row_slice
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::VerticalPair") [] [ First; Second ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "p3_matrix::stack::EitherRow")
                []
                [
                  Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "{{synthetic}}'2";
                  Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "{{synthetic}}'2"
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.lt,
                            [
                              M.read (| r |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "p3_matrix::Matrix",
                                  First,
                                  [],
                                  [ T ],
                                  "height",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_matrix::stack::VerticalPair",
                                      "first"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "p3_matrix::stack::EitherRow")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            First
                            "{{synthetic}}'2";
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            Second
                            "{{synthetic}}'2"
                        ],
                      Value.StructTuple
                        "p3_matrix::stack::EitherRow::Left"
                        []
                        [
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            First
                            "{{synthetic}}'2";
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            Second
                            "{{synthetic}}'2"
                        ]
                        [
                          M.call_closure (|
                            Ty.associated_in_trait
                              "p3_matrix::Matrix"
                              []
                              [ T ]
                              First
                              "{{synthetic}}'2",
                            M.get_trait_method (|
                              "p3_matrix::Matrix",
                              First,
                              [],
                              [ T ],
                              "row_slice",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_matrix::stack::VerticalPair",
                                  "first"
                                |)
                              |);
                              M.read (| r |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.apply
                        (Ty.path "p3_matrix::stack::EitherRow")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            First
                            "{{synthetic}}'2";
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            Second
                            "{{synthetic}}'2"
                        ],
                      Value.StructTuple
                        "p3_matrix::stack::EitherRow::Right"
                        []
                        [
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            First
                            "{{synthetic}}'2";
                          Ty.associated_in_trait
                            "p3_matrix::Matrix"
                            []
                            [ T ]
                            Second
                            "{{synthetic}}'2"
                        ]
                        [
                          M.call_closure (|
                            Ty.associated_in_trait
                              "p3_matrix::Matrix"
                              []
                              [ T ]
                              Second
                              "{{synthetic}}'2",
                            M.get_trait_method (|
                              "p3_matrix::Matrix",
                              Second,
                              [],
                              [ T ],
                              "row_slice",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "p3_matrix::stack::VerticalPair",
                                  "second"
                                |)
                              |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.sub,
                                [
                                  M.read (| r |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "p3_matrix::Matrix",
                                      First,
                                      [],
                                      [ T ],
                                      "height",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "p3_matrix::stack::VerticalPair",
                                          "first"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T First Second : Ty.t),
      M.IsTraitInstance
        "p3_matrix::Matrix"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T First Second)
        (* Instance *)
        [
          ("width", InstanceField.Method (width T First Second));
          ("height", InstanceField.Method (height T First Second));
          ("get", InstanceField.Method (get T First Second));
          ("Row", InstanceField.Ty (_Row T First Second));
          ("row", InstanceField.Method (row T First Second));
          ("row_slice", InstanceField.Method (row_slice T First Second))
        ].
  End Impl_p3_matrix_Matrix_where_core_marker_Send_T_where_core_marker_Sync_T_where_p3_matrix_Matrix_First_T_where_p3_matrix_Matrix_Second_T_T_for_p3_matrix_stack_VerticalPair_First_Second.
  
  Module Impl_p3_matrix_Matrix_where_core_marker_Send_T_where_core_marker_Sync_T_where_p3_matrix_Matrix_First_T_where_p3_matrix_Matrix_Second_T_T_for_p3_matrix_stack_HorizontalPair_First_Second.
    Definition Self (T First Second : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ].
    
    (*
        fn width(&self) -> usize {
            self.first.width() + self.second.width()
        }
    *)
    Definition width
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.add,
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (| "p3_matrix::Matrix", First, [], [ T ], "width", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::stack::HorizontalPair",
                      "first"
                    |)
                  |)
                ]
              |);
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (| "p3_matrix::Matrix", Second, [], [ T ], "width", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::stack::HorizontalPair",
                      "second"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn height(&self) -> usize {
            self.first.height()
        }
    *)
    Definition height
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (| "p3_matrix::Matrix", First, [], [ T ], "height", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_matrix::stack::HorizontalPair",
                  "first"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn get(&self, r: usize, c: usize) -> T {
            if c < self.first.width() {
                self.first.get(r, c)
            } else {
                self.second.get(r, c - self.first.width())
            }
        }
    *)
    Definition get
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self; r; c ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          let c := M.alloc (| Ty.path "usize", c |) in
          M.read (|
            M.match_operator (|
              T,
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.lt,
                            [
                              M.read (| c |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "p3_matrix::Matrix",
                                  First,
                                  [],
                                  [ T ],
                                  "width",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_matrix::stack::HorizontalPair",
                                      "first"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      T,
                      M.call_closure (|
                        T,
                        M.get_trait_method (|
                          "p3_matrix::Matrix",
                          First,
                          [],
                          [ T ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_matrix::stack::HorizontalPair",
                              "first"
                            |)
                          |);
                          M.read (| r |);
                          M.read (| c |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      T,
                      M.call_closure (|
                        T,
                        M.get_trait_method (|
                          "p3_matrix::Matrix",
                          Second,
                          [],
                          [ T ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_matrix::stack::HorizontalPair",
                              "second"
                            |)
                          |);
                          M.read (| r |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.sub,
                            [
                              M.read (| c |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "p3_matrix::Matrix",
                                  First,
                                  [],
                                  [ T ],
                                  "width",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_matrix::stack::HorizontalPair",
                                      "first"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        type Row<'a>
            = Chain<First::Row<'a>, Second::Row<'a>>
        where
            Self: 'a;
    *)
    Definition _Row (T First Second : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "core::iter::adapters::chain::Chain")
        []
        [
          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
          Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
        ].
    
    (*
        fn row(&self, r: usize) -> Self::Row<'_> {
            self.first.row(r).chain(self.second.row(r))
        }
    *)
    Definition row
        (T First Second : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T First Second in
      match ε, τ, α with
      | [], [], [ self; r ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::HorizontalPair") [] [ First; Second ] ],
              self
            |) in
          let r := M.alloc (| Ty.path "usize", r |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::iter::adapters::chain::Chain")
              []
              [
                Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row";
                Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row"
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row",
              [],
              [],
              "chain",
              [],
              [ Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row" ]
            |),
            [
              M.call_closure (|
                Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] First "Row",
                M.get_trait_method (| "p3_matrix::Matrix", First, [], [ T ], "row", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::stack::HorizontalPair",
                      "first"
                    |)
                  |);
                  M.read (| r |)
                ]
              |);
              M.call_closure (|
                Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] Second "Row",
                M.get_trait_method (| "p3_matrix::Matrix", Second, [], [ T ], "row", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_matrix::stack::HorizontalPair",
                      "second"
                    |)
                  |);
                  M.read (| r |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T First Second : Ty.t),
      M.IsTraitInstance
        "p3_matrix::Matrix"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T First Second)
        (* Instance *)
        [
          ("width", InstanceField.Method (width T First Second));
          ("height", InstanceField.Method (height T First Second));
          ("get", InstanceField.Method (get T First Second));
          ("Row", InstanceField.Ty (_Row T First Second));
          ("row", InstanceField.Method (row T First Second))
        ].
  End Impl_p3_matrix_Matrix_where_core_marker_Send_T_where_core_marker_Sync_T_where_p3_matrix_Matrix_First_T_where_p3_matrix_Matrix_Second_T_T_for_p3_matrix_stack_HorizontalPair_First_Second.
  
  (*
  Enum EitherRow
  {
    const_params := [];
    ty_params := [ "L"; "R" ];
    variants :=
      [
        {
          name := "Left";
          item := StructTuple [ L ];
        };
        {
          name := "Right";
          item := StructTuple [ R ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_EitherRow_Left : M.IsDiscriminant "p3_matrix::stack::EitherRow::Left" 0.
  Axiom IsDiscriminant_EitherRow_Right : M.IsDiscriminant "p3_matrix::stack::EitherRow::Right" 1.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_L_where_core_fmt_Debug_R_for_p3_matrix_stack_EitherRow_L_R.
    Definition Self (L R : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::EitherRow") [] [ L; R ].
    
    (* Debug *)
    Definition fmt (L R : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self L R in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::EitherRow") [] [ L; R ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "p3_matrix::stack::EitherRow::Left",
                        0
                      |) in
                    let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ L ], γ1_0 |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Left" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |))
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "p3_matrix::stack::EitherRow::Right",
                        0
                      |) in
                    let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ R ], γ1_0 |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Right" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |))
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (L R : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self L R)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt L R)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_L_where_core_fmt_Debug_R_for_p3_matrix_stack_EitherRow_L_R.
  
  Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_L_where_core_iter_traits_iterator_Iterator_R_for_p3_matrix_stack_EitherRow_L_R.
    Definition Self (T L R : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::EitherRow") [] [ L; R ].
    
    (*     type Item = T; *)
    Definition _Item (T L R : Ty.t) : Ty.t := T.
    
    (*
        fn next(&mut self) -> Option<Self::Item> {
            match self {
                Self::Left(l) => l.next(),
                Self::Right(r) => r.next(),
            }
        }
    *)
    Definition next (T L R : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T L R in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::EitherRow") [] [ L; R ] ],
              self
            |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "p3_matrix::stack::EitherRow::Left",
                        0
                      |) in
                    let l := M.alloc (| Ty.apply (Ty.path "&mut") [] [ L ], γ1_0 |) in
                    M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ T ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          L,
                          [],
                          [],
                          "next",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| l |) |) |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "p3_matrix::stack::EitherRow::Right",
                        0
                      |) in
                    let r := M.alloc (| Ty.apply (Ty.path "&mut") [] [ R ], γ1_0 |) in
                    M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ T ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          R,
                          [],
                          [],
                          "next",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| r |) |) |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T L R : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T L R)
        (* Instance *)
        [ ("Item", InstanceField.Ty (_Item T L R)); ("next", InstanceField.Method (next T L R)) ].
  End Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_L_where_core_iter_traits_iterator_Iterator_R_for_p3_matrix_stack_EitherRow_L_R.
  
  Module Impl_core_ops_deref_Deref_where_core_ops_deref_Deref_L_where_core_ops_deref_Deref_R_for_p3_matrix_stack_EitherRow_L_R.
    Definition Self (T L R : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_matrix::stack::EitherRow") [] [ L; R ].
    
    (*     type Target = [T]; *)
    Definition _Target (T L R : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
    
    (*
        fn deref(&self) -> &Self::Target {
            match self {
                Self::Left(l) => l,
                Self::Right(r) => r,
            }
        }
    *)
    Definition deref (T L R : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T L R in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "p3_matrix::stack::EitherRow") [] [ L; R ] ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                      self,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "p3_matrix::stack::EitherRow::Left",
                                0
                              |) in
                            let l := M.alloc (| Ty.apply (Ty.path "&") [] [ L ], γ1_0 |) in
                            M.alloc (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      L,
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| l |) |) |)
                                    ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "p3_matrix::stack::EitherRow::Right",
                                0
                              |) in
                            let r := M.alloc (| Ty.apply (Ty.path "&") [] [ R ], γ1_0 |) in
                            M.alloc (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      R,
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| r |) |) |)
                                    ]
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T L R : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T L R)
        (* Instance *)
        [
          ("Target", InstanceField.Ty (_Target T L R));
          ("deref", InstanceField.Method (deref T L R))
        ].
  End Impl_core_ops_deref_Deref_where_core_ops_deref_Deref_L_where_core_ops_deref_Deref_R_for_p3_matrix_stack_EitherRow_L_R.
End stack.
