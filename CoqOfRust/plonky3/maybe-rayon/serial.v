(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module serial.
  (* Trait *)
  (* Empty module 'IntoParallelIterator' *)
  
  Module Impl_p3_maybe_rayon_serial_IntoParallelIterator_where_core_iter_traits_collect_IntoIterator_T_where_core_marker_Send_associated_in_trait_core_iter_traits_collect_IntoIterator___T_Item_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    (*     type Iter = T::IntoIter; *)
    Definition _Iter (T : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::iter::traits::collect::IntoIterator" [] [] T "IntoIter".
    
    (*     type Item = T::Item; *)
    Definition _Item (T : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::iter::traits::collect::IntoIterator" [] [] T "Item".
    
    (*
        fn into_par_iter(self) -> Self::Iter {
            self.into_iter()
        }
    *)
    Definition into_par_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| T, self |) in
          M.call_closure (|
            Ty.associated_in_trait "core::iter::traits::collect::IntoIterator" [] [] T "IntoIter",
            M.get_trait_method (|
              "core::iter::traits::collect::IntoIterator",
              T,
              [],
              [],
              "into_iter",
              [],
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "p3_maybe_rayon::serial::IntoParallelIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("Iter", InstanceField.Ty (_Iter T));
          ("Item", InstanceField.Ty (_Item T));
          ("into_par_iter", InstanceField.Method (into_par_iter T))
        ].
  End Impl_p3_maybe_rayon_serial_IntoParallelIterator_where_core_iter_traits_collect_IntoIterator_T_where_core_marker_Send_associated_in_trait_core_iter_traits_collect_IntoIterator___T_Item_for_T.
  
  (* Trait *)
  (* Empty module 'IntoParallelRefIterator' *)
  
  Module Impl_p3_maybe_rayon_serial_IntoParallelRefIterator_where_core_marker_Sized_I_where_p3_maybe_rayon_serial_IntoParallelIterator_ref__I_for_I.
    Definition Self (I : Ty.t) : Ty.t := I.
    
    (*     type Iter = <&'data I as IntoParallelIterator>::Iter; *)
    Definition _Iter (I : Ty.t) : Ty.t :=
      Ty.associated_in_trait
        "p3_maybe_rayon::serial::IntoParallelIterator"
        []
        []
        (Ty.apply (Ty.path "&") [] [ I ])
        "Iter".
    
    (*     type Item = <&'data I as IntoParallelIterator>::Item; *)
    Definition _Item (I : Ty.t) : Ty.t :=
      Ty.associated_in_trait
        "p3_maybe_rayon::serial::IntoParallelIterator"
        []
        []
        (Ty.apply (Ty.path "&") [] [ I ])
        "Item".
    
    (*
        fn par_iter(&'data self) -> Self::Iter {
            self.into_par_iter()
        }
    *)
    Definition par_iter (I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ I ], self |) in
          M.call_closure (|
            Ty.associated_in_trait
              "p3_maybe_rayon::serial::IntoParallelIterator"
              []
              []
              (Ty.apply (Ty.path "&") [] [ I ])
              "Iter",
            M.get_trait_method (|
              "p3_maybe_rayon::serial::IntoParallelIterator",
              Ty.apply (Ty.path "&") [] [ I ],
              [],
              [],
              "into_par_iter",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I : Ty.t),
      M.IsTraitInstance
        "p3_maybe_rayon::serial::IntoParallelRefIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self I)
        (* Instance *)
        [
          ("Iter", InstanceField.Ty (_Iter I));
          ("Item", InstanceField.Ty (_Item I));
          ("par_iter", InstanceField.Method (par_iter I))
        ].
  End Impl_p3_maybe_rayon_serial_IntoParallelRefIterator_where_core_marker_Sized_I_where_p3_maybe_rayon_serial_IntoParallelIterator_ref__I_for_I.
  
  (* Trait *)
  (* Empty module 'IntoParallelRefMutIterator' *)
  
  Module Impl_p3_maybe_rayon_serial_IntoParallelRefMutIterator_where_core_marker_Sized_I_where_p3_maybe_rayon_serial_IntoParallelIterator_ref_mut_I_for_I.
    Definition Self (I : Ty.t) : Ty.t := I.
    
    (*     type Iter = <&'data mut I as IntoParallelIterator>::Iter; *)
    Definition _Iter (I : Ty.t) : Ty.t :=
      Ty.associated_in_trait
        "p3_maybe_rayon::serial::IntoParallelIterator"
        []
        []
        (Ty.apply (Ty.path "&mut") [] [ I ])
        "Iter".
    
    (*     type Item = <&'data mut I as IntoParallelIterator>::Item; *)
    Definition _Item (I : Ty.t) : Ty.t :=
      Ty.associated_in_trait
        "p3_maybe_rayon::serial::IntoParallelIterator"
        []
        []
        (Ty.apply (Ty.path "&mut") [] [ I ])
        "Item".
    
    (*
        fn par_iter_mut(&'data mut self) -> Self::Iter {
            self.into_par_iter()
        }
    *)
    Definition par_iter_mut (I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ I ], self |) in
          M.call_closure (|
            Ty.associated_in_trait
              "p3_maybe_rayon::serial::IntoParallelIterator"
              []
              []
              (Ty.apply (Ty.path "&mut") [] [ I ])
              "Iter",
            M.get_trait_method (|
              "p3_maybe_rayon::serial::IntoParallelIterator",
              Ty.apply (Ty.path "&mut") [] [ I ],
              [],
              [],
              "into_par_iter",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I : Ty.t),
      M.IsTraitInstance
        "p3_maybe_rayon::serial::IntoParallelRefMutIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self I)
        (* Instance *)
        [
          ("Iter", InstanceField.Ty (_Iter I));
          ("Item", InstanceField.Ty (_Item I));
          ("par_iter_mut", InstanceField.Method (par_iter_mut I))
        ].
  End Impl_p3_maybe_rayon_serial_IntoParallelRefMutIterator_where_core_marker_Sized_I_where_p3_maybe_rayon_serial_IntoParallelIterator_ref_mut_I_for_I.
  
  (* Trait *)
  Module ParallelSlice.
    Definition par_split
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ P ], [ self; separator ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let separator := M.alloc (| P, separator |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::Split") [] [ T; P ],
            M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "split", [], [ P ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSlice",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| separator |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_split :
      forall (T : Ty.t),
      M.IsProvidedMethod "p3_maybe_rayon::serial::ParallelSlice" "par_split" (par_split T).
    Definition par_windows
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; window_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let window_size := M.alloc (| Ty.path "usize", window_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::Windows") [] [ T ],
            M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "windows", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSlice",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| window_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_windows :
      forall (T : Ty.t),
      M.IsProvidedMethod "p3_maybe_rayon::serial::ParallelSlice" "par_windows" (par_windows T).
    Definition par_chunks
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::Chunks") [] [ T ],
            M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "chunks", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSlice",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_chunks :
      forall (T : Ty.t),
      M.IsProvidedMethod "p3_maybe_rayon::serial::ParallelSlice" "par_chunks" (par_chunks T).
    Definition par_chunks_exact
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ T ],
              "chunks_exact",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSlice",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_chunks_exact :
      forall (T : Ty.t),
      M.IsProvidedMethod
        "p3_maybe_rayon::serial::ParallelSlice"
        "par_chunks_exact"
        (par_chunks_exact T).
    Definition par_rchunks
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::RChunks") [] [ T ],
            M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "rchunks", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSlice",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_rchunks :
      forall (T : Ty.t),
      M.IsProvidedMethod "p3_maybe_rayon::serial::ParallelSlice" "par_rchunks" (par_rchunks T).
    Definition par_rchunks_exact
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ T ],
              "rchunks_exact",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSlice",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_rchunks_exact :
      forall (T : Ty.t),
      M.IsProvidedMethod
        "p3_maybe_rayon::serial::ParallelSlice"
        "par_rchunks_exact"
        (par_rchunks_exact T).
  End ParallelSlice.
  
  Module Impl_p3_maybe_rayon_serial_ParallelSlice_where_core_marker_Sync_T_T_for_slice_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
    
    (*
        fn as_parallel_slice(&self) -> &[T] {
            self
        }
    *)
    Definition as_parallel_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ], self |) in
          M.read (| self |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "p3_maybe_rayon::serial::ParallelSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("as_parallel_slice", InstanceField.Method (as_parallel_slice T)) ].
  End Impl_p3_maybe_rayon_serial_ParallelSlice_where_core_marker_Sync_T_T_for_slice_T.
  
  (* Trait *)
  Module ParallelSliceMut.
    Definition par_split_mut
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ P ], [ self; separator ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Self ], self |) in
          let separator := M.alloc (| P, separator |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::SplitMut") [] [ T; P ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ T ],
              "split_mut",
              [],
              [ P ]
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSliceMut",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| separator |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_split_mut :
      forall (T : Ty.t),
      M.IsProvidedMethod
        "p3_maybe_rayon::serial::ParallelSliceMut"
        "par_split_mut"
        (par_split_mut T).
    Definition par_chunks_mut
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::ChunksMut") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ T ],
              "chunks_mut",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSliceMut",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_chunks_mut :
      forall (T : Ty.t),
      M.IsProvidedMethod
        "p3_maybe_rayon::serial::ParallelSliceMut"
        "par_chunks_mut"
        (par_chunks_mut T).
    Definition par_chunks_exact_mut
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::ChunksExactMut") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ T ],
              "chunks_exact_mut",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSliceMut",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_chunks_exact_mut :
      forall (T : Ty.t),
      M.IsProvidedMethod
        "p3_maybe_rayon::serial::ParallelSliceMut"
        "par_chunks_exact_mut"
        (par_chunks_exact_mut T).
    Definition par_rchunks_mut
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::RChunksMut") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ T ],
              "rchunks_mut",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSliceMut",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_rchunks_mut :
      forall (T : Ty.t),
      M.IsProvidedMethod
        "p3_maybe_rayon::serial::ParallelSliceMut"
        "par_rchunks_mut"
        (par_rchunks_mut T).
    Definition par_rchunks_exact_mut
        (T Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Self ], self |) in
          let chunk_size := M.alloc (| Ty.path "usize", chunk_size |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::RChunksExactMut") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ T ],
              "rchunks_exact_mut",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_trait_method (|
                      "p3_maybe_rayon::serial::ParallelSliceMut",
                      Self,
                      [],
                      [ T ],
                      "as_parallel_slice_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| chunk_size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_par_rchunks_exact_mut :
      forall (T : Ty.t),
      M.IsProvidedMethod
        "p3_maybe_rayon::serial::ParallelSliceMut"
        "par_rchunks_exact_mut"
        (par_rchunks_exact_mut T).
  End ParallelSliceMut.
  
  Module Impl_p3_maybe_rayon_serial_ParallelSliceMut_where_core_marker_Send_T_T_for_slice_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
    
    (*
        fn as_parallel_slice_mut(&mut self) -> &mut [T] {
            self
        }
    *)
    Definition as_parallel_slice_mut
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "p3_maybe_rayon::serial::ParallelSliceMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *)
        [ ("as_parallel_slice_mut", InstanceField.Method (as_parallel_slice_mut T)) ].
  End Impl_p3_maybe_rayon_serial_ParallelSliceMut_where_core_marker_Send_T_T_for_slice_T.
  
  (* Trait *)
  (* Empty module 'ParIterExt' *)
  
  Module Impl_p3_maybe_rayon_serial_ParIterExt_where_core_iter_traits_iterator_Iterator_T_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    (*
        fn find_any<P>(mut self, predicate: P) -> Option<Self::Item>
        where
            P: Fn(&Self::Item) -> bool + Sync + Send,
        {
            self.find(predicate)
        }
    *)
    Definition find_any (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ P ], [ self; predicate ] =>
        ltac:(M.monadic
          (let self := M.alloc (| T, self |) in
          let predicate := M.alloc (| P, predicate |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] T "Item" ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              T,
              [],
              [],
              "find",
              [],
              [ P ]
            |),
            [ M.borrow (| Pointer.Kind.MutRef, self |); M.read (| predicate |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn flat_map_iter<U, F>(self, map_op: F) -> FlatMap<Self, U, F>
        where
            Self: Sized,
            U: IntoIterator,
            F: Fn(Self::Item) -> U,
        {
            self.flat_map(map_op)
        }
    *)
    Definition flat_map_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ U; F ], [ self; map_op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| T, self |) in
          let map_op := M.alloc (| F, map_op |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::iter::adapters::flatten::FlatMap") [] [ T; U; F ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              T,
              [],
              [],
              "flat_map",
              [],
              [ U; F ]
            |),
            [ M.read (| self |); M.read (| map_op |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "p3_maybe_rayon::serial::ParIterExt"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("find_any", InstanceField.Method (find_any T));
          ("flat_map_iter", InstanceField.Method (flat_map_iter T))
        ].
  End Impl_p3_maybe_rayon_serial_ParIterExt_where_core_iter_traits_iterator_Iterator_T_for_T.
  
  (*
  pub fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)
  where
      A: FnOnce() -> RA,
      B: FnOnce() -> RB,
  {
      let result_a = oper_a();
      let result_b = oper_b();
      (result_a, result_b)
  }
  *)
  Definition join (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ A; B; RA; RB ], [ oper_a; oper_b ] =>
      ltac:(M.monadic
        (let oper_a := M.alloc (| A, oper_a |) in
        let oper_b := M.alloc (| B, oper_b |) in
        M.read (|
          let~ result_a : RA :=
            M.call_closure (|
              RA,
              M.get_trait_method (|
                "core::ops::function::FnOnce",
                A,
                [],
                [ Ty.tuple [] ],
                "call_once",
                [],
                []
              |),
              [ M.read (| oper_a |); Value.Tuple [] ]
            |) in
          let~ result_b : RB :=
            M.call_closure (|
              RB,
              M.get_trait_method (|
                "core::ops::function::FnOnce",
                B,
                [],
                [ Ty.tuple [] ],
                "call_once",
                [],
                []
              |),
              [ M.read (| oper_b |); Value.Tuple [] ]
            |) in
          M.alloc (|
            Ty.tuple [ RA; RB ],
            Value.Tuple [ M.read (| result_a |); M.read (| result_b |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_join : M.IsFunction.C "p3_maybe_rayon::serial::join" join.
  Admitted.
  Global Typeclasses Opaque join.
  
  (*
  pub const fn current_num_threads() -> usize {
      1
  }
  *)
  Definition current_num_threads (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Integer IntegerKind.Usize 1))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_current_num_threads :
    M.IsFunction.C "p3_maybe_rayon::serial::current_num_threads" current_num_threads.
  Admitted.
  Global Typeclasses Opaque current_num_threads.
End serial.
