(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module coset_mds.
  (* StructRecord
    {
      name := "CosetMds";
      const_params := [ "N" ];
      ty_params := [ "F" ];
      fields :=
        [
          ("fft_twiddles",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]);
          ("ifft_twiddles",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]);
          ("weights", Ty.apply (Ty.path "array") [ N ] [ F ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_mds_coset_mds_CosetMds_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::coset_mds::CosetMds") [ N ] [ F ].
    
    (* Clone *)
    Definition clone
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "p3_mds::coset_mds::CosetMds"
            [
              ("fft_twiddles",
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_mds::coset_mds::CosetMds",
                            "fft_twiddles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("ifft_twiddles",
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_mds::coset_mds::CosetMds",
                            "ifft_twiddles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("weights",
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ N ] [ F ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "array") [ N ] [ F ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_mds::coset_mds::CosetMds",
                            "weights"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("clone", InstanceField.Method (clone N F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_mds_coset_mds_CosetMds_N_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_mds_coset_mds_CosetMds_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::coset_mds::CosetMds") [ N ] [ F ].
    
    (* Debug *)
    Definition fmt
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CosetMds" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "fft_twiddles" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_mds::coset_mds::CosetMds",
                        "fft_twiddles"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ifft_twiddles" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_mds::coset_mds::CosetMds",
                        "ifft_twiddles"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "weights" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_mds::coset_mds::CosetMds",
                            "weights"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt N F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_mds_coset_mds_CosetMds_N_F.
  
  Module Impl_core_default_Default_where_p3_field_field_TwoAdicField_F_for_p3_mds_coset_mds_CosetMds_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::coset_mds::CosetMds") [ N ] [ F ].
    
    (*
        fn default() -> Self {
            let log_n = log2_strict_usize(N);
    
            let root = F::two_adic_generator(log_n);
            let root_inv = root.inverse();
            let mut fft_twiddles: Vec<F> = root.powers().take(N / 2).collect();
            let mut ifft_twiddles: Vec<F> = root_inv.powers().take(N / 2).collect();
            reverse_slice_index_bits(&mut fft_twiddles);
            reverse_slice_index_bits(&mut ifft_twiddles);
    
            let shift = F::GENERATOR;
            let mut weights: [F; N] = shift
                .powers()
                .take(N)
                .collect::<Vec<_>>()
                .try_into()
                .unwrap();
            reverse_slice_index_bits(&mut weights);
            Self {
                fft_twiddles,
                ifft_twiddles,
                weights,
            }
        }
    *)
    Definition default
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                  [ N ]
                |)
              |) in
            let~ root : Ty.apply (Ty.path "*") [] [ F ] :=
              M.alloc (|
                M.call_closure (|
                  F,
                  M.get_trait_method (|
                    "p3_field::field::TwoAdicField",
                    F,
                    [],
                    [],
                    "two_adic_generator",
                    [],
                    []
                  |),
                  [ M.read (| log_n |) ]
                |)
              |) in
            let~ root_inv : Ty.apply (Ty.path "*") [] [ F ] :=
              M.alloc (|
                M.call_closure (|
                  F,
                  M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, root |) ]
                |)
              |) in
            let~ fft_twiddles :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                    [],
                    [],
                    "collect",
                    [],
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                        [],
                        [],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                          M.get_trait_method (|
                            "p3_field::field::PrimeCharacteristicRing",
                            F,
                            [],
                            [],
                            "powers",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, root |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.div,
                          [ N; Value.Integer IntegerKind.Usize 2 ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ ifft_twiddles :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                    [],
                    [],
                    "collect",
                    [],
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                        [],
                        [],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                          M.get_trait_method (|
                            "p3_field::field::PrimeCharacteristicRing",
                            F,
                            [],
                            [],
                            "powers",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, root_inv |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.div,
                          [ N; Value.Integer IntegerKind.Usize 2 ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "p3_util::reverse_slice_index_bits", [], [ F ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (| M.borrow (| Pointer.Kind.MutRef, fft_twiddles |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "p3_util::reverse_slice_index_bits", [], [ F ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (| M.borrow (| Pointer.Kind.MutRef, ifft_twiddles |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ shift : Ty.apply (Ty.path "*") [] [ F ] :=
              M.copy (| get_constant (| "p3_field::field::Field::GENERATOR", F |) |) in
            let~ weights : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ N ] [ F ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ N ] [ F ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "array") [ N ] [ F ];
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ]
                      ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply (Ty.path "array") [ N ] [ F ];
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ]
                        ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        [ Ty.apply (Ty.path "array") [ N ] [ F ] ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::take::Take")
                              []
                              [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::take::Take")
                                []
                                [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                                [],
                                [],
                                "take",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                                  M.get_trait_method (|
                                    "p3_field::field::PrimeCharacteristicRing",
                                    F,
                                    [],
                                    [],
                                    "powers",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, shift |) ]
                                |);
                                N
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "p3_util::reverse_slice_index_bits", [], [ F ] |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (| M.borrow (| Pointer.Kind.MutRef, weights |) |)
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "p3_mds::coset_mds::CosetMds"
                [
                  ("fft_twiddles", M.read (| fft_twiddles |));
                  ("ifft_twiddles", M.read (| ifft_twiddles |));
                  ("weights", M.read (| weights |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("default", InstanceField.Method (default N F)) ].
  End Impl_core_default_Default_where_p3_field_field_TwoAdicField_F_for_p3_mds_coset_mds_CosetMds_N_F.
  
  Module Impl_p3_symmetric_permutation_Permutation_where_p3_field_field_TwoAdicField_F_where_p3_field_field_Algebra_A_F_array_N_A_for_p3_mds_coset_mds_CosetMds_N_F.
    Definition Self (N : Value.t) (F A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::coset_mds::CosetMds") [ N ] [ F ].
    
    (*
        fn permute(&self, mut input: [A; N]) -> [A; N] {
            self.permute_mut(&mut input);
            input
        }
    *)
    Definition permute
        (N : Value.t)
        (F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F A in
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "p3_symmetric::permutation::Permutation",
                    Ty.apply (Ty.path "p3_mds::coset_mds::CosetMds") [ N ] [ F ],
                    [],
                    [ Ty.apply (Ty.path "array") [ N ] [ A ] ],
                    "permute_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (| M.borrow (| Pointer.Kind.MutRef, input |) |)
                    |)
                  ]
                |)
              |) in
            input
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permute_mut(&self, values: &mut [A; N]) {
            // Inverse DFT, except we skip bit reversal and rescaling by 1/N.
            bowers_g_t(values, &self.ifft_twiddles);
    
            // Multiply by powers of the coset shift (see default coset LDE impl for an explanation)
            for (value, weight) in values.iter_mut().zip(self.weights) {
                *value = value.clone() * weight;
            }
    
            // DFT, assuming bit-reversed input.
            bowers_g(values, &self.fft_twiddles);
        }
    *)
    Definition permute_mut
        (N : Value.t)
        (F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F A in
      match ε, τ, α with
      | [], [], [ self; values ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let values := M.alloc (| values |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "p3_mds::coset_mds::bowers_g_t", [ N ], [ F; A ] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| values |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_mds::coset_mds::CosetMds",
                                    "ifft_twiddles"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.use
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ];
                          Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ];
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                          ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ];
                              Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ F ]
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                            [],
                            [],
                            "zip",
                            [],
                            [ Ty.apply (Ty.path "array") [ N ] [ F ] ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ A ],
                                "iter_mut",
                                [],
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| values |) |)
                                  |))
                              ]
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_mds::coset_mds::CosetMds",
                                "weights"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ A ]; F ] ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::zip::Zip")
                                        []
                                        [
                                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ];
                                          Ty.apply
                                            (Ty.path "core::array::iter::IntoIter")
                                            [ N ]
                                            [ F ]
                                        ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let value := M.copy (| γ1_0 |) in
                                      let weight := M.copy (| γ1_1 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.write (|
                                            M.deref (| M.read (| value |) |),
                                            M.call_closure (|
                                              A,
                                              M.get_trait_method (|
                                                "core::ops::arith::Mul",
                                                A,
                                                [],
                                                [ F ],
                                                "mul",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    [],
                                                    "clone",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| value |) |)
                                                    |)
                                                  ]
                                                |);
                                                M.read (| weight |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "p3_mds::coset_mds::bowers_g", [ N ], [ F; A ] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| values |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_mds::coset_mds::CosetMds",
                                    "fft_twiddles"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F A : Ty.t),
      M.IsTraitInstance
        "p3_symmetric::permutation::Permutation"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ A ] ]
        (Self N F A)
        (* Instance *)
        [
          ("permute", InstanceField.Method (permute N F A));
          ("permute_mut", InstanceField.Method (permute_mut N F A))
        ].
  End Impl_p3_symmetric_permutation_Permutation_where_p3_field_field_TwoAdicField_F_where_p3_field_field_Algebra_A_F_array_N_A_for_p3_mds_coset_mds_CosetMds_N_F.
  
  Module Impl_p3_mds_MdsPermutation_where_p3_field_field_TwoAdicField_F_where_p3_field_field_Algebra_A_F_N_A_for_p3_mds_coset_mds_CosetMds_N_F.
    Definition Self (N : Value.t) (F A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::coset_mds::CosetMds") [ N ] [ F ].
    
    Axiom Implements :
      forall (N : Value.t) (F A : Ty.t),
      M.IsTraitInstance
        "p3_mds::MdsPermutation"
        (* Trait polymorphic consts *) [ N ]
        (* Trait polymorphic types *) [ A ]
        (Self N F A)
        (* Instance *) [].
  End Impl_p3_mds_MdsPermutation_where_p3_field_field_TwoAdicField_F_where_p3_field_field_Algebra_A_F_N_A_for_p3_mds_coset_mds_CosetMds_N_F.
  
  (*
  fn bowers_g<F: Field, A: Algebra<F>, const N: usize>(values: &mut [A; N], twiddles: &[F]) {
      let log_n = log2_strict_usize(N);
      for log_half_block_size in 0..log_n {
          bowers_g_layer(values, log_half_block_size, twiddles);
      }
  }
  *)
  Definition bowers_g (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [ F; A ], [ values; twiddles ] =>
      ltac:(M.monadic
        (let values := M.alloc (| values |) in
        let twiddles := M.alloc (| twiddles |) in
        M.read (|
          let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                [ N ]
              |)
            |) in
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "core::ops::range::Range"
                      [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", M.read (| log_n |)) ]
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let log_half_block_size := M.copy (| γ0_0 |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_function (|
                                          "p3_mds::coset_mds::bowers_g_layer",
                                          [ N ],
                                          [ F; A ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| values |) |)
                                          |);
                                          M.read (| log_half_block_size |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| twiddles |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bowers_g :
    M.IsFunction.C "p3_mds::coset_mds::bowers_g" bowers_g.
  Admitted.
  Global Typeclasses Opaque bowers_g.
  
  (*
  fn bowers_g_t<F: Field, A: Algebra<F>, const N: usize>(values: &mut [A; N], twiddles: &[F]) {
      let log_n = log2_strict_usize(N);
      for log_half_block_size in (0..log_n).rev() {
          bowers_g_t_layer(values, log_half_block_size, twiddles);
      }
  }
  *)
  Definition bowers_g_t (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [ F; A ], [ values; twiddles ] =>
      ltac:(M.monadic
        (let values := M.alloc (| values |) in
        let twiddles := M.alloc (| twiddles |) in
        M.read (|
          let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                [ N ]
              |)
            |) in
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::rev::Rev")
                    []
                    [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::rev::Rev")
                      []
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::rev::Rev")
                        []
                        [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "rev",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 0);
                            ("end_", M.read (| log_n |))
                          ]
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::rev::Rev")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ]
                                    ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let log_half_block_size := M.copy (| γ0_0 |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_function (|
                                          "p3_mds::coset_mds::bowers_g_t_layer",
                                          [ N ],
                                          [ F; A ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| values |) |)
                                          |);
                                          M.read (| log_half_block_size |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| twiddles |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bowers_g_t :
    M.IsFunction.C "p3_mds::coset_mds::bowers_g_t" bowers_g_t.
  Admitted.
  Global Typeclasses Opaque bowers_g_t.
  
  (*
  fn bowers_g_layer<F: Field, A: Algebra<F>, const N: usize>(
      values: &mut [A; N],
      log_half_block_size: usize,
      twiddles: &[F],
  ) {
      let log_block_size = log_half_block_size + 1;
      let half_block_size = 1 << log_half_block_size;
      let num_blocks = N >> log_block_size;
  
      // Unroll first iteration with a twiddle factor of 1.
      for hi in 0..half_block_size {
          let lo = hi + half_block_size;
          twiddle_free_butterfly(values, hi, lo);
      }
  
      for (block, &twiddle) in (1..num_blocks).zip(&twiddles[1..]) {
          let block_start = block << log_block_size;
          for hi in block_start..block_start + half_block_size {
              let lo = hi + half_block_size;
              dif_butterfly(values, hi, lo, twiddle);
          }
      }
  }
  *)
  Definition bowers_g_layer (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [ F; A ], [ values; log_half_block_size; twiddles ] =>
      ltac:(M.monadic
        (let values := M.alloc (| values |) in
        let log_half_block_size := M.alloc (| log_half_block_size |) in
        let twiddles := M.alloc (| twiddles |) in
        M.read (|
          let~ log_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [ M.read (| log_half_block_size |); Value.Integer IntegerKind.Usize 1 ]
              |)
            |) in
          let~ half_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shl,
                [ Value.Integer IntegerKind.Usize 1; M.read (| log_half_block_size |) ]
              |)
            |) in
          let~ num_blocks : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shr,
                [ N; M.read (| log_block_size |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::Range"
                        [
                          ("start", Value.Integer IntegerKind.Usize 0);
                          ("end_", M.read (| half_block_size |))
                        ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let hi := M.copy (| γ0_0 |) in
                                    let~ lo : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [ M.read (| hi |); M.read (| half_block_size |) ]
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_function (|
                                            "p3_mds::butterflies::twiddle_free_butterfly",
                                            [ N ],
                                            [ F; A ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| values |) |)
                                            |);
                                            M.read (| hi |);
                                            M.read (| lo |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                      ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "zip",
                        [],
                        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 1);
                            ("end_", M.read (| num_blocks |))
                          ];
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "slice") [] [ F ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| twiddles |) |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", Value.Integer IntegerKind.Usize 1) ]
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                    ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                  let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                  let block := M.copy (| γ1_0 |) in
                                  let γ1_1 := M.read (| γ1_1 |) in
                                  let twiddle := M.copy (| γ1_1 |) in
                                  let~ block_start :
                                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.shl,
                                        [ M.read (| block |); M.read (| log_block_size |) ]
                                      |)
                                    |) in
                                  M.use
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "into_iter",
                                            [],
                                            []
                                          |),
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", M.read (| block_start |));
                                                ("end_",
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [
                                                      M.read (| block_start |);
                                                      M.read (| half_block_size |)
                                                    ]
                                                  |))
                                              ]
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let iter := M.copy (| γ |) in
                                            M.loop (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              ltac:(M.monadic
                                                (let~ _ :
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                  M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          [],
                                                          [],
                                                          "next",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                iter
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "core::option::Option::None"
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let hi := M.copy (| γ0_0 |) in
                                                          let~ lo :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.path "usize" ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.read (| hi |);
                                                                  M.read (| half_block_size |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.tuple [],
                                                                M.get_function (|
                                                                  "p3_mds::butterflies::dif_butterfly",
                                                                  [ N ],
                                                                  [ F; A ]
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutRef,
                                                                    M.deref (|
                                                                      M.read (| values |)
                                                                    |)
                                                                  |);
                                                                  M.read (| hi |);
                                                                  M.read (| lo |);
                                                                  M.read (| twiddle |)
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                            |)))
                                      ]
                                    |))))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bowers_g_layer :
    M.IsFunction.C "p3_mds::coset_mds::bowers_g_layer" bowers_g_layer.
  Admitted.
  Global Typeclasses Opaque bowers_g_layer.
  
  (*
  fn bowers_g_t_layer<F: Field, A: Algebra<F>, const N: usize>(
      values: &mut [A; N],
      log_half_block_size: usize,
      twiddles: &[F],
  ) {
      let log_block_size = log_half_block_size + 1;
      let half_block_size = 1 << log_half_block_size;
      let num_blocks = N >> log_block_size;
  
      // Unroll first iteration with a twiddle factor of 1.
      for hi in 0..half_block_size {
          let lo = hi + half_block_size;
          twiddle_free_butterfly(values, hi, lo);
      }
  
      for (block, &twiddle) in (1..num_blocks).zip(&twiddles[1..]) {
          let block_start = block << log_block_size;
          for hi in block_start..block_start + half_block_size {
              let lo = hi + half_block_size;
              dit_butterfly(values, hi, lo, twiddle);
          }
      }
  }
  *)
  Definition bowers_g_t_layer (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [ F; A ], [ values; log_half_block_size; twiddles ] =>
      ltac:(M.monadic
        (let values := M.alloc (| values |) in
        let log_half_block_size := M.alloc (| log_half_block_size |) in
        let twiddles := M.alloc (| twiddles |) in
        M.read (|
          let~ log_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [ M.read (| log_half_block_size |); Value.Integer IntegerKind.Usize 1 ]
              |)
            |) in
          let~ half_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shl,
                [ Value.Integer IntegerKind.Usize 1; M.read (| log_half_block_size |) ]
              |)
            |) in
          let~ num_blocks : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shr,
                [ N; M.read (| log_block_size |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::Range"
                        [
                          ("start", Value.Integer IntegerKind.Usize 0);
                          ("end_", M.read (| half_block_size |))
                        ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let hi := M.copy (| γ0_0 |) in
                                    let~ lo : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [ M.read (| hi |); M.read (| half_block_size |) ]
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_function (|
                                            "p3_mds::butterflies::twiddle_free_butterfly",
                                            [ N ],
                                            [ F; A ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| values |) |)
                                            |);
                                            M.read (| hi |);
                                            M.read (| lo |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                      ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "zip",
                        [],
                        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 1);
                            ("end_", M.read (| num_blocks |))
                          ];
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "slice") [] [ F ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| twiddles |) |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", Value.Integer IntegerKind.Usize 1) ]
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                    ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                  let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                  let block := M.copy (| γ1_0 |) in
                                  let γ1_1 := M.read (| γ1_1 |) in
                                  let twiddle := M.copy (| γ1_1 |) in
                                  let~ block_start :
                                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.shl,
                                        [ M.read (| block |); M.read (| log_block_size |) ]
                                      |)
                                    |) in
                                  M.use
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "into_iter",
                                            [],
                                            []
                                          |),
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", M.read (| block_start |));
                                                ("end_",
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [
                                                      M.read (| block_start |);
                                                      M.read (| half_block_size |)
                                                    ]
                                                  |))
                                              ]
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let iter := M.copy (| γ |) in
                                            M.loop (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              ltac:(M.monadic
                                                (let~ _ :
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                  M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          [],
                                                          [],
                                                          "next",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                iter
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "core::option::Option::None"
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let hi := M.copy (| γ0_0 |) in
                                                          let~ lo :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.path "usize" ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.read (| hi |);
                                                                  M.read (| half_block_size |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.tuple [],
                                                                M.get_function (|
                                                                  "p3_mds::butterflies::dit_butterfly",
                                                                  [ N ],
                                                                  [ F; A ]
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutRef,
                                                                    M.deref (|
                                                                      M.read (| values |)
                                                                    |)
                                                                  |);
                                                                  M.read (| hi |);
                                                                  M.read (| lo |);
                                                                  M.read (| twiddle |)
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                            |)))
                                      ]
                                    |))))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bowers_g_t_layer :
    M.IsFunction.C "p3_mds::coset_mds::bowers_g_t_layer" bowers_g_t_layer.
  Admitted.
  Global Typeclasses Opaque bowers_g_t_layer.
End coset_mds.
