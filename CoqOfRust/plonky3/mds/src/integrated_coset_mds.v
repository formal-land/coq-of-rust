(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module integrated_coset_mds.
  (* StructRecord
    {
      name := "IntegratedCosetMds";
      const_params := [ "N" ];
      ty_params := [ "F" ];
      fields :=
        [
          ("ifft_twiddles",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]);
          ("fft_twiddles",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::integrated_coset_mds::IntegratedCosetMds") [ N ] [ F ].
    
    (* Clone *)
    Definition clone
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "p3_mds::integrated_coset_mds::IntegratedCosetMds"
            [
              ("ifft_twiddles",
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_mds::integrated_coset_mds::IntegratedCosetMds",
                            "ifft_twiddles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("fft_twiddles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_mds::integrated_coset_mds::IntegratedCosetMds",
                            "fft_twiddles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("clone", InstanceField.Method (clone N F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::integrated_coset_mds::IntegratedCosetMds") [ N ] [ F ].
    
    (* Debug *)
    Definition fmt
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "IntegratedCosetMds" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ifft_twiddles" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_mds::integrated_coset_mds::IntegratedCosetMds",
                        "ifft_twiddles"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "fft_twiddles" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_mds::integrated_coset_mds::IntegratedCosetMds",
                            "fft_twiddles"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt N F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
  
  Module Impl_core_default_Default_where_p3_field_field_TwoAdicField_F_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
    Definition Self (N : Value.t) (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::integrated_coset_mds::IntegratedCosetMds") [ N ] [ F ].
    
    (*
        fn default() -> Self {
            let log_n = log2_strict_usize(N);
            let root = F::two_adic_generator(log_n);
            let root_inv = root.inverse();
            let coset_shift = F::GENERATOR;
    
            let mut ifft_twiddles: Vec<F> = root_inv.powers().take(N / 2).collect();
            reverse_slice_index_bits(&mut ifft_twiddles);
    
            let fft_twiddles: Vec<Vec<F>> = (0..log_n)
                .map(|layer| {
                    let shift_power = coset_shift.exp_power_of_2(layer);
                    let powers = Powers {
                        base: root.exp_power_of_2(layer),
                        current: shift_power,
                    };
                    let mut twiddles: Vec<_> = powers.take(N >> (layer + 1)).collect();
                    reverse_slice_index_bits(&mut twiddles);
                    twiddles
                })
                .collect();
    
            Self {
                ifft_twiddles,
                fft_twiddles,
            }
        }
    *)
    Definition default
        (N : Value.t)
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                  [ N ]
                |)
              |) in
            let~ root : Ty.apply (Ty.path "*") [] [ F ] :=
              M.alloc (|
                M.call_closure (|
                  F,
                  M.get_trait_method (|
                    "p3_field::field::TwoAdicField",
                    F,
                    [],
                    [],
                    "two_adic_generator",
                    [],
                    []
                  |),
                  [ M.read (| log_n |) ]
                |)
              |) in
            let~ root_inv : Ty.apply (Ty.path "*") [] [ F ] :=
              M.alloc (|
                M.call_closure (|
                  F,
                  M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, root |) ]
                |)
              |) in
            let~ coset_shift : Ty.apply (Ty.path "*") [] [ F ] :=
              M.copy (| get_constant (| "p3_field::field::Field::GENERATOR", F |) |) in
            let~ ifft_twiddles :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                    [],
                    [],
                    "collect",
                    [],
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ] ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                        [],
                        [],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "p3_field::field::Powers") [] [ F ],
                          M.get_trait_method (|
                            "p3_field::field::PrimeCharacteristicRing",
                            F,
                            [],
                            [],
                            "powers",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, root_inv |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.div,
                          [ N; Value.Integer IntegerKind.Usize 2 ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "p3_util::reverse_slice_index_bits", [], [ F ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (| M.borrow (| Pointer.Kind.MutRef, ifft_twiddles |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ fft_twiddles :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                        Ty.function
                          [ Ty.tuple [ Ty.path "usize" ] ]
                          (Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ])
                      ],
                    [],
                    [],
                    "collect",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                          Ty.function
                            [ Ty.tuple [ Ty.path "usize" ] ]
                            (Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ])
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "map",
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ];
                          Ty.function
                            [ Ty.tuple [ Ty.path "usize" ] ]
                            (Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ])
                        ]
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 0);
                            ("end_", M.read (| log_n |))
                          ];
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.function
                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                          (Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ F; Ty.path "alloc::alloc::Global" ])
                                      ],
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let layer := M.copy (| γ |) in
                                          M.read (|
                                            let~ shift_power : Ty.apply (Ty.path "*") [] [ F ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  F,
                                                  M.get_trait_method (|
                                                    "p3_field::field::PrimeCharacteristicRing",
                                                    F,
                                                    [],
                                                    [],
                                                    "exp_power_of_2",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.Ref, coset_shift |);
                                                    M.read (| layer |)
                                                  ]
                                                |)
                                              |) in
                                            let~ powers :
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "p3_field::field::Powers")
                                                      []
                                                      [ F ]
                                                  ] :=
                                              M.alloc (|
                                                Value.StructRecord
                                                  "p3_field::field::Powers"
                                                  [
                                                    ("base",
                                                      M.call_closure (|
                                                        F,
                                                        M.get_trait_method (|
                                                          "p3_field::field::PrimeCharacteristicRing",
                                                          F,
                                                          [],
                                                          [],
                                                          "exp_power_of_2",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.Ref, root |);
                                                          M.read (| layer |)
                                                        ]
                                                      |));
                                                    ("current", M.read (| shift_power |))
                                                  ]
                                              |) in
                                            let~ twiddles :
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ F; Ty.path "alloc::alloc::Global" ]
                                                  ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ F; Ty.path "alloc::alloc::Global" ],
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::take::Take")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "p3_field::field::Powers")
                                                          []
                                                          [ F ]
                                                      ],
                                                    [],
                                                    [],
                                                    "collect",
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ]
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::take::Take")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "p3_field::field::Powers")
                                                            []
                                                            [ F ]
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path "p3_field::field::Powers")
                                                          []
                                                          [ F ],
                                                        [],
                                                        [],
                                                        "take",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.read (| powers |);
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.shr,
                                                          [
                                                            N;
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              BinOp.Wrap.add,
                                                              [
                                                                M.read (| layer |);
                                                                Value.Integer IntegerKind.Usize 1
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_function (|
                                                    "p3_util::reverse_slice_index_bits",
                                                    [],
                                                    [ F ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "&mut")
                                                            []
                                                            [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                          M.get_trait_method (|
                                                            "core::ops::deref::DerefMut",
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [ F; Ty.path "alloc::alloc::Global" ],
                                                            [],
                                                            [],
                                                            "deref_mut",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.MutRef,
                                                                  twiddles
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            twiddles
                                          |)))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "p3_mds::integrated_coset_mds::IntegratedCosetMds"
                [
                  ("ifft_twiddles", M.read (| ifft_twiddles |));
                  ("fft_twiddles", M.read (| fft_twiddles |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N F)
        (* Instance *) [ ("default", InstanceField.Method (default N F)) ].
  End Impl_core_default_Default_where_p3_field_field_TwoAdicField_F_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
  
  Module Impl_p3_symmetric_permutation_Permutation_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_array_N_A_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
    Definition Self (N : Value.t) (F A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::integrated_coset_mds::IntegratedCosetMds") [ N ] [ F ].
    
    (*
        fn permute(&self, mut input: [A; N]) -> [A; N] {
            self.permute_mut(&mut input);
            input
        }
    *)
    Definition permute
        (N : Value.t)
        (F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F A in
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "p3_symmetric::permutation::Permutation",
                    Ty.apply
                      (Ty.path "p3_mds::integrated_coset_mds::IntegratedCosetMds")
                      [ N ]
                      [ F ],
                    [],
                    [ Ty.apply (Ty.path "array") [ N ] [ A ] ],
                    "permute_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (| M.borrow (| Pointer.Kind.MutRef, input |) |)
                    |)
                  ]
                |)
              |) in
            input
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permute_mut(&self, values: &mut [A; N]) {
            let log_n = log2_strict_usize(N);
    
            // Bit-reversed DIF, aka Bowers G
            for layer in 0..log_n {
                bowers_g_layer(values, layer, &self.ifft_twiddles);
            }
    
            // Bit-reversed DIT, aka Bowers G^T
            for layer in (0..log_n).rev() {
                bowers_g_t_layer(values, layer, &self.fft_twiddles[layer]);
            }
        }
    *)
    Definition permute_mut
        (N : Value.t)
        (F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N F A in
      match ε, τ, α with
      | [], [], [ self; values ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let values := M.alloc (| values |) in
          M.read (|
            let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                  [ N ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.use
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 0);
                            ("end_", M.read (| log_n |))
                          ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let layer := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (|
                                              "p3_mds::integrated_coset_mds::bowers_g_layer",
                                              [ N ],
                                              [ F; A ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| values |) |)
                                              |);
                                              M.read (| layer |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "p3_mds::integrated_coset_mds::IntegratedCosetMds",
                                                              "ifft_twiddles"
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::rev::Rev")
                      []
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::rev::Rev")
                        []
                        [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::rev::Rev")
                          []
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          [],
                          "rev",
                          [],
                          []
                        |),
                        [
                          Value.StructRecord
                            "core::ops::range::Range"
                            [
                              ("start", Value.Integer IntegerKind.Usize 0);
                              ("end_", M.read (| log_n |))
                            ]
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::rev::Rev")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let layer := M.copy (| γ0_0 |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_function (|
                                            "p3_mds::integrated_coset_mds::bowers_g_t_layer",
                                            [ N ],
                                            [ F; A ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| values |) |)
                                            |);
                                            M.read (| layer |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ F; Ty.path "alloc::alloc::Global" ],
                                                    [],
                                                    [],
                                                    "deref",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "alloc::vec::Vec")
                                                                    []
                                                                    [
                                                                      F;
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::index::Index",
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      []
                                                                      [
                                                                        F;
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ];
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                [],
                                                                [ Ty.path "usize" ],
                                                                "index",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "p3_mds::integrated_coset_mds::IntegratedCosetMds",
                                                                    "fft_twiddles"
                                                                  |)
                                                                |);
                                                                M.read (| layer |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (F A : Ty.t),
      M.IsTraitInstance
        "p3_symmetric::permutation::Permutation"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ A ] ]
        (Self N F A)
        (* Instance *)
        [
          ("permute", InstanceField.Method (permute N F A));
          ("permute_mut", InstanceField.Method (permute_mut N F A))
        ].
  End Impl_p3_symmetric_permutation_Permutation_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_array_N_A_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
  
  Module Impl_p3_mds_MdsPermutation_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_N_A_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
    Definition Self (N : Value.t) (F A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_mds::integrated_coset_mds::IntegratedCosetMds") [ N ] [ F ].
    
    Axiom Implements :
      forall (N : Value.t) (F A : Ty.t),
      M.IsTraitInstance
        "p3_mds::MdsPermutation"
        (* Trait polymorphic consts *) [ N ]
        (* Trait polymorphic types *) [ A ]
        (Self N F A)
        (* Instance *) [].
  End Impl_p3_mds_MdsPermutation_where_p3_field_field_Field_F_where_p3_field_field_Algebra_A_F_N_A_for_p3_mds_integrated_coset_mds_IntegratedCosetMds_N_F.
  
  (*
  fn bowers_g_layer<F: Field, A: Algebra<F>, const N: usize>(
      values: &mut [A; N],
      log_half_block_size: usize,
      twiddles: &[F],
  ) {
      let log_block_size = log_half_block_size + 1;
      let half_block_size = 1 << log_half_block_size;
      let num_blocks = N >> log_block_size;
  
      // Unroll first iteration with a twiddle factor of 1.
      for hi in 0..half_block_size {
          let lo = hi + half_block_size;
          twiddle_free_butterfly(values, hi, lo);
      }
  
      for (block, &twiddle) in (1..num_blocks).zip(&twiddles[1..]) {
          let block_start = block << log_block_size;
          for hi in block_start..block_start + half_block_size {
              let lo = hi + half_block_size;
              dif_butterfly(values, hi, lo, twiddle);
          }
      }
  }
  *)
  Definition bowers_g_layer (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [ F; A ], [ values; log_half_block_size; twiddles ] =>
      ltac:(M.monadic
        (let values := M.alloc (| values |) in
        let log_half_block_size := M.alloc (| log_half_block_size |) in
        let twiddles := M.alloc (| twiddles |) in
        M.read (|
          let~ log_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [ M.read (| log_half_block_size |); Value.Integer IntegerKind.Usize 1 ]
              |)
            |) in
          let~ half_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shl,
                [ Value.Integer IntegerKind.Usize 1; M.read (| log_half_block_size |) ]
              |)
            |) in
          let~ num_blocks : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shr,
                [ N; M.read (| log_block_size |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::Range"
                        [
                          ("start", Value.Integer IntegerKind.Usize 0);
                          ("end_", M.read (| half_block_size |))
                        ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let hi := M.copy (| γ0_0 |) in
                                    let~ lo : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [ M.read (| hi |); M.read (| half_block_size |) ]
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_function (|
                                            "p3_mds::butterflies::twiddle_free_butterfly",
                                            [ N ],
                                            [ F; A ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| values |) |)
                                            |);
                                            M.read (| hi |);
                                            M.read (| lo |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                      ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "zip",
                        [],
                        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 1);
                            ("end_", M.read (| num_blocks |))
                          ];
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "slice") [] [ F ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| twiddles |) |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", Value.Integer IntegerKind.Usize 1) ]
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                    ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                  let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                  let block := M.copy (| γ1_0 |) in
                                  let γ1_1 := M.read (| γ1_1 |) in
                                  let twiddle := M.copy (| γ1_1 |) in
                                  let~ block_start :
                                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.shl,
                                        [ M.read (| block |); M.read (| log_block_size |) ]
                                      |)
                                    |) in
                                  M.use
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "into_iter",
                                            [],
                                            []
                                          |),
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", M.read (| block_start |));
                                                ("end_",
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [
                                                      M.read (| block_start |);
                                                      M.read (| half_block_size |)
                                                    ]
                                                  |))
                                              ]
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let iter := M.copy (| γ |) in
                                            M.loop (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              ltac:(M.monadic
                                                (let~ _ :
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                  M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          [],
                                                          [],
                                                          "next",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                iter
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "core::option::Option::None"
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let hi := M.copy (| γ0_0 |) in
                                                          let~ lo :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.path "usize" ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.read (| hi |);
                                                                  M.read (| half_block_size |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.tuple [],
                                                                M.get_function (|
                                                                  "p3_mds::butterflies::dif_butterfly",
                                                                  [ N ],
                                                                  [ F; A ]
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutRef,
                                                                    M.deref (|
                                                                      M.read (| values |)
                                                                    |)
                                                                  |);
                                                                  M.read (| hi |);
                                                                  M.read (| lo |);
                                                                  M.read (| twiddle |)
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                            |)))
                                      ]
                                    |))))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bowers_g_layer :
    M.IsFunction.C "p3_mds::integrated_coset_mds::bowers_g_layer" bowers_g_layer.
  Admitted.
  Global Typeclasses Opaque bowers_g_layer.
  
  (*
  fn bowers_g_t_layer<F: Field, A: Algebra<F>, const N: usize>(
      values: &mut [A; N],
      log_half_block_size: usize,
      twiddles: &[F],
  ) {
      let log_block_size = log_half_block_size + 1;
      let half_block_size = 1 << log_half_block_size;
      let num_blocks = N >> log_block_size;
  
      for (block, &twiddle) in (0..num_blocks).zip(twiddles) {
          let block_start = block << log_block_size;
          for hi in block_start..block_start + half_block_size {
              let lo = hi + half_block_size;
              dit_butterfly(values, hi, lo, twiddle);
          }
      }
  }
  *)
  Definition bowers_g_t_layer (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [ F; A ], [ values; log_half_block_size; twiddles ] =>
      ltac:(M.monadic
        (let values := M.alloc (| values |) in
        let log_half_block_size := M.alloc (| log_half_block_size |) in
        let twiddles := M.alloc (| twiddles |) in
        M.read (|
          let~ log_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [ M.read (| log_half_block_size |); Value.Integer IntegerKind.Usize 1 ]
              |)
            |) in
          let~ half_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shl,
                [ Value.Integer IntegerKind.Usize 1; M.read (| log_half_block_size |) ]
              |)
            |) in
          let~ num_blocks : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shr,
                [ N; M.read (| log_block_size |) ]
              |)
            |) in
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::zip::Zip")
                      []
                      [
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                      ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "zip",
                        [],
                        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 0);
                            ("end_", M.read (| num_blocks |))
                          ];
                        M.read (| twiddles |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [] [ F ] ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                    ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                  let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                  let block := M.copy (| γ1_0 |) in
                                  let γ1_1 := M.read (| γ1_1 |) in
                                  let twiddle := M.copy (| γ1_1 |) in
                                  let~ block_start :
                                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.shl,
                                        [ M.read (| block |); M.read (| log_block_size |) ]
                                      |)
                                    |) in
                                  M.use
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "into_iter",
                                            [],
                                            []
                                          |),
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", M.read (| block_start |));
                                                ("end_",
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [
                                                      M.read (| block_start |);
                                                      M.read (| half_block_size |)
                                                    ]
                                                  |))
                                              ]
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let iter := M.copy (| γ |) in
                                            M.loop (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              ltac:(M.monadic
                                                (let~ _ :
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                  M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          [],
                                                          [],
                                                          "next",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                iter
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "core::option::Option::None"
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let hi := M.copy (| γ0_0 |) in
                                                          let~ lo :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.path "usize" ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.read (| hi |);
                                                                  M.read (| half_block_size |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.tuple [],
                                                                M.get_function (|
                                                                  "p3_mds::butterflies::dit_butterfly",
                                                                  [ N ],
                                                                  [ F; A ]
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutRef,
                                                                    M.deref (|
                                                                      M.read (| values |)
                                                                    |)
                                                                  |);
                                                                  M.read (| hi |);
                                                                  M.read (| lo |);
                                                                  M.read (| twiddle |)
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                            |)))
                                      ]
                                    |))))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bowers_g_t_layer :
    M.IsFunction.C "p3_mds::integrated_coset_mds::bowers_g_t_layer" bowers_g_t_layer.
  Admitted.
  Global Typeclasses Opaque bowers_g_t_layer.
End integrated_coset_mds.
