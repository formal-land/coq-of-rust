(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module karatsuba_convolution.
  (* Trait *)
  (* Empty module 'RngElt' *)
  
  Module Impl_p3_mds_karatsuba_convolution_RngElt_for_i64.
    Definition Self : Ty.t := Ty.path "i64".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::karatsuba_convolution::RngElt"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_mds_karatsuba_convolution_RngElt_for_i64.
  
  Module Impl_p3_mds_karatsuba_convolution_RngElt_for_i128.
    Definition Self : Ty.t := Ty.path "i128".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::karatsuba_convolution::RngElt"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_p3_mds_karatsuba_convolution_RngElt_for_i128.
  
  (* Trait *)
  Module Convolve.
    Definition apply
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [ N ], [ C ], [ lhs; rhs; conv ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let conv := M.alloc (| conv |) in
          M.read (|
            let~ lhs : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ N ] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ N ] [ F ],
                    "map",
                    [],
                    [ Ty.function [ F ] T; T ]
                  |),
                  [
                    M.read (| lhs |);
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "read",
                      [],
                      []
                    |)
                  ]
                |)
              |) in
            let~ output : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ N ] [ V ] ] :=
              M.alloc (|
                repeat (|
                  M.call_closure (|
                    V,
                    M.get_trait_method (| "core::default::Default", V, [], [], "default", [], [] |),
                    []
                  |),
                  N
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::function::Fn",
                    C,
                    [],
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "array") [ N ] [ T ];
                          Ty.apply (Ty.path "array") [ N ] [ U ];
                          Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                        ]
                    ],
                    "call",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, conv |);
                    Value.Tuple
                      [
                        M.read (| lhs |);
                        M.read (| rhs |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (| M.borrow (| Pointer.Kind.MutRef, output |) |)
                          |))
                      ]
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "array") [ N ] [ V ],
                  "map",
                  [],
                  [ Ty.function [ V ] F; F ]
                |),
                [
                  M.read (| output |);
                  M.get_trait_method (|
                    "p3_mds::karatsuba_convolution::Convolve",
                    Self,
                    [],
                    [ F; T; U; V ],
                    "reduce",
                    [],
                    []
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_apply :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "apply" (apply F T U V).
    Definition conv3
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 0
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 3 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 2
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 1
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 3 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 2
                            |)
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 2
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 3 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 2
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv3 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv3" (conv3 F T U V).
    Definition negacyclic_conv3
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 0
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 3 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 2
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 1
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 3 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 2
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 2
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 3 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 2
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_negacyclic_conv3 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod
        "p3_mds::karatsuba_convolution::Convolve"
        "negacyclic_conv3"
        (negacyclic_conv3 F T U V).
    Definition conv4
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.read (|
            let~ u_p :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ T ] ] :=
              M.alloc (|
                Value.Array
                  [
                    M.call_closure (|
                      T,
                      M.get_trait_method (| "core::ops::arith::Add", T, [], [ T ], "add", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 0 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 2 |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      T,
                      M.get_trait_method (| "core::ops::arith::Add", T, [], [ T ], "add", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 1 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 3 |)
                        |)
                      ]
                    |)
                  ]
              |) in
            let~ u_m :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ T ] ] :=
              M.alloc (|
                Value.Array
                  [
                    M.call_closure (|
                      T,
                      M.get_trait_method (| "core::ops::arith::Sub", T, [], [ T ], "sub", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 0 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 2 |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      T,
                      M.get_trait_method (| "core::ops::arith::Sub", T, [], [ T ], "sub", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 1 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| lhs, Value.Integer IntegerKind.Usize 3 |)
                        |)
                      ]
                    |)
                  ]
              |) in
            let~ v_p :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ U ] ] :=
              M.alloc (|
                Value.Array
                  [
                    M.call_closure (|
                      U,
                      M.get_trait_method (| "core::ops::arith::Add", U, [], [ U ], "add", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 0 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 2 |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      U,
                      M.get_trait_method (| "core::ops::arith::Add", U, [], [ U ], "add", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 1 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 3 |)
                        |)
                      ]
                    |)
                  ]
              |) in
            let~ v_m :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ U ] ] :=
              M.alloc (|
                Value.Array
                  [
                    M.call_closure (|
                      U,
                      M.get_trait_method (| "core::ops::arith::Sub", U, [], [ U ], "sub", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 0 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 2 |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      U,
                      M.get_trait_method (| "core::ops::arith::Sub", U, [], [ U ], "sub", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 1 |)
                        |);
                        M.read (|
                          M.SubPointer.get_array_field (| rhs, Value.Integer IntegerKind.Usize 3 |)
                        |)
                      ]
                    |)
                  ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 0
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 2 ],
                      []
                    |),
                    [
                      M.read (| u_m |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              v_m,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  v_m,
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 1
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 2 ],
                      []
                    |),
                    [
                      M.read (| u_m |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              v_m,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              v_m,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 2
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 2 ],
                      []
                    |),
                    [ M.read (| u_p |); M.read (| v_p |) ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 3
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 2 ],
                      []
                    |),
                    [
                      M.read (| u_p |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              v_p,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              v_p,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    V,
                    [],
                    [ V ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    V,
                    [],
                    [ V ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 3
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::ShrAssign",
                    V,
                    [],
                    [ Ty.path "u32" ],
                    "shr_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U32 1
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::ShrAssign",
                    V,
                    [],
                    [ Ty.path "u32" ],
                    "shr_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    Value.Integer IntegerKind.U32 1
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::SubAssign",
                    V,
                    [],
                    [ V ],
                    "sub_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::SubAssign",
                    V,
                    [],
                    [ V ],
                    "sub_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 3
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| output |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv4 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv4" (conv4 F T U V).
    Definition negacyclic_conv4
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 0
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 4 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 3
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 2
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 1
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 4 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 3
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 2
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 2
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 4 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 2
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.call_closure (|
                            U,
                            M.get_trait_method (|
                              "core::ops::arith::Neg",
                              U,
                              [],
                              [],
                              "neg",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  rhs,
                                  Value.Integer IntegerKind.Usize 3
                                |)
                              |)
                            ]
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| output |) |),
                    Value.Integer IntegerKind.Usize 3
                  |),
                  M.call_closure (|
                    V,
                    M.get_trait_method (|
                      "p3_mds::karatsuba_convolution::Convolve",
                      Self,
                      [],
                      [ F; T; U; V ],
                      "parity_dot",
                      [ Value.Integer IntegerKind.Usize 4 ],
                      []
                    |),
                    [
                      M.read (| lhs |);
                      Value.Array
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 3
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 2
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              rhs,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |)
                        ]
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_negacyclic_conv4 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod
        "p3_mds::karatsuba_convolution::Convolve"
        "negacyclic_conv4"
        (negacyclic_conv4 F T U V).
    Definition conv6
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 6; Value.Integer IntegerKind.Usize 3 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 3 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 3 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple []);
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 3 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 3 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "conv3",
                [],
                []
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv3",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv6 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv6" (conv6 F T U V).
    Definition negacyclic_conv6
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::negacyclic_conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 6; Value.Integer IntegerKind.Usize 3 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 3 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 3 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv3",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_negacyclic_conv6 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod
        "p3_mds::karatsuba_convolution::Convolve"
        "negacyclic_conv6"
        (negacyclic_conv6 F T U V).
    Definition conv8
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 4 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple []);
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "conv4",
                [],
                []
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv4",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv8 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv8" (conv8 F T U V).
    Definition negacyclic_conv8
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::negacyclic_conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 4 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv4",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_negacyclic_conv8 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod
        "p3_mds::karatsuba_convolution::Convolve"
        "negacyclic_conv8"
        (negacyclic_conv8 F T U V).
    Definition conv12
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 12; Value.Integer IntegerKind.Usize 6 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 6 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 6 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple []);
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 6 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 6 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "conv6",
                [],
                []
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv6",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv12 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv12" (conv12 F T U V).
    Definition negacyclic_conv12
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::negacyclic_conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 12; Value.Integer IntegerKind.Usize 6 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 6 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 6 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv6",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_negacyclic_conv12 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod
        "p3_mds::karatsuba_convolution::Convolve"
        "negacyclic_conv12"
        (negacyclic_conv12 F T U V).
    Definition conv16
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 8 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple []);
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "conv8",
                [],
                []
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv8",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv16 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv16" (conv16 F T U V).
    Definition negacyclic_conv16
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::negacyclic_conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 8 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv8",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_negacyclic_conv16 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod
        "p3_mds::karatsuba_convolution::Convolve"
        "negacyclic_conv16"
        (negacyclic_conv16 F T U V).
    Definition conv24
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 24; Value.Integer IntegerKind.Usize 12 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 12 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 12 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple []);
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 12 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 12 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "conv12",
                [],
                []
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv12",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv24 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv24" (conv24 F T U V).
    Definition conv32
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 16 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 16 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 16 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple []);
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 16 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 16 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "conv16",
                [],
                []
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv16",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv32 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv32" (conv32 F T U V).
    Definition negacyclic_conv32
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::negacyclic_conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 16 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 16 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 16 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv16",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_negacyclic_conv32 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod
        "p3_mds::karatsuba_convolution::Convolve"
        "negacyclic_conv32"
        (negacyclic_conv32 F T U V).
    Definition conv64
        (F T U V Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; output ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (|
              "p3_mds::karatsuba_convolution::conv_n_recursive",
              [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 32 ],
              [
                T;
                U;
                V;
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple []);
                Ty.function
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ T ];
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ U ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| lhs |);
              M.read (| rhs |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "conv32",
                [],
                []
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Self,
                [],
                [ F; T; U; V ],
                "negacyclic_conv32",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_conv64 :
      forall (F T U V : Ty.t),
      M.IsProvidedMethod "p3_mds::karatsuba_convolution::Convolve" "conv64" (conv64 F T U V).
  End Convolve.
  
  (*
  fn conv_n_recursive<const N: usize, const HALF_N: usize, T, U, V, C, NC>(
      lhs: [T; N],
      rhs: [U; N],
      output: &mut [V],
      inner_conv: C,
      inner_negacyclic_conv: NC,
  ) where
      T: RngElt,
      U: RngElt,
      V: RngElt,
      C: Fn([T; HALF_N], [U; HALF_N], &mut [V]),
      NC: Fn([T; HALF_N], [U; HALF_N], &mut [V]),
  {
      debug_assert_eq!(2 * HALF_N, N);
      // NB: The compiler is smart enough not to initialise these arrays.
      let mut lhs_pos = [T::default(); HALF_N]; // lhs_pos = lhs(x) mod x^{N/2} - 1
      let mut lhs_neg = [T::default(); HALF_N]; // lhs_neg = lhs(x) mod x^{N/2} + 1
      let mut rhs_pos = [U::default(); HALF_N]; // rhs_pos = rhs(x) mod x^{N/2} - 1
      let mut rhs_neg = [U::default(); HALF_N]; // rhs_neg = rhs(x) mod x^{N/2} + 1
  
      for i in 0..HALF_N {
          let s = lhs[i];
          let t = lhs[i + HALF_N];
  
          lhs_pos[i] = s + t;
          lhs_neg[i] = s - t;
  
          let s = rhs[i];
          let t = rhs[i + HALF_N];
  
          rhs_pos[i] = s + t;
          rhs_neg[i] = s - t;
      }
  
      let (left, right) = output.split_at_mut(HALF_N);
  
      // left = w1 = lhs(x)rhs(x) mod x^{N/2} + 1
      inner_negacyclic_conv(lhs_neg, rhs_neg, left);
  
      // right = w0 = lhs(x)rhs(x) mod x^{N/2} - 1
      inner_conv(lhs_pos, rhs_pos, right);
  
      for i in 0..HALF_N {
          left[i] += right[i]; // w_0 + w_1
          left[i] >>= 1; // (w_0 + w_1)/2
          right[i] -= left[i]; // (w_0 - w_1)/2
      }
  }
  *)
  Definition conv_n_recursive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N; HALF_N ], [ T; U; V; C; NC ], [ lhs; rhs; output; inner_conv; inner_negacyclic_conv ] =>
      ltac:(M.monadic
        (let lhs := M.alloc (| lhs |) in
        let rhs := M.alloc (| rhs |) in
        let output := M.alloc (| output |) in
        let inner_conv := M.alloc (| inner_conv |) in
        let inner_negacyclic_conv := M.alloc (| inner_negacyclic_conv |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          Value.Tuple
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.mul,
                                    [ Value.Integer IntegerKind.Usize 2; HALF_N ]
                                  |)
                                |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |)
                            ]
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let left_val := M.copy (| γ0_0 |) in
                              let right_val := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.eq,
                                                [
                                                  M.read (| M.deref (| M.read (| left_val |) |) |);
                                                  M.read (| M.deref (| M.read (| right_val |) |) |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ kind :
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [ Ty.path "core::panicking::AssertKind" ] :=
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::panicking::AssertKind::Eq"
                                                  []
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "never",
                                                M.get_function (|
                                                  "core::panicking::assert_failed",
                                                  [],
                                                  [ Ty.path "usize"; Ty.path "usize" ]
                                                |),
                                                [
                                                  M.read (| kind |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| left_val |) |)
                                                      |)
                                                    |)
                                                  |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| right_val |) |)
                                                      |)
                                                    |)
                                                  |);
                                                  Value.StructTuple "core::option::Option::None" []
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          let~ lhs_pos :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ T ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ lhs_neg :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ T ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ rhs_pos :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ U ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  U,
                  M.get_trait_method (| "core::default::Default", U, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ rhs_neg :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ U ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  U,
                  M.get_trait_method (| "core::default::Default", U, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::Range"
                        [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", HALF_N) ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| γ0_0 |) in
                                    let~ s : Ty.apply (Ty.path "*") [] [ T ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (| lhs, M.read (| i |) |)
                                      |) in
                                    let~ t : Ty.apply (Ty.path "*") [] [ T ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (|
                                          lhs,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.add,
                                            [ M.read (| i |); HALF_N ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            lhs_pos,
                                            M.read (| i |)
                                          |),
                                          M.call_closure (|
                                            T,
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              T,
                                              [],
                                              [ T ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| s |); M.read (| t |) ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            lhs_neg,
                                            M.read (| i |)
                                          |),
                                          M.call_closure (|
                                            T,
                                            M.get_trait_method (|
                                              "core::ops::arith::Sub",
                                              T,
                                              [],
                                              [ T ],
                                              "sub",
                                              [],
                                              []
                                            |),
                                            [ M.read (| s |); M.read (| t |) ]
                                          |)
                                        |)
                                      |) in
                                    let~ s : Ty.apply (Ty.path "*") [] [ U ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (| rhs, M.read (| i |) |)
                                      |) in
                                    let~ t : Ty.apply (Ty.path "*") [] [ U ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (|
                                          rhs,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.add,
                                            [ M.read (| i |); HALF_N ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            rhs_pos,
                                            M.read (| i |)
                                          |),
                                          M.call_closure (|
                                            U,
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              U,
                                              [],
                                              [ U ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| s |); M.read (| t |) ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            rhs_neg,
                                            M.read (| i |)
                                          |),
                                          M.call_closure (|
                                            U,
                                            M.get_trait_method (|
                                              "core::ops::arith::Sub",
                                              U,
                                              [],
                                              [ U ],
                                              "sub",
                                              [],
                                              []
                                            |),
                                            [ M.read (| s |); M.read (| t |) ]
                                          |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
            M.alloc (|
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ V ],
                  "split_at_mut",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |); HALF_N ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left := M.copy (| γ0_0 |) in
                  let right := M.copy (| γ0_1 |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::ops::function::Fn",
                          NC,
                          [],
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "array") [ HALF_N ] [ T ];
                                Ty.apply (Ty.path "array") [ HALF_N ] [ U ];
                                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                              ]
                          ],
                          "call",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, inner_negacyclic_conv |);
                          Value.Tuple
                            [
                              M.read (| lhs_neg |);
                              M.read (| rhs_neg |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| left |) |) |)
                            ]
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::ops::function::Fn",
                          C,
                          [],
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "array") [ HALF_N ] [ T ];
                                Ty.apply (Ty.path "array") [ HALF_N ] [ U ];
                                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                              ]
                          ],
                          "call",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, inner_conv |);
                          Value.Tuple
                            [
                              M.read (| lhs_pos |);
                              M.read (| rhs_pos |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| right |) |) |)
                            ]
                        ]
                      |)
                    |) in
                  M.use
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            Value.StructRecord
                              "core::ops::range::Range"
                              [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", HALF_N) ]
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter := M.copy (| γ |) in
                            M.loop (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              ltac:(M.monadic
                                (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let i := M.copy (| γ0_0 |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "core::ops::arith::AddAssign",
                                                  V,
                                                  [],
                                                  [ V ],
                                                  "add_assign",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_array_field (|
                                                      M.deref (| M.read (| left |) |),
                                                      M.read (| i |)
                                                    |)
                                                  |);
                                                  M.read (|
                                                    M.SubPointer.get_array_field (|
                                                      M.deref (| M.read (| right |) |),
                                                      M.read (| i |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "core::ops::bit::ShrAssign",
                                                  V,
                                                  [],
                                                  [ Ty.path "u32" ],
                                                  "shr_assign",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_array_field (|
                                                      M.deref (| M.read (| left |) |),
                                                      M.read (| i |)
                                                    |)
                                                  |);
                                                  Value.Integer IntegerKind.U32 1
                                                ]
                                              |)
                                            |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "core::ops::arith::SubAssign",
                                                  V,
                                                  [],
                                                  [ V ],
                                                  "sub_assign",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_array_field (|
                                                      M.deref (| M.read (| right |) |),
                                                      M.read (| i |)
                                                    |)
                                                  |);
                                                  M.read (|
                                                    M.SubPointer.get_array_field (|
                                                      M.deref (| M.read (| left |) |),
                                                      M.read (| i |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                            |)))
                      ]
                    |))))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_conv_n_recursive :
    M.IsFunction.C "p3_mds::karatsuba_convolution::conv_n_recursive" conv_n_recursive.
  Admitted.
  Global Typeclasses Opaque conv_n_recursive.
  
  (*
  fn negacyclic_conv_n_recursive<const N: usize, const HALF_N: usize, T, U, V, NC>(
      lhs: [T; N],
      rhs: [U; N],
      output: &mut [V],
      inner_negacyclic_conv: NC,
  ) where
      T: RngElt,
      U: RngElt,
      V: RngElt,
      NC: Fn([T; HALF_N], [U; HALF_N], &mut [V]),
  {
      debug_assert_eq!(2 * HALF_N, N);
      // NB: The compiler is smart enough not to initialise these arrays.
      let mut lhs_even = [T::default(); HALF_N];
      let mut lhs_odd = [T::default(); HALF_N];
      let mut lhs_sum = [T::default(); HALF_N];
      let mut rhs_even = [U::default(); HALF_N];
      let mut rhs_odd = [U::default(); HALF_N];
      let mut rhs_sum = [U::default(); HALF_N];
  
      for i in 0..HALF_N {
          let s = lhs[2 * i];
          let t = lhs[2 * i + 1];
          lhs_even[i] = s;
          lhs_odd[i] = t;
          lhs_sum[i] = s + t;
  
          let s = rhs[2 * i];
          let t = rhs[2 * i + 1];
          rhs_even[i] = s;
          rhs_odd[i] = t;
          rhs_sum[i] = s + t;
      }
  
      let mut even_s_conv = [V::default(); HALF_N];
      let (left, right) = output.split_at_mut(HALF_N);
  
      // Recursively compute the size N/2 negacyclic convolutions of
      // the even parts, odd parts, and sums.
      inner_negacyclic_conv(lhs_even, rhs_even, &mut even_s_conv);
      inner_negacyclic_conv(lhs_odd, rhs_odd, left);
      inner_negacyclic_conv(lhs_sum, rhs_sum, right);
  
      // Adjust so that the correct values are in right and
      // even_s_conv respectively:
      right[0] -= even_s_conv[0] + left[0];
      even_s_conv[0] -= left[HALF_N - 1];
  
      for i in 1..HALF_N {
          right[i] -= even_s_conv[i] + left[i];
          even_s_conv[i] += left[i - 1];
      }
  
      // Interleave even_s_conv and right in the output:
      for i in 0..HALF_N {
          output[2 * i] = even_s_conv[i];
          output[2 * i + 1] = output[i + HALF_N];
      }
  }
  *)
  Definition negacyclic_conv_n_recursive
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [ N; HALF_N ], [ T; U; V; NC ], [ lhs; rhs; output; inner_negacyclic_conv ] =>
      ltac:(M.monadic
        (let lhs := M.alloc (| lhs |) in
        let rhs := M.alloc (| rhs |) in
        let output := M.alloc (| output |) in
        let inner_negacyclic_conv := M.alloc (| inner_negacyclic_conv |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          Value.Tuple
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.mul,
                                    [ Value.Integer IntegerKind.Usize 2; HALF_N ]
                                  |)
                                |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |)
                            ]
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let left_val := M.copy (| γ0_0 |) in
                              let right_val := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.eq,
                                                [
                                                  M.read (| M.deref (| M.read (| left_val |) |) |);
                                                  M.read (| M.deref (| M.read (| right_val |) |) |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ kind :
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [ Ty.path "core::panicking::AssertKind" ] :=
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::panicking::AssertKind::Eq"
                                                  []
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "never",
                                                M.get_function (|
                                                  "core::panicking::assert_failed",
                                                  [],
                                                  [ Ty.path "usize"; Ty.path "usize" ]
                                                |),
                                                [
                                                  M.read (| kind |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| left_val |) |)
                                                      |)
                                                    |)
                                                  |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| right_val |) |)
                                                      |)
                                                    |)
                                                  |);
                                                  Value.StructTuple "core::option::Option::None" []
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          let~ lhs_even :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ T ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ lhs_odd :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ T ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ lhs_sum :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ T ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ rhs_even :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ U ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  U,
                  M.get_trait_method (| "core::default::Default", U, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ rhs_odd :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ U ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  U,
                  M.get_trait_method (| "core::default::Default", U, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ rhs_sum :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ U ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  U,
                  M.get_trait_method (| "core::default::Default", U, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::Range"
                        [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", HALF_N) ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| γ0_0 |) in
                                    let~ s : Ty.apply (Ty.path "*") [] [ T ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (|
                                          lhs,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.mul,
                                            [ Value.Integer IntegerKind.Usize 2; M.read (| i |) ]
                                          |)
                                        |)
                                      |) in
                                    let~ t : Ty.apply (Ty.path "*") [] [ T ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (|
                                          lhs,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.add,
                                            [
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.mul,
                                                [ Value.Integer IntegerKind.Usize 2; M.read (| i |)
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            lhs_even,
                                            M.read (| i |)
                                          |),
                                          M.read (| s |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            lhs_odd,
                                            M.read (| i |)
                                          |),
                                          M.read (| t |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            lhs_sum,
                                            M.read (| i |)
                                          |),
                                          M.call_closure (|
                                            T,
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              T,
                                              [],
                                              [ T ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| s |); M.read (| t |) ]
                                          |)
                                        |)
                                      |) in
                                    let~ s : Ty.apply (Ty.path "*") [] [ U ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (|
                                          rhs,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.mul,
                                            [ Value.Integer IntegerKind.Usize 2; M.read (| i |) ]
                                          |)
                                        |)
                                      |) in
                                    let~ t : Ty.apply (Ty.path "*") [] [ U ] :=
                                      M.copy (|
                                        M.SubPointer.get_array_field (|
                                          rhs,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.add,
                                            [
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.mul,
                                                [ Value.Integer IntegerKind.Usize 2; M.read (| i |)
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            rhs_even,
                                            M.read (| i |)
                                          |),
                                          M.read (| s |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            rhs_odd,
                                            M.read (| i |)
                                          |),
                                          M.read (| t |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_array_field (|
                                            rhs_sum,
                                            M.read (| i |)
                                          |),
                                          M.call_closure (|
                                            U,
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              U,
                                              [],
                                              [ U ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| s |); M.read (| t |) ]
                                          |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          let~ even_s_conv :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ HALF_N ] [ V ] ] :=
            M.alloc (|
              repeat (|
                M.call_closure (|
                  V,
                  M.get_trait_method (| "core::default::Default", V, [], [], "default", [], [] |),
                  []
                |),
                HALF_N
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
            M.alloc (|
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ V ],
                  "split_at_mut",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |); HALF_N ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let left := M.copy (| γ0_0 |) in
                  let right := M.copy (| γ0_1 |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::ops::function::Fn",
                          NC,
                          [],
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "array") [ HALF_N ] [ T ];
                                Ty.apply (Ty.path "array") [ HALF_N ] [ U ];
                                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                              ]
                          ],
                          "call",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, inner_negacyclic_conv |);
                          Value.Tuple
                            [
                              M.read (| lhs_even |);
                              M.read (| rhs_even |);
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.borrow (| Pointer.Kind.MutRef, even_s_conv |) |)
                                |))
                            ]
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::ops::function::Fn",
                          NC,
                          [],
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "array") [ HALF_N ] [ T ];
                                Ty.apply (Ty.path "array") [ HALF_N ] [ U ];
                                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                              ]
                          ],
                          "call",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, inner_negacyclic_conv |);
                          Value.Tuple
                            [
                              M.read (| lhs_odd |);
                              M.read (| rhs_odd |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| left |) |) |)
                            ]
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::ops::function::Fn",
                          NC,
                          [],
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "array") [ HALF_N ] [ T ];
                                Ty.apply (Ty.path "array") [ HALF_N ] [ U ];
                                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ V ] ]
                              ]
                          ],
                          "call",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, inner_negacyclic_conv |);
                          Value.Tuple
                            [
                              M.read (| lhs_sum |);
                              M.read (| rhs_sum |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| right |) |) |)
                            ]
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::ops::arith::SubAssign",
                          V,
                          [],
                          [ V ],
                          "sub_assign",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| right |) |),
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.call_closure (|
                            V,
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              V,
                              [],
                              [ V ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  even_s_conv,
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| left |) |),
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::ops::arith::SubAssign",
                          V,
                          [],
                          [ V ],
                          "sub_assign",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_array_field (|
                              even_s_conv,
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| left |) |),
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.sub,
                                [ HALF_N; Value.Integer IntegerKind.Usize 1 ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.use
                      (M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              Value.StructRecord
                                "core::ops::range::Range"
                                [ ("start", Value.Integer IntegerKind.Usize 1); ("end_", HALF_N) ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                ltac:(M.monadic
                                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let i := M.copy (| γ0_0 |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_trait_method (|
                                                    "core::ops::arith::SubAssign",
                                                    V,
                                                    [],
                                                    [ V ],
                                                    "sub_assign",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.SubPointer.get_array_field (|
                                                        M.deref (| M.read (| right |) |),
                                                        M.read (| i |)
                                                      |)
                                                    |);
                                                    M.call_closure (|
                                                      V,
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Add",
                                                        V,
                                                        [],
                                                        [ V ],
                                                        "add",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_array_field (|
                                                            even_s_conv,
                                                            M.read (| i |)
                                                          |)
                                                        |);
                                                        M.read (|
                                                          M.SubPointer.get_array_field (|
                                                            M.deref (| M.read (| left |) |),
                                                            M.read (| i |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_trait_method (|
                                                    "core::ops::arith::AddAssign",
                                                    V,
                                                    [],
                                                    [ V ],
                                                    "add_assign",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.SubPointer.get_array_field (|
                                                        even_s_conv,
                                                        M.read (| i |)
                                                      |)
                                                    |);
                                                    M.read (|
                                                      M.SubPointer.get_array_field (|
                                                        M.deref (| M.read (| left |) |),
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.sub,
                                                          [
                                                            M.read (| i |);
                                                            Value.Integer IntegerKind.Usize 1
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |)) in
                  M.use
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            Value.StructRecord
                              "core::ops::range::Range"
                              [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", HALF_N) ]
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter := M.copy (| γ |) in
                            M.loop (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              ltac:(M.monadic
                                (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let i := M.copy (| γ0_0 |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_array_field (|
                                                  M.deref (| M.read (| output |) |),
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.mul,
                                                    [
                                                      Value.Integer IntegerKind.Usize 2;
                                                      M.read (| i |)
                                                    ]
                                                  |)
                                                |),
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    even_s_conv,
                                                    M.read (| i |)
                                                  |)
                                                |)
                                              |)
                                            |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_array_field (|
                                                  M.deref (| M.read (| output |) |),
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.mul,
                                                        [
                                                          Value.Integer IntegerKind.Usize 2;
                                                          M.read (| i |)
                                                        ]
                                                      |);
                                                      Value.Integer IntegerKind.Usize 1
                                                    ]
                                                  |)
                                                |),
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| output |) |),
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.add,
                                                      [ M.read (| i |); HALF_N ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                            |)))
                      ]
                    |))))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_negacyclic_conv_n_recursive :
    M.IsFunction.C
      "p3_mds::karatsuba_convolution::negacyclic_conv_n_recursive"
      negacyclic_conv_n_recursive.
  Admitted.
  Global Typeclasses Opaque negacyclic_conv_n_recursive.
End karatsuba_convolution.
