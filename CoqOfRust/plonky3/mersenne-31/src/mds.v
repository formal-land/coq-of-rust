(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module mds.
  (* StructTuple
    {
      name := "MdsMatrixMersenne31";
      const_params := [];
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_core_clone_Clone_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple "p3_mersenne_31::mds::MdsMatrixMersenne31" []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Module Impl_core_fmt_Debug_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "MdsMatrixMersenne31" |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Module Impl_core_default_Default_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic (Value.StructTuple "p3_mersenne_31::mds::MdsMatrixMersenne31" []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  (* StructTuple
    {
      name := "SmallConvolveMersenne31";
      const_params := [];
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_p3_mds_karatsuba_convolution_Convolve_p3_mersenne_31_mersenne_31_Mersenne31_i64_i64_i64_for_p3_mersenne_31_mds_SmallConvolveMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::SmallConvolveMersenne31".
    
    (*
        fn read(input: Mersenne31) -> i64 {
            input.value as i64
        }
    *)
    Definition read (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ input ] =>
        ltac:(M.monadic
          (let input := M.alloc (| input |) in
          M.cast
            (Ty.path "i64")
            (M.read (|
              M.SubPointer.get_struct_record_field (|
                input,
                "p3_mersenne_31::mersenne_31::Mersenne31",
                "value"
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn parity_dot<const N: usize>(u: [i64; N], v: [i64; N]) -> i64 {
            dot_product(u, v)
        }
    *)
    Definition parity_dot (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ N ], [], [ u; v ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.path "i64",
            M.get_function (| "p3_mds::util::dot_product", [ N ], [ Ty.path "i64" ] |),
            [ M.read (| u |); M.read (| v |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn reduce(z: i64) -> Mersenne31 {
            debug_assert!(z >= 0);
            Mersenne31::from_u64(z as u64)
        }
    *)
    Definition reduce (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ z ] =>
        ltac:(M.monadic
          (let z := M.alloc (| z |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.ge,
                                          [ M.read (| z |); Value.Integer IntegerKind.I64 0 ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: z >= 0" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                M.get_trait_method (|
                  "p3_field::field::PrimeCharacteristicRing",
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                  [],
                  [],
                  "from_u64",
                  [],
                  []
                |),
                [ M.cast (Ty.path "u64") (M.read (| z |)) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::karatsuba_convolution::Convolve"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
          Ty.path "i64";
          Ty.path "i64";
          Ty.path "i64"
        ]
        Self
        (* Instance *)
        [
          ("read", InstanceField.Method read);
          ("parity_dot", InstanceField.Method parity_dot);
          ("reduce", InstanceField.Method reduce)
        ].
  End Impl_p3_mds_karatsuba_convolution_Convolve_p3_mersenne_31_mersenne_31_Mersenne31_i64_i64_i64_for_p3_mersenne_31_mds_SmallConvolveMersenne31.
  
  (* StructTuple
    {
      name := "LargeConvolveMersenne31";
      const_params := [];
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_p3_mds_karatsuba_convolution_Convolve_p3_mersenne_31_mersenne_31_Mersenne31_i64_i64_i64_for_p3_mersenne_31_mds_LargeConvolveMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::LargeConvolveMersenne31".
    
    (*
        fn read(input: Mersenne31) -> i64 {
            input.value as i64
        }
    *)
    Definition read (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ input ] =>
        ltac:(M.monadic
          (let input := M.alloc (| input |) in
          M.cast
            (Ty.path "i64")
            (M.read (|
              M.SubPointer.get_struct_record_field (|
                input,
                "p3_mersenne_31::mersenne_31::Mersenne31",
                "value"
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn parity_dot<const N: usize>(u: [i64; N], v: [i64; N]) -> i64 {
            // For a convolution of size N, |x|, |y| < N * 2^31, so the product
            // could be as much as N^2 * 2^62. This will overflow an i64, so
            // we first widen to i128.
    
            let mut dp = 0i128;
            for i in 0..N {
                dp += u[i] as i128 * v[i] as i128;
            }
    
            const LOWMASK: i128 = (1 << 42) - 1; // Gets the bits lower than 42.
            const HIGHMASK: i128 = !LOWMASK; // Gets all bits higher than 42.
    
            let low_bits = (dp & LOWMASK) as i64; // low_bits < 2**42
            let high_bits = ((dp & HIGHMASK) >> 31) as i64; // |high_bits| < 2**(n - 31)
    
            // Proof that low_bits + high_bits is congruent to dp (mod p)
            // and congruent to dp (mod 2^11):
            //
            // The individual bounds clearly show that low_bits +
            // high_bits < 2**(n - 30).
            //
            // Next observe that low_bits + high_bits = input - (2**31 -
            // 1) * (high_bits) = input mod P.
            //
            // Finally note that 2**11 divides high_bits and so low_bits +
            // high_bits = low_bits mod 2**11 = input mod 2**11.
    
            low_bits + high_bits
        }
    *)
    Definition parity_dot (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ N ], [], [ u; v ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          let v := M.alloc (| v |) in
          M.read (|
            let~ dp : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
              M.alloc (| Value.Integer IntegerKind.I128 0 |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.use
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [ ("start", Value.Integer IntegerKind.Usize 0); ("end_", N) ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let i := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          let β := dp in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "i128",
                                              BinOp.Wrap.add,
                                              [
                                                M.read (| β |);
                                                M.call_closure (|
                                                  Ty.path "i128",
                                                  BinOp.Wrap.mul,
                                                  [
                                                    M.cast
                                                      (Ty.path "i128")
                                                      (M.read (|
                                                        M.SubPointer.get_array_field (|
                                                          u,
                                                          M.read (| i |)
                                                        |)
                                                      |));
                                                    M.cast
                                                      (Ty.path "i128")
                                                      (M.read (|
                                                        M.SubPointer.get_array_field (|
                                                          v,
                                                          M.read (| i |)
                                                        |)
                                                      |))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            let~ low_bits : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
              M.alloc (|
                M.cast
                  (Ty.path "i64")
                  (M.call_closure (|
                    Ty.path "i128",
                    BinOp.Wrap.bit_and,
                    [
                      M.read (| dp |);
                      M.read (|
                        get_constant (|
                          "p3_mersenne_31::mds::parity_dot::LOWMASK",
                          Ty.path "i128"
                        |)
                      |)
                    ]
                  |))
              |) in
            let~ high_bits : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
              M.alloc (|
                M.cast
                  (Ty.path "i64")
                  (M.call_closure (|
                    Ty.path "i128",
                    BinOp.Wrap.shr,
                    [
                      M.call_closure (|
                        Ty.path "i128",
                        BinOp.Wrap.bit_and,
                        [
                          M.read (| dp |);
                          M.read (|
                            get_constant (|
                              "p3_mersenne_31::mds::parity_dot::HIGHMASK",
                              Ty.path "i128"
                            |)
                          |)
                        ]
                      |);
                      Value.Integer IntegerKind.I32 31
                    ]
                  |))
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "i64",
                BinOp.Wrap.add,
                [ M.read (| low_bits |); M.read (| high_bits |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn reduce(z: i64) -> Mersenne31 {
            // After the dot product, the maximal size is N^2 * 2^62 < 2^74
            // as N = 64 is the biggest size. So, after the partial
            // reduction, the output z of parity dot satisfies |z| < 2^44
            // (Where 44 is 74 - 30).
            //
            // In the recombining steps, conv maps (wo, w1) -> ((wo + w1)/2,
            // (wo + w1)/2) which has no effect on the maximal size. (Indeed,
            // it makes sizes almost strictly smaller).
            //
            // On the other hand, negacyclic_conv (ignoring the re-index)
            // recombines as: (w0, w1, w2) -> (w0 + w1, w2 - w0 - w1). Hence
            // if the input is <= K, the output is <= 3K.
            //
            // Thus the values appearing at the end are bounded by 3^n 2^44
            // where n is the maximal number of negacyclic_conv recombination
            // steps. When N = 64, we need to recombine for singed_conv_32,
            // singed_conv_16, singed_conv_8 so the overall bound will be 3^3
            // 2^44 < 32 * 2^44 < 2^49.
            debug_assert!(z > -(1i64 << 49));
            debug_assert!(z < (1i64 << 49));
    
            const MASK: i64 = (1 << 31) - 1;
            // Morally, our value is a i62 not a i64 as the top 3 bits are
            // guaranteed to be equal.
            let low_bits = unsafe {
                // This is safe as 0 <= z & MASK < 2^31
                Mersenne31::from_canonical_unchecked((z & MASK) as u32)
            };
    
            let high_bits = ((z >> 31) & MASK) as i32;
            let sign_bits = (z >> 62) as i32;
    
            let high = unsafe {
                // This is safe as high_bits + sign_bits > 0 as by assumption b[63] = b[61].
                Mersenne31::from_canonical_unchecked((high_bits + sign_bits) as u32)
            };
            low_bits + high
        }
    *)
    Definition reduce (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ z ] =>
        ltac:(M.monadic
          (let z := M.alloc (| z |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.gt,
                                          [
                                            M.read (| z |);
                                            UnOp.neg (|
                                              M.call_closure (|
                                                Ty.path "i64",
                                                BinOp.Wrap.shl,
                                                [
                                                  Value.Integer IntegerKind.I64 1;
                                                  Value.Integer IntegerKind.I32 49
                                                ]
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: z > -(1i64 << 49)" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [
                                            M.read (| z |);
                                            M.call_closure (|
                                              Ty.path "i64",
                                              BinOp.Wrap.shl,
                                              [
                                                Value.Integer IntegerKind.I64 1;
                                                Value.Integer IntegerKind.I32 49
                                              ]
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: z < (1i64 << 49)" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ low_bits :
                Ty.apply (Ty.path "*") [] [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                    [],
                    [ Ty.path "u32" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [
                    M.cast
                      (Ty.path "u32")
                      (M.call_closure (|
                        Ty.path "i64",
                        BinOp.Wrap.bit_and,
                        [
                          M.read (| z |);
                          M.read (|
                            get_constant (| "p3_mersenne_31::mds::reduce::MASK", Ty.path "i64" |)
                          |)
                        ]
                      |))
                  ]
                |)
              |) in
            let~ high_bits : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
              M.alloc (|
                M.cast
                  (Ty.path "i32")
                  (M.call_closure (|
                    Ty.path "i64",
                    BinOp.Wrap.bit_and,
                    [
                      M.call_closure (|
                        Ty.path "i64",
                        BinOp.Wrap.shr,
                        [ M.read (| z |); Value.Integer IntegerKind.I32 31 ]
                      |);
                      M.read (|
                        get_constant (| "p3_mersenne_31::mds::reduce::MASK", Ty.path "i64" |)
                      |)
                    ]
                  |))
              |) in
            let~ sign_bits : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
              M.alloc (|
                M.cast
                  (Ty.path "i32")
                  (M.call_closure (|
                    Ty.path "i64",
                    BinOp.Wrap.shr,
                    [ M.read (| z |); Value.Integer IntegerKind.I32 62 ]
                  |))
              |) in
            let~ high :
                Ty.apply (Ty.path "*") [] [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                  M.get_trait_method (|
                    "p3_field::integers::QuotientMap",
                    Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                    [],
                    [ Ty.path "u32" ],
                    "from_canonical_unchecked",
                    [],
                    []
                  |),
                  [
                    M.cast
                      (Ty.path "u32")
                      (M.call_closure (|
                        Ty.path "i32",
                        BinOp.Wrap.add,
                        [ M.read (| high_bits |); M.read (| sign_bits |) ]
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                M.get_trait_method (|
                  "core::ops::arith::Add",
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31",
                  [],
                  [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
                  "add",
                  [],
                  []
                |),
                [ M.read (| low_bits |); M.read (| high |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::karatsuba_convolution::Convolve"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
          Ty.path "i64";
          Ty.path "i64";
          Ty.path "i64"
        ]
        Self
        (* Instance *)
        [
          ("read", InstanceField.Method read);
          ("parity_dot", InstanceField.Method parity_dot);
          ("reduce", InstanceField.Method reduce)
        ].
  End Impl_p3_mds_karatsuba_convolution_Convolve_p3_mersenne_31_mersenne_31_Mersenne31_i64_i64_i64_for_p3_mersenne_31_mds_LargeConvolveMersenne31.
  
  Definition value_MATRIX_CIRC_MDS_8_SML_ROW
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.Array
          [
            Value.Integer IntegerKind.I64 7;
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 3;
            Value.Integer IntegerKind.I64 8;
            Value.Integer IntegerKind.I64 8;
            Value.Integer IntegerKind.I64 3;
            Value.Integer IntegerKind.I64 4;
            Value.Integer IntegerKind.I64 9
          ]
      |))).
  
  Global Instance Instance_IsConstant_value_MATRIX_CIRC_MDS_8_SML_ROW :
    M.IsFunction.C "p3_mersenne_31::mds::MATRIX_CIRC_MDS_8_SML_ROW" value_MATRIX_CIRC_MDS_8_SML_ROW.
  Admitted.
  Global Typeclasses Opaque value_MATRIX_CIRC_MDS_8_SML_ROW.
  
  Module Impl_p3_symmetric_permutation_Permutation_array_Usize_8_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (*
        fn permute(&self, input: [Mersenne31; 8]) -> [Mersenne31; 8] {
            const MATRIX_CIRC_MDS_8_SML_COL: [i64; 8] =
                first_row_to_first_col(&MATRIX_CIRC_MDS_8_SML_ROW);
            SmallConvolveMersenne31::apply(
                input,
                MATRIX_CIRC_MDS_8_SML_COL,
                SmallConvolveMersenne31::conv8,
            )
        }
    *)
    Definition permute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 8 ]
              [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
            M.get_trait_method (|
              "p3_mds::karatsuba_convolution::Convolve",
              Ty.path "p3_mersenne_31::mds::SmallConvolveMersenne31",
              [],
              [
                Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                Ty.path "i64";
                Ty.path "i64";
                Ty.path "i64"
              ],
              "apply",
              [ Value.Integer IntegerKind.Usize 8 ],
              [
                Ty.function
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 8 ]
                      [ Ty.path "i64" ];
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 8 ]
                      [ Ty.path "i64" ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| input |);
              M.read (|
                get_constant (|
                  "p3_mersenne_31::mds::permute::MATRIX_CIRC_MDS_8_SML_COL",
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "i64" ]
                |)
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Ty.path "p3_mersenne_31::mds::SmallConvolveMersenne31",
                [],
                [
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                  Ty.path "i64";
                  Ty.path "i64";
                  Ty.path "i64"
                ],
                "conv8",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permute_mut(&self, input: &mut [Mersenne31; 8]) {
            *input = self.permute( *input);
        }
    *)
    Definition permute_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| input |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 8 ]
                      [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
                    M.get_trait_method (|
                      "p3_symmetric::permutation::Permutation",
                      Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31",
                      [],
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 8 ]
                          [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
                      ],
                      "permute",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| M.deref (| M.read (| input |) |) |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_symmetric::permutation::Permutation"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "array")
            [ Value.Integer IntegerKind.Usize 8 ]
            [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        ]
        Self
        (* Instance *)
        [
          ("permute", InstanceField.Method permute);
          ("permute_mut", InstanceField.Method permute_mut)
        ].
  End Impl_p3_symmetric_permutation_Permutation_array_Usize_8_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Module Impl_p3_mds_MdsPermutation_Usize_8_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::MdsPermutation"
        (* Trait polymorphic consts *) [ Value.Integer IntegerKind.Usize 8 ]
        (* Trait polymorphic types *) [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        Self
        (* Instance *) [].
  End Impl_p3_mds_MdsPermutation_Usize_8_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Definition value_MATRIX_CIRC_MDS_12_SML_ROW
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.Array
          [
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 2;
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 8;
            Value.Integer IntegerKind.I64 9;
            Value.Integer IntegerKind.I64 10;
            Value.Integer IntegerKind.I64 7;
            Value.Integer IntegerKind.I64 5;
            Value.Integer IntegerKind.I64 9;
            Value.Integer IntegerKind.I64 4;
            Value.Integer IntegerKind.I64 10
          ]
      |))).
  
  Global Instance Instance_IsConstant_value_MATRIX_CIRC_MDS_12_SML_ROW :
    M.IsFunction.C
      "p3_mersenne_31::mds::MATRIX_CIRC_MDS_12_SML_ROW"
      value_MATRIX_CIRC_MDS_12_SML_ROW.
  Admitted.
  Global Typeclasses Opaque value_MATRIX_CIRC_MDS_12_SML_ROW.
  
  Module Impl_p3_symmetric_permutation_Permutation_array_Usize_12_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (*
        fn permute(&self, input: [Mersenne31; 12]) -> [Mersenne31; 12] {
            const MATRIX_CIRC_MDS_12_SML_COL: [i64; 12] =
                first_row_to_first_col(&MATRIX_CIRC_MDS_12_SML_ROW);
            SmallConvolveMersenne31::apply(
                input,
                MATRIX_CIRC_MDS_12_SML_COL,
                SmallConvolveMersenne31::conv12,
            )
        }
    *)
    Definition permute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 12 ]
              [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
            M.get_trait_method (|
              "p3_mds::karatsuba_convolution::Convolve",
              Ty.path "p3_mersenne_31::mds::SmallConvolveMersenne31",
              [],
              [
                Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                Ty.path "i64";
                Ty.path "i64";
                Ty.path "i64"
              ],
              "apply",
              [ Value.Integer IntegerKind.Usize 12 ],
              [
                Ty.function
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 12 ]
                      [ Ty.path "i64" ];
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 12 ]
                      [ Ty.path "i64" ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| input |);
              M.read (|
                get_constant (|
                  "p3_mersenne_31::mds::permute::MATRIX_CIRC_MDS_12_SML_COL",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 12 ]
                    [ Ty.path "i64" ]
                |)
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Ty.path "p3_mersenne_31::mds::SmallConvolveMersenne31",
                [],
                [
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                  Ty.path "i64";
                  Ty.path "i64";
                  Ty.path "i64"
                ],
                "conv12",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permute_mut(&self, input: &mut [Mersenne31; 12]) {
            *input = self.permute( *input);
        }
    *)
    Definition permute_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| input |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 12 ]
                      [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
                    M.get_trait_method (|
                      "p3_symmetric::permutation::Permutation",
                      Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31",
                      [],
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 12 ]
                          [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
                      ],
                      "permute",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| M.deref (| M.read (| input |) |) |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_symmetric::permutation::Permutation"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "array")
            [ Value.Integer IntegerKind.Usize 12 ]
            [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        ]
        Self
        (* Instance *)
        [
          ("permute", InstanceField.Method permute);
          ("permute_mut", InstanceField.Method permute_mut)
        ].
  End Impl_p3_symmetric_permutation_Permutation_array_Usize_12_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Module Impl_p3_mds_MdsPermutation_Usize_12_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::MdsPermutation"
        (* Trait polymorphic consts *) [ Value.Integer IntegerKind.Usize 12 ]
        (* Trait polymorphic types *) [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        Self
        (* Instance *) [].
  End Impl_p3_mds_MdsPermutation_Usize_12_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Definition value_MATRIX_CIRC_MDS_16_SML_ROW
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.Array
          [
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 51;
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 11;
            Value.Integer IntegerKind.I64 17;
            Value.Integer IntegerKind.I64 2;
            Value.Integer IntegerKind.I64 1;
            Value.Integer IntegerKind.I64 101;
            Value.Integer IntegerKind.I64 63;
            Value.Integer IntegerKind.I64 15;
            Value.Integer IntegerKind.I64 2;
            Value.Integer IntegerKind.I64 67;
            Value.Integer IntegerKind.I64 22;
            Value.Integer IntegerKind.I64 13;
            Value.Integer IntegerKind.I64 3
          ]
      |))).
  
  Global Instance Instance_IsConstant_value_MATRIX_CIRC_MDS_16_SML_ROW :
    M.IsFunction.C
      "p3_mersenne_31::mds::MATRIX_CIRC_MDS_16_SML_ROW"
      value_MATRIX_CIRC_MDS_16_SML_ROW.
  Admitted.
  Global Typeclasses Opaque value_MATRIX_CIRC_MDS_16_SML_ROW.
  
  Module Impl_p3_symmetric_permutation_Permutation_array_Usize_16_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (*
        fn permute(&self, input: [Mersenne31; 16]) -> [Mersenne31; 16] {
            const MATRIX_CIRC_MDS_16_SML_COL: [i64; 16] =
                first_row_to_first_col(&MATRIX_CIRC_MDS_16_SML_ROW);
            SmallConvolveMersenne31::apply(
                input,
                MATRIX_CIRC_MDS_16_SML_COL,
                SmallConvolveMersenne31::conv16,
            )
        }
    *)
    Definition permute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 16 ]
              [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
            M.get_trait_method (|
              "p3_mds::karatsuba_convolution::Convolve",
              Ty.path "p3_mersenne_31::mds::SmallConvolveMersenne31",
              [],
              [
                Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                Ty.path "i64";
                Ty.path "i64";
                Ty.path "i64"
              ],
              "apply",
              [ Value.Integer IntegerKind.Usize 16 ],
              [
                Ty.function
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "i64" ];
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "i64" ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| input |);
              M.read (|
                get_constant (|
                  "p3_mersenne_31::mds::permute::MATRIX_CIRC_MDS_16_SML_COL",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "i64" ]
                |)
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Ty.path "p3_mersenne_31::mds::SmallConvolveMersenne31",
                [],
                [
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                  Ty.path "i64";
                  Ty.path "i64";
                  Ty.path "i64"
                ],
                "conv16",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permute_mut(&self, input: &mut [Mersenne31; 16]) {
            *input = self.permute( *input);
        }
    *)
    Definition permute_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| input |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
                    M.get_trait_method (|
                      "p3_symmetric::permutation::Permutation",
                      Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31",
                      [],
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 16 ]
                          [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
                      ],
                      "permute",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| M.deref (| M.read (| input |) |) |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_symmetric::permutation::Permutation"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "array")
            [ Value.Integer IntegerKind.Usize 16 ]
            [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        ]
        Self
        (* Instance *)
        [
          ("permute", InstanceField.Method permute);
          ("permute_mut", InstanceField.Method permute_mut)
        ].
  End Impl_p3_symmetric_permutation_Permutation_array_Usize_16_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Module Impl_p3_mds_MdsPermutation_Usize_16_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::MdsPermutation"
        (* Trait polymorphic consts *) [ Value.Integer IntegerKind.Usize 16 ]
        (* Trait polymorphic types *) [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        Self
        (* Instance *) [].
  End Impl_p3_mds_MdsPermutation_Usize_16_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Definition value_MATRIX_CIRC_MDS_32_MERSENNE31_ROW
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.Array
          [
            Value.Integer IntegerKind.I64 412540024;
            Value.Integer IntegerKind.I64 1436360233;
            Value.Integer IntegerKind.I64 82564914;
            Value.Integer IntegerKind.I64 1072974295;
            Value.Integer IntegerKind.I64 766567118;
            Value.Integer IntegerKind.I64 645360517;
            Value.Integer IntegerKind.I64 1979813463;
            Value.Integer IntegerKind.I64 270924307;
            Value.Integer IntegerKind.I64 105409451;
            Value.Integer IntegerKind.I64 930115258;
            Value.Integer IntegerKind.I64 636196459;
            Value.Integer IntegerKind.I64 289154277;
            Value.Integer IntegerKind.I64 719457988;
            Value.Integer IntegerKind.I64 1512525948;
            Value.Integer IntegerKind.I64 215190769;
            Value.Integer IntegerKind.I64 1981550821;
            Value.Integer IntegerKind.I64 434368282;
            Value.Integer IntegerKind.I64 53244687;
            Value.Integer IntegerKind.I64 903393155;
            Value.Integer IntegerKind.I64 1696461115;
            Value.Integer IntegerKind.I64 2126764826;
            Value.Integer IntegerKind.I64 1779722644;
            Value.Integer IntegerKind.I64 1485803845;
            Value.Integer IntegerKind.I64 163026005;
            Value.Integer IntegerKind.I64 2144994796;
            Value.Integer IntegerKind.I64 436105640;
            Value.Integer IntegerKind.I64 1770558586;
            Value.Integer IntegerKind.I64 1649351985;
            Value.Integer IntegerKind.I64 1342944808;
            Value.Integer IntegerKind.I64 185870542;
            Value.Integer IntegerKind.I64 979558870;
            Value.Integer IntegerKind.I64 2003379079
          ]
      |))).
  
  Global Instance Instance_IsConstant_value_MATRIX_CIRC_MDS_32_MERSENNE31_ROW :
    M.IsFunction.C
      "p3_mersenne_31::mds::MATRIX_CIRC_MDS_32_MERSENNE31_ROW"
      value_MATRIX_CIRC_MDS_32_MERSENNE31_ROW.
  Admitted.
  Global Typeclasses Opaque value_MATRIX_CIRC_MDS_32_MERSENNE31_ROW.
  
  Module Impl_p3_symmetric_permutation_Permutation_array_Usize_32_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (*
        fn permute(&self, input: [Mersenne31; 32]) -> [Mersenne31; 32] {
            const MATRIX_CIRC_MDS_32_MERSENNE31_COL: [i64; 32] =
                first_row_to_first_col(&MATRIX_CIRC_MDS_32_MERSENNE31_ROW);
            LargeConvolveMersenne31::apply(
                input,
                MATRIX_CIRC_MDS_32_MERSENNE31_COL,
                LargeConvolveMersenne31::conv32,
            )
        }
    *)
    Definition permute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 32 ]
              [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
            M.get_trait_method (|
              "p3_mds::karatsuba_convolution::Convolve",
              Ty.path "p3_mersenne_31::mds::LargeConvolveMersenne31",
              [],
              [
                Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                Ty.path "i64";
                Ty.path "i64";
                Ty.path "i64"
              ],
              "apply",
              [ Value.Integer IntegerKind.Usize 32 ],
              [
                Ty.function
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "i64" ];
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "i64" ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| input |);
              M.read (|
                get_constant (|
                  "p3_mersenne_31::mds::permute::MATRIX_CIRC_MDS_32_MERSENNE31_COL",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [ Ty.path "i64" ]
                |)
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Ty.path "p3_mersenne_31::mds::LargeConvolveMersenne31",
                [],
                [
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                  Ty.path "i64";
                  Ty.path "i64";
                  Ty.path "i64"
                ],
                "conv32",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permute_mut(&self, input: &mut [Mersenne31; 32]) {
            *input = self.permute( *input);
        }
    *)
    Definition permute_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| input |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
                    M.get_trait_method (|
                      "p3_symmetric::permutation::Permutation",
                      Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31",
                      [],
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
                      ],
                      "permute",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| M.deref (| M.read (| input |) |) |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_symmetric::permutation::Permutation"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "array")
            [ Value.Integer IntegerKind.Usize 32 ]
            [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        ]
        Self
        (* Instance *)
        [
          ("permute", InstanceField.Method permute);
          ("permute_mut", InstanceField.Method permute_mut)
        ].
  End Impl_p3_symmetric_permutation_Permutation_array_Usize_32_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Module Impl_p3_mds_MdsPermutation_Usize_32_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::MdsPermutation"
        (* Trait polymorphic consts *) [ Value.Integer IntegerKind.Usize 32 ]
        (* Trait polymorphic types *) [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        Self
        (* Instance *) [].
  End Impl_p3_mds_MdsPermutation_Usize_32_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Definition value_MATRIX_CIRC_MDS_64_MERSENNE31_ROW
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.Array
          [
            Value.Integer IntegerKind.I64 1459759013;
            Value.Integer IntegerKind.I64 922916927;
            Value.Integer IntegerKind.I64 1266367242;
            Value.Integer IntegerKind.I64 1961967075;
            Value.Integer IntegerKind.I64 1213404336;
            Value.Integer IntegerKind.I64 22536940;
            Value.Integer IntegerKind.I64 450029022;
            Value.Integer IntegerKind.I64 1913984483;
            Value.Integer IntegerKind.I64 1414704547;
            Value.Integer IntegerKind.I64 208975553;
            Value.Integer IntegerKind.I64 1742378064;
            Value.Integer IntegerKind.I64 866419561;
            Value.Integer IntegerKind.I64 1004269062;
            Value.Integer IntegerKind.I64 2087161182;
            Value.Integer IntegerKind.I64 370087635;
            Value.Integer IntegerKind.I64 1418234764;
            Value.Integer IntegerKind.I64 1718385318;
            Value.Integer IntegerKind.I64 289114594;
            Value.Integer IntegerKind.I64 708852962;
            Value.Integer IntegerKind.I64 419028802;
            Value.Integer IntegerKind.I64 711483012;
            Value.Integer IntegerKind.I64 1240399333;
            Value.Integer IntegerKind.I64 1560561670;
            Value.Integer IntegerKind.I64 1443512824;
            Value.Integer IntegerKind.I64 1777277904;
            Value.Integer IntegerKind.I64 751916934;
            Value.Integer IntegerKind.I64 1658877798;
            Value.Integer IntegerKind.I64 581054946;
            Value.Integer IntegerKind.I64 1023210508;
            Value.Integer IntegerKind.I64 1318020056;
            Value.Integer IntegerKind.I64 1768258069;
            Value.Integer IntegerKind.I64 1181436717;
            Value.Integer IntegerKind.I64 1100264658;
            Value.Integer IntegerKind.I64 513443306;
            Value.Integer IntegerKind.I64 963681319;
            Value.Integer IntegerKind.I64 1258490867;
            Value.Integer IntegerKind.I64 1700646429;
            Value.Integer IntegerKind.I64 622823577;
            Value.Integer IntegerKind.I64 1529784441;
            Value.Integer IntegerKind.I64 504423471;
            Value.Integer IntegerKind.I64 838188551;
            Value.Integer IntegerKind.I64 721139705;
            Value.Integer IntegerKind.I64 1041302042;
            Value.Integer IntegerKind.I64 1570218363;
            Value.Integer IntegerKind.I64 1862672573;
            Value.Integer IntegerKind.I64 1572848413;
            Value.Integer IntegerKind.I64 1992586781;
            Value.Integer IntegerKind.I64 563316057;
            Value.Integer IntegerKind.I64 863466611;
            Value.Integer IntegerKind.I64 1911613740;
            Value.Integer IntegerKind.I64 194540193;
            Value.Integer IntegerKind.I64 1277432313;
            Value.Integer IntegerKind.I64 1415281814;
            Value.Integer IntegerKind.I64 539323311;
            Value.Integer IntegerKind.I64 2072725822;
            Value.Integer IntegerKind.I64 866996828;
            Value.Integer IntegerKind.I64 367716892;
            Value.Integer IntegerKind.I64 1831672353;
            Value.Integer IntegerKind.I64 111680788;
            Value.Integer IntegerKind.I64 1068297039;
            Value.Integer IntegerKind.I64 319734300;
            Value.Integer IntegerKind.I64 1015334133;
            Value.Integer IntegerKind.I64 1358784448;
            Value.Integer IntegerKind.I64 821942362
          ]
      |))).
  
  Global Instance Instance_IsConstant_value_MATRIX_CIRC_MDS_64_MERSENNE31_ROW :
    M.IsFunction.C
      "p3_mersenne_31::mds::MATRIX_CIRC_MDS_64_MERSENNE31_ROW"
      value_MATRIX_CIRC_MDS_64_MERSENNE31_ROW.
  Admitted.
  Global Typeclasses Opaque value_MATRIX_CIRC_MDS_64_MERSENNE31_ROW.
  
  Module Impl_p3_symmetric_permutation_Permutation_array_Usize_64_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    (*
        fn permute(&self, input: [Mersenne31; 64]) -> [Mersenne31; 64] {
            const MATRIX_CIRC_MDS_64_MERSENNE31_COL: [i64; 64] =
                first_row_to_first_col(&MATRIX_CIRC_MDS_64_MERSENNE31_ROW);
            LargeConvolveMersenne31::apply(
                input,
                MATRIX_CIRC_MDS_64_MERSENNE31_COL,
                LargeConvolveMersenne31::conv64,
            )
        }
    *)
    Definition permute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 64 ]
              [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
            M.get_trait_method (|
              "p3_mds::karatsuba_convolution::Convolve",
              Ty.path "p3_mersenne_31::mds::LargeConvolveMersenne31",
              [],
              [
                Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                Ty.path "i64";
                Ty.path "i64";
                Ty.path "i64"
              ],
              "apply",
              [ Value.Integer IntegerKind.Usize 64 ],
              [
                Ty.function
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 64 ]
                      [ Ty.path "i64" ];
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 64 ]
                      [ Ty.path "i64" ];
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ] ]
                  ]
                  (Ty.tuple [])
              ]
            |),
            [
              M.read (| input |);
              M.read (|
                get_constant (|
                  "p3_mersenne_31::mds::permute::MATRIX_CIRC_MDS_64_MERSENNE31_COL",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 64 ]
                    [ Ty.path "i64" ]
                |)
              |);
              M.get_trait_method (|
                "p3_mds::karatsuba_convolution::Convolve",
                Ty.path "p3_mersenne_31::mds::LargeConvolveMersenne31",
                [],
                [
                  Ty.path "p3_mersenne_31::mersenne_31::Mersenne31";
                  Ty.path "i64";
                  Ty.path "i64";
                  Ty.path "i64"
                ],
                "conv64",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permute_mut(&self, input: &mut [Mersenne31; 64]) {
            *input = self.permute( *input);
        }
    *)
    Definition permute_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; input ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let input := M.alloc (| input |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| input |) |),
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 64 ]
                      [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ],
                    M.get_trait_method (|
                      "p3_symmetric::permutation::Permutation",
                      Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31",
                      [],
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 64 ]
                          [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
                      ],
                      "permute",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| M.deref (| M.read (| input |) |) |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_symmetric::permutation::Permutation"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "array")
            [ Value.Integer IntegerKind.Usize 64 ]
            [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        ]
        Self
        (* Instance *)
        [
          ("permute", InstanceField.Method permute);
          ("permute_mut", InstanceField.Method permute_mut)
        ].
  End Impl_p3_symmetric_permutation_Permutation_array_Usize_64_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
  
  Module Impl_p3_mds_MdsPermutation_Usize_64_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
    Definition Self : Ty.t := Ty.path "p3_mersenne_31::mds::MdsMatrixMersenne31".
    
    Axiom Implements :
      M.IsTraitInstance
        "p3_mds::MdsPermutation"
        (* Trait polymorphic consts *) [ Value.Integer IntegerKind.Usize 64 ]
        (* Trait polymorphic types *) [ Ty.path "p3_mersenne_31::mersenne_31::Mersenne31" ]
        Self
        (* Instance *) [].
  End Impl_p3_mds_MdsPermutation_Usize_64_p3_mersenne_31_mersenne_31_Mersenne31_for_p3_mersenne_31_mds_MdsMatrixMersenne31.
End mds.
