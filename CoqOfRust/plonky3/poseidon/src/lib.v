(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructRecord
  {
    name := "Poseidon";
    const_params := [ "WIDTH"; "ALPHA" ];
    ty_params := [ "F"; "Mds" ];
    fields :=
      [
        ("half_num_full_rounds", Ty.path "usize");
        ("num_partial_rounds", Ty.path "usize");
        ("constants",
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]);
        ("mds", Mds)
      ];
  } *)

Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_core_clone_Clone_Mds_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.
  Definition Self (WIDTH ALPHA : Value.t) (F Mds : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ].
  
  (* Clone *)
  Definition clone
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        Value.StructRecord
          "p3_poseidon::Poseidon"
          [
            ("half_num_full_rounds",
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "usize",
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_poseidon::Poseidon",
                          "half_num_full_rounds"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("num_partial_rounds",
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "usize",
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_poseidon::Poseidon",
                          "num_partial_rounds"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("constants",
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_poseidon::Poseidon",
                          "constants"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("mds",
              M.call_closure (|
                Mds,
                M.get_trait_method (| "core::clone::Clone", Mds, [], [], "clone", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_poseidon::Poseidon",
                          "mds"
                        |)
                      |)
                    |)
                  |)
                ]
              |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self WIDTH ALPHA F Mds)
      (* Instance *) [ ("clone", InstanceField.Method (clone WIDTH ALPHA F Mds)) ].
End Impl_core_clone_Clone_where_core_clone_Clone_F_where_core_clone_Clone_Mds_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.

Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_core_fmt_Debug_Mds_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.
  Definition Self (WIDTH ALPHA : Value.t) (F Mds : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ].
  
  (* Debug *)
  Definition fmt
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_associated_function (|
            Ty.path "core::fmt::Formatter",
            "debug_struct_field4_finish",
            [],
            []
          |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Poseidon" |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "half_num_full_rounds" |) |) |);
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_poseidon::Poseidon",
                      "half_num_full_rounds"
                    |)
                  |)
                |)
              |));
            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "num_partial_rounds" |) |) |);
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_poseidon::Poseidon",
                      "num_partial_rounds"
                    |)
                  |)
                |)
              |));
            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "constants" |) |) |);
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_poseidon::Poseidon",
                      "constants"
                    |)
                  |)
                |)
              |));
            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "mds" |) |) |);
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_poseidon::Poseidon",
                          "mds"
                        |)
                      |)
                    |)
                  |)
                |)
              |))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self WIDTH ALPHA F Mds)
      (* Instance *) [ ("fmt", InstanceField.Method (fmt WIDTH ALPHA F Mds)) ].
End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_core_fmt_Debug_Mds_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.

Module Impl_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.
  Definition Self (WIDTH ALPHA : Value.t) (F Mds : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ].
  
  (*
      pub fn new(
          half_num_full_rounds: usize,
          num_partial_rounds: usize,
          constants: Vec<F>,
          mds: Mds,
      ) -> Self {
          let num_rounds = 2 * half_num_full_rounds + num_partial_rounds;
          assert_eq!(constants.len(), WIDTH * num_rounds);
          Self {
              half_num_full_rounds,
              num_partial_rounds,
              constants,
              mds,
          }
      }
  *)
  Definition new
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [], [ half_num_full_rounds; num_partial_rounds; constants; mds ] =>
      ltac:(M.monadic
        (let half_num_full_rounds := M.alloc (| half_num_full_rounds |) in
        let num_partial_rounds := M.alloc (| num_partial_rounds |) in
        let constants := M.alloc (| constants |) in
        let mds := M.alloc (| mds |) in
        M.read (|
          let~ num_rounds : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.mul,
                    [ Value.Integer IntegerKind.Usize 2; M.read (| half_num_full_rounds |) ]
                  |);
                  M.read (| num_partial_rounds |)
                ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                Value.Tuple
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, constants |) ]
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.mul,
                          [ WIDTH; M.read (| num_rounds |) ]
                        |)
                      |)
                    |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ kind :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.path "core::panicking::AssertKind" ] :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Eq" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          M.alloc (|
            Value.StructRecord
              "p3_poseidon::Poseidon"
              [
                ("half_num_full_rounds", M.read (| half_num_full_rounds |));
                ("num_partial_rounds", M.read (| num_partial_rounds |));
                ("constants", M.read (| constants |));
                ("mds", M.read (| mds |))
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_new :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsAssociatedFunction.C (Self WIDTH ALPHA F Mds) "new" (new WIDTH ALPHA F Mds).
  Admitted.
  Global Typeclasses Opaque new.
  
  (*
      pub fn new_from_rng<R: Rng>(
          half_num_full_rounds: usize,
          num_partial_rounds: usize,
          mds: Mds,
          rng: &mut R,
      ) -> Self
      where
          StandardUniform: Distribution<F>,
      {
          let num_rounds = 2 * half_num_full_rounds + num_partial_rounds;
          let num_constants = WIDTH * num_rounds;
          let constants = rng
              .sample_iter(StandardUniform)
              .take(num_constants)
              .collect::<Vec<_>>();
          Self {
              half_num_full_rounds,
              num_partial_rounds,
              constants,
              mds,
          }
      }
  *)
  Definition new_from_rng
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [ R ], [ half_num_full_rounds; num_partial_rounds; mds; rng ] =>
      ltac:(M.monadic
        (let half_num_full_rounds := M.alloc (| half_num_full_rounds |) in
        let num_partial_rounds := M.alloc (| num_partial_rounds |) in
        let mds := M.alloc (| mds |) in
        let rng := M.alloc (| rng |) in
        M.read (|
          let~ num_rounds : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.mul,
                    [ Value.Integer IntegerKind.Usize 2; M.read (| half_num_full_rounds |) ]
                  |);
                  M.read (| num_partial_rounds |)
                ]
              |)
            |) in
          let~ num_constants : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.mul,
                [ WIDTH; M.read (| num_rounds |) ]
              |)
            |) in
          let~ constants :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::take::Take")
                    []
                    [
                      Ty.apply
                        (Ty.path "rand::distr::distribution::Iter")
                        []
                        [
                          Ty.path "rand::distr::StandardUniform";
                          Ty.apply (Ty.path "&mut") [] [ R ];
                          F
                        ]
                    ],
                  [],
                  [],
                  "collect",
                  [],
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [
                        Ty.apply
                          (Ty.path "rand::distr::distribution::Iter")
                          []
                          [
                            Ty.path "rand::distr::StandardUniform";
                            Ty.apply (Ty.path "&mut") [] [ R ];
                            F
                          ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "rand::distr::distribution::Iter")
                        []
                        [
                          Ty.path "rand::distr::StandardUniform";
                          Ty.apply (Ty.path "&mut") [] [ R ];
                          F
                        ],
                      [],
                      [],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "rand::distr::distribution::Iter")
                          []
                          [
                            Ty.path "rand::distr::StandardUniform";
                            Ty.apply (Ty.path "&mut") [] [ R ];
                            F
                          ],
                        M.get_trait_method (|
                          "rand::rng::Rng",
                          Ty.apply (Ty.path "&mut") [] [ R ],
                          [],
                          [],
                          "sample_iter",
                          [],
                          [ F; Ty.path "rand::distr::StandardUniform" ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rng |) |) |);
                          Value.StructTuple "rand::distr::StandardUniform" []
                        ]
                      |);
                      M.read (| num_constants |)
                    ]
                  |)
                ]
              |)
            |) in
          M.alloc (|
            Value.StructRecord
              "p3_poseidon::Poseidon"
              [
                ("half_num_full_rounds", M.read (| half_num_full_rounds |));
                ("num_partial_rounds", M.read (| num_partial_rounds |));
                ("constants", M.read (| constants |));
                ("mds", M.read (| mds |))
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_new_from_rng :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsAssociatedFunction.C
      (Self WIDTH ALPHA F Mds)
      "new_from_rng"
      (new_from_rng WIDTH ALPHA F Mds).
  Admitted.
  Global Typeclasses Opaque new_from_rng.
  
  (*
      fn half_full_rounds<A>(&self, state: &mut [A; WIDTH], round_ctr: &mut usize)
      where
          A: Algebra<F> + InjectiveMonomial<ALPHA>,
          Mds: MdsPermutation<A, WIDTH>,
      {
          for _ in 0..self.half_num_full_rounds {
              self.constant_layer(state, *round_ctr);
              Self::full_sbox_layer(state);
              self.mds.permute_mut(state);
              *round_ctr += 1;
          }
      }
  *)
  Definition half_full_rounds
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [ A ], [ self; state; round_ctr ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let state := M.alloc (| state |) in
        let round_ctr := M.alloc (| round_ctr |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "core::ops::range::Range"
                      [
                        ("start", Value.Integer IntegerKind.Usize 0);
                        ("end_",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_poseidon::Poseidon",
                              "half_num_full_rounds"
                            |)
                          |))
                      ]
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "p3_poseidon::Poseidon")
                                            [ WIDTH; ALPHA ]
                                            [ F; Mds ],
                                          "constant_layer",
                                          [],
                                          [ A ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |);
                                          M.read (| M.deref (| M.read (| round_ctr |) |) |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "p3_poseidon::Poseidon")
                                            [ WIDTH; ALPHA ]
                                            [ F; Mds ],
                                          "full_sbox_layer",
                                          [],
                                          [ A ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "p3_symmetric::permutation::Permutation",
                                          Mds,
                                          [],
                                          [ Ty.apply (Ty.path "array") [ WIDTH ] [ A ] ],
                                          "permute_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "p3_poseidon::Poseidon",
                                              "mds"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      let β := M.deref (| M.read (| round_ctr |) |) in
                                      M.write (|
                                        β,
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                        |)
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_half_full_rounds :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsAssociatedFunction.C
      (Self WIDTH ALPHA F Mds)
      "half_full_rounds"
      (half_full_rounds WIDTH ALPHA F Mds).
  Admitted.
  Global Typeclasses Opaque half_full_rounds.
  
  (*
      fn partial_rounds<A>(&self, state: &mut [A; WIDTH], round_ctr: &mut usize)
      where
          A: Algebra<F> + InjectiveMonomial<ALPHA>,
          Mds: MdsPermutation<A, WIDTH>,
      {
          for _ in 0..self.num_partial_rounds {
              self.constant_layer(state, *round_ctr);
              Self::partial_sbox_layer(state);
              self.mds.permute_mut(state);
              *round_ctr += 1;
          }
      }
  *)
  Definition partial_rounds
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [ A ], [ self; state; round_ctr ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let state := M.alloc (| state |) in
        let round_ctr := M.alloc (| round_ctr |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "core::ops::range::Range"
                      [
                        ("start", Value.Integer IntegerKind.Usize 0);
                        ("end_",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_poseidon::Poseidon",
                              "num_partial_rounds"
                            |)
                          |))
                      ]
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "p3_poseidon::Poseidon")
                                            [ WIDTH; ALPHA ]
                                            [ F; Mds ],
                                          "constant_layer",
                                          [],
                                          [ A ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |);
                                          M.read (| M.deref (| M.read (| round_ctr |) |) |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "p3_poseidon::Poseidon")
                                            [ WIDTH; ALPHA ]
                                            [ F; Mds ],
                                          "partial_sbox_layer",
                                          [],
                                          [ A ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "p3_symmetric::permutation::Permutation",
                                          Mds,
                                          [],
                                          [ Ty.apply (Ty.path "array") [ WIDTH ] [ A ] ],
                                          "permute_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "p3_poseidon::Poseidon",
                                              "mds"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      let β := M.deref (| M.read (| round_ctr |) |) in
                                      M.write (|
                                        β,
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                        |)
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_partial_rounds :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsAssociatedFunction.C
      (Self WIDTH ALPHA F Mds)
      "partial_rounds"
      (partial_rounds WIDTH ALPHA F Mds).
  Admitted.
  Global Typeclasses Opaque partial_rounds.
  
  (*
      fn full_sbox_layer<A>(state: &mut [A; WIDTH])
      where
          A: Algebra<F> + InjectiveMonomial<ALPHA>,
      {
          for x in state.iter_mut() {
              *x = x.injective_exp_n();
          }
      }
  *)
  Definition full_sbox_layer
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [ A ], [ state ] =>
      ltac:(M.monadic
        (let state := M.alloc (| state |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ A ],
                        "iter_mut",
                        [],
                        []
                      |),
                      [
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |))
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ A ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let x := M.copy (| γ0_0 |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.write (|
                                        M.deref (| M.read (| x |) |),
                                        M.call_closure (|
                                          A,
                                          M.get_trait_method (|
                                            "p3_field::field::InjectiveMonomial",
                                            A,
                                            [ ALPHA ],
                                            [],
                                            "injective_exp_n",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| x |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_full_sbox_layer :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsAssociatedFunction.C
      (Self WIDTH ALPHA F Mds)
      "full_sbox_layer"
      (full_sbox_layer WIDTH ALPHA F Mds).
  Admitted.
  Global Typeclasses Opaque full_sbox_layer.
  
  (*
      fn partial_sbox_layer<A>(state: &mut [A; WIDTH])
      where
          A: Algebra<F> + InjectiveMonomial<ALPHA>,
      {
          state[0] = state[0].injective_exp_n();
      }
  *)
  Definition partial_sbox_layer
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [ A ], [ state ] =>
      ltac:(M.monadic
        (let state := M.alloc (| state |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (|
                  M.deref (| M.read (| state |) |),
                  Value.Integer IntegerKind.Usize 0
                |),
                M.call_closure (|
                  A,
                  M.get_trait_method (|
                    "p3_field::field::InjectiveMonomial",
                    A,
                    [ ALPHA ],
                    [],
                    "injective_exp_n",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| state |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |)
                  ]
                |)
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_partial_sbox_layer :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsAssociatedFunction.C
      (Self WIDTH ALPHA F Mds)
      "partial_sbox_layer"
      (partial_sbox_layer WIDTH ALPHA F Mds).
  Admitted.
  Global Typeclasses Opaque partial_sbox_layer.
  
  (*
      fn constant_layer<A>(&self, state: &mut [A; WIDTH], round: usize)
      where
          A: Algebra<F>,
      {
          for (i, x) in state.iter_mut().enumerate() {
              *x += self.constants[round * WIDTH + i];
          }
      }
  *)
  Definition constant_layer
      (WIDTH ALPHA : Value.t)
      (F Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F Mds in
    match ε, τ, α with
    | [], [ A ], [ self; state; round ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let state := M.alloc (| state |) in
        let round := M.alloc (| round |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::enumerate::Enumerate")
                    []
                    [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ] ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::enumerate::Enumerate")
                      []
                      [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ] ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ] ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                        [],
                        [],
                        "enumerate",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ A ],
                            "iter_mut",
                            [],
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |))
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&mut") [] [ A ] ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                    []
                                    [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ A ] ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                  let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                  let i := M.copy (| γ1_0 |) in
                                  let x := M.copy (| γ1_1 |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::ops::arith::AddAssign",
                                          A,
                                          [],
                                          [ F ],
                                          "add_assign",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| x |) |)
                                          |);
                                          M.read (|
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply (Ty.path "&") [] [ F ],
                                                M.get_trait_method (|
                                                  "core::ops::index::Index",
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ F; Ty.path "alloc::alloc::Global" ],
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "index",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "p3_poseidon::Poseidon",
                                                      "constants"
                                                    |)
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.mul,
                                                        [ M.read (| round |); WIDTH ]
                                                      |);
                                                      M.read (| i |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_constant_layer :
    forall (WIDTH ALPHA : Value.t) (F Mds : Ty.t),
    M.IsAssociatedFunction.C
      (Self WIDTH ALPHA F Mds)
      "constant_layer"
      (constant_layer WIDTH ALPHA F Mds).
  Admitted.
  Global Typeclasses Opaque constant_layer.
End Impl_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.

Module Impl_p3_symmetric_permutation_Permutation_where_p3_field_field_PrimeField_F_where_p3_field_field_InjectiveMonomial_F_where_p3_field_field_Algebra_A_F_where_p3_field_field_InjectiveMonomial_A_where_p3_mds_MdsPermutation_Mds_A_array_WIDTH_A_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.
  Definition Self (WIDTH ALPHA : Value.t) (F A Mds : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ].
  
  (*
      fn permute_mut(&self, state: &mut [A; WIDTH]) {
          let mut round_ctr = 0;
          self.half_full_rounds(state, &mut round_ctr);
          self.partial_rounds(state, &mut round_ctr);
          self.half_full_rounds(state, &mut round_ctr);
      }
  *)
  Definition permute_mut
      (WIDTH ALPHA : Value.t)
      (F A Mds : Ty.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self WIDTH ALPHA F A Mds in
    match ε, τ, α with
    | [], [], [ self; state ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let state := M.alloc (| state |) in
        M.read (|
          let~ round_ctr : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ],
                  "half_full_rounds",
                  [],
                  [ A ]
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (| M.borrow (| Pointer.Kind.MutRef, round_ctr |) |)
                  |)
                ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ],
                  "partial_rounds",
                  [],
                  [ A ]
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (| M.borrow (| Pointer.Kind.MutRef, round_ctr |) |)
                  |)
                ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ],
                  "half_full_rounds",
                  [],
                  [ A ]
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (| M.borrow (| Pointer.Kind.MutRef, round_ctr |) |)
                  |)
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (WIDTH ALPHA : Value.t) (F A Mds : Ty.t),
    M.IsTraitInstance
      "p3_symmetric::permutation::Permutation"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ WIDTH ] [ A ] ]
      (Self WIDTH ALPHA F A Mds)
      (* Instance *) [ ("permute_mut", InstanceField.Method (permute_mut WIDTH ALPHA F A Mds)) ].
End Impl_p3_symmetric_permutation_Permutation_where_p3_field_field_PrimeField_F_where_p3_field_field_InjectiveMonomial_F_where_p3_field_field_Algebra_A_F_where_p3_field_field_InjectiveMonomial_A_where_p3_mds_MdsPermutation_Mds_A_array_WIDTH_A_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.

Module Impl_p3_symmetric_permutation_CryptographicPermutation_where_p3_field_field_PrimeField_F_where_p3_field_field_InjectiveMonomial_F_where_p3_field_field_Algebra_A_F_where_p3_field_field_InjectiveMonomial_A_where_p3_mds_MdsPermutation_Mds_A_array_WIDTH_A_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.
  Definition Self (WIDTH ALPHA : Value.t) (F A Mds : Ty.t) : Ty.t :=
    Ty.apply (Ty.path "p3_poseidon::Poseidon") [ WIDTH; ALPHA ] [ F; Mds ].
  
  Axiom Implements :
    forall (WIDTH ALPHA : Value.t) (F A Mds : Ty.t),
    M.IsTraitInstance
      "p3_symmetric::permutation::CryptographicPermutation"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ WIDTH ] [ A ] ]
      (Self WIDTH ALPHA F A Mds)
      (* Instance *) [].
End Impl_p3_symmetric_permutation_CryptographicPermutation_where_p3_field_field_PrimeField_F_where_p3_field_field_InjectiveMonomial_F_where_p3_field_field_Algebra_A_F_where_p3_field_field_InjectiveMonomial_A_where_p3_mds_MdsPermutation_Mds_A_array_WIDTH_A_for_p3_poseidon_Poseidon_WIDTH_ALPHA_F_Mds.
