(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module util.
  (*
  pub(crate) fn shake256_hash(seed_bytes: &[u8], num_bytes: usize) -> Vec<u8> {
      let mut hasher = Shake256::default();
      hasher.update(seed_bytes);
      let mut reader = hasher.finalize_xof();
      let mut result = vec![0u8; num_bytes];
      reader.read(&mut result);
      result
  }
  *)
  Definition shake256_hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ seed_bytes; num_bytes ] =>
      ltac:(M.monadic
        (let seed_bytes := M.alloc (| seed_bytes |) in
        let num_bytes := M.alloc (| num_bytes |) in
        M.read (|
          let~ hasher :
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "digest::core_api::wrapper::CoreWrapper")
                    []
                    [ Ty.path "sha3::Shake256Core" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "digest::core_api::wrapper::CoreWrapper")
                  []
                  [ Ty.path "sha3::Shake256Core" ],
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.apply
                    (Ty.path "digest::core_api::wrapper::CoreWrapper")
                    []
                    [ Ty.path "sha3::Shake256Core" ],
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "digest::Update",
                  Ty.apply
                    (Ty.path "digest::core_api::wrapper::CoreWrapper")
                    []
                    [ Ty.path "sha3::Shake256Core" ],
                  [],
                  [],
                  "update",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, hasher |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| seed_bytes |) |) |)
                ]
              |)
            |) in
          let~ reader :
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "digest::core_api::xof_reader::XofReaderCoreWrapper")
                    []
                    [ Ty.path "sha3::Shake256ReaderCore" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "digest::core_api::xof_reader::XofReaderCoreWrapper")
                  []
                  [ Ty.path "sha3::Shake256ReaderCore" ],
                M.get_trait_method (|
                  "digest::ExtendableOutput",
                  Ty.apply
                    (Ty.path "digest::core_api::wrapper::CoreWrapper")
                    []
                    [ Ty.path "sha3::Shake256Core" ],
                  [],
                  [],
                  "finalize_xof",
                  [],
                  []
                |),
                [ M.read (| hasher |) ]
              |)
            |) in
          let~ result :
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_function (| "alloc::vec::from_elem", [], [ Ty.path "u8" ] |),
                [ Value.Integer IntegerKind.U8 0; M.read (| num_bytes |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "digest::XofReader",
                  Ty.apply
                    (Ty.path "digest::core_api::xof_reader::XofReaderCoreWrapper")
                    []
                    [ Ty.path "sha3::Shake256ReaderCore" ],
                  [],
                  [],
                  "read",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, reader |);
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::deref::DerefMut",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          [],
                          [],
                          "deref_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (| M.borrow (| Pointer.Kind.MutRef, result |) |)
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            |) in
          result
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shake256_hash :
    M.IsFunction.C "p3_rescue::util::shake256_hash" shake256_hash.
  Admitted.
  Global Typeclasses Opaque shake256_hash.
  
  (*
  fn pow2_no_std(x: f32, tol: f32) -> f32 {
      let y = x * core::f32::consts::LN_2;
      let mut t = 1.0; // ith Taylor term = (x ln(2))^i/i!
      let mut two_pow_x = t;
      for i in 1.. {
          t *= y / (i as f32);
          if t < tol {
              break;
          }
          two_pow_x += t;
      }
      two_pow_x
  }
  *)
  Definition pow2_no_std (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ x; tol ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        let tol := M.alloc (| tol |) in
        M.read (|
          let~ y : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.mul,
                [
                  M.read (| x |);
                  M.read (| get_constant (| "core::f32::consts::LN_2", Ty.path "f32" |) |)
                ]
              |)
            |) in
          let~ t : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] := M.copy (| UnsupportedLiteral |) in
          let~ two_pow_x : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] := M.copy (| t |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Ty.path "i32" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ Ty.path "i32" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::RangeFrom"
                        [ ("start", Value.Integer IntegerKind.I32 1) ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      []
                                      [ Ty.path "i32" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| γ0_0 |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        let β := t in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "f32",
                                            BinOp.Wrap.mul,
                                            [
                                              M.read (| β |);
                                              M.call_closure (|
                                                Ty.path "f32",
                                                BinOp.Wrap.div,
                                                [
                                                  M.read (| y |);
                                                  M.cast (Ty.path "f32") (M.read (| i |))
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.lt,
                                                      [ M.read (| t |); M.read (| tol |) ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        let β := two_pow_x in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "f32",
                                            BinOp.Wrap.add,
                                            [ M.read (| β |); M.read (| t |) ]
                                          |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          two_pow_x
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_pow2_no_std :
    M.IsFunction.C "p3_rescue::util::pow2_no_std" pow2_no_std.
  Admitted.
  Global Typeclasses Opaque pow2_no_std.
  
  (*
  fn log2_no_std(x: u64) -> f32 {
      const LOG2_E: f32 = core::f32::consts::LOG2_E;
      const POW2_TOL: f32 = 0.0001;
      // Initial estimate x0 = floor(log2(x))
      let x0 = log2_ceil_u64(x + 1) - 1;
      let p0 = (1 << x0) as f32; // 2^x0
      let x1 = x0 as f32 - LOG2_E * (1.0 - x as f32 / p0);
      // precision 20 determined by experiment
      let p1 = pow2_no_std(x1, POW2_TOL);
      let x2 = x1 - LOG2_E * (1.0 - x as f32 / p1);
      let p2 = pow2_no_std(x2, POW2_TOL);
      x2 - LOG2_E * (1.0 - x as f32 / p2)
  }
  *)
  Definition log2_no_std (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        M.read (|
          let~ x0 : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.sub,
                [
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_function (| "p3_util::log2_ceil_u64", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.add,
                        [ M.read (| x |); Value.Integer IntegerKind.U64 1 ]
                      |)
                    ]
                  |);
                  Value.Integer IntegerKind.U64 1
                ]
              |)
            |) in
          let~ p0 : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.cast
                (Ty.path "f32")
                (M.call_closure (|
                  Ty.path "i32",
                  BinOp.Wrap.shl,
                  [ Value.Integer IntegerKind.I32 1; M.read (| x0 |) ]
                |))
            |) in
          let~ x1 : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.sub,
                [
                  M.cast (Ty.path "f32") (M.read (| x0 |));
                  M.call_closure (|
                    Ty.path "f32",
                    BinOp.Wrap.mul,
                    [
                      M.read (|
                        get_constant (| "p3_rescue::util::log2_no_std::LOG2_E", Ty.path "f32" |)
                      |);
                      M.call_closure (|
                        Ty.path "f32",
                        BinOp.Wrap.sub,
                        [
                          M.read (| UnsupportedLiteral |);
                          M.call_closure (|
                            Ty.path "f32",
                            BinOp.Wrap.div,
                            [ M.cast (Ty.path "f32") (M.read (| x |)); M.read (| p0 |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            |) in
          let~ p1 : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                M.get_function (| "p3_rescue::util::pow2_no_std", [], [] |),
                [
                  M.read (| x1 |);
                  M.read (|
                    get_constant (| "p3_rescue::util::log2_no_std::POW2_TOL", Ty.path "f32" |)
                  |)
                ]
              |)
            |) in
          let~ x2 : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                BinOp.Wrap.sub,
                [
                  M.read (| x1 |);
                  M.call_closure (|
                    Ty.path "f32",
                    BinOp.Wrap.mul,
                    [
                      M.read (|
                        get_constant (| "p3_rescue::util::log2_no_std::LOG2_E", Ty.path "f32" |)
                      |);
                      M.call_closure (|
                        Ty.path "f32",
                        BinOp.Wrap.sub,
                        [
                          M.read (| UnsupportedLiteral |);
                          M.call_closure (|
                            Ty.path "f32",
                            BinOp.Wrap.div,
                            [ M.cast (Ty.path "f32") (M.read (| x |)); M.read (| p1 |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            |) in
          let~ p2 : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                M.get_function (| "p3_rescue::util::pow2_no_std", [], [] |),
                [
                  M.read (| x2 |);
                  M.read (|
                    get_constant (| "p3_rescue::util::log2_no_std::POW2_TOL", Ty.path "f32" |)
                  |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "f32",
              BinOp.Wrap.sub,
              [
                M.read (| x2 |);
                M.call_closure (|
                  Ty.path "f32",
                  BinOp.Wrap.mul,
                  [
                    M.read (|
                      get_constant (| "p3_rescue::util::log2_no_std::LOG2_E", Ty.path "f32" |)
                    |);
                    M.call_closure (|
                      Ty.path "f32",
                      BinOp.Wrap.sub,
                      [
                        M.read (| UnsupportedLiteral |);
                        M.call_closure (|
                          Ty.path "f32",
                          BinOp.Wrap.div,
                          [ M.cast (Ty.path "f32") (M.read (| x |)); M.read (| p2 |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log2_no_std :
    M.IsFunction.C "p3_rescue::util::log2_no_std" log2_no_std.
  Admitted.
  Global Typeclasses Opaque log2_no_std.
  
  Module log2_no_std.
    Definition value_LOG2_E (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (get_constant (| "core::f32::consts::LOG2_E", Ty.path "f32" |))).
    
    Global Instance Instance_IsConstant_value_LOG2_E :
      M.IsFunction.C "p3_rescue::util::log2_no_std::LOG2_E" value_LOG2_E.
    Admitted.
    Global Typeclasses Opaque value_LOG2_E.
    
    Definition value_POW2_TOL (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_POW2_TOL :
      M.IsFunction.C "p3_rescue::util::log2_no_std::POW2_TOL" value_POW2_TOL.
    Admitted.
    Global Typeclasses Opaque value_POW2_TOL.
  End log2_no_std.
  
  (*
  pub(crate) fn log2_binom(n: u64, k: u64) -> f32 {
      const LOG2_2PI: f32 = 2.6514961;
      let log2_n = log2_no_std(n);
      let log2_k = log2_no_std(k);
      let log2_nmk = log2_no_std(n - k);
  
      n as f32 * log2_n - k as f32 * log2_k - (n - k) as f32 * log2_nmk
          + 0.5 * (log2_n - log2_k - log2_nmk - LOG2_2PI)
  }
  *)
  Definition log2_binom (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ n; k ] =>
      ltac:(M.monadic
        (let n := M.alloc (| n |) in
        let k := M.alloc (| k |) in
        M.read (|
          let~ log2_n : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                M.get_function (| "p3_rescue::util::log2_no_std", [], [] |),
                [ M.read (| n |) ]
              |)
            |) in
          let~ log2_k : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                M.get_function (| "p3_rescue::util::log2_no_std", [], [] |),
                [ M.read (| k |) ]
              |)
            |) in
          let~ log2_nmk : Ty.apply (Ty.path "*") [] [ Ty.path "f32" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "f32",
                M.get_function (| "p3_rescue::util::log2_no_std", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "u64",
                    BinOp.Wrap.sub,
                    [ M.read (| n |); M.read (| k |) ]
                  |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "f32",
              BinOp.Wrap.add,
              [
                M.call_closure (|
                  Ty.path "f32",
                  BinOp.Wrap.sub,
                  [
                    M.call_closure (|
                      Ty.path "f32",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "f32",
                          BinOp.Wrap.mul,
                          [ M.cast (Ty.path "f32") (M.read (| n |)); M.read (| log2_n |) ]
                        |);
                        M.call_closure (|
                          Ty.path "f32",
                          BinOp.Wrap.mul,
                          [ M.cast (Ty.path "f32") (M.read (| k |)); M.read (| log2_k |) ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.path "f32",
                      BinOp.Wrap.mul,
                      [
                        M.cast
                          (Ty.path "f32")
                          (M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.sub,
                            [ M.read (| n |); M.read (| k |) ]
                          |));
                        M.read (| log2_nmk |)
                      ]
                    |)
                  ]
                |);
                M.call_closure (|
                  Ty.path "f32",
                  BinOp.Wrap.mul,
                  [
                    M.read (| UnsupportedLiteral |);
                    M.call_closure (|
                      Ty.path "f32",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "f32",
                          BinOp.Wrap.sub,
                          [
                            M.call_closure (|
                              Ty.path "f32",
                              BinOp.Wrap.sub,
                              [ M.read (| log2_n |); M.read (| log2_k |) ]
                            |);
                            M.read (| log2_nmk |)
                          ]
                        |);
                        M.read (|
                          get_constant (| "p3_rescue::util::log2_binom::LOG2_2PI", Ty.path "f32" |)
                        |)
                      ]
                    |)
                  ]
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log2_binom :
    M.IsFunction.C "p3_rescue::util::log2_binom" log2_binom.
  Admitted.
  Global Typeclasses Opaque log2_binom.
  
  Module log2_binom.
    Definition value_LOG2_2PI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_LOG2_2PI :
      M.IsFunction.C "p3_rescue::util::log2_binom::LOG2_2PI" value_LOG2_2PI.
    Admitted.
    Global Typeclasses Opaque value_LOG2_2PI.
  End log2_binom.
End util.
