(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module symbolic_variable.
  (*
  Enum Entry
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Preprocessed";
          item := StructRecord [ ("offset", Ty.path "usize") ];
        };
        {
          name := "Main";
          item := StructRecord [ ("offset", Ty.path "usize") ];
        };
        {
          name := "Permutation";
          item := StructRecord [ ("offset", Ty.path "usize") ];
        };
        {
          name := "Public";
          item := StructTuple [];
        };
        {
          name := "Challenge";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_Entry_Preprocessed :
    M.IsDiscriminant "p3_uni_stark::symbolic_variable::Entry::Preprocessed" 0.
  Axiom IsDiscriminant_Entry_Main :
    M.IsDiscriminant "p3_uni_stark::symbolic_variable::Entry::Main" 1.
  Axiom IsDiscriminant_Entry_Permutation :
    M.IsDiscriminant "p3_uni_stark::symbolic_variable::Entry::Permutation" 2.
  Axiom IsDiscriminant_Entry_Public :
    M.IsDiscriminant "p3_uni_stark::symbolic_variable::Entry::Public" 3.
  Axiom IsDiscriminant_Entry_Challenge :
    M.IsDiscriminant "p3_uni_stark::symbolic_variable::Entry::Challenge" 4.
  
  Module Impl_core_marker_Copy_for_p3_uni_stark_symbolic_variable_Entry.
    Definition Self : Ty.t := Ty.path "p3_uni_stark::symbolic_variable::Entry".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_p3_uni_stark_symbolic_variable_Entry.
  
  Module Impl_core_clone_Clone_for_p3_uni_stark_symbolic_variable_Entry.
    Definition Self : Ty.t := Ty.path "p3_uni_stark::symbolic_variable::Entry".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "p3_uni_stark::symbolic_variable::Entry" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_p3_uni_stark_symbolic_variable_Entry.
  
  Module Impl_core_fmt_Debug_for_p3_uni_stark_symbolic_variable_Entry.
    Definition Self : Ty.t := Ty.path "p3_uni_stark::symbolic_variable::Entry".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "p3_uni_stark::symbolic_variable::Entry::Preprocessed",
                        "offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Preprocessed" |) |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "offset" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |))
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "p3_uni_stark::symbolic_variable::Entry::Main",
                        "offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Main" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "offset" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |))
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "p3_uni_stark::symbolic_variable::Entry::Permutation",
                        "offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Permutation" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "offset" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |))
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "p3_uni_stark::symbolic_variable::Entry::Public" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Public" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "p3_uni_stark::symbolic_variable::Entry::Challenge"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Challenge" |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_p3_uni_stark_symbolic_variable_Entry.
  
  Module Impl_core_marker_StructuralPartialEq_for_p3_uni_stark_symbolic_variable_Entry.
    Definition Self : Ty.t := Ty.path "p3_uni_stark::symbolic_variable::Entry".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_p3_uni_stark_symbolic_variable_Entry.
  
  Module Impl_core_cmp_PartialEq_p3_uni_stark_symbolic_variable_Entry_for_p3_uni_stark_symbolic_variable_Entry.
    Definition Self : Ty.t := Ty.path "p3_uni_stark::symbolic_variable::Entry".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_uni_stark::symbolic_variable::Entry" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_uni_stark::symbolic_variable::Entry" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "p3_uni_stark::symbolic_variable::Entry::Preprocessed",
                                "offset"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "p3_uni_stark::symbolic_variable::Entry::Preprocessed",
                                "offset"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "p3_uni_stark::symbolic_variable::Entry::Main",
                                "offset"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "p3_uni_stark::symbolic_variable::Entry::Main",
                                "offset"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "p3_uni_stark::symbolic_variable::Entry::Permutation",
                                "offset"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "p3_uni_stark::symbolic_variable::Entry::Permutation",
                                "offset"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "p3_uni_stark::symbolic_variable::Entry" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_p3_uni_stark_symbolic_variable_Entry_for_p3_uni_stark_symbolic_variable_Entry.
  
  Module Impl_core_cmp_Eq_for_p3_uni_stark_symbolic_variable_Entry.
    Definition Self : Ty.t := Ty.path "p3_uni_stark::symbolic_variable::Entry".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_p3_uni_stark_symbolic_variable_Entry.
  
  Module Impl_core_hash_Hash_for_p3_uni_stark_symbolic_variable_Entry.
    Definition Self : Ty.t := Ty.path "p3_uni_stark::symbolic_variable::Entry".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "p3_uni_stark::symbolic_variable::Entry" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "p3_uni_stark::symbolic_variable::Entry::Preprocessed",
                        "offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "usize",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "p3_uni_stark::symbolic_variable::Entry::Main",
                        "offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "usize",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "p3_uni_stark::symbolic_variable::Entry::Permutation",
                        "offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "usize",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_p3_uni_stark_symbolic_variable_Entry.
  
  (* StructRecord
    {
      name := "SymbolicVariable";
      const_params := [];
      ty_params := [ "F" ];
      fields :=
        [
          ("entry", Ty.path "p3_uni_stark::symbolic_variable::Entry");
          ("index", Ty.path "usize");
          ("_phantom", Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ])
        ];
    } *)
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_F_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ].
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_F_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ].
    
    (* Clone *)
    Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "p3_uni_stark::symbolic_variable::SymbolicVariable"
            [
              ("entry",
                M.call_closure (|
                  Ty.path "p3_uni_stark::symbolic_variable::Entry",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "p3_uni_stark::symbolic_variable::Entry",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_uni_stark::symbolic_variable::SymbolicVariable",
                            "entry"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("index",
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "usize",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_uni_stark::symbolic_variable::SymbolicVariable",
                            "index"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("_phantom",
                M.call_closure (|
                  Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_uni_stark::symbolic_variable::SymbolicVariable",
                            "_phantom"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "SymbolicVariable" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "entry" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_uni_stark::symbolic_variable::SymbolicVariable",
                        "entry"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "index" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_uni_stark::symbolic_variable::SymbolicVariable",
                        "index"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "_phantom" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_uni_stark::symbolic_variable::SymbolicVariable",
                            "_phantom"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
  
  Module Impl_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ].
    
    (*
        pub const fn new(entry: Entry, index: usize) -> Self {
            Self {
                entry,
                index,
                _phantom: PhantomData,
            }
        }
    *)
    Definition new (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ entry; index ] =>
        ltac:(M.monadic
          (let entry := M.alloc (| entry |) in
          let index := M.alloc (| index |) in
          Value.StructRecord
            "p3_uni_stark::symbolic_variable::SymbolicVariable"
            [
              ("entry", M.read (| entry |));
              ("index", M.read (| index |));
              ("_phantom", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "new" (new F).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub const fn degree_multiple(&self) -> usize {
            match self.entry {
                Entry::Preprocessed { .. } | Entry::Main { .. } | Entry::Permutation { .. } => 1,
                Entry::Public | Entry::Challenge => 0,
            }
        }
    *)
    Definition degree_multiple
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "p3_uni_stark::symbolic_variable::SymbolicVariable",
                "entry"
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "p3_uni_stark::symbolic_variable::Entry::Preprocessed"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "p3_uni_stark::symbolic_variable::Entry::Main"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "p3_uni_stark::symbolic_variable::Entry::Permutation"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1 |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "p3_uni_stark::symbolic_variable::Entry::Public"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "p3_uni_stark::symbolic_variable::Entry::Challenge"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_degree_multiple :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "degree_multiple" (degree_multiple F).
    Admitted.
    Global Typeclasses Opaque degree_multiple.
  End Impl_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
  
  Module Impl_core_convert_From_where_p3_field_field_Field_F_p3_uni_stark_symbolic_variable_SymbolicVariable_F_for_p3_uni_stark_symbolic_expression_SymbolicExpression_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ].
    
    (*
        fn from(value: SymbolicVariable<F>) -> Self {
            Self::Variable(value)
        }
    *)
    Definition from (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "p3_uni_stark::symbolic_expression::SymbolicExpression::Variable"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ] ]
        (Self F)
        (* Instance *) [ ("from", InstanceField.Method (from F)) ].
  End Impl_core_convert_From_where_p3_field_field_Field_F_p3_uni_stark_symbolic_variable_SymbolicVariable_F_for_p3_uni_stark_symbolic_expression_SymbolicExpression_F.
  
  Module Impl_core_ops_arith_Add_where_p3_field_field_Field_F_where_core_convert_Into_T_p3_uni_stark_symbolic_expression_SymbolicExpression_F_T_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
    Definition Self (F T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ].
    
    (*     type Output = SymbolicExpression<F>; *)
    Definition _Output (F T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ].
    
    (*
        fn add(self, rhs: T) -> Self::Output {
            SymbolicExpression::from(self) + rhs.into()
        }
    *)
    Definition add (F T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F T in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
            M.get_trait_method (|
              "core::ops::arith::Add",
              Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ]
              ],
              "add",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression")
                    []
                    [ F ],
                  [],
                  [ Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ]
                  ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
                M.get_trait_method (|
                  "core::convert::Into",
                  T,
                  [],
                  [
                    Ty.apply
                      (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression")
                      []
                      [ F ]
                  ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| rhs |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F T : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self F T)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F T)); ("add", InstanceField.Method (add F T)) ].
  End Impl_core_ops_arith_Add_where_p3_field_field_Field_F_where_core_convert_Into_T_p3_uni_stark_symbolic_expression_SymbolicExpression_F_T_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
  
  Module Impl_core_ops_arith_Sub_where_p3_field_field_Field_F_where_core_convert_Into_T_p3_uni_stark_symbolic_expression_SymbolicExpression_F_T_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
    Definition Self (F T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ].
    
    (*     type Output = SymbolicExpression<F>; *)
    Definition _Output (F T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ].
    
    (*
        fn sub(self, rhs: T) -> Self::Output {
            SymbolicExpression::from(self) - rhs.into()
        }
    *)
    Definition sub (F T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F T in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
            M.get_trait_method (|
              "core::ops::arith::Sub",
              Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ]
              ],
              "sub",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression")
                    []
                    [ F ],
                  [],
                  [ Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ]
                  ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
                M.get_trait_method (|
                  "core::convert::Into",
                  T,
                  [],
                  [
                    Ty.apply
                      (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression")
                      []
                      [ F ]
                  ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| rhs |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F T : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self F T)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F T)); ("sub", InstanceField.Method (sub F T)) ].
  End Impl_core_ops_arith_Sub_where_p3_field_field_Field_F_where_core_convert_Into_T_p3_uni_stark_symbolic_expression_SymbolicExpression_F_T_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
  
  Module Impl_core_ops_arith_Mul_where_p3_field_field_Field_F_where_core_convert_Into_T_p3_uni_stark_symbolic_expression_SymbolicExpression_F_T_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
    Definition Self (F T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ].
    
    (*     type Output = SymbolicExpression<F>; *)
    Definition _Output (F T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ].
    
    (*
        fn mul(self, rhs: T) -> Self::Output {
            SymbolicExpression::from(self) * rhs.into()
        }
    *)
    Definition mul (F T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F T in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
            M.get_trait_method (|
              "core::ops::arith::Mul",
              Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ]
              ],
              "mul",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression")
                    []
                    [ F ],
                  [],
                  [ Ty.apply (Ty.path "p3_uni_stark::symbolic_variable::SymbolicVariable") [] [ F ]
                  ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                Ty.apply (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression") [] [ F ],
                M.get_trait_method (|
                  "core::convert::Into",
                  T,
                  [],
                  [
                    Ty.apply
                      (Ty.path "p3_uni_stark::symbolic_expression::SymbolicExpression")
                      []
                      [ F ]
                  ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| rhs |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F T : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self F T)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F T)); ("mul", InstanceField.Method (mul F T)) ].
  End Impl_core_ops_arith_Mul_where_p3_field_field_Field_F_where_core_convert_Into_T_p3_uni_stark_symbolic_expression_SymbolicExpression_F_T_for_p3_uni_stark_symbolic_variable_SymbolicVariable_F.
End symbolic_variable.
