(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module transpose.
  Definition value_LB_BLOCK_SIZE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 3 |))).
  
  Global Instance Instance_IsConstant_value_LB_BLOCK_SIZE :
    M.IsFunction.C "p3_util::transpose::LB_BLOCK_SIZE" value_LB_BLOCK_SIZE.
  Admitted.
  Global Typeclasses Opaque value_LB_BLOCK_SIZE.
  
  (*
  unsafe fn transpose_in_place_square_small<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
  ) {
      unsafe {
          for i in x + 1..x + (1 << lb_size) {
              for j in x..i {
                  swap(
                      arr.get_unchecked_mut(i + (j << lb_stride)),
                      arr.get_unchecked_mut((i << lb_stride) + j),
                  );
              }
          }
      }
  }
  *)
  Definition transpose_in_place_square_small
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x ] =>
      ltac:(M.monadic
        (let arr := M.alloc (| arr |) in
        let lb_stride := M.alloc (| lb_stride |) in
        let lb_size := M.alloc (| lb_size |) in
        let x := M.alloc (| x |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "core::ops::range::Range"
                      [
                        ("start",
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| x |); Value.Integer IntegerKind.Usize 1 ]
                          |));
                        ("end_",
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [
                              M.read (| x |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.shl,
                                [ Value.Integer IntegerKind.Usize 1; M.read (| lb_size |) ]
                              |)
                            ]
                          |))
                      ]
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let i := M.copy (| γ0_0 |) in
                                  M.use
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "into_iter",
                                            [],
                                            []
                                          |),
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [ ("start", M.read (| x |)); ("end_", M.read (| i |))
                                              ]
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let iter := M.copy (| γ |) in
                                            M.loop (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              ltac:(M.monadic
                                                (let~ _ :
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                  M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          [],
                                                          [],
                                                          "next",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                iter
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "core::option::Option::None"
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let j := M.copy (| γ0_0 |) in
                                                          let~ _ :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.tuple [],
                                                                M.get_function (|
                                                                  "core::ptr::swap",
                                                                  [],
                                                                  [ T ]
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutPointer,
                                                                    M.deref (|
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path "&mut")
                                                                          []
                                                                          [ T ],
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ T ],
                                                                          "get_unchecked_mut",
                                                                          [],
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            M.deref (|
                                                                              M.read (| arr |)
                                                                            |)
                                                                          |);
                                                                          M.call_closure (|
                                                                            Ty.path "usize",
                                                                            BinOp.Wrap.add,
                                                                            [
                                                                              M.read (| i |);
                                                                              M.call_closure (|
                                                                                Ty.path "usize",
                                                                                BinOp.Wrap.shl,
                                                                                [
                                                                                  M.read (| j |);
                                                                                  M.read (|
                                                                                    lb_stride
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutPointer,
                                                                    M.deref (|
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path "&mut")
                                                                          []
                                                                          [ T ],
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ T ],
                                                                          "get_unchecked_mut",
                                                                          [],
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            M.deref (|
                                                                              M.read (| arr |)
                                                                            |)
                                                                          |);
                                                                          M.call_closure (|
                                                                            Ty.path "usize",
                                                                            BinOp.Wrap.add,
                                                                            [
                                                                              M.call_closure (|
                                                                                Ty.path "usize",
                                                                                BinOp.Wrap.shl,
                                                                                [
                                                                                  M.read (| i |);
                                                                                  M.read (|
                                                                                    lb_stride
                                                                                  |)
                                                                                ]
                                                                              |);
                                                                              M.read (| j |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                            |)))
                                      ]
                                    |))))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_in_place_square_small :
    M.IsFunction.C
      "p3_util::transpose::transpose_in_place_square_small"
      transpose_in_place_square_small.
  Admitted.
  Global Typeclasses Opaque transpose_in_place_square_small.
  
  (*
  unsafe fn transpose_swap_square_small<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
      y: usize,
  ) {
      unsafe {
          for i in x..x + (1 << lb_size) {
              for j in y..y + (1 << lb_size) {
                  swap(
                      arr.get_unchecked_mut(i + (j << lb_stride)),
                      arr.get_unchecked_mut((i << lb_stride) + j),
                  );
              }
          }
      }
  }
  *)
  Definition transpose_swap_square_small
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x; y ] =>
      ltac:(M.monadic
        (let arr := M.alloc (| arr |) in
        let lb_stride := M.alloc (| lb_stride |) in
        let lb_size := M.alloc (| lb_size |) in
        let x := M.alloc (| x |) in
        let y := M.alloc (| y |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "core::ops::range::Range"
                      [
                        ("start", M.read (| x |));
                        ("end_",
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [
                              M.read (| x |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.shl,
                                [ Value.Integer IntegerKind.Usize 1; M.read (| lb_size |) ]
                              |)
                            ]
                          |))
                      ]
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let i := M.copy (| γ0_0 |) in
                                  M.use
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            [],
                                            [],
                                            "into_iter",
                                            [],
                                            []
                                          |),
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", M.read (| y |));
                                                ("end_",
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [
                                                      M.read (| y |);
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.shl,
                                                        [
                                                          Value.Integer IntegerKind.Usize 1;
                                                          M.read (| lb_size |)
                                                        ]
                                                      |)
                                                    ]
                                                  |))
                                              ]
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let iter := M.copy (| γ |) in
                                            M.loop (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              ltac:(M.monadic
                                                (let~ _ :
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                  M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          [],
                                                          [],
                                                          "next",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                iter
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "core::option::Option::None"
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let j := M.copy (| γ0_0 |) in
                                                          let~ _ :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ] :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.tuple [],
                                                                M.get_function (|
                                                                  "core::ptr::swap",
                                                                  [],
                                                                  [ T ]
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutPointer,
                                                                    M.deref (|
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path "&mut")
                                                                          []
                                                                          [ T ],
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ T ],
                                                                          "get_unchecked_mut",
                                                                          [],
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            M.deref (|
                                                                              M.read (| arr |)
                                                                            |)
                                                                          |);
                                                                          M.call_closure (|
                                                                            Ty.path "usize",
                                                                            BinOp.Wrap.add,
                                                                            [
                                                                              M.read (| i |);
                                                                              M.call_closure (|
                                                                                Ty.path "usize",
                                                                                BinOp.Wrap.shl,
                                                                                [
                                                                                  M.read (| j |);
                                                                                  M.read (|
                                                                                    lb_stride
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutPointer,
                                                                    M.deref (|
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path "&mut")
                                                                          []
                                                                          [ T ],
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ T ],
                                                                          "get_unchecked_mut",
                                                                          [],
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            M.deref (|
                                                                              M.read (| arr |)
                                                                            |)
                                                                          |);
                                                                          M.call_closure (|
                                                                            Ty.path "usize",
                                                                            BinOp.Wrap.add,
                                                                            [
                                                                              M.call_closure (|
                                                                                Ty.path "usize",
                                                                                BinOp.Wrap.shl,
                                                                                [
                                                                                  M.read (| i |);
                                                                                  M.read (|
                                                                                    lb_stride
                                                                                  |)
                                                                                ]
                                                                              |);
                                                                              M.read (| j |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                            |)))
                                      ]
                                    |))))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_swap_square_small :
    M.IsFunction.C "p3_util::transpose::transpose_swap_square_small" transpose_swap_square_small.
  Admitted.
  Global Typeclasses Opaque transpose_swap_square_small.
  
  (*
  unsafe fn transpose_swap_square<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
      y: usize,
  ) {
      unsafe {
          if lb_size <= LB_BLOCK_SIZE {
              transpose_swap_square_small(arr, lb_stride, lb_size, x, y);
          } else {
              let lb_block_size = lb_size - 1;
              let block_size = 1 << lb_block_size;
              transpose_swap_square(arr, lb_stride, lb_block_size, x, y);
              transpose_swap_square(arr, lb_stride, lb_block_size, x + block_size, y);
              transpose_swap_square(arr, lb_stride, lb_block_size, x, y + block_size);
              transpose_swap_square(
                  arr,
                  lb_stride,
                  lb_block_size,
                  x + block_size,
                  y + block_size,
              );
          }
      }
  }
  *)
  Definition transpose_swap_square (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x; y ] =>
      ltac:(M.monadic
        (let arr := M.alloc (| arr |) in
        let lb_stride := M.alloc (| lb_stride |) in
        let lb_size := M.alloc (| lb_size |) in
        let x := M.alloc (| x |) in
        let y := M.alloc (| y |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.le,
                          [
                            M.read (| lb_size |);
                            M.read (|
                              get_constant (|
                                "p3_util::transpose::LB_BLOCK_SIZE",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "p3_util::transpose::transpose_swap_square_small",
                          [],
                          [ T ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_size |);
                          M.read (| x |);
                          M.read (| y |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ lb_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| lb_size |); Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |) in
                  let~ block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.shl,
                        [ Value.Integer IntegerKind.Usize 1; M.read (| lb_block_size |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_block_size |);
                          M.read (| x |);
                          M.read (| y |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_block_size |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| x |); M.read (| block_size |) ]
                          |);
                          M.read (| y |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_block_size |);
                          M.read (| x |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| y |); M.read (| block_size |) ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_block_size |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| x |); M.read (| block_size |) ]
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| y |); M.read (| block_size |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_swap_square :
    M.IsFunction.C "p3_util::transpose::transpose_swap_square" transpose_swap_square.
  Admitted.
  Global Typeclasses Opaque transpose_swap_square.
  
  (*
  pub(crate) unsafe fn transpose_in_place_square<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
  ) {
      unsafe {
          if lb_size <= LB_BLOCK_SIZE {
              transpose_in_place_square_small(arr, lb_stride, lb_size, x);
          } else {
              let lb_block_size = lb_size - 1;
              let block_size = 1 << lb_block_size;
              transpose_in_place_square(arr, lb_stride, lb_block_size, x);
              transpose_swap_square(arr, lb_stride, lb_block_size, x, x + block_size);
              transpose_in_place_square(arr, lb_stride, lb_block_size, x + block_size);
          }
      }
  }
  *)
  Definition transpose_in_place_square (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x ] =>
      ltac:(M.monadic
        (let arr := M.alloc (| arr |) in
        let lb_stride := M.alloc (| lb_stride |) in
        let lb_size := M.alloc (| lb_size |) in
        let x := M.alloc (| x |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.le,
                          [
                            M.read (| lb_size |);
                            M.read (|
                              get_constant (|
                                "p3_util::transpose::LB_BLOCK_SIZE",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "p3_util::transpose::transpose_in_place_square_small",
                          [],
                          [ T ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_size |);
                          M.read (| x |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ lb_block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| lb_size |); Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |) in
                  let~ block_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.shl,
                        [ Value.Integer IntegerKind.Usize 1; M.read (| lb_block_size |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "p3_util::transpose::transpose_in_place_square",
                          [],
                          [ T ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_block_size |);
                          M.read (| x |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_block_size |);
                          M.read (| x |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| x |); M.read (| block_size |) ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "p3_util::transpose::transpose_in_place_square",
                          [],
                          [ T ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                          M.read (| lb_stride |);
                          M.read (| lb_block_size |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| x |); M.read (| block_size |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_in_place_square :
    M.IsFunction.C "p3_util::transpose::transpose_in_place_square" transpose_in_place_square.
  Admitted.
  Global Typeclasses Opaque transpose_in_place_square.
End transpose.
