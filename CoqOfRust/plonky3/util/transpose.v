(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module transpose.
  Definition value_LB_BLOCK_SIZE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 3 |))).
  
  Global Instance Instance_IsConstant_value_LB_BLOCK_SIZE :
    M.IsFunction.C "p3_util::transpose::LB_BLOCK_SIZE" value_LB_BLOCK_SIZE.
  Admitted.
  Global Typeclasses Opaque value_LB_BLOCK_SIZE.
  
  (*
  unsafe fn transpose_in_place_square_small<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
  ) {
      unsafe {
          for i in x + 1..x + (1 << lb_size) {
              for j in x..i {
                  swap(
                      arr.get_unchecked_mut(i + (j << lb_stride)),
                      arr.get_unchecked_mut((i << lb_stride) + j),
                  );
              }
          }
      }
  }
  *)
  Definition transpose_in_place_square_small
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x ] =>
      ltac:(M.monadic
        (let arr :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ], arr |) in
        let lb_stride := M.alloc (| Ty.path "usize", lb_stride |) in
        let lb_size := M.alloc (| Ty.path "usize", lb_size |) in
        let x := M.alloc (| Ty.path "usize", x |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.tuple [],
              M.alloc (|
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    Value.mkStructRecord
                      "core::ops::range::Range"
                      []
                      [ Ty.path "usize" ]
                      [
                        ("start",
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| x |); Value.Integer IntegerKind.Usize 1 ]
                          |));
                        ("end_",
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [
                              M.read (| x |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.shl,
                                [ Value.Integer IntegerKind.Usize 1; M.read (| lb_size |) ]
                              |)
                            ]
                          |))
                      ]
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter :=
                      M.copy (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        γ
                      |) in
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (|
                                      Ty.tuple [],
                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                    M.use
                                      (M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::collect::IntoIterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ],
                                              [],
                                              [],
                                              "into_iter",
                                              [],
                                              []
                                            |),
                                            [
                                              Value.mkStructRecord
                                                "core::ops::range::Range"
                                                []
                                                [ Ty.path "usize" ]
                                                [
                                                  ("start", M.read (| x |));
                                                  ("end_", M.read (| i |))
                                                ]
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let iter :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  γ
                                                |) in
                                              M.loop (|
                                                Ty.tuple [],
                                                ltac:(M.monadic
                                                  (let~ _ : Ty.tuple [] :=
                                                    M.read (|
                                                      M.match_operator (|
                                                        Ty.tuple [],
                                                        M.alloc (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.path "usize" ],
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                []
                                                                [ Ty.path "usize" ],
                                                              [],
                                                              [],
                                                              "next",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutRef,
                                                                    iter
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ,
                                                                  "core::option::Option::None"
                                                                |) in
                                                              M.alloc (|
                                                                Ty.tuple [],
                                                                M.never_to_any (|
                                                                  M.read (| M.break (||) |)
                                                                |)
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_struct_tuple_field (|
                                                                  γ,
                                                                  "core::option::Option::Some",
                                                                  0
                                                                |) in
                                                              let j :=
                                                                M.copy (|
                                                                  Ty.path "usize",
                                                                  γ0_0
                                                                |) in
                                                              let~ _ : Ty.tuple [] :=
                                                                M.call_closure (|
                                                                  Ty.tuple [],
                                                                  M.get_function (|
                                                                    "core::ptr::swap",
                                                                    [],
                                                                    [ T ]
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutPointer,
                                                                      M.deref (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ T ],
                                                                          M.get_associated_function (|
                                                                            Ty.apply
                                                                              (Ty.path "slice")
                                                                              []
                                                                              [ T ],
                                                                            "get_unchecked_mut",
                                                                            [],
                                                                            [ Ty.path "usize" ]
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.MutRef,
                                                                              M.deref (|
                                                                                M.read (| arr |)
                                                                              |)
                                                                            |);
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              BinOp.Wrap.add,
                                                                              [
                                                                                M.read (| i |);
                                                                                M.call_closure (|
                                                                                  Ty.path "usize",
                                                                                  BinOp.Wrap.shl,
                                                                                  [
                                                                                    M.read (| j |);
                                                                                    M.read (|
                                                                                      lb_stride
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutPointer,
                                                                      M.deref (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ T ],
                                                                          M.get_associated_function (|
                                                                            Ty.apply
                                                                              (Ty.path "slice")
                                                                              []
                                                                              [ T ],
                                                                            "get_unchecked_mut",
                                                                            [],
                                                                            [ Ty.path "usize" ]
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.MutRef,
                                                                              M.deref (|
                                                                                M.read (| arr |)
                                                                              |)
                                                                            |);
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              BinOp.Wrap.add,
                                                                              [
                                                                                M.call_closure (|
                                                                                  Ty.path "usize",
                                                                                  BinOp.Wrap.shl,
                                                                                  [
                                                                                    M.read (| i |);
                                                                                    M.read (|
                                                                                      lb_stride
                                                                                    |)
                                                                                  ]
                                                                                |);
                                                                                M.read (| j |)
                                                                              ]
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |) in
                                                              M.alloc (|
                                                                Ty.tuple [],
                                                                Value.Tuple []
                                                              |)))
                                                        ]
                                                      |)
                                                    |) in
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                              |)))
                                        ]
                                      |))))
                              ]
                            |)
                          |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_in_place_square_small :
    M.IsFunction.C
      "p3_util::transpose::transpose_in_place_square_small"
      transpose_in_place_square_small.
  Admitted.
  Global Typeclasses Opaque transpose_in_place_square_small.
  
  (*
  unsafe fn transpose_swap_square_small<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
      y: usize,
  ) {
      unsafe {
          for i in x..x + (1 << lb_size) {
              for j in y..y + (1 << lb_size) {
                  swap(
                      arr.get_unchecked_mut(i + (j << lb_stride)),
                      arr.get_unchecked_mut((i << lb_stride) + j),
                  );
              }
          }
      }
  }
  *)
  Definition transpose_swap_square_small
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x; y ] =>
      ltac:(M.monadic
        (let arr :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ], arr |) in
        let lb_stride := M.alloc (| Ty.path "usize", lb_stride |) in
        let lb_size := M.alloc (| Ty.path "usize", lb_size |) in
        let x := M.alloc (| Ty.path "usize", x |) in
        let y := M.alloc (| Ty.path "usize", y |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.tuple [],
              M.alloc (|
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    Value.mkStructRecord
                      "core::ops::range::Range"
                      []
                      [ Ty.path "usize" ]
                      [
                        ("start", M.read (| x |));
                        ("end_",
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [
                              M.read (| x |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.shl,
                                [ Value.Integer IntegerKind.Usize 1; M.read (| lb_size |) ]
                              |)
                            ]
                          |))
                      ]
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter :=
                      M.copy (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        γ
                      |) in
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (|
                                      Ty.tuple [],
                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                    M.use
                                      (M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::collect::IntoIterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ],
                                              [],
                                              [],
                                              "into_iter",
                                              [],
                                              []
                                            |),
                                            [
                                              Value.mkStructRecord
                                                "core::ops::range::Range"
                                                []
                                                [ Ty.path "usize" ]
                                                [
                                                  ("start", M.read (| y |));
                                                  ("end_",
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.add,
                                                      [
                                                        M.read (| y |);
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.shl,
                                                          [
                                                            Value.Integer IntegerKind.Usize 1;
                                                            M.read (| lb_size |)
                                                          ]
                                                        |)
                                                      ]
                                                    |))
                                                ]
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let iter :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  γ
                                                |) in
                                              M.loop (|
                                                Ty.tuple [],
                                                ltac:(M.monadic
                                                  (let~ _ : Ty.tuple [] :=
                                                    M.read (|
                                                      M.match_operator (|
                                                        Ty.tuple [],
                                                        M.alloc (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.path "usize" ],
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                []
                                                                [ Ty.path "usize" ],
                                                              [],
                                                              [],
                                                              "next",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.MutRef,
                                                                    iter
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ,
                                                                  "core::option::Option::None"
                                                                |) in
                                                              M.alloc (|
                                                                Ty.tuple [],
                                                                M.never_to_any (|
                                                                  M.read (| M.break (||) |)
                                                                |)
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_struct_tuple_field (|
                                                                  γ,
                                                                  "core::option::Option::Some",
                                                                  0
                                                                |) in
                                                              let j :=
                                                                M.copy (|
                                                                  Ty.path "usize",
                                                                  γ0_0
                                                                |) in
                                                              let~ _ : Ty.tuple [] :=
                                                                M.call_closure (|
                                                                  Ty.tuple [],
                                                                  M.get_function (|
                                                                    "core::ptr::swap",
                                                                    [],
                                                                    [ T ]
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutPointer,
                                                                      M.deref (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ T ],
                                                                          M.get_associated_function (|
                                                                            Ty.apply
                                                                              (Ty.path "slice")
                                                                              []
                                                                              [ T ],
                                                                            "get_unchecked_mut",
                                                                            [],
                                                                            [ Ty.path "usize" ]
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.MutRef,
                                                                              M.deref (|
                                                                                M.read (| arr |)
                                                                              |)
                                                                            |);
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              BinOp.Wrap.add,
                                                                              [
                                                                                M.read (| i |);
                                                                                M.call_closure (|
                                                                                  Ty.path "usize",
                                                                                  BinOp.Wrap.shl,
                                                                                  [
                                                                                    M.read (| j |);
                                                                                    M.read (|
                                                                                      lb_stride
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutPointer,
                                                                      M.deref (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&mut")
                                                                            []
                                                                            [ T ],
                                                                          M.get_associated_function (|
                                                                            Ty.apply
                                                                              (Ty.path "slice")
                                                                              []
                                                                              [ T ],
                                                                            "get_unchecked_mut",
                                                                            [],
                                                                            [ Ty.path "usize" ]
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.MutRef,
                                                                              M.deref (|
                                                                                M.read (| arr |)
                                                                              |)
                                                                            |);
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              BinOp.Wrap.add,
                                                                              [
                                                                                M.call_closure (|
                                                                                  Ty.path "usize",
                                                                                  BinOp.Wrap.shl,
                                                                                  [
                                                                                    M.read (| i |);
                                                                                    M.read (|
                                                                                      lb_stride
                                                                                    |)
                                                                                  ]
                                                                                |);
                                                                                M.read (| j |)
                                                                              ]
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |) in
                                                              M.alloc (|
                                                                Ty.tuple [],
                                                                Value.Tuple []
                                                              |)))
                                                        ]
                                                      |)
                                                    |) in
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                              |)))
                                        ]
                                      |))))
                              ]
                            |)
                          |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_swap_square_small :
    M.IsFunction.C "p3_util::transpose::transpose_swap_square_small" transpose_swap_square_small.
  Admitted.
  Global Typeclasses Opaque transpose_swap_square_small.
  
  (*
  unsafe fn transpose_swap_square<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
      y: usize,
  ) {
      unsafe {
          if lb_size <= LB_BLOCK_SIZE {
              transpose_swap_square_small(arr, lb_stride, lb_size, x, y);
          } else {
              let lb_block_size = lb_size - 1;
              let block_size = 1 << lb_block_size;
              transpose_swap_square(arr, lb_stride, lb_block_size, x, y);
              transpose_swap_square(arr, lb_stride, lb_block_size, x + block_size, y);
              transpose_swap_square(arr, lb_stride, lb_block_size, x, y + block_size);
              transpose_swap_square(
                  arr,
                  lb_stride,
                  lb_block_size,
                  x + block_size,
                  y + block_size,
              );
          }
      }
  }
  *)
  Definition transpose_swap_square (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x; y ] =>
      ltac:(M.monadic
        (let arr :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ], arr |) in
        let lb_stride := M.alloc (| Ty.path "usize", lb_stride |) in
        let lb_size := M.alloc (| Ty.path "usize", lb_size |) in
        let x := M.alloc (| Ty.path "usize", x |) in
        let y := M.alloc (| Ty.path "usize", y |) in
        M.read (|
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.le,
                          [
                            M.read (| lb_size |);
                            M.read (|
                              get_constant (|
                                "p3_util::transpose::LB_BLOCK_SIZE",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (|
                        "p3_util::transpose::transpose_swap_square_small",
                        [],
                        [ T ]
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_size |);
                        M.read (| x |);
                        M.read (| y |)
                      ]
                    |) in
                  M.alloc (| Ty.tuple [], Value.Tuple [] |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ lb_block_size : Ty.path "usize" :=
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [ M.read (| lb_size |); Value.Integer IntegerKind.Usize 1 ]
                    |) in
                  let~ block_size : Ty.path "usize" :=
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.shl,
                      [ Value.Integer IntegerKind.Usize 1; M.read (| lb_block_size |) ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_block_size |);
                        M.read (| x |);
                        M.read (| y |)
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_block_size |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| x |); M.read (| block_size |) ]
                        |);
                        M.read (| y |)
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_block_size |);
                        M.read (| x |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| y |); M.read (| block_size |) ]
                        |)
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_block_size |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| x |); M.read (| block_size |) ]
                        |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| y |); M.read (| block_size |) ]
                        |)
                      ]
                    |) in
                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_swap_square :
    M.IsFunction.C "p3_util::transpose::transpose_swap_square" transpose_swap_square.
  Admitted.
  Global Typeclasses Opaque transpose_swap_square.
  
  (*
  pub(crate) unsafe fn transpose_in_place_square<T>(
      arr: &mut [T],
      lb_stride: usize,
      lb_size: usize,
      x: usize,
  ) {
      unsafe {
          if lb_size <= LB_BLOCK_SIZE {
              transpose_in_place_square_small(arr, lb_stride, lb_size, x);
          } else {
              let lb_block_size = lb_size - 1;
              let block_size = 1 << lb_block_size;
              transpose_in_place_square(arr, lb_stride, lb_block_size, x);
              transpose_swap_square(arr, lb_stride, lb_block_size, x, x + block_size);
              transpose_in_place_square(arr, lb_stride, lb_block_size, x + block_size);
          }
      }
  }
  *)
  Definition transpose_in_place_square (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ arr; lb_stride; lb_size; x ] =>
      ltac:(M.monadic
        (let arr :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ], arr |) in
        let lb_stride := M.alloc (| Ty.path "usize", lb_stride |) in
        let lb_size := M.alloc (| Ty.path "usize", lb_size |) in
        let x := M.alloc (| Ty.path "usize", x |) in
        M.read (|
          M.match_operator (|
            Ty.tuple [],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        Ty.path "bool",
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.le,
                          [
                            M.read (| lb_size |);
                            M.read (|
                              get_constant (|
                                "p3_util::transpose::LB_BLOCK_SIZE",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (|
                        "p3_util::transpose::transpose_in_place_square_small",
                        [],
                        [ T ]
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_size |);
                        M.read (| x |)
                      ]
                    |) in
                  M.alloc (| Ty.tuple [], Value.Tuple [] |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ lb_block_size : Ty.path "usize" :=
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [ M.read (| lb_size |); Value.Integer IntegerKind.Usize 1 ]
                    |) in
                  let~ block_size : Ty.path "usize" :=
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.shl,
                      [ Value.Integer IntegerKind.Usize 1; M.read (| lb_block_size |) ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (|
                        "p3_util::transpose::transpose_in_place_square",
                        [],
                        [ T ]
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_block_size |);
                        M.read (| x |)
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "p3_util::transpose::transpose_swap_square", [], [ T ] |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_block_size |);
                        M.read (| x |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| x |); M.read (| block_size |) ]
                        |)
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (|
                        "p3_util::transpose::transpose_in_place_square",
                        [],
                        [ T ]
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| arr |) |) |);
                        M.read (| lb_stride |);
                        M.read (| lb_block_size |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| x |); M.read (| block_size |) ]
                        |)
                      ]
                    |) in
                  M.alloc (| Ty.tuple [], Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transpose_in_place_square :
    M.IsFunction.C "p3_util::transpose::transpose_in_place_square" transpose_in_place_square.
  Admitted.
  Global Typeclasses Opaque transpose_in_place_square.
End transpose.
