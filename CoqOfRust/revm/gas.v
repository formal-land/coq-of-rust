(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module gas.
  (* StructRecord
    {
      name := "Gas";
      ty_params := [];
      fields :=
        [ ("limit", Ty.path "u64"); ("remaining", Ty.path "u64"); ("refunded", Ty.path "i64") ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.of_value (| Value.DeclaredButUndefined |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.of_value (| Value.DeclaredButUndefined |),
                      [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| M.of_value (| Value.String "Gas" |) |);
              M.read (| M.of_value (| Value.String "limit" |) |);
              (* Unsize *)
              M.pointer_coercion (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::gas::Gas",
                  "limit"
                |)
              |);
              M.read (| M.of_value (| Value.String "remaining" |) |);
              (* Unsize *)
              M.pointer_coercion (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::gas::Gas",
                  "remaining"
                |)
              |);
              M.read (| M.of_value (| Value.String "refunded" |) |);
              (* Unsize *)
              M.pointer_coercion (|
                M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_interpreter::gas::Gas",
                    "refunded"
                  |)
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_default_Default_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Default *)
    Definition default (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.of_value (|
            Value.StructRecord
              "revm_interpreter::gas::Gas"
              [
                ("limit",
                  A.to_value
                    (M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "u64",
                        [],
                        "default",
                        []
                      |),
                      []
                    |)));
                ("remaining",
                  A.to_value
                    (M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "u64",
                        [],
                        "default",
                        []
                      |),
                      []
                    |)));
                ("refunded",
                  A.to_value
                    (M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "i64",
                        [],
                        "default",
                        []
                      |),
                      []
                    |)))
              ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              BinOp.Pure.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_interpreter::gas::Gas",
                    "limit"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "revm_interpreter::gas::Gas",
                    "limit"
                  |)
                |)
              |),
              ltac:(M.monadic
                (BinOp.Pure.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::gas::Gas",
                      "remaining"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "revm_interpreter::gas::Gas",
                      "remaining"
                    |)
                  |)
                |)))
            |),
            ltac:(M.monadic
              (BinOp.Pure.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_interpreter::gas::Gas",
                    "refunded"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "revm_interpreter::gas::Gas",
                    "refunded"
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_marker_StructuralEq_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.of_value (| Value.DeclaredButUndefined |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.of_value (| Value.DeclaredButUndefined |),
                      [ fun γ => ltac:(M.monadic (M.alloc (| M.of_value (| Value.Tuple [] |) |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "u64", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::gas::Gas",
                      "limit"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "u64", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::gas::Gas",
                      "remaining"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "i64", [], "hash", [ __H ] |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_interpreter::gas::Gas",
                    "refunded"
                  |);
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_gas_Gas.
  
  Module Impl_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (*
        pub const fn new(limit: u64) -> Self {
            Self {
                limit,
                remaining: limit,
                refunded: 0,
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ limit ] =>
        ltac:(M.monadic
          (let limit := M.alloc (| limit |) in
          M.of_value (|
            Value.StructRecord
              "revm_interpreter::gas::Gas"
              [
                ("limit", A.to_value (M.read (| limit |)));
                ("remaining", A.to_value (M.read (| limit |)));
                ("refunded", A.to_value (M.of_value (| Value.Integer 0 |)))
              ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub const fn new_spent(limit: u64) -> Self {
            Self {
                limit,
                remaining: 0,
                refunded: 0,
            }
        }
    *)
    Definition new_spent (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ limit ] =>
        ltac:(M.monadic
          (let limit := M.alloc (| limit |) in
          M.of_value (|
            Value.StructRecord
              "revm_interpreter::gas::Gas"
              [
                ("limit", A.to_value (M.read (| limit |)));
                ("remaining", A.to_value (M.of_value (| Value.Integer 0 |)));
                ("refunded", A.to_value (M.of_value (| Value.Integer 0 |)))
              ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_spent : M.IsAssociatedFunction Self "new_spent" new_spent.
    
    (*
        pub const fn limit(&self) -> u64 {
            self.limit
        }
    *)
    Definition limit (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::gas::Gas",
              "limit"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_limit : M.IsAssociatedFunction Self "limit" limit.
    
    (*
        pub const fn memory(&self) -> u64 {
            0
        }
    *)
    Definition memory (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.of_value (| Value.Integer 0 |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_memory : M.IsAssociatedFunction Self "memory" memory.
    
    (*
        pub const fn refunded(&self) -> i64 {
            self.refunded
        }
    *)
    Definition refunded (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::gas::Gas",
              "refunded"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_refunded : M.IsAssociatedFunction Self "refunded" refunded.
    
    (*
        pub const fn spent(&self) -> u64 {
            self.limit - self.remaining
        }
    *)
    Definition spent (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Panic.sub (|
            Integer.U64,
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_interpreter::gas::Gas",
                "limit"
              |)
            |),
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_interpreter::gas::Gas",
                "remaining"
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_spent : M.IsAssociatedFunction Self "spent" spent.
    
    (*
        pub const fn spend(&self) -> u64 {
            self.spent()
        }
    *)
    Definition spend (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "revm_interpreter::gas::Gas", "spent", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_spend : M.IsAssociatedFunction Self "spend" spend.
    
    (*
        pub const fn remaining(&self) -> u64 {
            self.remaining
        }
    *)
    Definition remaining (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::gas::Gas",
              "remaining"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_remaining : M.IsAssociatedFunction Self "remaining" remaining.
    
    (*
        pub fn erase_cost(&mut self, returned: u64) {
            self.remaining += returned;
        }
    *)
    Definition erase_cost (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self; returned ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let returned := M.alloc (| returned |) in
          M.read (|
            let _ :=
              let β :=
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::gas::Gas",
                  "remaining"
                |) in
              M.write (|
                β,
                BinOp.Panic.add (| Integer.U64, M.read (| β |), M.read (| returned |) |)
              |) in
            M.alloc (| M.of_value (| Value.Tuple [] |) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_erase_cost : M.IsAssociatedFunction Self "erase_cost" erase_cost.
    
    (*
        pub fn spend_all(&mut self) {
            self.remaining = 0;
        }
    *)
    Definition spend_all (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::gas::Gas",
                  "remaining"
                |),
                M.of_value (| Value.Integer 0 |)
              |) in
            M.alloc (| M.of_value (| Value.Tuple [] |) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_spend_all : M.IsAssociatedFunction Self "spend_all" spend_all.
    
    (*
        pub fn record_refund(&mut self, refund: i64) {
            self.refunded += refund;
        }
    *)
    Definition record_refund (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self; refund ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let refund := M.alloc (| refund |) in
          M.read (|
            let _ :=
              let β :=
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::gas::Gas",
                  "refunded"
                |) in
              M.write (|
                β,
                BinOp.Panic.add (| Integer.I64, M.read (| β |), M.read (| refund |) |)
              |) in
            M.alloc (| M.of_value (| Value.Tuple [] |) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_record_refund :
      M.IsAssociatedFunction Self "record_refund" record_refund.
    
    (*
        pub fn set_final_refund(&mut self, is_london: bool) {
            let max_refund_quotient = if is_london { 5 } else { 2 };
            self.refunded = (self.refunded() as u64).min(self.spent() / max_refund_quotient) as i64;
        }
    *)
    Definition set_final_refund (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self; is_london ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let is_london := M.alloc (| is_london |) in
          M.read (|
            let max_refund_quotient :=
              M.copy (|
                M.match_operator (|
                  M.alloc (| M.of_value (| Value.Tuple [] |) |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use is_london in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (| M.of_value (| Value.Integer 5 |) |)));
                    fun γ => ltac:(M.monadic (M.alloc (| M.of_value (| Value.Integer 2 |) |)))
                  ]
                |)
              |) in
            let _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::gas::Gas",
                  "refunded"
                |),
                M.rust_cast (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::Ord", Ty.path "u64", [], "min", [] |),
                    [
                      M.rust_cast (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::gas::Gas",
                            "refunded",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |);
                      BinOp.Panic.div (|
                        Integer.U64,
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::gas::Gas",
                            "spent",
                            []
                          |),
                          [ M.read (| self |) ]
                        |),
                        M.read (| max_refund_quotient |)
                      |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| M.of_value (| Value.Tuple [] |) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_set_final_refund :
      M.IsAssociatedFunction Self "set_final_refund" set_final_refund.
    
    (*
        pub fn set_refund(&mut self, refund: i64) {
            self.refunded = refund;
        }
    *)
    Definition set_refund (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self; refund ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let refund := M.alloc (| refund |) in
          M.read (|
            let _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::gas::Gas",
                  "refunded"
                |),
                M.read (| refund |)
              |) in
            M.alloc (| M.of_value (| Value.Tuple [] |) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_set_refund : M.IsAssociatedFunction Self "set_refund" set_refund.
    
    (*
        pub fn record_cost(&mut self, cost: u64) -> bool {
            let (remaining, overflow) = self.remaining.overflowing_sub(cost);
            let success = !overflow;
            if success {
                self.remaining = remaining;
            }
            success
        }
    *)
    Definition record_cost (τ : list Ty.t) (α : list A.t) : M :=
      match τ, α with
      | [], [ self; cost ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cost := M.alloc (| cost |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "overflowing_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm_interpreter::gas::Gas",
                        "remaining"
                      |)
                    |);
                    M.read (| cost |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let remaining := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    let success := M.alloc (| UnOp.Pure.not (| M.read (| overflow |) |) |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (| M.of_value (| Value.Tuple [] |) |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use success in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let _ :=
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "revm_interpreter::gas::Gas",
                                    "remaining"
                                  |),
                                  M.read (| remaining |)
                                |) in
                              M.alloc (| M.of_value (| Value.Tuple [] |) |)));
                          fun γ => ltac:(M.monadic (M.alloc (| M.of_value (| Value.Tuple [] |) |)))
                        ]
                      |) in
                    success))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_record_cost : M.IsAssociatedFunction Self "record_cost" record_cost.
  End Impl_revm_interpreter_gas_Gas.
End gas.
