(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module instructions.
  Module stack.
    (*
    pub fn pop<H: Host + ?Sized>(interpreter: &mut Interpreter, _host: &mut H) {
        gas!(interpreter, gas::BASE);
        if let Err(result) = interpreter.stack.pop() {
            interpreter.instruction_result = result;
        }
    }
    *)
    Definition pop (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::BASE"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "revm_interpreter::interpreter::stack::Stack",
                                "pop",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| interpreter |),
                                  "revm_interpreter::interpreter::Interpreter",
                                  "stack"
                                |)
                              ]
                            |)
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let result := M.copy (| γ0_0 |) in
                        let _ :=
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| interpreter |),
                              "revm_interpreter::interpreter::Interpreter",
                              "instruction_result"
                            |),
                            M.read (| result |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_pop : M.IsFunction "revm_interpreter::instructions::stack::pop" pop.
    
    (*
    pub fn push0<H: Host + ?Sized, SPEC: Spec>(interpreter: &mut Interpreter, _host: &mut H) {
        check!(interpreter, SHANGHAI);
        gas!(interpreter, gas::BASE);
        if let Err(result) = interpreter.stack.push(U256::ZERO) {
            interpreter.instruction_result = result;
        }
    }
    *)
    Definition push0 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H; SPEC ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "revm_primitives::specification::Spec",
                                      SPEC,
                                      [],
                                      "enabled",
                                      []
                                    |),
                                    [
                                      Value.StructTuple
                                        "revm_primitives::specification::SpecId::SHANGHAI"
                                        []
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::BASE"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "revm_interpreter::interpreter::stack::Stack",
                                "push",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| interpreter |),
                                  "revm_interpreter::interpreter::Interpreter",
                                  "stack"
                                |);
                                M.read (| M.get_constant (| "ruint::ZERO" |) |)
                              ]
                            |)
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let result := M.copy (| γ0_0 |) in
                        let _ :=
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| interpreter |),
                              "revm_interpreter::interpreter::Interpreter",
                              "instruction_result"
                            |),
                            M.read (| result |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_push0 : M.IsFunction "revm_interpreter::instructions::stack::push0" push0.
    
    (*
    pub fn push<const N: usize, H: Host + ?Sized>(interpreter: &mut Interpreter, _host: &mut H) {
        gas!(interpreter, gas::VERYLOW);
        // SAFETY: In analysis we append trailing bytes to the bytecode so that this is safe to do
        // without bounds checking.
        let ip = interpreter.instruction_pointer;
        if let Err(result) = interpreter
            .stack
            .push_slice(unsafe { core::slice::from_raw_parts(ip, N) })
        {
            interpreter.instruction_result = result;
            return;
        }
        interpreter.instruction_pointer = unsafe { ip.add(N) };
    }
    *)
    Definition push (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::VERYLOW"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let ip :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| interpreter |),
                      "revm_interpreter::interpreter::Interpreter",
                      "instruction_pointer"
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "revm_interpreter::interpreter::stack::Stack",
                                  "push_slice",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| interpreter |),
                                    "revm_interpreter::interpreter::Interpreter",
                                    "stack"
                                  |);
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::slice::raw::from_raw_parts",
                                      [ Ty.path "u8" ]
                                    |),
                                    [
                                      M.read (| ip |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::instructions::stack::push::N"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let result := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    M.read (| result |)
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| interpreter |),
                      "revm_interpreter::interpreter::Interpreter",
                      "instruction_pointer"
                    |),
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                        "add",
                        []
                      |),
                      [
                        M.read (| ip |);
                        M.read (|
                          M.get_constant (| "revm_interpreter::instructions::stack::push::N" |)
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_push : M.IsFunction "revm_interpreter::instructions::stack::push" push.
    
    (*
    pub fn dup<const N: usize, H: Host + ?Sized>(interpreter: &mut Interpreter, _host: &mut H) {
        gas!(interpreter, gas::VERYLOW);
        if let Err(result) = interpreter.stack.dup(N) {
            interpreter.instruction_result = result;
        }
    }
    *)
    Definition dup (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::VERYLOW"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "revm_interpreter::interpreter::stack::Stack",
                                "dup",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| interpreter |),
                                  "revm_interpreter::interpreter::Interpreter",
                                  "stack"
                                |);
                                M.read (|
                                  M.get_constant (|
                                    "revm_interpreter::instructions::stack::dup::N"
                                  |)
                                |)
                              ]
                            |)
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let result := M.copy (| γ0_0 |) in
                        let _ :=
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| interpreter |),
                              "revm_interpreter::interpreter::Interpreter",
                              "instruction_result"
                            |),
                            M.read (| result |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_dup : M.IsFunction "revm_interpreter::instructions::stack::dup" dup.
    
    (*
    pub fn swap<const N: usize, H: Host + ?Sized>(interpreter: &mut Interpreter, _host: &mut H) {
        gas!(interpreter, gas::VERYLOW);
        if let Err(result) = interpreter.stack.swap(N) {
            interpreter.instruction_result = result;
        }
    }
    *)
    Definition swap (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::VERYLOW"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "revm_interpreter::interpreter::stack::Stack",
                                "swap",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| interpreter |),
                                  "revm_interpreter::interpreter::Interpreter",
                                  "stack"
                                |);
                                M.read (|
                                  M.get_constant (|
                                    "revm_interpreter::instructions::stack::swap::N"
                                  |)
                                |)
                              ]
                            |)
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let result := M.copy (| γ0_0 |) in
                        let _ :=
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| interpreter |),
                              "revm_interpreter::interpreter::Interpreter",
                              "instruction_result"
                            |),
                            M.read (| result |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_swap : M.IsFunction "revm_interpreter::instructions::stack::swap" swap.
    
    (*
    pub fn dupn<H: Host + ?Sized>(interpreter: &mut Interpreter, _host: &mut H) {
        require_eof!(interpreter);
        gas!(interpreter, gas::VERYLOW);
        let imm = unsafe { *interpreter.instruction_pointer };
        if let Err(result) = interpreter.stack.dup(imm as usize + 1) {
            interpreter.instruction_result = result;
        }
        interpreter.instruction_pointer = unsafe { interpreter.instruction_pointer.offset(1) };
    }
    *)
    Definition dupn (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "is_eof"
                                    |)
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::VERYLOW"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let imm :=
                  M.copy (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| interpreter |),
                        "revm_interpreter::interpreter::Interpreter",
                        "instruction_pointer"
                      |)
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "revm_interpreter::interpreter::stack::Stack",
                                  "dup",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| interpreter |),
                                    "revm_interpreter::interpreter::Interpreter",
                                    "stack"
                                  |);
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.rust_cast (M.read (| imm |)))
                                    (Value.Integer 1)
                                ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let result := M.copy (| γ0_0 |) in
                          let _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| interpreter |),
                                "revm_interpreter::interpreter::Interpreter",
                                "instruction_result"
                              |),
                              M.read (| result |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| interpreter |),
                      "revm_interpreter::interpreter::Interpreter",
                      "instruction_pointer"
                    |),
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                        "offset",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| interpreter |),
                            "revm_interpreter::interpreter::Interpreter",
                            "instruction_pointer"
                          |)
                        |);
                        Value.Integer 1
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_dupn : M.IsFunction "revm_interpreter::instructions::stack::dupn" dupn.
    
    (*
    pub fn swapn<H: Host + ?Sized>(interpreter: &mut Interpreter, _host: &mut H) {
        require_eof!(interpreter);
        gas!(interpreter, gas::VERYLOW);
        let imm = unsafe { *interpreter.instruction_pointer };
        if let Err(result) = interpreter.stack.swap(imm as usize + 1) {
            interpreter.instruction_result = result;
        }
        interpreter.instruction_pointer = unsafe { interpreter.instruction_pointer.offset(1) };
    }
    *)
    Definition swapn (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "is_eof"
                                    |)
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::VERYLOW"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let imm :=
                  M.copy (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| interpreter |),
                        "revm_interpreter::interpreter::Interpreter",
                        "instruction_pointer"
                      |)
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "revm_interpreter::interpreter::stack::Stack",
                                  "swap",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| interpreter |),
                                    "revm_interpreter::interpreter::Interpreter",
                                    "stack"
                                  |);
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.rust_cast (M.read (| imm |)))
                                    (Value.Integer 1)
                                ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let result := M.copy (| γ0_0 |) in
                          let _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| interpreter |),
                                "revm_interpreter::interpreter::Interpreter",
                                "instruction_result"
                              |),
                              M.read (| result |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| interpreter |),
                      "revm_interpreter::interpreter::Interpreter",
                      "instruction_pointer"
                    |),
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                        "offset",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| interpreter |),
                            "revm_interpreter::interpreter::Interpreter",
                            "instruction_pointer"
                          |)
                        |);
                        Value.Integer 1
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_swapn : M.IsFunction "revm_interpreter::instructions::stack::swapn" swapn.
    
    (*
    pub fn exchange<H: Host + ?Sized>(interpreter: &mut Interpreter, _host: &mut H) {
        require_eof!(interpreter);
        gas!(interpreter, gas::VERYLOW);
        let imm = unsafe { *interpreter.instruction_pointer };
        let n = (imm >> 4) + 1;
        let m = (imm & 0x0F) + 1;
        if let Err(result) = interpreter.stack.exchange(n as usize, m as usize) {
            interpreter.instruction_result = result;
        }
    
        interpreter.instruction_pointer = unsafe { interpreter.instruction_pointer.offset(1) };
    }
    *)
    Definition exchange (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ interpreter; _host ] =>
        ltac:(M.monadic
          (let interpreter := M.alloc (| interpreter |) in
          let _host := M.alloc (| _host |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "is_eof"
                                    |)
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::gas::Gas",
                                      "record_cost",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| interpreter |),
                                        "revm_interpreter::interpreter::Interpreter",
                                        "gas"
                                      |);
                                      M.read (|
                                        M.get_constant (|
                                          "revm_interpreter::gas::constants::VERYLOW"
                                        |)
                                      |)
                                    ]
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| interpreter |),
                                      "revm_interpreter::interpreter::Interpreter",
                                      "instruction_result"
                                    |),
                                    Value.StructTuple
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                      []
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let imm :=
                  M.copy (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| interpreter |),
                        "revm_interpreter::interpreter::Interpreter",
                        "instruction_pointer"
                      |)
                    |)
                  |) in
                let n :=
                  M.alloc (|
                    BinOp.Wrap.add
                      Integer.U8
                      (BinOp.Wrap.shr (M.read (| imm |)) (Value.Integer 4))
                      (Value.Integer 1)
                  |) in
                let m :=
                  M.alloc (|
                    BinOp.Wrap.add
                      Integer.U8
                      (BinOp.Pure.bit_and (M.read (| imm |)) (Value.Integer 15))
                      (Value.Integer 1)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "revm_interpreter::interpreter::stack::Stack",
                                  "exchange",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| interpreter |),
                                    "revm_interpreter::interpreter::Interpreter",
                                    "stack"
                                  |);
                                  M.rust_cast (M.read (| n |));
                                  M.rust_cast (M.read (| m |))
                                ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let result := M.copy (| γ0_0 |) in
                          let _ :=
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| interpreter |),
                                "revm_interpreter::interpreter::Interpreter",
                                "instruction_result"
                              |),
                              M.read (| result |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| interpreter |),
                      "revm_interpreter::interpreter::Interpreter",
                      "instruction_pointer"
                    |),
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                        "offset",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| interpreter |),
                            "revm_interpreter::interpreter::Interpreter",
                            "instruction_pointer"
                          |)
                        |);
                        Value.Integer 1
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_exchange :
      M.IsFunction "revm_interpreter::instructions::stack::exchange" exchange.
  End stack.
End instructions.
