(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module opcode.
  Axiom Instruction :
    forall (H : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::opcode::Instruction") [ H ]) =
      (Ty.function
        [
          Ty.apply (Ty.path "&mut") [ Ty.path "revm_interpreter::interpreter::Interpreter" ];
          Ty.apply (Ty.path "&mut") [ H ]
        ]
        (Ty.tuple [])).
  
  Axiom InstructionTable :
    forall (H : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::opcode::InstructionTable") [ H ]) =
      (Ty.apply
        (Ty.path "array")
        [
          Ty.function
            [
              Ty.apply (Ty.path "&mut") [ Ty.path "revm_interpreter::interpreter::Interpreter" ];
              Ty.apply (Ty.path "&mut") [ H ]
            ]
            (Ty.tuple [])
        ]).
  
  Axiom BoxedInstruction :
    forall (H : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::opcode::BoxedInstruction") [ H ]) =
      (Ty.apply
        (Ty.path "alloc::boxed::Box")
        [
          Ty.dyn
            [
              ("existential predicate with variables", []);
              ("existential predicate with variables", [])
            ];
          Ty.path "alloc::alloc::Global"
        ]).
  
  Axiom BoxedInstructionTable :
    forall (H : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::opcode::BoxedInstructionTable") [ H ]) =
      (Ty.apply
        (Ty.path "array")
        [
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            [
              Ty.dyn
                [
                  ("existential predicate with variables", []);
                  ("existential predicate with variables", [])
                ];
              Ty.path "alloc::alloc::Global"
            ]
        ]).
  
  (*
  Enum InstructionTables
  {
    ty_params := [ "H" ];
    variants :=
      [
        {
          name := "Plain";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "array")
                  [
                    Ty.function
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          [ Ty.path "revm_interpreter::interpreter::Interpreter" ];
                        Ty.apply (Ty.path "&mut") [ H ]
                      ]
                      (Ty.tuple [])
                  ]
              ];
          discriminant := None;
        };
        {
          name := "Boxed";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "array")
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [
                        Ty.dyn
                          [
                            ("existential predicate with variables", []);
                            ("existential predicate with variables", [])
                          ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_revm_interpreter_opcode_InstructionTables_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::opcode::InstructionTables") [ H ].
    
    (*
        pub const fn new_plain<SPEC: Spec>() -> Self {
            Self::Plain(make_instruction_table::<H, SPEC>())
        }
    *)
    Definition new_plain (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [ SPEC ], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "revm_interpreter::opcode::InstructionTables::Plain"
            [
              M.call_closure (|
                M.get_function (|
                  "revm_interpreter::opcode::make_instruction_table",
                  [ H; SPEC ]
                |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_plain :
      forall (H : Ty.t),
      M.IsAssociatedFunction (Self H) "new_plain" (new_plain H).
    (*
        pub fn insert_boxed(&mut self, opcode: u8, instruction: BoxedInstruction<'a, H>) {
            // first convert the table to boxed variant
            self.convert_boxed();
    
            // now we can insert the instruction
            match self {
                Self::Plain(_) => {
                    unreachable!("we already converted the table to boxed variant");
                }
                Self::Boxed(table) => {
                    table[opcode as usize] = Box::new(instruction);
                }
            }
        }
    *)
    Definition insert_boxed (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; opcode; instruction ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let opcode := M.alloc (| opcode |) in
          let instruction := M.alloc (| instruction |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "revm_interpreter::opcode::InstructionTables") [ H ],
                    "convert_boxed",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::opcode::InstructionTables::Plain",
                        0
                      |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "internal error: entered unreachable code: we already converted the table to boxed variant"
                                        |)
                                      ]
                                  |));
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "none",
                                        []
                                      |),
                                      []
                                    |)
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::opcode::InstructionTables::Boxed",
                        0
                      |) in
                    let table := M.alloc (| γ1_0 |) in
                    let~ _ :=
                      M.write (|
                        M.SubPointer.get_array_field (|
                          M.read (| table |),
                          M.alloc (| M.rust_cast (M.read (| opcode |)) |)
                        |),
                        (* Unsize *)
                        M.pointer_coercion
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.dyn
                                        [
                                          ("existential predicate with variables", []);
                                          ("existential predicate with variables", [])
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "new",
                              []
                            |),
                            [ M.read (| instruction |) ]
                          |))
                      |) in
                    M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_insert_boxed :
      forall (H : Ty.t),
      M.IsAssociatedFunction (Self H) "insert_boxed" (insert_boxed H).
    
    (*
        pub fn insert(&mut self, opcode: u8, instruction: Instruction<H>) {
            match self {
                Self::Plain(table) => {
                    table[opcode as usize] = instruction;
                }
                Self::Boxed(table) => {
                    table[opcode as usize] = Box::new(instruction);
                }
            }
        }
    *)
    Definition insert (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; opcode; instruction ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let opcode := M.alloc (| opcode |) in
          let instruction := M.alloc (| instruction |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::opcode::InstructionTables::Plain",
                        0
                      |) in
                    let table := M.alloc (| γ1_0 |) in
                    let~ _ :=
                      M.write (|
                        M.SubPointer.get_array_field (|
                          M.read (| table |),
                          M.alloc (| M.rust_cast (M.read (| opcode |)) |)
                        |),
                        M.read (| instruction |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::opcode::InstructionTables::Boxed",
                        0
                      |) in
                    let table := M.alloc (| γ1_0 |) in
                    let~ _ :=
                      M.write (|
                        M.SubPointer.get_array_field (|
                          M.read (| table |),
                          M.alloc (| M.rust_cast (M.read (| opcode |)) |)
                        |),
                        (* Unsize *)
                        M.pointer_coercion
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.function
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        [ Ty.path "revm_interpreter::interpreter::Interpreter" ];
                                      Ty.apply (Ty.path "&mut") [ H ]
                                    ]
                                    (Ty.tuple []);
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "new",
                              []
                            |),
                            [ M.read (| instruction |) ]
                          |))
                      |) in
                    M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_insert :
      forall (H : Ty.t),
      M.IsAssociatedFunction (Self H) "insert" (insert H).
    
    (*
        pub fn convert_boxed(&mut self) {
            match self {
                Self::Plain(table) => {
                    *self = Self::Boxed(core::array::from_fn(|i| {
                        let instruction: BoxedInstruction<'a, H> = Box::new(table[i]);
                        instruction
                    }));
                }
                Self::Boxed(_) => {}
            };
        }
    *)
    Definition convert_boxed (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "revm_interpreter::opcode::InstructionTables::Plain",
                          0
                        |) in
                      let table := M.alloc (| γ1_0 |) in
                      let~ _ :=
                        M.write (|
                          M.read (| self |),
                          Value.StructTuple
                            "revm_interpreter::opcode::InstructionTables::Boxed"
                            [
                              M.call_closure (|
                                M.get_function (|
                                  "core::array::from_fn",
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      [
                                        Ty.dyn
                                          [
                                            ("existential predicate with variables", []);
                                            ("existential predicate with variables", [])
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.function
                                      [ Ty.tuple [ Ty.path "usize" ] ]
                                      (Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        [
                                          Ty.dyn
                                            [
                                              ("existential predicate with variables", []);
                                              ("existential predicate with variables", [])
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ])
                                  ]
                                |),
                                [
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let i := M.copy (| γ |) in
                                                  (* Unsize *)
                                                  M.pointer_coercion
                                                    (M.read (|
                                                      let~ instruction :=
                                                        M.alloc (|
                                                          (* Unsize *)
                                                          M.pointer_coercion
                                                            (M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "alloc::boxed::Box")
                                                                  [
                                                                    Ty.function
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&mut")
                                                                          [
                                                                            Ty.path
                                                                              "revm_interpreter::interpreter::Interpreter"
                                                                          ];
                                                                        Ty.apply
                                                                          (Ty.path "&mut")
                                                                          [ H ]
                                                                      ]
                                                                      (Ty.tuple []);
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                "new",
                                                                []
                                                              |),
                                                              [
                                                                M.read (|
                                                                  M.SubPointer.get_array_field (|
                                                                    M.read (| table |),
                                                                    i
                                                                  |)
                                                                |)
                                                              ]
                                                            |))
                                                        |) in
                                                      instruction
                                                    |))))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "revm_interpreter::opcode::InstructionTables::Boxed",
                          0
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_convert_boxed :
      forall (H : Ty.t),
      M.IsAssociatedFunction (Self H) "convert_boxed" (convert_boxed H).
  End Impl_revm_interpreter_opcode_InstructionTables_H.
  
  
  (*
  pub const fn make_instruction_table<H: Host + ?Sized, SPEC: Spec>() -> InstructionTable<H> {
      // Force const-eval of the table creation, making this function trivial.
      // TODO: Replace this with a `const {}` block once it is stable.
      struct ConstTable<H: Host + ?Sized, SPEC: Spec> {
          _host: core::marker::PhantomData<H>,
          _spec: core::marker::PhantomData<SPEC>,
      }
      impl<H: Host + ?Sized, SPEC: Spec> ConstTable<H, SPEC> {
          const NEW: InstructionTable<H> = {
              let mut tables: InstructionTable<H> = [control::unknown; 256];
              let mut i = 0;
              while i < 256 {
                  tables[i] = instruction::<H, SPEC>(i as u8);
                  i += 1;
              }
              tables
          };
      }
      ConstTable::<H, SPEC>::NEW
  }
  *)
  Definition make_instruction_table (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ H; SPEC ], [] =>
      ltac:(M.monadic
        (M.read (| M.get_constant (| "revm_interpreter::opcode::make_instruction_table::NEW" |) |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_make_instruction_table :
    M.IsFunction "revm_interpreter::opcode::make_instruction_table" make_instruction_table.
  
  Module make_instruction_table.
    (* StructRecord
      {
        name := "ConstTable";
        ty_params := [ "H"; "SPEC" ];
        fields :=
          [
            ("_host", Ty.apply (Ty.path "core::marker::PhantomData") [ H ]);
            ("_spec", Ty.apply (Ty.path "core::marker::PhantomData") [ SPEC ])
          ];
      } *)
    
    Module Impl_revm_interpreter_opcode_make_instruction_table_ConstTable_H_SPEC.
      Definition Self (H SPEC : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "revm_interpreter::opcode::make_instruction_table::ConstTable")
          [ H; SPEC ].
      
      (*
              const NEW: InstructionTable<H> = {
                  let mut tables: InstructionTable<H> = [control::unknown; 256];
                  let mut i = 0;
                  while i < 256 {
                      tables[i] = instruction::<H, SPEC>(i as u8);
                      i += 1;
                  }
                  tables
              };
      *)
      (* Ty.apply
        (Ty.path "array")
        [
          Ty.function
            [
              Ty.apply (Ty.path "&mut") [ Ty.path "revm_interpreter::interpreter::Interpreter" ];
              Ty.apply (Ty.path "&mut") [ H ]
            ]
            (Ty.tuple [])
        ] *)
      Definition value_NEW (H SPEC : Ty.t) : Value.t :=
        let Self : Ty.t := Self H SPEC in
        M.run
          ltac:(M.monadic
            (let~ tables :=
              M.alloc (|
                repeat
                  (* ReifyFnPointer *)
                  (M.pointer_coercion
                    (M.get_function (|
                      "revm_interpreter::instructions::control::unknown",
                      [ H ]
                    |)))
                  256
              |) in
            let~ i := M.alloc (| Value.Integer 0 |) in
            let~ _ :=
              M.loop (|
                ltac:(M.monadic
                  (M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.lt (M.read (| i |)) (Value.Integer 256) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.write (|
                              M.SubPointer.get_array_field (| tables, i |),
                              M.call_closure (|
                                M.get_function (|
                                  "revm_interpreter::opcode::instruction",
                                  [ H; SPEC ]
                                |),
                                [ M.rust_cast (M.read (| i |)) ]
                              |)
                            |) in
                          let~ _ :=
                            let β := i in
                            M.write (|
                              β,
                              BinOp.Wrap.add Integer.Usize (M.read (| β |)) (Value.Integer 1)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |) in
            tables)).
      
      Axiom AssociatedConstant_value_NEW :
        forall (H SPEC : Ty.t),
        M.IsAssociatedConstant (Self H SPEC) "value_NEW" (value_NEW H SPEC).
    End Impl_revm_interpreter_opcode_make_instruction_table_ConstTable_H_SPEC.
  End make_instruction_table.
  
  (*
  pub fn make_boxed_instruction_table<'a, H, SPEC, FN>(
      table: InstructionTable<H>,
      mut outer: FN,
  ) -> BoxedInstructionTable<'a, H>
  where
      H: Host,
      SPEC: Spec + 'a,
      FN: FnMut(Instruction<H>) -> BoxedInstruction<'a, H>,
  {
      core::array::from_fn(|i| outer(table[i]))
  }
  *)
  Definition make_boxed_instruction_table (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ H; SPEC; FN ], [ table; outer ] =>
      ltac:(M.monadic
        (let table := M.alloc (| table |) in
        let outer := M.alloc (| outer |) in
        M.call_closure (|
          M.get_function (|
            "core::array::from_fn",
            [
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [
                  Ty.dyn
                    [
                      ("existential predicate with variables", []);
                      ("existential predicate with variables", [])
                    ];
                  Ty.path "alloc::alloc::Global"
                ];
              Ty.function
                [ Ty.tuple [ Ty.path "usize" ] ]
                (Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [
                    Ty.dyn
                      [
                        ("existential predicate with variables", []);
                        ("existential predicate with variables", [])
                      ];
                    Ty.path "alloc::alloc::Global"
                  ])
            ]
          |),
          [
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let i := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::FnMut",
                                FN,
                                [
                                  Ty.tuple
                                    [
                                      Ty.function
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            [ Ty.path "revm_interpreter::interpreter::Interpreter"
                                            ];
                                          Ty.apply (Ty.path "&mut") [ H ]
                                        ]
                                        (Ty.tuple [])
                                    ]
                                ],
                                "call_mut",
                                []
                              |),
                              [
                                outer;
                                Value.Tuple
                                  [ M.read (| M.SubPointer.get_array_field (| table, i |) |) ]
                              ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_make_boxed_instruction_table :
    M.IsFunction
      "revm_interpreter::opcode::make_boxed_instruction_table"
      make_boxed_instruction_table.
  
  (* StructTuple
    {
      name := "OpCodeError";
      ty_params := [];
      fields := [ Ty.tuple [] ];
    } *)
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_opcode_OpCodeError.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "OpCodeError" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "revm_interpreter::opcode::OpCodeError",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_opcode_OpCodeError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_opcode_OpCodeError.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_opcode_OpCodeError.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_opcode_OpCodeError.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", Ty.tuple [], [ Ty.tuple [] ], "eq", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_interpreter::opcode::OpCodeError",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "revm_interpreter::opcode::OpCodeError",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_opcode_OpCodeError.
  
  Module Impl_core_marker_StructuralEq_for_revm_interpreter_opcode_OpCodeError.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_interpreter_opcode_OpCodeError.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_opcode_OpCodeError.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_opcode_OpCodeError.
  
  Module Impl_core_fmt_Display_for_revm_interpreter_opcode_OpCodeError.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_str("invalid opcode")
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| f |); M.read (| Value.String "invalid opcode" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_interpreter_opcode_OpCodeError.
  
  Module Impl_core_error_Error_for_revm_interpreter_opcode_OpCodeError.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_interpreter_opcode_OpCodeError.
  
  (* StructTuple
    {
      name := "OpCode";
      ty_params := [];
      fields := [ Ty.path "u8" ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "OpCode" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "revm_interpreter::opcode::OpCode",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_default_Default_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* Default *)
    Definition default (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "revm_interpreter::opcode::OpCode"
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", Ty.path "u8", [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          BinOp.Pure.eq
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_interpreter::opcode::OpCode",
                0
              |)
            |))
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "revm_interpreter::opcode::OpCode",
                0
              |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_marker_StructuralEq_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_cmp_PartialOrd_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u8",
              [ Ty.path "u8" ],
              "partial_cmp",
              []
            |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_interpreter::opcode::OpCode",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "revm_interpreter::opcode::OpCode",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_cmp_Ord_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], "cmp", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_interpreter::opcode::OpCode",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "revm_interpreter::opcode::OpCode",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], "hash", [ __H ] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_interpreter::opcode::OpCode",
                0
              |);
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_fmt_Display_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let n = self.get();
            if let Some(val) = OPCODE_INFO_JUMPTABLE[n as usize] {
                f.write_str(val.name())
            } else {
                write!(f, "UNKNOWN(0x{n:02X})")
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ n :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::opcode::OpCode",
                    "get",
                    []
                  |),
                  [ M.read (| M.read (| self |) |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.SubPointer.get_array_field (|
                        M.get_constant (| "revm_interpreter::opcode::OPCODE_INFO_JUMPTABLE" |),
                        M.alloc (| M.rust_cast (M.read (| n |)) |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let val := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_interpreter::opcode::OpCodeInfo",
                              "name",
                              []
                            |),
                            [ val ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1_formatted",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (| Value.String "UNKNOWN(0x" |);
                                      M.read (| Value.String ")" |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_upper_hex",
                                          [ Ty.path "u8" ]
                                        |),
                                        [ n ]
                                      |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Placeholder",
                                          "new",
                                          []
                                        |),
                                        [
                                          Value.Integer 0;
                                          Value.UnicodeChar 32;
                                          Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                          Value.Integer 8;
                                          Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                          Value.StructTuple
                                            "core::fmt::rt::Count::Is"
                                            [ Value.Integer 2 ]
                                        ]
                                      |)
                                    ]
                                |));
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::UnsafeArg",
                                  "new",
                                  []
                                |),
                                []
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_core_str_traits_FromStr_for_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (*     type Err = OpCodeError; *)
    Definition _Err : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeError".
    
    (*
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Self::parse(s).ok_or(OpCodeError(()))
        }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "revm_interpreter::opcode::OpCode" ],
              "ok_or",
              [ Ty.path "revm_interpreter::opcode::OpCodeError" ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "revm_interpreter::opcode::OpCode",
                  "parse",
                  []
                |),
                [ M.read (| s |) ]
              |);
              Value.StructTuple "revm_interpreter::opcode::OpCodeError" [ Value.Tuple [] ]
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_revm_interpreter_opcode_OpCode.
  
  Module Impl_revm_interpreter_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCode".
    
    (*
        pub const fn new(opcode: u8) -> Option<Self> {
            match OPCODE_INFO_JUMPTABLE[opcode as usize] {
                Some(_) => Some(Self(opcode)),
                None => None,
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.SubPointer.get_array_field (|
                M.get_constant (| "revm_interpreter::opcode::OPCODE_INFO_JUMPTABLE" |),
                M.alloc (| M.rust_cast (M.read (| opcode |)) |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          Value.StructTuple
                            "revm_interpreter::opcode::OpCode"
                            [ M.read (| opcode |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn parse(s: &str) -> Option<Self> {
            NAME_TO_OPCODE.get(s).copied()
        }
    *)
    Definition parse (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.apply (Ty.path "&") [ Ty.path "revm_interpreter::opcode::OpCode" ] ],
              "copied",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "phf::map::Map")
                    [
                      Ty.apply (Ty.path "&") [ Ty.path "str" ];
                      Ty.path "revm_interpreter::opcode::OpCode"
                    ],
                  "get",
                  [ Ty.path "str" ]
                |),
                [
                  M.read (| M.get_constant (| "revm_interpreter::opcode::NAME_TO_OPCODE" |) |);
                  M.read (| s |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_parse : M.IsAssociatedFunction Self "parse" parse.
    
    (*
        pub const fn is_jumpdest(&self) -> bool {
            self.0 == JUMPDEST
        }
    *)
    Definition is_jumpdest (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_interpreter::opcode::OpCode",
                0
              |)
            |))
            (M.read (| M.get_constant (| "revm_interpreter::opcode::JUMPDEST" |) |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_jumpdest : M.IsAssociatedFunction Self "is_jumpdest" is_jumpdest.
    
    (*
        pub const fn is_jumpdest_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_jumpdest()
            } else {
                false
            }
        }
    *)
    Definition is_jumpdest_by_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::opcode::OpCode",
                            "new",
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "revm_interpreter::opcode::OpCode",
                          "is_jumpdest",
                          []
                        |),
                        [ opcode ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_jumpdest_by_op :
      M.IsAssociatedFunction Self "is_jumpdest_by_op" is_jumpdest_by_op.
    
    (*
        pub const fn is_jump(self) -> bool {
            self.0 == JUMP
        }
    *)
    Definition is_jump (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "revm_interpreter::opcode::OpCode", 0 |)
            |))
            (M.read (| M.get_constant (| "revm_interpreter::opcode::JUMP" |) |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_jump : M.IsAssociatedFunction Self "is_jump" is_jump.
    
    (*
        pub const fn is_jump_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_jump()
            } else {
                false
            }
        }
    *)
    Definition is_jump_by_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::opcode::OpCode",
                            "new",
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "revm_interpreter::opcode::OpCode",
                          "is_jump",
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_jump_by_op :
      M.IsAssociatedFunction Self "is_jump_by_op" is_jump_by_op.
    
    (*
        pub const fn is_push(self) -> bool {
            self.0 >= PUSH1 && self.0 <= PUSH32
        }
    *)
    Definition is_push (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          LogicalOp.and (|
            BinOp.Pure.ge
              (M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  self,
                  "revm_interpreter::opcode::OpCode",
                  0
                |)
              |))
              (M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH1" |) |)),
            ltac:(M.monadic
              (BinOp.Pure.le
                (M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "revm_interpreter::opcode::OpCode",
                    0
                  |)
                |))
                (M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH32" |) |))))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_push : M.IsAssociatedFunction Self "is_push" is_push.
    
    (*
        pub fn is_push_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_push()
            } else {
                false
            }
        }
    *)
    Definition is_push_by_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::opcode::OpCode",
                            "new",
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "revm_interpreter::opcode::OpCode",
                          "is_push",
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_push_by_op :
      M.IsAssociatedFunction Self "is_push_by_op" is_push_by_op.
    
    (*
        pub unsafe fn new_unchecked(opcode: u8) -> Self {
            Self(opcode)
        }
    *)
    Definition new_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          Value.StructTuple "revm_interpreter::opcode::OpCode" [ M.read (| opcode |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_unchecked :
      M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
    
    (*
        pub const fn as_str(self) -> &'static str {
            self.info().name()
        }
    *)
    Definition as_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "revm_interpreter::opcode::OpCodeInfo",
              "name",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::opcode::OpCode",
                    "info",
                    []
                  |),
                  [ self ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_str : M.IsAssociatedFunction Self "as_str" as_str.
    
    (*
        pub const fn name_by_op(opcode: u8) -> &'static str {
            if let Some(opcode) = Self::new(opcode) {
                opcode.as_str()
            } else {
                "Unknown"
            }
        }
    *)
    Definition name_by_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::opcode::OpCode",
                            "new",
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "revm_interpreter::opcode::OpCode",
                          "as_str",
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (Value.String "Unknown"))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name_by_op : M.IsAssociatedFunction Self "name_by_op" name_by_op.
    
    (*
        pub const fn inputs(&self) -> u8 {
            self.info().inputs()
        }
    *)
    Definition inputs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "revm_interpreter::opcode::OpCodeInfo",
              "inputs",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::opcode::OpCode",
                    "info",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_inputs : M.IsAssociatedFunction Self "inputs" inputs.
    
    (*
        pub const fn outputs(&self) -> u8 {
            self.info().outputs()
        }
    *)
    Definition outputs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "revm_interpreter::opcode::OpCodeInfo",
              "outputs",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::opcode::OpCode",
                    "info",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_outputs : M.IsAssociatedFunction Self "outputs" outputs.
    
    (*
        pub const fn io_diff(&self) -> i16 {
            self.info().io_diff()
        }
    *)
    Definition io_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "revm_interpreter::opcode::OpCodeInfo",
              "io_diff",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::opcode::OpCode",
                    "info",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_io_diff : M.IsAssociatedFunction Self "io_diff" io_diff.
    
    (*
        pub const fn info_by_op(opcode: u8) -> Option<OpCodeInfo> {
            if let Some(opcode) = Self::new(opcode) {
                Some(opcode.info())
            } else {
                None
            }
        }
    *)
    Definition info_by_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::opcode::OpCode",
                            "new",
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_interpreter::opcode::OpCode",
                              "info",
                              []
                            |),
                            [ opcode ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_info_by_op : M.IsAssociatedFunction Self "info_by_op" info_by_op.
    
    (*
        pub const fn info(&self) -> OpCodeInfo {
            if let Some(t) = OPCODE_INFO_JUMPTABLE[self.0 as usize] {
                t
            } else {
                panic!("opcode not found")
            }
        }
    *)
    Definition info (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.SubPointer.get_array_field (|
                        M.get_constant (| "revm_interpreter::opcode::OPCODE_INFO_JUMPTABLE" |),
                        M.alloc (|
                          M.rust_cast
                            (M.read (|
                              M.SubPointer.get_struct_tuple_field (|
                                M.read (| self |),
                                "revm_interpreter::opcode::OpCode",
                                0
                              |)
                            |))
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let t := M.copy (| γ0_0 |) in
                    t));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array [ M.read (| Value.String "opcode not found" |) ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_info : M.IsAssociatedFunction Self "info" info.
    
    (*
        pub const fn input_output(&self) -> (u8, u8) {
            let info = self.info();
            (info.inputs, info.outputs)
        }
    *)
    Definition input_output (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ info :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::opcode::OpCode",
                    "info",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      info,
                      "revm_interpreter::opcode::OpCodeInfo",
                      "inputs"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      info,
                      "revm_interpreter::opcode::OpCodeInfo",
                      "outputs"
                    |)
                  |)
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_input_output : M.IsAssociatedFunction Self "input_output" input_output.
    
    (*
        pub const fn get(self) -> u8 {
            self.0
        }
    *)
    Definition get (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_tuple_field (| self, "revm_interpreter::opcode::OpCode", 0 |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_STOP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 0 ] |))).
    
    Axiom AssociatedConstant_value_STOP : M.IsAssociatedConstant Self "value_STOP" value_STOP.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_ADD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 1 ] |))).
    
    Axiom AssociatedConstant_value_ADD : M.IsAssociatedConstant Self "value_ADD" value_ADD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MUL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 2 ] |))).
    
    Axiom AssociatedConstant_value_MUL : M.IsAssociatedConstant Self "value_MUL" value_MUL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SUB : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 3 ] |))).
    
    Axiom AssociatedConstant_value_SUB : M.IsAssociatedConstant Self "value_SUB" value_SUB.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DIV : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 4 ] |))).
    
    Axiom AssociatedConstant_value_DIV : M.IsAssociatedConstant Self "value_DIV" value_DIV.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SDIV : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 5 ] |))).
    
    Axiom AssociatedConstant_value_SDIV : M.IsAssociatedConstant Self "value_SDIV" value_SDIV.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 6 ] |))).
    
    Axiom AssociatedConstant_value_MOD : M.IsAssociatedConstant Self "value_MOD" value_MOD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SMOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 7 ] |))).
    
    Axiom AssociatedConstant_value_SMOD : M.IsAssociatedConstant Self "value_SMOD" value_SMOD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_ADDMOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 8 ] |))).
    
    Axiom AssociatedConstant_value_ADDMOD : M.IsAssociatedConstant Self "value_ADDMOD" value_ADDMOD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MULMOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (| Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 9 ] |))).
    
    Axiom AssociatedConstant_value_MULMOD : M.IsAssociatedConstant Self "value_MULMOD" value_MULMOD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 10 ]
          |))).
    
    Axiom AssociatedConstant_value_EXP : M.IsAssociatedConstant Self "value_EXP" value_EXP.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SIGNEXTEND : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 11 ]
          |))).
    
    Axiom AssociatedConstant_value_SIGNEXTEND :
      M.IsAssociatedConstant Self "value_SIGNEXTEND" value_SIGNEXTEND.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_LT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 16 ]
          |))).
    
    Axiom AssociatedConstant_value_LT : M.IsAssociatedConstant Self "value_LT" value_LT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_GT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 17 ]
          |))).
    
    Axiom AssociatedConstant_value_GT : M.IsAssociatedConstant Self "value_GT" value_GT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SLT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 18 ]
          |))).
    
    Axiom AssociatedConstant_value_SLT : M.IsAssociatedConstant Self "value_SLT" value_SLT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SGT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 19 ]
          |))).
    
    Axiom AssociatedConstant_value_SGT : M.IsAssociatedConstant Self "value_SGT" value_SGT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EQ : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 20 ]
          |))).
    
    Axiom AssociatedConstant_value_EQ : M.IsAssociatedConstant Self "value_EQ" value_EQ.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_ISZERO : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 21 ]
          |))).
    
    Axiom AssociatedConstant_value_ISZERO : M.IsAssociatedConstant Self "value_ISZERO" value_ISZERO.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_AND : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 22 ]
          |))).
    
    Axiom AssociatedConstant_value_AND : M.IsAssociatedConstant Self "value_AND" value_AND.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_OR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 23 ]
          |))).
    
    Axiom AssociatedConstant_value_OR : M.IsAssociatedConstant Self "value_OR" value_OR.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_XOR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 24 ]
          |))).
    
    Axiom AssociatedConstant_value_XOR : M.IsAssociatedConstant Self "value_XOR" value_XOR.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_NOT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 25 ]
          |))).
    
    Axiom AssociatedConstant_value_NOT : M.IsAssociatedConstant Self "value_NOT" value_NOT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_BYTE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 26 ]
          |))).
    
    Axiom AssociatedConstant_value_BYTE : M.IsAssociatedConstant Self "value_BYTE" value_BYTE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SHL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 27 ]
          |))).
    
    Axiom AssociatedConstant_value_SHL : M.IsAssociatedConstant Self "value_SHL" value_SHL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SHR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 28 ]
          |))).
    
    Axiom AssociatedConstant_value_SHR : M.IsAssociatedConstant Self "value_SHR" value_SHR.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SAR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 29 ]
          |))).
    
    Axiom AssociatedConstant_value_SAR : M.IsAssociatedConstant Self "value_SAR" value_SAR.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_KECCAK256 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 32 ]
          |))).
    
    Axiom AssociatedConstant_value_KECCAK256 :
      M.IsAssociatedConstant Self "value_KECCAK256" value_KECCAK256.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_ADDRESS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 48 ]
          |))).
    
    Axiom AssociatedConstant_value_ADDRESS :
      M.IsAssociatedConstant Self "value_ADDRESS" value_ADDRESS.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_BALANCE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 49 ]
          |))).
    
    Axiom AssociatedConstant_value_BALANCE :
      M.IsAssociatedConstant Self "value_BALANCE" value_BALANCE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_ORIGIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 50 ]
          |))).
    
    Axiom AssociatedConstant_value_ORIGIN : M.IsAssociatedConstant Self "value_ORIGIN" value_ORIGIN.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALLER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 51 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLER : M.IsAssociatedConstant Self "value_CALLER" value_CALLER.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALLVALUE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 52 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLVALUE :
      M.IsAssociatedConstant Self "value_CALLVALUE" value_CALLVALUE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALLDATALOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 53 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLDATALOAD :
      M.IsAssociatedConstant Self "value_CALLDATALOAD" value_CALLDATALOAD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALLDATASIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 54 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLDATASIZE :
      M.IsAssociatedConstant Self "value_CALLDATASIZE" value_CALLDATASIZE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALLDATACOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 55 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLDATACOPY :
      M.IsAssociatedConstant Self "value_CALLDATACOPY" value_CALLDATACOPY.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CODESIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 56 ]
          |))).
    
    Axiom AssociatedConstant_value_CODESIZE :
      M.IsAssociatedConstant Self "value_CODESIZE" value_CODESIZE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CODECOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 57 ]
          |))).
    
    Axiom AssociatedConstant_value_CODECOPY :
      M.IsAssociatedConstant Self "value_CODECOPY" value_CODECOPY.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_GASPRICE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 58 ]
          |))).
    
    Axiom AssociatedConstant_value_GASPRICE :
      M.IsAssociatedConstant Self "value_GASPRICE" value_GASPRICE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXTCODESIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 59 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCODESIZE :
      M.IsAssociatedConstant Self "value_EXTCODESIZE" value_EXTCODESIZE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXTCODECOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 60 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCODECOPY :
      M.IsAssociatedConstant Self "value_EXTCODECOPY" value_EXTCODECOPY.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RETURNDATASIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 61 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNDATASIZE :
      M.IsAssociatedConstant Self "value_RETURNDATASIZE" value_RETURNDATASIZE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RETURNDATACOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 62 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNDATACOPY :
      M.IsAssociatedConstant Self "value_RETURNDATACOPY" value_RETURNDATACOPY.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXTCODEHASH : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 63 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCODEHASH :
      M.IsAssociatedConstant Self "value_EXTCODEHASH" value_EXTCODEHASH.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_BLOCKHASH : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 64 ]
          |))).
    
    Axiom AssociatedConstant_value_BLOCKHASH :
      M.IsAssociatedConstant Self "value_BLOCKHASH" value_BLOCKHASH.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_COINBASE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 65 ]
          |))).
    
    Axiom AssociatedConstant_value_COINBASE :
      M.IsAssociatedConstant Self "value_COINBASE" value_COINBASE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_TIMESTAMP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 66 ]
          |))).
    
    Axiom AssociatedConstant_value_TIMESTAMP :
      M.IsAssociatedConstant Self "value_TIMESTAMP" value_TIMESTAMP.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_NUMBER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 67 ]
          |))).
    
    Axiom AssociatedConstant_value_NUMBER : M.IsAssociatedConstant Self "value_NUMBER" value_NUMBER.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DIFFICULTY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 68 ]
          |))).
    
    Axiom AssociatedConstant_value_DIFFICULTY :
      M.IsAssociatedConstant Self "value_DIFFICULTY" value_DIFFICULTY.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_GASLIMIT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 69 ]
          |))).
    
    Axiom AssociatedConstant_value_GASLIMIT :
      M.IsAssociatedConstant Self "value_GASLIMIT" value_GASLIMIT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CHAINID : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 70 ]
          |))).
    
    Axiom AssociatedConstant_value_CHAINID :
      M.IsAssociatedConstant Self "value_CHAINID" value_CHAINID.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SELFBALANCE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 71 ]
          |))).
    
    Axiom AssociatedConstant_value_SELFBALANCE :
      M.IsAssociatedConstant Self "value_SELFBALANCE" value_SELFBALANCE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_BASEFEE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 72 ]
          |))).
    
    Axiom AssociatedConstant_value_BASEFEE :
      M.IsAssociatedConstant Self "value_BASEFEE" value_BASEFEE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_BLOBHASH : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 73 ]
          |))).
    
    Axiom AssociatedConstant_value_BLOBHASH :
      M.IsAssociatedConstant Self "value_BLOBHASH" value_BLOBHASH.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_BLOBBASEFEE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 74 ]
          |))).
    
    Axiom AssociatedConstant_value_BLOBBASEFEE :
      M.IsAssociatedConstant Self "value_BLOBBASEFEE" value_BLOBBASEFEE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_POP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 80 ]
          |))).
    
    Axiom AssociatedConstant_value_POP : M.IsAssociatedConstant Self "value_POP" value_POP.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MLOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 81 ]
          |))).
    
    Axiom AssociatedConstant_value_MLOAD : M.IsAssociatedConstant Self "value_MLOAD" value_MLOAD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MSTORE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 82 ]
          |))).
    
    Axiom AssociatedConstant_value_MSTORE : M.IsAssociatedConstant Self "value_MSTORE" value_MSTORE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MSTORE8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 83 ]
          |))).
    
    Axiom AssociatedConstant_value_MSTORE8 :
      M.IsAssociatedConstant Self "value_MSTORE8" value_MSTORE8.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SLOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 84 ]
          |))).
    
    Axiom AssociatedConstant_value_SLOAD : M.IsAssociatedConstant Self "value_SLOAD" value_SLOAD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SSTORE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 85 ]
          |))).
    
    Axiom AssociatedConstant_value_SSTORE : M.IsAssociatedConstant Self "value_SSTORE" value_SSTORE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_JUMP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 86 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMP : M.IsAssociatedConstant Self "value_JUMP" value_JUMP.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_JUMPI : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 87 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMPI : M.IsAssociatedConstant Self "value_JUMPI" value_JUMPI.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PC : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 88 ]
          |))).
    
    Axiom AssociatedConstant_value_PC : M.IsAssociatedConstant Self "value_PC" value_PC.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MSIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 89 ]
          |))).
    
    Axiom AssociatedConstant_value_MSIZE : M.IsAssociatedConstant Self "value_MSIZE" value_MSIZE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_GAS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 90 ]
          |))).
    
    Axiom AssociatedConstant_value_GAS : M.IsAssociatedConstant Self "value_GAS" value_GAS.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_JUMPDEST : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 91 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMPDEST :
      M.IsAssociatedConstant Self "value_JUMPDEST" value_JUMPDEST.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_TLOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 92 ]
          |))).
    
    Axiom AssociatedConstant_value_TLOAD : M.IsAssociatedConstant Self "value_TLOAD" value_TLOAD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_TSTORE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 93 ]
          |))).
    
    Axiom AssociatedConstant_value_TSTORE : M.IsAssociatedConstant Self "value_TSTORE" value_TSTORE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_MCOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 94 ]
          |))).
    
    Axiom AssociatedConstant_value_MCOPY : M.IsAssociatedConstant Self "value_MCOPY" value_MCOPY.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH0 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 95 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH0 : M.IsAssociatedConstant Self "value_PUSH0" value_PUSH0.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 96 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH1 : M.IsAssociatedConstant Self "value_PUSH1" value_PUSH1.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 97 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH2 : M.IsAssociatedConstant Self "value_PUSH2" value_PUSH2.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 98 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH3 : M.IsAssociatedConstant Self "value_PUSH3" value_PUSH3.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 99 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH4 : M.IsAssociatedConstant Self "value_PUSH4" value_PUSH4.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH5 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 100 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH5 : M.IsAssociatedConstant Self "value_PUSH5" value_PUSH5.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH6 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 101 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH6 : M.IsAssociatedConstant Self "value_PUSH6" value_PUSH6.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH7 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 102 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH7 : M.IsAssociatedConstant Self "value_PUSH7" value_PUSH7.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 103 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH8 : M.IsAssociatedConstant Self "value_PUSH8" value_PUSH8.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH9 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 104 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH9 : M.IsAssociatedConstant Self "value_PUSH9" value_PUSH9.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH10 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 105 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH10 : M.IsAssociatedConstant Self "value_PUSH10" value_PUSH10.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH11 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 106 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH11 : M.IsAssociatedConstant Self "value_PUSH11" value_PUSH11.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH12 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 107 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH12 : M.IsAssociatedConstant Self "value_PUSH12" value_PUSH12.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH13 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 108 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH13 : M.IsAssociatedConstant Self "value_PUSH13" value_PUSH13.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH14 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 109 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH14 : M.IsAssociatedConstant Self "value_PUSH14" value_PUSH14.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH15 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 110 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH15 : M.IsAssociatedConstant Self "value_PUSH15" value_PUSH15.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH16 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 111 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH16 : M.IsAssociatedConstant Self "value_PUSH16" value_PUSH16.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH17 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 112 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH17 : M.IsAssociatedConstant Self "value_PUSH17" value_PUSH17.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH18 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 113 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH18 : M.IsAssociatedConstant Self "value_PUSH18" value_PUSH18.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH19 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 114 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH19 : M.IsAssociatedConstant Self "value_PUSH19" value_PUSH19.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH20 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 115 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH20 : M.IsAssociatedConstant Self "value_PUSH20" value_PUSH20.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH21 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 116 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH21 : M.IsAssociatedConstant Self "value_PUSH21" value_PUSH21.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH22 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 117 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH22 : M.IsAssociatedConstant Self "value_PUSH22" value_PUSH22.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH23 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 118 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH23 : M.IsAssociatedConstant Self "value_PUSH23" value_PUSH23.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH24 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 119 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH24 : M.IsAssociatedConstant Self "value_PUSH24" value_PUSH24.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH25 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 120 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH25 : M.IsAssociatedConstant Self "value_PUSH25" value_PUSH25.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH26 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 121 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH26 : M.IsAssociatedConstant Self "value_PUSH26" value_PUSH26.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH27 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 122 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH27 : M.IsAssociatedConstant Self "value_PUSH27" value_PUSH27.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH28 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 123 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH28 : M.IsAssociatedConstant Self "value_PUSH28" value_PUSH28.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH29 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 124 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH29 : M.IsAssociatedConstant Self "value_PUSH29" value_PUSH29.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH30 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 125 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH30 : M.IsAssociatedConstant Self "value_PUSH30" value_PUSH30.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH31 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 126 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH31 : M.IsAssociatedConstant Self "value_PUSH31" value_PUSH31.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_PUSH32 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 127 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH32 : M.IsAssociatedConstant Self "value_PUSH32" value_PUSH32.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 128 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP1 : M.IsAssociatedConstant Self "value_DUP1" value_DUP1.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 129 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP2 : M.IsAssociatedConstant Self "value_DUP2" value_DUP2.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 130 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP3 : M.IsAssociatedConstant Self "value_DUP3" value_DUP3.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 131 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP4 : M.IsAssociatedConstant Self "value_DUP4" value_DUP4.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP5 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 132 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP5 : M.IsAssociatedConstant Self "value_DUP5" value_DUP5.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP6 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 133 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP6 : M.IsAssociatedConstant Self "value_DUP6" value_DUP6.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP7 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 134 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP7 : M.IsAssociatedConstant Self "value_DUP7" value_DUP7.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 135 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP8 : M.IsAssociatedConstant Self "value_DUP8" value_DUP8.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP9 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 136 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP9 : M.IsAssociatedConstant Self "value_DUP9" value_DUP9.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP10 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 137 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP10 : M.IsAssociatedConstant Self "value_DUP10" value_DUP10.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP11 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 138 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP11 : M.IsAssociatedConstant Self "value_DUP11" value_DUP11.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP12 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 139 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP12 : M.IsAssociatedConstant Self "value_DUP12" value_DUP12.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP13 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 140 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP13 : M.IsAssociatedConstant Self "value_DUP13" value_DUP13.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP14 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 141 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP14 : M.IsAssociatedConstant Self "value_DUP14" value_DUP14.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP15 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 142 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP15 : M.IsAssociatedConstant Self "value_DUP15" value_DUP15.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUP16 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 143 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP16 : M.IsAssociatedConstant Self "value_DUP16" value_DUP16.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 144 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP1 : M.IsAssociatedConstant Self "value_SWAP1" value_SWAP1.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 145 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP2 : M.IsAssociatedConstant Self "value_SWAP2" value_SWAP2.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 146 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP3 : M.IsAssociatedConstant Self "value_SWAP3" value_SWAP3.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 147 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP4 : M.IsAssociatedConstant Self "value_SWAP4" value_SWAP4.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP5 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 148 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP5 : M.IsAssociatedConstant Self "value_SWAP5" value_SWAP5.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP6 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 149 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP6 : M.IsAssociatedConstant Self "value_SWAP6" value_SWAP6.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP7 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 150 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP7 : M.IsAssociatedConstant Self "value_SWAP7" value_SWAP7.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 151 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP8 : M.IsAssociatedConstant Self "value_SWAP8" value_SWAP8.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP9 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 152 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP9 : M.IsAssociatedConstant Self "value_SWAP9" value_SWAP9.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP10 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 153 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP10 : M.IsAssociatedConstant Self "value_SWAP10" value_SWAP10.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP11 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 154 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP11 : M.IsAssociatedConstant Self "value_SWAP11" value_SWAP11.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP12 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 155 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP12 : M.IsAssociatedConstant Self "value_SWAP12" value_SWAP12.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP13 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 156 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP13 : M.IsAssociatedConstant Self "value_SWAP13" value_SWAP13.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP14 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 157 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP14 : M.IsAssociatedConstant Self "value_SWAP14" value_SWAP14.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP15 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 158 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP15 : M.IsAssociatedConstant Self "value_SWAP15" value_SWAP15.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAP16 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 159 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP16 : M.IsAssociatedConstant Self "value_SWAP16" value_SWAP16.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_LOG0 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 160 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG0 : M.IsAssociatedConstant Self "value_LOG0" value_LOG0.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_LOG1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 161 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG1 : M.IsAssociatedConstant Self "value_LOG1" value_LOG1.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_LOG2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 162 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG2 : M.IsAssociatedConstant Self "value_LOG2" value_LOG2.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_LOG3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 163 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG3 : M.IsAssociatedConstant Self "value_LOG3" value_LOG3.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_LOG4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 164 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG4 : M.IsAssociatedConstant Self "value_LOG4" value_LOG4.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DATALOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 208 ]
          |))).
    
    Axiom AssociatedConstant_value_DATALOAD :
      M.IsAssociatedConstant Self "value_DATALOAD" value_DATALOAD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DATALOADN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 209 ]
          |))).
    
    Axiom AssociatedConstant_value_DATALOADN :
      M.IsAssociatedConstant Self "value_DATALOADN" value_DATALOADN.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DATASIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 210 ]
          |))).
    
    Axiom AssociatedConstant_value_DATASIZE :
      M.IsAssociatedConstant Self "value_DATASIZE" value_DATASIZE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DATACOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 211 ]
          |))).
    
    Axiom AssociatedConstant_value_DATACOPY :
      M.IsAssociatedConstant Self "value_DATACOPY" value_DATACOPY.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RJUMP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 224 ]
          |))).
    
    Axiom AssociatedConstant_value_RJUMP : M.IsAssociatedConstant Self "value_RJUMP" value_RJUMP.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RJUMPI : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 225 ]
          |))).
    
    Axiom AssociatedConstant_value_RJUMPI : M.IsAssociatedConstant Self "value_RJUMPI" value_RJUMPI.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RJUMPV : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 226 ]
          |))).
    
    Axiom AssociatedConstant_value_RJUMPV : M.IsAssociatedConstant Self "value_RJUMPV" value_RJUMPV.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALLF : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 227 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLF : M.IsAssociatedConstant Self "value_CALLF" value_CALLF.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RETF : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 228 ]
          |))).
    
    Axiom AssociatedConstant_value_RETF : M.IsAssociatedConstant Self "value_RETF" value_RETF.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_JUMPF : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 229 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMPF : M.IsAssociatedConstant Self "value_JUMPF" value_JUMPF.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DUPN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 230 ]
          |))).
    
    Axiom AssociatedConstant_value_DUPN : M.IsAssociatedConstant Self "value_DUPN" value_DUPN.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SWAPN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 231 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAPN : M.IsAssociatedConstant Self "value_SWAPN" value_SWAPN.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXCHANGE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 232 ]
          |))).
    
    Axiom AssociatedConstant_value_EXCHANGE :
      M.IsAssociatedConstant Self "value_EXCHANGE" value_EXCHANGE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EOFCREATE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 236 ]
          |))).
    
    Axiom AssociatedConstant_value_EOFCREATE :
      M.IsAssociatedConstant Self "value_EOFCREATE" value_EOFCREATE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_TXCREATE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 237 ]
          |))).
    
    Axiom AssociatedConstant_value_TXCREATE :
      M.IsAssociatedConstant Self "value_TXCREATE" value_TXCREATE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RETURNCONTRACT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 238 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNCONTRACT :
      M.IsAssociatedConstant Self "value_RETURNCONTRACT" value_RETURNCONTRACT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CREATE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 240 ]
          |))).
    
    Axiom AssociatedConstant_value_CREATE : M.IsAssociatedConstant Self "value_CREATE" value_CREATE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 241 ]
          |))).
    
    Axiom AssociatedConstant_value_CALL : M.IsAssociatedConstant Self "value_CALL" value_CALL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CALLCODE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 242 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLCODE :
      M.IsAssociatedConstant Self "value_CALLCODE" value_CALLCODE.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RETURN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 243 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURN : M.IsAssociatedConstant Self "value_RETURN" value_RETURN.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_DELEGATECALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 244 ]
          |))).
    
    Axiom AssociatedConstant_value_DELEGATECALL :
      M.IsAssociatedConstant Self "value_DELEGATECALL" value_DELEGATECALL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_CREATE2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 245 ]
          |))).
    
    Axiom AssociatedConstant_value_CREATE2 :
      M.IsAssociatedConstant Self "value_CREATE2" value_CREATE2.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_RETURNDATALOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 247 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNDATALOAD :
      M.IsAssociatedConstant Self "value_RETURNDATALOAD" value_RETURNDATALOAD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXTCALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 248 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCALL :
      M.IsAssociatedConstant Self "value_EXTCALL" value_EXTCALL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXFCALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 249 ]
          |))).
    
    Axiom AssociatedConstant_value_EXFCALL :
      M.IsAssociatedConstant Self "value_EXFCALL" value_EXFCALL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_STATICCALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 250 ]
          |))).
    
    Axiom AssociatedConstant_value_STATICCALL :
      M.IsAssociatedConstant Self "value_STATICCALL" value_STATICCALL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_EXTSCALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 251 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTSCALL :
      M.IsAssociatedConstant Self "value_EXTSCALL" value_EXTSCALL.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_REVERT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 253 ]
          |))).
    
    Axiom AssociatedConstant_value_REVERT : M.IsAssociatedConstant Self "value_REVERT" value_REVERT.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_INVALID : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 254 ]
          |))).
    
    Axiom AssociatedConstant_value_INVALID :
      M.IsAssociatedConstant Self "value_INVALID" value_INVALID.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_interpreter::opcode::OpCode" *)
    Definition value_SELFDESTRUCT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_interpreter::opcode::OpCode" [ Value.Integer 255 ]
          |))).
    
    Axiom AssociatedConstant_value_SELFDESTRUCT :
      M.IsAssociatedConstant Self "value_SELFDESTRUCT" value_SELFDESTRUCT.
  End Impl_revm_interpreter_opcode_OpCode.
  
  (* StructRecord
    {
      name := "OpCodeInfo";
      ty_params := [];
      fields :=
        [
          ("name_ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ]);
          ("name_len", Ty.path "u8");
          ("inputs", Ty.path "u8");
          ("outputs", Ty.path "u8");
          ("immediate_size", Ty.path "u8");
          ("not_eof", Ty.path "bool");
          ("terminating", Ty.path "bool")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  LogicalOp.and (|
                    LogicalOp.and (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialEq",
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                          [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ] ],
                          "eq",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "revm_interpreter::opcode::OpCodeInfo",
                            "name_ptr"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| other |),
                            "revm_interpreter::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        ]
                      |),
                      ltac:(M.monadic
                        (BinOp.Pure.eq
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm_interpreter::opcode::OpCodeInfo",
                              "name_len"
                            |)
                          |))
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| other |),
                              "revm_interpreter::opcode::OpCodeInfo",
                              "name_len"
                            |)
                          |))))
                    |),
                    ltac:(M.monadic
                      (BinOp.Pure.eq
                        (M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "revm_interpreter::opcode::OpCodeInfo",
                            "inputs"
                          |)
                        |))
                        (M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| other |),
                            "revm_interpreter::opcode::OpCodeInfo",
                            "inputs"
                          |)
                        |))))
                  |),
                  ltac:(M.monadic
                    (BinOp.Pure.eq
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm_interpreter::opcode::OpCodeInfo",
                          "outputs"
                        |)
                      |))
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| other |),
                          "revm_interpreter::opcode::OpCodeInfo",
                          "outputs"
                        |)
                      |))))
                |),
                ltac:(M.monadic
                  (BinOp.Pure.eq
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm_interpreter::opcode::OpCodeInfo",
                        "immediate_size"
                      |)
                    |))
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "revm_interpreter::opcode::OpCodeInfo",
                        "immediate_size"
                      |)
                    |))))
              |),
              ltac:(M.monadic
                (BinOp.Pure.eq
                  (M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "not_eof"
                    |)
                  |))
                  (M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "not_eof"
                    |)
                  |))))
            |),
            ltac:(M.monadic
              (BinOp.Pure.eq
                (M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_interpreter::opcode::OpCodeInfo",
                    "terminating"
                  |)
                |))
                (M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "revm_interpreter::opcode::OpCodeInfo",
                    "terminating"
                  |)
                |))))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_marker_StructuralEq_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_PartialOrd_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                    [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ] ],
                    "partial_cmp",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "name_ptr"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "name_ptr"
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "u8",
                            [ Ty.path "u8" ],
                            "partial_cmp",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm_interpreter::opcode::OpCodeInfo",
                              "name_len"
                            |);
                            M.SubPointer.get_struct_record_field (|
                              M.read (| other |),
                              "revm_interpreter::opcode::OpCodeInfo",
                              "name_len"
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "u8",
                                    [ Ty.path "u8" ],
                                    "partial_cmp",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "revm_interpreter::opcode::OpCodeInfo",
                                      "inputs"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| other |),
                                      "revm_interpreter::opcode::OpCodeInfo",
                                      "inputs"
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::cmp::PartialOrd",
                                            Ty.path "u8",
                                            [ Ty.path "u8" ],
                                            "partial_cmp",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "revm_interpreter::opcode::OpCodeInfo",
                                              "outputs"
                                            |);
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| other |),
                                              "revm_interpreter::opcode::OpCodeInfo",
                                              "outputs"
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let _ :=
                                              M.is_struct_tuple (|
                                                γ0_0,
                                                "core::cmp::Ordering::Equal"
                                              |) in
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialOrd",
                                                    Ty.path "u8",
                                                    [ Ty.path "u8" ],
                                                    "partial_cmp",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "revm_interpreter::opcode::OpCodeInfo",
                                                      "immediate_size"
                                                    |);
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| other |),
                                                      "revm_interpreter::opcode::OpCodeInfo",
                                                      "immediate_size"
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let _ :=
                                                      M.is_struct_tuple (|
                                                        γ0_0,
                                                        "core::cmp::Ordering::Equal"
                                                      |) in
                                                    M.match_operator (|
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::cmp::PartialOrd",
                                                            Ty.path "bool",
                                                            [ Ty.path "bool" ],
                                                            "partial_cmp",
                                                            []
                                                          |),
                                                          [
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.read (| self |),
                                                              "revm_interpreter::opcode::OpCodeInfo",
                                                              "not_eof"
                                                            |);
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.read (| other |),
                                                              "revm_interpreter::opcode::OpCodeInfo",
                                                              "not_eof"
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::option::Option::Some",
                                                                0
                                                              |) in
                                                            let _ :=
                                                              M.is_struct_tuple (|
                                                                γ0_0,
                                                                "core::cmp::Ordering::Equal"
                                                              |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::cmp::PartialOrd",
                                                                  Ty.path "bool",
                                                                  [ Ty.path "bool" ],
                                                                  "partial_cmp",
                                                                  []
                                                                |),
                                                                [
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| self |),
                                                                    "revm_interpreter::opcode::OpCodeInfo",
                                                                    "terminating"
                                                                  |);
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| other |),
                                                                    "revm_interpreter::opcode::OpCodeInfo",
                                                                    "terminating"
                                                                  |)
                                                                ]
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let cmp := M.copy (| γ |) in
                                                            cmp))
                                                      ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let cmp := M.copy (| γ |) in
                                                    cmp))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_Ord_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                    [],
                    "cmp",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "name_ptr"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "name_ptr"
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], "cmp", [] |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm_interpreter::opcode::OpCodeInfo",
                              "name_len"
                            |);
                            M.SubPointer.get_struct_record_field (|
                              M.read (| other |),
                              "revm_interpreter::opcode::OpCodeInfo",
                              "name_len"
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "u8",
                                    [],
                                    "cmp",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "revm_interpreter::opcode::OpCodeInfo",
                                      "inputs"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| other |),
                                      "revm_interpreter::opcode::OpCodeInfo",
                                      "inputs"
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::cmp::Ord",
                                            Ty.path "u8",
                                            [],
                                            "cmp",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "revm_interpreter::opcode::OpCodeInfo",
                                              "outputs"
                                            |);
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| other |),
                                              "revm_interpreter::opcode::OpCodeInfo",
                                              "outputs"
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::cmp::Ordering::Equal"
                                              |) in
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::Ord",
                                                    Ty.path "u8",
                                                    [],
                                                    "cmp",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "revm_interpreter::opcode::OpCodeInfo",
                                                      "immediate_size"
                                                    |);
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| other |),
                                                      "revm_interpreter::opcode::OpCodeInfo",
                                                      "immediate_size"
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let _ :=
                                                      M.is_struct_tuple (|
                                                        γ,
                                                        "core::cmp::Ordering::Equal"
                                                      |) in
                                                    M.match_operator (|
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::cmp::Ord",
                                                            Ty.path "bool",
                                                            [],
                                                            "cmp",
                                                            []
                                                          |),
                                                          [
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.read (| self |),
                                                              "revm_interpreter::opcode::OpCodeInfo",
                                                              "not_eof"
                                                            |);
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.read (| other |),
                                                              "revm_interpreter::opcode::OpCodeInfo",
                                                              "not_eof"
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let _ :=
                                                              M.is_struct_tuple (|
                                                                γ,
                                                                "core::cmp::Ordering::Equal"
                                                              |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::cmp::Ord",
                                                                  Ty.path "bool",
                                                                  [],
                                                                  "cmp",
                                                                  []
                                                                |),
                                                                [
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| self |),
                                                                    "revm_interpreter::opcode::OpCodeInfo",
                                                                    "terminating"
                                                                  |);
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| other |),
                                                                    "revm_interpreter::opcode::OpCodeInfo",
                                                                    "terminating"
                                                                  |)
                                                                ]
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let cmp := M.copy (| γ |) in
                                                            cmp))
                                                      ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let cmp := M.copy (| γ |) in
                                                    cmp))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "name_ptr"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "name_len"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "inputs"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "outputs"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "immediate_size"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "bool", [], "hash", [ __H ] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_interpreter::opcode::OpCodeInfo",
                      "not_eof"
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "bool", [], "hash", [ __H ] |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_interpreter::opcode::OpCodeInfo",
                    "terminating"
                  |);
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("OpCodeInfo")
                .field("name", &self.name())
                .field("inputs", &self.inputs())
                .field("outputs", &self.outputs())
                .field("not_eof", &self.is_disabled_in_eof())
                .field("terminating", &self.is_terminating())
                .field("immediate_size", &self.immediate_size())
                .finish()
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugStruct",
              "finish",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugStruct",
                  "field",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      "field",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "field",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "debug_struct",
                                            []
                                          |),
                                          [ M.read (| f |); M.read (| Value.String "OpCodeInfo" |) ]
                                        |)
                                      |);
                                      M.read (| Value.String "name" |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "revm_interpreter::opcode::OpCodeInfo",
                                              "name",
                                              []
                                            |),
                                            [ M.read (| self |) ]
                                          |)
                                        |))
                                    ]
                                  |);
                                  M.read (| Value.String "inputs" |);
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "revm_interpreter::opcode::OpCodeInfo",
                                          "inputs",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |)
                                    |))
                                ]
                              |);
                              M.read (| Value.String "outputs" |);
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_interpreter::opcode::OpCodeInfo",
                                      "outputs",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |))
                            ]
                          |);
                          M.read (| Value.String "not_eof" |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "revm_interpreter::opcode::OpCodeInfo",
                                  "is_disabled_in_eof",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |))
                        ]
                      |);
                      M.read (| Value.String "terminating" |);
                      (* Unsize *)
                      M.pointer_coercion
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_interpreter::opcode::OpCodeInfo",
                              "is_terminating",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        |))
                    ]
                  |);
                  M.read (| Value.String "immediate_size" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "revm_interpreter::opcode::OpCodeInfo",
                          "immediate_size",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_opcode_OpCodeInfo.
  
  Module Impl_revm_interpreter_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_interpreter::opcode::OpCodeInfo".
    
    (*
        pub const fn new(name: &'static str) -> Self {
            assert!(name.len() < 256, "opcode name is too long");
            Self {
                name_ptr: unsafe { NonNull::new_unchecked(name.as_ptr().cast_mut()) },
                name_len: name.len() as u8,
                inputs: 0,
                outputs: 0,
                not_eof: false,
                terminating: false,
                immediate_size: 0,
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ name ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (BinOp.Pure.lt
                                (M.call_closure (|
                                  M.get_associated_function (| Ty.path "str", "len", [] |),
                                  [ M.read (| name |) ]
                                |))
                                (Value.Integer 256))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [ M.read (| Value.String "opcode name is too long" |) ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "revm_interpreter::opcode::OpCodeInfo"
                [
                  ("name_ptr",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                        "new_unchecked",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                            "cast_mut",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "str", "as_ptr", [] |),
                              [ M.read (| name |) ]
                            |)
                          ]
                        |)
                      ]
                    |));
                  ("name_len",
                    M.rust_cast
                      (M.call_closure (|
                        M.get_associated_function (| Ty.path "str", "len", [] |),
                        [ M.read (| name |) ]
                      |)));
                  ("inputs", Value.Integer 0);
                  ("outputs", Value.Integer 0);
                  ("not_eof", Value.Bool false);
                  ("terminating", Value.Bool false);
                  ("immediate_size", Value.Integer 0)
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub const fn name(&self) -> &'static str {
            // SAFETY: `self.name_*` can only be initialized with a valid `&'static str`.
            unsafe {
                // TODO: Use `str::from_raw_parts` when it's stable.
                let slice = core::slice::from_raw_parts(self.name_ptr.as_ptr(), self.name_len as usize);
                core::str::from_utf8_unchecked(slice)
            }
        }
    *)
    Definition name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ slice :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                  [
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                          "as_ptr",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm_interpreter::opcode::OpCodeInfo",
                              "name_ptr"
                            |)
                          |)
                        ]
                      |));
                    M.rust_cast
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm_interpreter::opcode::OpCodeInfo",
                          "name_len"
                        |)
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_function (| "core::str::converts::from_utf8_unchecked", [] |),
                [ M.read (| slice |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
    
    (*
        pub const fn io_diff(&self) -> i16 {
            self.outputs as i16 - self.inputs as i16
        }
    *)
    Definition io_diff (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.sub
            Integer.I16
            (M.rust_cast
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::opcode::OpCodeInfo",
                  "outputs"
                |)
              |)))
            (M.rust_cast
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_interpreter::opcode::OpCodeInfo",
                  "inputs"
                |)
              |)))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_io_diff : M.IsAssociatedFunction Self "io_diff" io_diff.
    
    (*
        pub const fn inputs(&self) -> u8 {
            self.inputs
        }
    *)
    Definition inputs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::opcode::OpCodeInfo",
              "inputs"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_inputs : M.IsAssociatedFunction Self "inputs" inputs.
    
    (*
        pub const fn outputs(&self) -> u8 {
            self.outputs
        }
    *)
    Definition outputs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::opcode::OpCodeInfo",
              "outputs"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_outputs : M.IsAssociatedFunction Self "outputs" outputs.
    
    (*
        pub const fn is_disabled_in_eof(&self) -> bool {
            self.not_eof
        }
    *)
    Definition is_disabled_in_eof (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::opcode::OpCodeInfo",
              "not_eof"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_disabled_in_eof :
      M.IsAssociatedFunction Self "is_disabled_in_eof" is_disabled_in_eof.
    
    (*
        pub const fn is_terminating(&self) -> bool {
            self.terminating
        }
    *)
    Definition is_terminating (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::opcode::OpCodeInfo",
              "terminating"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_terminating :
      M.IsAssociatedFunction Self "is_terminating" is_terminating.
    
    (*
        pub const fn immediate_size(&self) -> u8 {
            self.immediate_size
        }
    *)
    Definition immediate_size (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_interpreter::opcode::OpCodeInfo",
              "immediate_size"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_immediate_size :
      M.IsAssociatedFunction Self "immediate_size" immediate_size.
  End Impl_revm_interpreter_opcode_OpCodeInfo.
  
  (*
  pub const fn not_eof(mut op: OpCodeInfo) -> OpCodeInfo {
      op.not_eof = true;
      op
  }
  *)
  Definition not_eof (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ op ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        M.read (|
          let~ _ :=
            M.write (|
              M.SubPointer.get_struct_record_field (|
                op,
                "revm_interpreter::opcode::OpCodeInfo",
                "not_eof"
              |),
              Value.Bool true
            |) in
          op
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_not_eof : M.IsFunction "revm_interpreter::opcode::not_eof" not_eof.
  
  (*
  pub const fn immediate_size(mut op: OpCodeInfo, n: u8) -> OpCodeInfo {
      op.immediate_size = n;
      op
  }
  *)
  Definition immediate_size (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ op; n ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        let n := M.alloc (| n |) in
        M.read (|
          let~ _ :=
            M.write (|
              M.SubPointer.get_struct_record_field (|
                op,
                "revm_interpreter::opcode::OpCodeInfo",
                "immediate_size"
              |),
              M.read (| n |)
            |) in
          op
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_immediate_size :
    M.IsFunction "revm_interpreter::opcode::immediate_size" immediate_size.
  
  (*
  pub const fn terminating(mut op: OpCodeInfo) -> OpCodeInfo {
      op.terminating = true;
      op
  }
  *)
  Definition terminating (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ op ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        M.read (|
          let~ _ :=
            M.write (|
              M.SubPointer.get_struct_record_field (|
                op,
                "revm_interpreter::opcode::OpCodeInfo",
                "terminating"
              |),
              Value.Bool true
            |) in
          op
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_terminating : M.IsFunction "revm_interpreter::opcode::terminating" terminating.
  
  (*
  pub const fn stack_io(mut op: OpCodeInfo, inputs: u8, outputs: u8) -> OpCodeInfo {
      op.inputs = inputs;
      op.outputs = outputs;
      op
  }
  *)
  Definition stack_io (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ op; inputs; outputs ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        let inputs := M.alloc (| inputs |) in
        let outputs := M.alloc (| outputs |) in
        M.read (|
          let~ _ :=
            M.write (|
              M.SubPointer.get_struct_record_field (|
                op,
                "revm_interpreter::opcode::OpCodeInfo",
                "inputs"
              |),
              M.read (| inputs |)
            |) in
          let~ _ :=
            M.write (|
              M.SubPointer.get_struct_record_field (|
                op,
                "revm_interpreter::opcode::OpCodeInfo",
                "outputs"
              |),
              M.read (| outputs |)
            |) in
          op
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_stack_io : M.IsFunction "revm_interpreter::opcode::stack_io" stack_io.
  
  Definition value_NOP : Value.t :=
    M.run ltac:(M.monadic (M.get_constant (| "revm_interpreter::opcode::JUMPDEST" |))).
  
  Definition value_STOP : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 0 |))).
  
  Definition value_ADD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 1 |))).
  
  Definition value_MUL : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 2 |))).
  
  Definition value_SUB : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 3 |))).
  
  Definition value_DIV : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 4 |))).
  
  Definition value_SDIV : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 5 |))).
  
  Definition value_MOD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 6 |))).
  
  Definition value_SMOD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 7 |))).
  
  Definition value_ADDMOD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 8 |))).
  
  Definition value_MULMOD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 9 |))).
  
  Definition value_EXP : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 10 |))).
  
  Definition value_SIGNEXTEND : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 11 |))).
  
  Definition value_LT : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 16 |))).
  
  Definition value_GT : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 17 |))).
  
  Definition value_SLT : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 18 |))).
  
  Definition value_SGT : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 19 |))).
  
  Definition value_EQ : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 20 |))).
  
  Definition value_ISZERO : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 21 |))).
  
  Definition value_AND : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 22 |))).
  
  Definition value_OR : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 23 |))).
  
  Definition value_XOR : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 24 |))).
  
  Definition value_NOT : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 25 |))).
  
  Definition value_BYTE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 26 |))).
  
  Definition value_SHL : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 27 |))).
  
  Definition value_SHR : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 28 |))).
  
  Definition value_SAR : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 29 |))).
  
  Definition value_KECCAK256 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 32 |))).
  
  Definition value_ADDRESS : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 48 |))).
  
  Definition value_BALANCE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 49 |))).
  
  Definition value_ORIGIN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 50 |))).
  
  Definition value_CALLER : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 51 |))).
  
  Definition value_CALLVALUE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 52 |))).
  
  Definition value_CALLDATALOAD : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 53 |))).
  
  Definition value_CALLDATASIZE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 54 |))).
  
  Definition value_CALLDATACOPY : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 55 |))).
  
  Definition value_CODESIZE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 56 |))).
  
  Definition value_CODECOPY : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 57 |))).
  
  Definition value_GASPRICE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 58 |))).
  
  Definition value_EXTCODESIZE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 59 |))).
  
  Definition value_EXTCODECOPY : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 60 |))).
  
  Definition value_RETURNDATASIZE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 61 |))).
  
  Definition value_RETURNDATACOPY : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 62 |))).
  
  Definition value_EXTCODEHASH : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 63 |))).
  
  Definition value_BLOCKHASH : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 64 |))).
  
  Definition value_COINBASE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 65 |))).
  
  Definition value_TIMESTAMP : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 66 |))).
  
  Definition value_NUMBER : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 67 |))).
  
  Definition value_DIFFICULTY : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 68 |))).
  
  Definition value_GASLIMIT : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 69 |))).
  
  Definition value_CHAINID : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 70 |))).
  
  Definition value_SELFBALANCE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 71 |))).
  
  Definition value_BASEFEE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 72 |))).
  
  Definition value_BLOBHASH : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 73 |))).
  
  Definition value_BLOBBASEFEE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 74 |))).
  
  Definition value_POP : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 80 |))).
  
  Definition value_MLOAD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 81 |))).
  
  Definition value_MSTORE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 82 |))).
  
  Definition value_MSTORE8 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 83 |))).
  
  Definition value_SLOAD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 84 |))).
  
  Definition value_SSTORE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 85 |))).
  
  Definition value_JUMP : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 86 |))).
  
  Definition value_JUMPI : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 87 |))).
  
  Definition value_PC : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 88 |))).
  
  Definition value_MSIZE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 89 |))).
  
  Definition value_GAS : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 90 |))).
  
  Definition value_JUMPDEST : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 91 |))).
  
  Definition value_TLOAD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 92 |))).
  
  Definition value_TSTORE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 93 |))).
  
  Definition value_MCOPY : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 94 |))).
  
  Definition value_PUSH0 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 95 |))).
  
  Definition value_PUSH1 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 96 |))).
  
  Definition value_PUSH2 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 97 |))).
  
  Definition value_PUSH3 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 98 |))).
  
  Definition value_PUSH4 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 99 |))).
  
  Definition value_PUSH5 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 100 |))).
  
  Definition value_PUSH6 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 101 |))).
  
  Definition value_PUSH7 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 102 |))).
  
  Definition value_PUSH8 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 103 |))).
  
  Definition value_PUSH9 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 104 |))).
  
  Definition value_PUSH10 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 105 |))).
  
  Definition value_PUSH11 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 106 |))).
  
  Definition value_PUSH12 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 107 |))).
  
  Definition value_PUSH13 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 108 |))).
  
  Definition value_PUSH14 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 109 |))).
  
  Definition value_PUSH15 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 110 |))).
  
  Definition value_PUSH16 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 111 |))).
  
  Definition value_PUSH17 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 112 |))).
  
  Definition value_PUSH18 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 113 |))).
  
  Definition value_PUSH19 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 114 |))).
  
  Definition value_PUSH20 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 115 |))).
  
  Definition value_PUSH21 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 116 |))).
  
  Definition value_PUSH22 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 117 |))).
  
  Definition value_PUSH23 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 118 |))).
  
  Definition value_PUSH24 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 119 |))).
  
  Definition value_PUSH25 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 120 |))).
  
  Definition value_PUSH26 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 121 |))).
  
  Definition value_PUSH27 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 122 |))).
  
  Definition value_PUSH28 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 123 |))).
  
  Definition value_PUSH29 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 124 |))).
  
  Definition value_PUSH30 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 125 |))).
  
  Definition value_PUSH31 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 126 |))).
  
  Definition value_PUSH32 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 127 |))).
  
  Definition value_DUP1 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 128 |))).
  
  Definition value_DUP2 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 129 |))).
  
  Definition value_DUP3 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 130 |))).
  
  Definition value_DUP4 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 131 |))).
  
  Definition value_DUP5 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 132 |))).
  
  Definition value_DUP6 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 133 |))).
  
  Definition value_DUP7 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 134 |))).
  
  Definition value_DUP8 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 135 |))).
  
  Definition value_DUP9 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 136 |))).
  
  Definition value_DUP10 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 137 |))).
  
  Definition value_DUP11 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 138 |))).
  
  Definition value_DUP12 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 139 |))).
  
  Definition value_DUP13 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 140 |))).
  
  Definition value_DUP14 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 141 |))).
  
  Definition value_DUP15 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 142 |))).
  
  Definition value_DUP16 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 143 |))).
  
  Definition value_SWAP1 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 144 |))).
  
  Definition value_SWAP2 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 145 |))).
  
  Definition value_SWAP3 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 146 |))).
  
  Definition value_SWAP4 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 147 |))).
  
  Definition value_SWAP5 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 148 |))).
  
  Definition value_SWAP6 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 149 |))).
  
  Definition value_SWAP7 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 150 |))).
  
  Definition value_SWAP8 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 151 |))).
  
  Definition value_SWAP9 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 152 |))).
  
  Definition value_SWAP10 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 153 |))).
  
  Definition value_SWAP11 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 154 |))).
  
  Definition value_SWAP12 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 155 |))).
  
  Definition value_SWAP13 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 156 |))).
  
  Definition value_SWAP14 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 157 |))).
  
  Definition value_SWAP15 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 158 |))).
  
  Definition value_SWAP16 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 159 |))).
  
  Definition value_LOG0 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 160 |))).
  
  Definition value_LOG1 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 161 |))).
  
  Definition value_LOG2 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 162 |))).
  
  Definition value_LOG3 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 163 |))).
  
  Definition value_LOG4 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 164 |))).
  
  Definition value_DATALOAD : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 208 |))).
  
  Definition value_DATALOADN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 209 |))).
  
  Definition value_DATASIZE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 210 |))).
  
  Definition value_DATACOPY : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 211 |))).
  
  Definition value_RJUMP : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 224 |))).
  
  Definition value_RJUMPI : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 225 |))).
  
  Definition value_RJUMPV : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 226 |))).
  
  Definition value_CALLF : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 227 |))).
  
  Definition value_RETF : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 228 |))).
  
  Definition value_JUMPF : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 229 |))).
  
  Definition value_DUPN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 230 |))).
  
  Definition value_SWAPN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 231 |))).
  
  Definition value_EXCHANGE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 232 |))).
  
  Definition value_EOFCREATE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 236 |))).
  
  Definition value_TXCREATE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 237 |))).
  
  Definition value_RETURNCONTRACT : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 238 |))).
  
  Definition value_CREATE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 240 |))).
  
  Definition value_CALL : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 241 |))).
  
  Definition value_CALLCODE : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 242 |))).
  
  Definition value_RETURN : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 243 |))).
  
  Definition value_DELEGATECALL : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 244 |))).
  
  Definition value_CREATE2 : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 245 |))).
  
  Definition value_RETURNDATALOAD : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 247 |))).
  
  Definition value_EXTCALL : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 248 |))).
  
  Definition value_EXFCALL : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 249 |))).
  
  Definition value_STATICCALL : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 250 |))).
  
  Definition value_EXTSCALL : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 251 |))).
  
  Definition value_REVERT : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 253 |))).
  
  Definition value_INVALID : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 254 |))).
  
  Definition value_SELFDESTRUCT : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer 255 |))).
  
  
  Definition value_OPCODE_INFO_JUMPTABLE : Value.t :=
    M.run
      ltac:(M.monadic
        (let~ map := M.alloc (| repeat (Value.StructTuple "core::option::Option::None" []) 256 |) in
        let~ prev := M.alloc (| Value.Integer 0 |) in
        let~ val := M.alloc (| Value.Integer 0 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "STOP" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 0 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 1 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "ADD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 1 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 2 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MUL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 2 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 3 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SUB" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 3 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 4 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DIV" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 4 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 5 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SDIV" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 5 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 6 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MOD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 6 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 7 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SMOD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 7 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 8 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "ADDMOD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 8 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 9 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MULMOD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 9 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 10 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXP" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 10 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 11 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SIGNEXTEND" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 11 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 16 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "LT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 16 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 17 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "GT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 17 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 18 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SLT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 18 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 19 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SGT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 19 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 20 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EQ" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 20 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 21 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "ISZERO" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 21 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 22 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "AND" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 22 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 23 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "OR" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 23 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 24 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "XOR" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 24 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 25 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "NOT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 25 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 26 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "BYTE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 26 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 27 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SHL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 27 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 28 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SHR" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 28 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 29 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SAR" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 29 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 32 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "KECCAK256" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 32 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 48 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "ADDRESS" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 48 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 49 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "BALANCE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 49 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 50 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "ORIGIN" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 50 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 51 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALLER" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 51 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 52 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALLVALUE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 52 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 53 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALLDATALOAD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 53 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 54 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALLDATASIZE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 54 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 55 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALLDATACOPY" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 55 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 56 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CODESIZE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 56 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 57 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CODECOPY" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 57 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 58 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "GASPRICE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 58 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 59 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXTCODESIZE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 59 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 60 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXTCODECOPY" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 4; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 60 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 61 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RETURNDATASIZE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 61 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 62 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RETURNDATACOPY" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 62 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 63 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXTCODEHASH" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 63 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 64 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "BLOCKHASH" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 64 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 65 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "COINBASE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 65 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 66 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "TIMESTAMP" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 66 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 67 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "NUMBER" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 67 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 68 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DIFFICULTY" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 68 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 69 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "GASLIMIT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 69 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 70 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CHAINID" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 70 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 71 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SELFBALANCE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 71 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 72 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "BASEFEE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 72 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 73 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "BLOBHASH" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 73 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 74 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "BLOBBASEFEE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 74 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 80 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "POP" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 80 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 81 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MLOAD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 81 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 82 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MSTORE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 82 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 83 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MSTORE8" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 83 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 84 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SLOAD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 84 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 85 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SSTORE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 85 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 86 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "JUMP" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 86 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 87 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "JUMPI" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 87 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 88 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PC" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 88 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 89 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MSIZE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 89 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 90 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "GAS" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 90 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 91 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "JUMPDEST" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 91 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 92 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "TLOAD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 92 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 93 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "TSTORE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 93 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 94 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "MCOPY" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 94 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 95 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH0" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 95 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 96 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH1" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 96 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 97 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH2" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 2 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 97 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 98 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH3" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 3 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 98 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 99 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH4" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 4 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 99 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 100 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH5" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 5 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 100 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 101 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH6" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 6 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 101 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 102 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH7" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 7 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 102 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 103 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH8" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 8 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 103 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 104 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH9" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 9 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 104 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 105 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH10" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 10 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 105 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 106 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH11" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 11 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 106 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 107 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH12" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 12 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 107 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 108 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH13" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 13 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 108 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 109 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH14" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 14 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 109 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 110 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH15" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 15 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 110 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 111 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH16" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 16 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 111 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 112 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH17" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 17 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 112 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 113 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH18" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 18 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 113 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 114 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH19" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 19 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 114 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 115 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH20" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 20 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 115 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 116 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH21" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 21 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 116 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 117 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH22" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 22 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 117 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 118 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH23" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 23 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 118 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 119 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH24" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 24 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 119 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 120 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH25" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 25 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 120 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 121 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH26" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 26 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 121 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 122 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH27" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 27 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 122 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 123 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH28" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 28 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 123 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 124 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH29" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 29 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 124 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 125 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH30" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 30 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 125 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 126 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH31" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 31 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 126 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 127 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "PUSH32" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 32 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 127 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 128 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP1" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 2 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 128 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 129 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP2" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 3 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 129 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 130 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP3" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 4 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 130 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 131 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP4" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 4; Value.Integer 5 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 131 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 132 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP5" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 5; Value.Integer 6 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 132 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 133 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP6" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 6; Value.Integer 7 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 133 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 134 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP7" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 7; Value.Integer 8 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 134 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 135 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP8" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 8; Value.Integer 9 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 135 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 136 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP9" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 9; Value.Integer 10 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 136 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 137 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP10" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 10; Value.Integer 11 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 137 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 138 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP11" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 11; Value.Integer 12 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 138 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 139 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP12" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 12; Value.Integer 13 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 139 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 140 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP13" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 13; Value.Integer 14 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 140 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 141 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP14" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 14; Value.Integer 15 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 141 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 142 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP15" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 15; Value.Integer 16 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 142 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 143 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUP16" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 16; Value.Integer 17 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 143 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 144 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP1" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 2 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 144 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 145 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP2" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 3 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 145 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 146 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP3" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 4; Value.Integer 4 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 146 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 147 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP4" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 5; Value.Integer 5 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 147 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 148 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP5" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 6; Value.Integer 6 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 148 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 149 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP6" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 7; Value.Integer 7 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 149 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 150 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP7" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 8; Value.Integer 8 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 150 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 151 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP8" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 9; Value.Integer 9 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 151 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 152 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP9" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 10; Value.Integer 10 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 152 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 153 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP10" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 11; Value.Integer 11 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 153 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 154 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP11" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 12; Value.Integer 12 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 154 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 155 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP12" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 13; Value.Integer 13 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 155 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 156 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP13" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 14; Value.Integer 14 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 156 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 157 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP14" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 15; Value.Integer 15 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 157 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 158 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP15" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 16; Value.Integer 16 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 158 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 159 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAP16" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 17; Value.Integer 17 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 159 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 160 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "LOG0" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 160 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 161 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "LOG1" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 161 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 162 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "LOG2" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 4; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 162 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 163 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "LOG3" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 5; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 163 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 164 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "LOG4" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 6; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 164 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 208 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DATALOAD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 208 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 209 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DATALOADN" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 2 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 209 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 210 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DATASIZE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 210 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 211 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DATACOPY" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 0 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 211 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 224 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RJUMP" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 2 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 224 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 225 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RJUMPI" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 2 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 225 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 226 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RJUMPV" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 226 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 227 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALLF" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 2 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 227 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 228 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RETF" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 228 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 229 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "JUMPF" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 2 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 229 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 230 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DUPN" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 230 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 231 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SWAPN" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 231 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 232 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXCHANGE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 232 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 236 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EOFCREATE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 4; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 236 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 237 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "TXCREATE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 5; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 237 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 238 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RETURNCONTRACT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::immediate_size", [] |),
              [ M.read (| info |); Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 238 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 240 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CREATE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 240 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 241 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 7; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 241 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 242 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CALLCODE" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 7; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 242 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 243 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RETURN" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 243 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 244 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "DELEGATECALL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 6; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 244 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 245 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "CREATE2" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 4; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 245 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 247 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "RETURNDATALOAD" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 247 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 248 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXTCALL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 4; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 248 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 249 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXFCALL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 249 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 250 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "STATICCALL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 6; Value.Integer 1 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 250 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 251 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "EXTSCALL" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 3; Value.Integer 1 ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 251 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 253 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "REVERT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 2; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 253 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 254 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "INVALID" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 0; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 254 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        let~ val := M.alloc (| Value.Integer 255 |) in
        let~ _ :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.Pure.not
                          (LogicalOp.or (|
                            BinOp.Pure.eq (M.read (| val |)) (Value.Integer 0),
                            ltac:(M.monadic (BinOp.Pure.gt (M.read (| val |)) (M.read (| prev |))))
                          |))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "core::panicking::panic_fmt", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "opcodes must be sorted in ascending order"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ := M.write (| prev, M.read (| val |) |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "revm_interpreter::opcode::OpCodeInfo",
                "new",
                []
              |),
              [ M.read (| Value.String "SELFDESTRUCT" |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::stack_io", [] |),
              [ M.read (| info |); Value.Integer 1; Value.Integer 0 ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::not_eof", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ info :=
          M.alloc (|
            M.call_closure (|
              M.get_function (| "revm_interpreter::opcode::terminating", [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ :=
          M.write (|
            M.SubPointer.get_array_field (| map, M.alloc (| Value.Integer 255 |) |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |) in
        M.match_operator (| prev, [ fun γ => ltac:(M.monadic map) ] |))).
  
  Definition value_NAME_TO_OPCODE : Value.t :=
    M.run
      ltac:(M.monadic
        (M.alloc (|
          M.alloc (|
            Value.StructRecord
              "phf::map::Map"
              [
                ("key", Value.Integer 12913932095322966823);
                ("disps",
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          Value.Tuple [ Value.Integer 0; Value.Integer 27 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 3 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 155 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 0 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 153 ];
                          Value.Tuple [ Value.Integer 26; Value.Integer 134 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 135 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 123 ];
                          Value.Tuple [ Value.Integer 2; Value.Integer 3 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 70 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 0 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 100 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 4 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 111 ];
                          Value.Tuple [ Value.Integer 2; Value.Integer 33 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 0 ];
                          Value.Tuple [ Value.Integer 1; Value.Integer 154 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 8 ];
                          Value.Tuple [ Value.Integer 1; Value.Integer 49 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 1 ];
                          Value.Tuple [ Value.Integer 7; Value.Integer 29 ];
                          Value.Tuple [ Value.Integer 39; Value.Integer 151 ];
                          Value.Tuple [ Value.Integer 2; Value.Integer 77 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 55 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 17 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 75 ];
                          Value.Tuple [ Value.Integer 15; Value.Integer 42 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 2 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 3 ];
                          Value.Tuple [ Value.Integer 2; Value.Integer 32 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 5 ];
                          Value.Tuple [ Value.Integer 1; Value.Integer 18 ];
                          Value.Tuple [ Value.Integer 0; Value.Integer 2 ];
                          Value.Tuple [ Value.Integer 69; Value.Integer 21 ]
                        ]
                    |)));
                ("entries",
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          Value.Tuple
                            [
                              M.read (| Value.String "RETURN" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::RETURN" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH15" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH15" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP6" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP6" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH27" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH27" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "JUMPDEST" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::JUMPDEST" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "TIMESTAMP" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::TIMESTAMP" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH7" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH7" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SELFDESTRUCT" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::SELFDESTRUCT" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "ISZERO" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::ISZERO" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SLOAD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SLOAD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP1" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP1" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH20" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH20" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RETURNDATACOPY" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::RETURNDATACOPY" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXTSCALL" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::EXTSCALL" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "JUMPI" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::JUMPI" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DATASIZE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DATASIZE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP15" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP15" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP10" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP10" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP1" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP1" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH30" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH30" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CREATE2" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CREATE2" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "LOG3" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::LOG3" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALL" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CALL" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP9" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP9" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "BLOCKHASH" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::BLOCKHASH" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "BLOBHASH" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::BLOBHASH" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "LOG1" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::LOG1" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP2" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP2" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EQ" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::EQ" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MCOPY" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MCOPY" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RJUMP" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::RJUMP" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "GAS" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::GAS" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "LOG0" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::LOG0" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXTCODEHASH" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::EXTCODEHASH" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH12" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH12" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALLDATACOPY" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::CALLDATACOPY" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RETURNDATALOAD" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::RETURNDATALOAD" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH17" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH17" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "BASEFEE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::BASEFEE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MLOAD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MLOAD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "TXCREATE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::TXCREATE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP15" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP15" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SMOD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SMOD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EOFCREATE" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::EOFCREATE" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP10" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP10" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "ADDMOD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::ADDMOD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RJUMPI" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::RJUMPI" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "GASPRICE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::GASPRICE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH23" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH23" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP12" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP12" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP7" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP7" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXTCALL" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::EXTCALL" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "LT" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::LT" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH3" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH3" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SDIV" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SDIV" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXTCODESIZE" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::EXTCODESIZE" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP4" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP4" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALLDATALOAD" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::CALLDATALOAD" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH13" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH13" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "JUMP" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::JUMP" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP6" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP6" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MOD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MOD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "INVALID" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::INVALID" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH31" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH31" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH29" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH29" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP8" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP8" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALLER" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CALLER" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH25" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH25" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH2" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH2" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP16" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP16" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP14" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP14" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH14" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH14" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUPN" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUPN" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DATALOADN" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::DATALOADN" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CHAINID" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CHAINID" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH10" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH10" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH9" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH9" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP3" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP3" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXCHANGE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::EXCHANGE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP2" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP2" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXTCODECOPY" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::EXTCODECOPY" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MULMOD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MULMOD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH11" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH11" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "ORIGIN" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::ORIGIN" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "POP" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::POP" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP13" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP13" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "AND" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::AND" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH21" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH21" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH16" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH16" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "TSTORE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::TSTORE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "TLOAD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::TLOAD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DIFFICULTY" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::DIFFICULTY" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP5" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP5" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP11" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP11" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALLF" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CALLF" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MUL" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MUL" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SHL" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SHL" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH6" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH6" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "GASLIMIT" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::GASLIMIT" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH28" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH28" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CREATE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CREATE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALLVALUE" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::CALLVALUE" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DATALOAD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DATALOAD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH4" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH4" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RETURNCONTRACT" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::RETURNCONTRACT" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "JUMPF" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::JUMPF" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DATACOPY" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DATACOPY" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "KECCAK256" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::KECCAK256" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RJUMPV" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::RJUMPV" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "BYTE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::BYTE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SGT" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SGT" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RETF" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::RETF" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH22" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH22" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MSIZE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MSIZE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP14" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP14" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "REVERT" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::REVERT" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MSTORE8" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MSTORE8" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH5" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH5" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SUB" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SUB" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP5" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP5" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH32" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH32" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP11" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP11" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SHR" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SHR" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP3" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP3" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "NUMBER" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::NUMBER" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PC" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PC" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH8" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH8" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH0" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH0" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "MSTORE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::MSTORE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP16" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP16" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "BALANCE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::BALANCE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "ADD" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::ADD" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH19" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH19" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "STOP" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::STOP" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "BLOBBASEFEE" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::BLOBBASEFEE" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "GT" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::GT" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DIV" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DIV" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH26" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH26" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "NOT" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::NOT" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "OR" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::OR" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "ADDRESS" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::ADDRESS" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAPN" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAPN" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SAR" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SAR" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALLDATASIZE" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::CALLDATASIZE" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DELEGATECALL" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::DELEGATECALL" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXFCALL" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::EXFCALL" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH18" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH18" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CODESIZE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CODESIZE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP13" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP13" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP12" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP12" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SIGNEXTEND" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::SIGNEXTEND" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CALLCODE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CALLCODE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP7" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP7" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "XOR" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::XOR" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SLT" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SLT" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "CODECOPY" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::CODECOPY" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "LOG4" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::LOG4" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "COINBASE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::COINBASE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH1" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH1" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "STATICCALL" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::STATICCALL" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "LOG2" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::LOG2" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SSTORE" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SSTORE" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "RETURNDATASIZE" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::RETURNDATASIZE" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP9" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP9" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "DUP4" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::DUP4" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "EXP" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::EXP" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SELFBALANCE" |);
                              M.read (|
                                M.get_constant (| "revm_interpreter::opcode::SELFBALANCE" |)
                              |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "PUSH24" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::PUSH24" |) |)
                            ];
                          Value.Tuple
                            [
                              M.read (| Value.String "SWAP8" |);
                              M.read (| M.get_constant (| "revm_interpreter::opcode::SWAP8" |) |)
                            ]
                        ]
                    |)))
              ]
          |)
        |))).
  
  (*
          pub const fn instruction<H: Host + ?Sized, SPEC: Spec>(opcode: u8) -> Instruction<H> {
              match opcode {
                  $($name => $f,)*
                  _ => control::unknown,
              }
          }
  *)
  Definition instruction (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ H; SPEC ], [ opcode ] =>
      ltac:(M.monadic
        (let opcode := M.alloc (| opcode |) in
        M.read (|
          M.match_operator (|
            opcode,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 0 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::stop", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 1 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::add",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 2 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::mul",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 3 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::sub",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 4 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::div",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 5 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::sdiv",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 6 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::rem",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 7 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::smod",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 8 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::addmod",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 9 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::mulmod",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 10 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::exp",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 11 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::arithmetic::signextend",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 16 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::lt", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 17 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::gt", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 18 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::slt", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 19 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::sgt", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 20 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::eq", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 21 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::bitwise::iszero",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 22 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::bitwise::bitand",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 23 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::bitor", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 24 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::bitwise::bitxor",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 25 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::not", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 26 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::bitwise::byte", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 27 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::bitwise::shl",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 28 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::bitwise::shr",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 29 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::bitwise::sar",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 32 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::keccak256",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 48 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::address",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 49 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::balance",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 50 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::origin",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 51 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::system::caller", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 52 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::callvalue",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 53 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::calldataload",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 54 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::calldatasize",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 55 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::calldatacopy",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 56 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::codesize",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 57 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::codecopy",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 58 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::gasprice",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 59 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::extcodesize",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 60 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::extcodecopy",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 61 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::returndatasize",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 62 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::returndatacopy",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 63 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::extcodehash",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 64 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::blockhash",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 65 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::coinbase",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 66 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::timestamp",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 67 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::block_number",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 68 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::difficulty",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 69 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::gaslimit",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 70 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::chainid",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 71 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::selfbalance",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 72 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::basefee",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 73 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::blob_hash",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 74 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host_env::blob_basefee",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 80 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::pop", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 81 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::memory::mload", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 82 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::memory::mstore", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 83 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::memory::mstore8",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 84 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::sload",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 85 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::sstore",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 86 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::jump", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 87 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::jumpi", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 88 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::pc", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 89 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::memory::msize", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 90 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::system::gas", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 91 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::control::jumpdest_or_nop",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 92 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::tload",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 93 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::tstore",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 94 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::memory::mcopy",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 95 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::stack::push0",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 96 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 97 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 98 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 99 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 100 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 101 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 102 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 103 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 104 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 105 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 106 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 107 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 108 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 109 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 110 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 111 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 112 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 113 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 114 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 115 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 116 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 117 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 118 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 119 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 120 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 121 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 122 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 123 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 124 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 125 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 126 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 127 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::push", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 128 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 129 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 130 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 131 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 132 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 133 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 134 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 135 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 136 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 137 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 138 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 139 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 140 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 141 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 142 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 143 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dup", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 144 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 145 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 146 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 147 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 148 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 149 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 150 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 151 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 152 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 153 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 154 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 155 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 156 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 157 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 158 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 159 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swap", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 160 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::host::log", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 161 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::host::log", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 162 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::host::log", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 163 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::host::log", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 164 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::host::log", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 208 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::data::data_load",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 209 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::data::data_loadn",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 210 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::data::data_size",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 211 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::data::data_copy",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 224 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::rjump", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 225 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::control::rjumpi",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 226 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::control::rjumpv",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 227 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::callf", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 228 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::retf", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 229 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::jumpf", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 230 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::dupn", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 231 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::stack::swapn", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 232 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::stack::exchange",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 236 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::eofcreate",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 237 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::txcreate",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 238 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::return_contract",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 240 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::create",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 241 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::call",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 242 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::call_code",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 243 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (| "revm_interpreter::instructions::control::ret", [ H ] |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 244 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::delegate_call",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 245 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::create",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 247 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::system::returndataload",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 248 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::extcall",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 249 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::extdcall",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 250 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::static_call",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 251 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::contract::extscall",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 253 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::control::revert",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 254 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::control::invalid",
                        [ H ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 255 |) in
                  M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::host::selfdestruct",
                        [ H; SPEC ]
                      |))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    (* ReifyFnPointer *)
                    M.pointer_coercion
                      (M.get_function (|
                        "revm_interpreter::instructions::control::unknown",
                        [ H ]
                      |))
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_instruction : M.IsFunction "revm_interpreter::opcode::instruction" instruction.
End opcode.
