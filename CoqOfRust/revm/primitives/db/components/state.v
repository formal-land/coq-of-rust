(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module db.
  Module components.
    Module state.
      (* Trait *)
      (* Empty module 'State' *)
      
      Module underscore.
        Module Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_State_T_where_core_marker_Sized_T_for_ref_mut_T.
          Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
          
          (* #[auto_impl(&mut, Box)] *)
          Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
          
          (* #[auto_impl(&mut, Box)] *)
          Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::State",
                    T,
                    [],
                    "basic",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&mut, Box)] *)
          Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; code_hash ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let code_hash := M.alloc (| code_hash |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::State",
                    T,
                    [],
                    "code_by_hash",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&mut, Box)] *)
          Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address; index ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                let index := M.alloc (| index |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::State",
                    T,
                    [],
                    "storage",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "revm_primitives::db::components::state::State"
              (Self T)
              (* Trait polymorphic types *) []
              (* Instance *)
              [
                ("Error", InstanceField.Ty (_Error T));
                ("basic", InstanceField.Method (basic T));
                ("code_by_hash", InstanceField.Method (code_by_hash T));
                ("storage", InstanceField.Method (storage T))
              ].
        End Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_State_T_where_core_marker_Sized_T_for_ref_mut_T.
        Module Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_State_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
          Definition Self (T : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
          
          (* #[auto_impl(&mut, Box)] *)
          Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
          
          (* #[auto_impl(&mut, Box)] *)
          Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::State",
                    T,
                    [],
                    "basic",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&mut, Box)] *)
          Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; code_hash ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let code_hash := M.alloc (| code_hash |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::State",
                    T,
                    [],
                    "code_by_hash",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&mut, Box)] *)
          Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address; index ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                let index := M.alloc (| index |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::State",
                    T,
                    [],
                    "storage",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "revm_primitives::db::components::state::State"
              (Self T)
              (* Trait polymorphic types *) []
              (* Instance *)
              [
                ("Error", InstanceField.Ty (_Error T));
                ("basic", InstanceField.Method (basic T));
                ("code_by_hash", InstanceField.Method (code_by_hash T));
                ("storage", InstanceField.Method (storage T))
              ].
        End Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_State_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
        Module Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_ref__T.
          Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "basic",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; code_hash ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let code_hash := M.alloc (| code_hash |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "code_by_hash",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address; index ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                let index := M.alloc (| index |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "storage",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "revm_primitives::db::components::state::StateRef"
              (Self T)
              (* Trait polymorphic types *) []
              (* Instance *)
              [
                ("Error", InstanceField.Ty (_Error T));
                ("basic", InstanceField.Method (basic T));
                ("code_by_hash", InstanceField.Method (code_by_hash T));
                ("storage", InstanceField.Method (storage T))
              ].
        End Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_ref__T.
        Module Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_ref_mut_T.
          Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "basic",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; code_hash ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let code_hash := M.alloc (| code_hash |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "code_by_hash",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address; index ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                let index := M.alloc (| index |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "storage",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "revm_primitives::db::components::state::StateRef"
              (Self T)
              (* Trait polymorphic types *) []
              (* Instance *)
              [
                ("Error", InstanceField.Ty (_Error T));
                ("basic", InstanceField.Method (basic T));
                ("code_by_hash", InstanceField.Method (code_by_hash T));
                ("storage", InstanceField.Method (storage T))
              ].
        End Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_ref_mut_T.
        Module Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
          Definition Self (T : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "basic",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; code_hash ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let code_hash := M.alloc (| code_hash |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "code_by_hash",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address; index ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                let index := M.alloc (| index |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "storage",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "revm_primitives::db::components::state::StateRef"
              (Self T)
              (* Trait polymorphic types *) []
              (* Instance *)
              [
                ("Error", InstanceField.Ty (_Error T));
                ("basic", InstanceField.Method (basic T));
                ("code_by_hash", InstanceField.Method (code_by_hash T));
                ("storage", InstanceField.Method (storage T))
              ].
        End Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
        Module Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
          Definition Self (T : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ].
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "basic",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| address |)
                  ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; code_hash ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let code_hash := M.alloc (| code_hash |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "code_by_hash",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| code_hash |)
                  ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address; index ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                let index := M.alloc (| index |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "storage",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| address |);
                    M.read (| index |)
                  ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "revm_primitives::db::components::state::StateRef"
              (Self T)
              (* Trait polymorphic types *) []
              (* Instance *)
              [
                ("Error", InstanceField.Ty (_Error T));
                ("basic", InstanceField.Method (basic T));
                ("code_by_hash", InstanceField.Method (code_by_hash T));
                ("storage", InstanceField.Method (storage T))
              ].
        End Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
        Module Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
          Definition Self (T : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "basic",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| address |)
                  ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; code_hash ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let code_hash := M.alloc (| code_hash |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "code_by_hash",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| code_hash |)
                  ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
          Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self T in
            match τ, α with
            | [], [ self; address; index ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let address := M.alloc (| address |) in
                let index := M.alloc (| index |) in
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_primitives::db::components::state::StateRef",
                    T,
                    [],
                    "storage",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| address |);
                    M.read (| index |)
                  ]
                |)))
            | _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (T : Ty.t),
            M.IsTraitInstance
              "revm_primitives::db::components::state::StateRef"
              (Self T)
              (* Trait polymorphic types *) []
              (* Instance *)
              [
                ("Error", InstanceField.Ty (_Error T));
                ("basic", InstanceField.Method (basic T));
                ("code_by_hash", InstanceField.Method (code_by_hash T));
                ("storage", InstanceField.Method (storage T))
              ].
        End Impl_revm_primitives_db_components_state_StateRef_where_revm_primitives_db_components_state_StateRef_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      End underscore.
      
      
      (* Trait *)
      (* Empty module 'StateRef' *)
      
      
      
      
      
      
      Module Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_StateRef_T_for_ref__T.
        Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
        
        (*     type Error = <T as StateRef>::Error; *)
        Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
        
        (*
            fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
                StateRef::basic( *self, address)
            }
        *)
        Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match τ, α with
          | [], [ self; address ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let address := M.alloc (| address |) in
              M.call_closure (|
                M.get_trait_method (|
                  "revm_primitives::db::components::state::StateRef",
                  T,
                  [],
                  "basic",
                  []
                |),
                [ M.read (| M.read (| self |) |); M.read (| address |) ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
                StateRef::code_by_hash( *self, code_hash)
            }
        *)
        Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match τ, α with
          | [], [ self; code_hash ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let code_hash := M.alloc (| code_hash |) in
              M.call_closure (|
                M.get_trait_method (|
                  "revm_primitives::db::components::state::StateRef",
                  T,
                  [],
                  "code_by_hash",
                  []
                |),
                [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
                StateRef::storage( *self, address, index)
            }
        *)
        Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match τ, α with
          | [], [ self; address; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let address := M.alloc (| address |) in
              let index := M.alloc (| index |) in
              M.call_closure (|
                M.get_trait_method (|
                  "revm_primitives::db::components::state::StateRef",
                  T,
                  [],
                  "storage",
                  []
                |),
                [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "revm_primitives::db::components::state::State"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Error", InstanceField.Ty (_Error T));
              ("basic", InstanceField.Method (basic T));
              ("code_by_hash", InstanceField.Method (code_by_hash T));
              ("storage", InstanceField.Method (storage T))
            ].
      End Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_StateRef_T_for_ref__T.
      
      Module Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_StateRef_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
        
        (*     type Error = <T as StateRef>::Error; *)
        Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
        
        (*
            fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
                self.deref().basic(address)
            }
        *)
        Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match τ, α with
          | [], [ self; address ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let address := M.alloc (| address |) in
              M.call_closure (|
                M.get_trait_method (|
                  "revm_primitives::db::components::state::StateRef",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  "basic",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [ self ]
                  |);
                  M.read (| address |)
                ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
                self.deref().code_by_hash(code_hash)
            }
        *)
        Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match τ, α with
          | [], [ self; code_hash ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let code_hash := M.alloc (| code_hash |) in
              M.call_closure (|
                M.get_trait_method (|
                  "revm_primitives::db::components::state::StateRef",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  "code_by_hash",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [ self ]
                  |);
                  M.read (| code_hash |)
                ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
                self.deref().storage(address, index)
            }
        *)
        Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match τ, α with
          | [], [ self; address; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let address := M.alloc (| address |) in
              let index := M.alloc (| index |) in
              M.call_closure (|
                M.get_trait_method (|
                  "revm_primitives::db::components::state::StateRef",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  "storage",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [ self ]
                  |);
                  M.read (| address |);
                  M.read (| index |)
                ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "revm_primitives::db::components::state::State"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Error", InstanceField.Ty (_Error T));
              ("basic", InstanceField.Method (basic T));
              ("code_by_hash", InstanceField.Method (code_by_hash T));
              ("storage", InstanceField.Method (storage T))
            ].
      End Impl_revm_primitives_db_components_state_State_where_revm_primitives_db_components_state_StateRef_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    End state.
  End components.
End db.
