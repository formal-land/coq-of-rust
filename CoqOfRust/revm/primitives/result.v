(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module result.
  Axiom EVMResult :
    forall (DBError : Ty.t),
    (Ty.apply (Ty.path "revm_primitives::result::EVMResult") [ DBError ]) =
      (Ty.apply
        (Ty.path "core::result::Result")
        [
          Ty.path "revm_primitives::result::ResultAndState";
          Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ]
        ]).
  
  Axiom EVMResultGeneric :
    forall (T DBError : Ty.t),
    (Ty.apply (Ty.path "revm_primitives::result::EVMResultGeneric") [ T; DBError ]) =
      (Ty.apply
        (Ty.path "core::result::Result")
        [ T; Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ] ]).
  
  (* StructRecord
    {
      name := "ResultAndState";
      ty_params := [];
      fields :=
        [
          ("result", Ty.path "revm_primitives::result::ExecutionResult");
          ("state",
            Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.path "revm_primitives::state::Account";
                Ty.path "std::hash::random::RandomState"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_ResultAndState.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ResultAndState".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "ResultAndState" |);
              M.read (| Value.String "result" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_primitives::result::ResultAndState",
                  "result"
                |));
              M.read (| Value.String "state" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_primitives::result::ResultAndState",
                    "state"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_ResultAndState.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_ResultAndState.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ResultAndState".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "revm_primitives::result::ResultAndState"
            [
              ("result",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "revm_primitives::result::ExecutionResult",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_primitives::result::ResultAndState",
                      "result"
                    |)
                  ]
                |));
              ("state",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "std::collections::hash::map::HashMap")
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.path "revm_primitives::state::Account";
                        Ty.path "std::hash::random::RandomState"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_primitives::result::ResultAndState",
                      "state"
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_ResultAndState.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_ResultAndState.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ResultAndState".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_ResultAndState.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_ResultAndState.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ResultAndState".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "revm_primitives::result::ExecutionResult",
                [ Ty.path "revm_primitives::result::ExecutionResult" ],
                "eq",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_primitives::result::ResultAndState",
                  "result"
                |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| other |),
                  "revm_primitives::result::ResultAndState",
                  "result"
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "std::collections::hash::map::HashMap")
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.path "revm_primitives::state::Account";
                      Ty.path "std::hash::random::RandomState"
                    ],
                  [
                    Ty.apply
                      (Ty.path "std::collections::hash::map::HashMap")
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.path "revm_primitives::state::Account";
                        Ty.path "std::hash::random::RandomState"
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_primitives::result::ResultAndState",
                    "state"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "revm_primitives::result::ResultAndState",
                    "state"
                  |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_ResultAndState.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_ResultAndState.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ResultAndState".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_ResultAndState.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_ResultAndState.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ResultAndState".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_ResultAndState.
  
  (*
  Enum ExecutionResult
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Success";
          item :=
            StructRecord
              [
                ("reason", Ty.path "revm_primitives::result::SuccessReason");
                ("gas_used", Ty.path "u64");
                ("gas_refunded", Ty.path "u64");
                ("logs",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::log::Log")
                        [ Ty.path "alloy_primitives::log::LogData" ];
                      Ty.path "alloc::alloc::Global"
                    ]);
                ("output", Ty.path "revm_primitives::result::Output")
              ];
          discriminant := None;
        };
        {
          name := "Revert";
          item :=
            StructRecord
              [ ("gas_used", Ty.path "u64"); ("output", Ty.path "alloy_primitives::bytes_::Bytes")
              ];
          discriminant := None;
        };
        {
          name := "Halt";
          item :=
            StructRecord
              [
                ("reason", Ty.path "revm_primitives::result::HaltReason");
                ("gas_used", Ty.path "u64")
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field5_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Success" |);
                          M.read (| Value.String "reason" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| Value.String "gas_used" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_1 |));
                          M.read (| Value.String "gas_refunded" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_2 |));
                          M.read (| Value.String "logs" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_3 |));
                          M.read (| Value.String "output" |);
                          (* Unsize *) M.pointer_coercion __self_4
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Revert" |);
                          M.read (| Value.String "gas_used" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| Value.String "output" |);
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Halt" |);
                          M.read (| Value.String "reason" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| Value.String "gas_used" |);
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_ExecutionResult.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_primitives::result::ExecutionResult::Success"
                        [
                          ("reason",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_primitives::result::SuccessReason",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("gas_used",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |));
                          ("gas_refunded",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_2 |) ]
                            |));
                          ("logs",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::log::Log")
                                      [ Ty.path "alloy_primitives::log::LogData" ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_3 |) ]
                            |));
                          ("output",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_primitives::result::Output",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_4 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_primitives::result::ExecutionResult::Revert"
                        [
                          ("gas_used",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("output",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "alloy_primitives::bytes_::Bytes",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_primitives::result::ExecutionResult::Halt"
                        [
                          ("reason",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_primitives::result::HaltReason",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("gas_used",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_ExecutionResult.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_ExecutionResult.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::ExecutionResult" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::ExecutionResult" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Success",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let γ2_2 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Success",
                                "gas_refunded"
                              |) in
                            let γ2_3 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Success",
                                "logs"
                              |) in
                            let γ2_4 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Success",
                                "output"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let __self_2 := M.alloc (| γ2_2 |) in
                            let __self_3 := M.alloc (| γ2_3 |) in
                            let __self_4 := M.alloc (| γ2_4 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Success",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let γ2_2 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Success",
                                "gas_refunded"
                              |) in
                            let γ2_3 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Success",
                                "logs"
                              |) in
                            let γ2_4 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Success",
                                "output"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            let __arg1_2 := M.alloc (| γ2_2 |) in
                            let __arg1_3 := M.alloc (| γ2_3 |) in
                            let __arg1_4 := M.alloc (| γ2_4 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    LogicalOp.and (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.path "revm_primitives::result::SuccessReason",
                                          [ Ty.path "revm_primitives::result::SuccessReason" ],
                                          "eq",
                                          []
                                        |),
                                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                      |),
                                      ltac:(M.monadic
                                        (BinOp.Pure.eq
                                          (M.read (| M.read (| __self_1 |) |))
                                          (M.read (| M.read (| __arg1_1 |) |))))
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq
                                        (M.read (| M.read (| __self_2 |) |))
                                        (M.read (| M.read (| __arg1_2 |) |))))
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::log::Log")
                                              [ Ty.path "alloy_primitives::log::LogData" ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::log::Log")
                                                [ Ty.path "alloy_primitives::log::LogData" ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ],
                                        "eq",
                                        []
                                      |),
                                      [ M.read (| __self_3 |); M.read (| __arg1_3 |) ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.path "revm_primitives::result::Output",
                                      [ Ty.path "revm_primitives::result::Output" ],
                                      "eq",
                                      []
                                    |),
                                    [ M.read (| __self_4 |); M.read (| __arg1_4 |) ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Revert",
                                "output"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Revert",
                                "output"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                BinOp.Pure.eq
                                  (M.read (| M.read (| __self_0 |) |))
                                  (M.read (| M.read (| __arg1_0 |) |)),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.path "alloy_primitives::bytes_::Bytes",
                                      [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                      "eq",
                                      []
                                    |),
                                    [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Halt",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Halt",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.path "revm_primitives::result::HaltReason",
                                    [ Ty.path "revm_primitives::result::HaltReason" ],
                                    "eq",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |),
                                ltac:(M.monadic
                                  (BinOp.Pure.eq
                                    (M.read (| M.read (| __self_1 |) |))
                                    (M.read (| M.read (| __arg1_1 |) |))))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_ExecutionResult.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_ExecutionResult.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_ExecutionResult.
  
  Module Impl_core_hash_Hash_for_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::ExecutionResult" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "revm_primitives::result::SuccessReason",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_1 |); M.read (| state |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_2 |); M.read (| state |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::log::Log")
                                  [ Ty.path "alloy_primitives::log::LogData" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_3 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_primitives::result::Output",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_4 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloy_primitives::bytes_::Bytes",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "revm_primitives::result::HaltReason",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_primitives_result_ExecutionResult.
  
  Module Impl_revm_primitives_result_ExecutionResult.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::ExecutionResult".
    
    (*
        pub fn is_success(&self) -> bool {
            matches!(self, Self::Success { .. })
        }
    *)
    Definition is_success (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_success : M.IsAssociatedFunction Self "is_success" is_success.
    
    (*
        pub fn is_halt(&self) -> bool {
            matches!(self, Self::Halt { .. })
        }
    *)
    Definition is_halt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "revm_primitives::result::ExecutionResult::Halt" |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_halt : M.IsAssociatedFunction Self "is_halt" is_halt.
    
    (*
        pub fn output(&self) -> Option<&Bytes> {
            match self {
                Self::Success { output, .. } => Some(output.data()),
                Self::Revert { output, .. } => Some(output),
                _ => None,
            }
        }
    *)
    Definition output (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_primitives::result::Output",
                              "data",
                              []
                            |),
                            [ M.read (| output |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| output |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_output : M.IsAssociatedFunction Self "output" output.
    
    (*
        pub fn into_output(self) -> Option<Bytes> {
            match self {
                Self::Success { output, .. } => Some(output.into_data()),
                Self::Revert { output, .. } => Some(output),
                _ => None,
            }
        }
    *)
    Definition into_output (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_primitives::result::Output",
                              "into_data",
                              []
                            |),
                            [ M.read (| output |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let output := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| output |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_output : M.IsAssociatedFunction Self "into_output" into_output.
    
    (*
        pub fn logs(&self) -> &[Log] {
            match self {
                Self::Success { logs, .. } => logs,
                _ => &[],
            }
        }
    *)
    Definition logs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let logs := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::log::Log")
                                [ Ty.path "alloy_primitives::log::LogData" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "deref",
                          []
                        |),
                        [ M.read (| logs |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (| (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [] |)) |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_logs : M.IsAssociatedFunction Self "logs" logs.
    
    (*
        pub fn into_logs(self) -> Vec<Log> {
            match self {
                Self::Success { logs, .. } => logs,
                _ => Vec::new(),
            }
        }
    *)
    Definition into_logs (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let logs := M.copy (| γ0_0 |) in
                    logs));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::log::Log")
                                [ Ty.path "alloy_primitives::log::LogData" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          []
                        |),
                        []
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_logs : M.IsAssociatedFunction Self "into_logs" into_logs.
    
    (*
        pub fn gas_used(&self) -> u64 {
            match *self {
                Self::Success { gas_used, .. }
                | Self::Revert { gas_used, .. }
                | Self::Halt { gas_used, .. } => gas_used,
            }
        }
    *)
    Definition gas_used (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_primitives::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_primitives::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_primitives::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ gas_used ] => ltac:(M.monadic gas_used)
                            | _ => ltac:(M.monadic (M.impossible (||)))
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_gas_used : M.IsAssociatedFunction Self "gas_used" gas_used.
  End Impl_revm_primitives_result_ExecutionResult.
  
  (*
  Enum Output
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Call";
          item := StructTuple [ Ty.path "alloy_primitives::bytes_::Bytes" ];
          discriminant := None;
        };
        {
          name := "Create";
          item :=
            StructTuple
              [
                Ty.path "alloy_primitives::bytes_::Bytes";
                Ty.apply
                  (Ty.path "core::option::Option")
                  [ Ty.path "alloy_primitives::bits::address::Address" ]
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Call" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Create" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_Output.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::Output::Call"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::Output::Create"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [ Ty.path "alloy_primitives::bits::address::Address" ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_1 |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_Output.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_Output.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::Output" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::Output" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::Output::Call",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::Output::Call",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloy_primitives::bytes_::Bytes",
                                  [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::Output::Create",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::Output::Create",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::Output::Create",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::Output::Create",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.path "alloy_primitives::bytes_::Bytes",
                                    [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                    "eq",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [ Ty.path "alloy_primitives::bits::address::Address" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "alloy_primitives::bits::address::Address" ]
                                      ],
                                      "eq",
                                      []
                                    |),
                                    [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_Output.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_Output.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_Output.
  
  Module Impl_core_hash_Hash_for_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::Output" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloy_primitives::bytes_::Bytes",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "alloy_primitives::bytes_::Bytes",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_primitives_result_Output.
  
  Module Impl_revm_primitives_result_Output.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::Output".
    
    (*
        pub fn into_data(self) -> Bytes {
            match self {
                Output::Call(data) => data,
                Output::Create(data, _) => data,
            }
        }
    *)
    Definition into_data (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Call",
                        0
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    data));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        0
                      |) in
                    let γ0_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        1
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    data))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_data : M.IsAssociatedFunction Self "into_data" into_data.
    
    (*
        pub fn data(&self) -> &Bytes {
            match self {
                Output::Call(data) => data,
                Output::Create(data, _) => data,
            }
        }
    *)
    Definition data (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Call",
                        0
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (| M.read (| data |) |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        1
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (| M.read (| data |) |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_data : M.IsAssociatedFunction Self "data" data.
    
    (*
        pub fn address(&self) -> Option<&Address> {
            match self {
                Output::Call(_) => None,
                Output::Create(_, address) => address.as_ref(),
            }
        }
    *)
    Definition address (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Call",
                        0
                      |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::Output::Create",
                        1
                      |) in
                    let address := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                          "as_ref",
                          []
                        |),
                        [ M.read (| address |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_address : M.IsAssociatedFunction Self "address" address.
  End Impl_revm_primitives_result_Output.
  
  (*
  Enum EVMError
  {
    ty_params := [ "DBError" ];
    variants :=
      [
        {
          name := "Transaction";
          item := StructTuple [ Ty.path "revm_primitives::result::InvalidTransaction" ];
          discriminant := None;
        };
        {
          name := "Header";
          item := StructTuple [ Ty.path "revm_primitives::result::InvalidHeader" ];
          discriminant := None;
        };
        {
          name := "Database";
          item := StructTuple [ DBError ];
          discriminant := None;
        };
        {
          name := "Custom";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_DBError_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (* Debug *)
    Definition fmt (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Transaction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Transaction" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Header",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Header" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Database",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Database" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Custom",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Custom" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt DBError)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_DBError_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_DBError_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (* Clone *)
    Definition clone (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Transaction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::EVMError::Transaction"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "revm_primitives::result::InvalidTransaction",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Header",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::EVMError::Header"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "revm_primitives::result::InvalidHeader",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Database",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::EVMError::Database"
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", DBError, [], "clone", [] |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Custom",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::EVMError::Custom"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloc::string::String",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone DBError)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_DBError_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_DBError_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (* PartialEq *)
    Definition eq (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ] ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::EVMError::Transaction",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::EVMError::Transaction",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "revm_primitives::result::InvalidTransaction",
                                  [ Ty.path "revm_primitives::result::InvalidTransaction" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::EVMError::Header",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::EVMError::Header",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "revm_primitives::result::InvalidHeader",
                                  [ Ty.path "revm_primitives::result::InvalidHeader" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::EVMError::Database",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::EVMError::Database",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  DBError,
                                  [ DBError ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::EVMError::Custom",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::EVMError::Custom",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq DBError)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_DBError_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralEq"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_DBError_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (DBError : Ty.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq DBError))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_DBError_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_DBError_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (* Hash *)
    Definition hash (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Transaction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_primitives::result::InvalidTransaction",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Header",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_primitives::result::InvalidHeader",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Database",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::hash::Hash", DBError, [], "hash", [ __H ] |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Custom",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloc::string::String",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash DBError)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_DBError_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_error_Error_where_core_error_Error_DBError_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (*
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            match self {
                Self::Transaction(e) => Some(e),
                Self::Header(e) => Some(e),
                Self::Database(e) => Some(e),
                Self::Custom(_) => None,
            }
        }
    *)
    Definition source (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ (* Unsize *) M.pointer_coercion (M.read (| e |)) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Header",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ (* Unsize *) M.pointer_coercion (M.read (| e |)) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Database",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ (* Unsize *) M.pointer_coercion (M.read (| e |)) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Custom",
                        0
                      |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("source", InstanceField.Method (source DBError)) ].
  End Impl_core_error_Error_where_core_error_Error_DBError_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_DBError_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Transaction(e) => write!(f, "transaction validation error: {e}"),
                Self::Header(e) => write!(f, "header validation error: {e}"),
                Self::Database(e) => write!(f, "database error: {e}"),
                Self::Custom(e) => f.write_str(e),
            }
        }
    *)
    Definition fmt (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "transaction validation error: " |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.path
                                                  "revm_primitives::result::InvalidTransaction"
                                              ]
                                          ]
                                        |),
                                        [ e ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Header",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "header validation error: " |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "revm_primitives::result::InvalidHeader" ]
                                          ]
                                        |),
                                        [ e ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Database",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| Value.String "database error: " |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ DBError ] ]
                                        |),
                                        [ e ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::EVMError::Custom",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "alloc::string::String",
                              [],
                              "deref",
                              []
                            |),
                            [ M.read (| e |) ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self DBError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt DBError)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_DBError_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_convert_From_revm_primitives_result_InvalidTransaction_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (*
        fn from(value: InvalidTransaction) -> Self {
            Self::Transaction(value)
        }
    *)
    Definition from (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_primitives::result::EVMError::Transaction"
            [ M.read (| value |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self DBError)
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "revm_primitives::result::InvalidTransaction" ]
        (* Instance *) [ ("from", InstanceField.Method (from DBError)) ].
  End Impl_core_convert_From_revm_primitives_result_InvalidTransaction_for_revm_primitives_result_EVMError_DBError.
  
  Module Impl_core_convert_From_revm_primitives_result_InvalidHeader_for_revm_primitives_result_EVMError_DBError.
    Definition Self (DBError : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::result::EVMError") [ DBError ].
    
    (*
        fn from(value: InvalidHeader) -> Self {
            Self::Header(value)
        }
    *)
    Definition from (DBError : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError in
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple "revm_primitives::result::EVMError::Header" [ M.read (| value |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (DBError : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self DBError)
        (* Trait polymorphic types *) [ (* T *) Ty.path "revm_primitives::result::InvalidHeader" ]
        (* Instance *) [ ("from", InstanceField.Method (from DBError)) ].
  End Impl_core_convert_From_revm_primitives_result_InvalidHeader_for_revm_primitives_result_EVMError_DBError.
  
  (*
  Enum InvalidTransaction
  {
    ty_params := [];
    variants :=
      [
        {
          name := "PriorityFeeGreaterThanMaxFee";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "GasPriceLessThanBasefee";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallerGasLimitMoreThanBlock";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallGasCostMoreThanGasLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "RejectCallerWithCode";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "LackOfFundForMaxFee";
          item :=
            StructRecord
              [
                ("fee",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ]);
                ("balance",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ])
              ];
          discriminant := None;
        };
        {
          name := "OverflowPaymentInTransaction";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NonceOverflowInTransaction";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NonceTooHigh";
          item := StructRecord [ ("tx", Ty.path "u64"); ("state", Ty.path "u64") ];
          discriminant := None;
        };
        {
          name := "NonceTooLow";
          item := StructRecord [ ("tx", Ty.path "u64"); ("state", Ty.path "u64") ];
          discriminant := None;
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidChainId";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "AccessListNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "MaxFeePerBlobGasNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BlobVersionedHashesNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BlobGasPriceGreaterThanMax";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EmptyBlobs";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BlobCreateTransaction";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "TooManyBlobs";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BlobVersionNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofInitcodesNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofInitcodesNumberLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofInitcodesSizeLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofCrateShouldHaveToAddress";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "PriorityFeeGreaterThanMaxFee" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "GasPriceLessThanBasefee" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallerGasLimitMoreThanBlock" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallGasCostMoreThanGasLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "RejectCallerWithCode" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "LackOfFundForMaxFee" |);
                          M.read (| Value.String "fee" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| Value.String "balance" |);
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OverflowPaymentInTransaction" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "NonceOverflowInTransaction" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "NonceTooHigh" |);
                          M.read (| Value.String "tx" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| Value.String "state" |);
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "NonceTooLow" |);
                          M.read (| Value.String "tx" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| Value.String "state" |);
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateInitCodeSizeLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "InvalidChainId" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "AccessListNotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "MaxFeePerBlobGasNotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "BlobVersionedHashesNotSupported" |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "BlobGasPriceGreaterThanMax" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EmptyBlobs" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "BlobCreateTransaction" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::TooManyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "TooManyBlobs" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "BlobVersionNotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EofInitcodesNotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNumberLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EofInitcodesNumberLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EofInitcodesSizeLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EofCrateShouldHaveToAddress" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::GasPriceLessThanBasefee"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::RejectCallerWithCode"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee"
                        [
                          ("fee",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("balance",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::OverflowPaymentInTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::NonceOverflowInTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh"
                        [
                          ("tx",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("state",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_primitives::result::InvalidTransaction::NonceTooLow"
                        [
                          ("tx",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("state",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::CreateInitCodeSizeLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::InvalidChainId"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::AccessListNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      Value.StructTuple "revm_primitives::result::InvalidTransaction::EmptyBlobs" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::BlobCreateTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::TooManyBlobs"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::TooManyBlobs"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::BlobVersionNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNumberLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNumberLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesSizeLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::EofInitcodesSizeLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                        []
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::InvalidTransaction" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::InvalidTransaction" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                                "fee"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                                "balance"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                                "fee"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                                "balance"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ],
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ]
                                    ],
                                    "eq",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ]
                                      ],
                                      "eq",
                                      []
                                    |),
                                    [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                                "state"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                                "state"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                BinOp.Pure.eq
                                  (M.read (| M.read (| __self_0 |) |))
                                  (M.read (| M.read (| __arg1_0 |) |)),
                                ltac:(M.monadic
                                  (BinOp.Pure.eq
                                    (M.read (| M.read (| __self_1 |) |))
                                    (M.read (| M.read (| __arg1_1 |) |))))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::InvalidTransaction::NonceTooLow",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_primitives::result::InvalidTransaction::NonceTooLow",
                                "state"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::InvalidTransaction::NonceTooLow",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_primitives::result::InvalidTransaction::NonceTooLow",
                                "state"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                BinOp.Pure.eq
                                  (M.read (| M.read (| __self_0 |) |))
                                  (M.read (| M.read (| __arg1_0 |) |)),
                                ltac:(M.monadic
                                  (BinOp.Pure.eq
                                    (M.read (| M.read (| __self_1 |) |))
                                    (M.read (| M.read (| __arg1_1 |) |))))
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_hash_Hash_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::InvalidTransaction" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ],
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.path "ruint::Uint"; Ty.path "alloc::alloc::Global" ],
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_error_Error_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_primitives_result_InvalidTransaction.
  
  Module Impl_core_fmt_Display_for_revm_primitives_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidTransaction".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::PriorityFeeGreaterThanMaxFee => {
                    write!(f, "priority fee is greater than max fee")
                }
                Self::GasPriceLessThanBasefee => {
                    write!(f, "gas price is less than basefee")
                }
                Self::CallerGasLimitMoreThanBlock => {
                    write!(f, "caller gas limit exceeds the block gas limit")
                }
                Self::CallGasCostMoreThanGasLimit => {
                    write!(f, "call gas cost exceeds the gas limit")
                }
                Self::RejectCallerWithCode => {
                    write!(f, "reject transactions from senders with deployed code")
                }
                Self::LackOfFundForMaxFee { fee, balance } => {
                    write!(f, "lack of funds ({balance}) for max fee ({fee})")
                }
                Self::OverflowPaymentInTransaction => {
                    write!(f, "overflow payment in transaction")
                }
                Self::NonceOverflowInTransaction => {
                    write!(f, "nonce overflow in transaction")
                }
                Self::NonceTooHigh { tx, state } => {
                    write!(f, "nonce {tx} too high, expected {state}")
                }
                Self::NonceTooLow { tx, state } => {
                    write!(f, "nonce {tx} too low, expected {state}")
                }
                Self::CreateInitCodeSizeLimit => {
                    write!(f, "create initcode size limit")
                }
                Self::InvalidChainId => write!(f, "invalid chain ID"),
                Self::AccessListNotSupported => write!(f, "access list not supported"),
                Self::MaxFeePerBlobGasNotSupported => {
                    write!(f, "max fee per blob gas not supported")
                }
                Self::BlobVersionedHashesNotSupported => {
                    write!(f, "blob versioned hashes not supported")
                }
                Self::BlobGasPriceGreaterThanMax => {
                    write!(f, "blob gas price is greater than max fee per blob gas")
                }
                Self::EmptyBlobs => write!(f, "empty blobs"),
                Self::BlobCreateTransaction => write!(f, "blob create transaction"),
                Self::TooManyBlobs => write!(f, "too many blobs"),
                Self::BlobVersionNotSupported => write!(f, "blob version not supported"),
                Self::EofInitcodesNotSupported => write!(f, "EOF initcodes not supported"),
                Self::EofCrateShouldHaveToAddress => write!(f, "EOF crate should have `to` address"),
                Self::EofInitcodesSizeLimit => write!(f, "EOF initcodes size limit"),
                Self::EofInitcodesNumberLimit => write!(f, "EOF initcodes number limit"),
                #[cfg(feature = "optimism")]
                Self::DepositSystemTxPostRegolith => {
                    write!(
                        f,
                        "deposit system transactions post regolith hardfork are not supported"
                    )
                }
                #[cfg(feature = "optimism")]
                Self::HaltedDepositPostRegolith => {
                    write!(
                        f,
                        "deposit transaction halted post-regolith; error will be bubbled up to main return handler"
                    )
                }
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "priority fee is greater than max fee"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "gas price is less than basefee" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "caller gas limit exceeds the block gas limit"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "call gas cost exceeds the gas limit"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String
                                          "reject transactions from senders with deployed code"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let fee := M.alloc (| γ1_0 |) in
                    let balance := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (| Value.String "lack of funds (" |);
                                      M.read (| Value.String ") for max fee (" |);
                                      M.read (| Value.String ")" |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  [
                                                    Ty.path "ruint::Uint";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ]
                                        |),
                                        [ balance ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  [
                                                    Ty.path "ruint::Uint";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ]
                                        |),
                                        [ fee ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "overflow payment in transaction" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "nonce overflow in transaction" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let tx := M.alloc (| γ1_0 |) in
                    let state := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (| Value.String "nonce " |);
                                      M.read (| Value.String " too high, expected " |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                        |),
                                        [ tx ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                        |),
                                        [ state ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let tx := M.alloc (| γ1_0 |) in
                    let state := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (| Value.String "nonce " |);
                                      M.read (| Value.String " too low, expected " |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                        |),
                                        [ tx ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                        |),
                                        [ state ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "create initcode size limit" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| Value.String "invalid chain ID" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "access list not supported" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "max fee per blob gas not supported" |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String "blob versioned hashes not supported"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (|
                                        Value.String
                                          "blob gas price is greater than max fee per blob gas"
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| Value.String "empty blobs" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "blob create transaction" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::TooManyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| Value.String "too many blobs" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "blob version not supported" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "EOF initcodes not supported" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "EOF crate should have `to` address" |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "EOF initcodes size limit" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidTransaction::EofInitcodesNumberLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "EOF initcodes number limit" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_primitives_result_InvalidTransaction.
  
  (*
  Enum InvalidHeader
  {
    ty_params := [];
    variants :=
      [
        {
          name := "PrevrandaoNotSet";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "ExcessBlobGasNotSet";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::InvalidHeader::PrevrandaoNotSet"
                          |) in
                        M.alloc (| M.read (| Value.String "PrevrandaoNotSet" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::InvalidHeader::ExcessBlobGasNotSet"
                          |) in
                        M.alloc (| M.read (| Value.String "ExcessBlobGasNotSet" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_marker_Copy_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::InvalidHeader" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::InvalidHeader" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_hash_Hash_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::InvalidHeader" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_tag; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_error_Error_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_primitives_result_InvalidHeader.
  
  Module Impl_core_fmt_Display_for_revm_primitives_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::InvalidHeader".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::PrevrandaoNotSet => write!(f, "`prevrandao` not set"),
                Self::ExcessBlobGasNotSet => write!(f, "`excess_blob_gas` not set"),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidHeader::PrevrandaoNotSet"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| Value.String "`prevrandao` not set" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::InvalidHeader::ExcessBlobGasNotSet"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| Value.String "`excess_blob_gas` not set" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_primitives_result_InvalidHeader.
  
  (*
  Enum SuccessReason
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Stop";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Return";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "SelfDestruct";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::SuccessReason::Stop"
                          |) in
                        M.alloc (| M.read (| Value.String "Stop" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::SuccessReason::Return"
                          |) in
                        M.alloc (| M.read (| Value.String "Return" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::SuccessReason::SelfDestruct"
                          |) in
                        M.alloc (| M.read (| Value.String "SelfDestruct" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_SuccessReason.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_SuccessReason.
  
  Module Impl_core_marker_Copy_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_primitives_result_SuccessReason.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_SuccessReason.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::SuccessReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::SuccessReason" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_SuccessReason.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_SuccessReason.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_SuccessReason.
  
  Module Impl_core_hash_Hash_for_revm_primitives_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::SuccessReason".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::SuccessReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_tag; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_primitives_result_SuccessReason.
  
  (*
  Enum HaltReason
  {
    ty_params := [];
    variants :=
      [
        {
          name := "OutOfGas";
          item := StructTuple [ Ty.path "revm_primitives::result::OutOfGasError" ];
          discriminant := None;
        };
        {
          name := "OpcodeNotFound";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidFEOpcode";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidJump";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NotActivated";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "StackUnderflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "StackOverflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OutOfOffset";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateCollision";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "PrecompileError";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NonceOverflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateContractSizeLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateContractStartingWithEF";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OverflowPayment";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "StateChangeDuringStaticCall";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallNotAllowedInsideStatic";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OutOfFunds";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallTooDeep";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::HaltReason::OutOfGas",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "OutOfGas" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::OpcodeNotFound"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OpcodeNotFound" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::InvalidFEOpcode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "InvalidFEOpcode" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::InvalidJump"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "InvalidJump" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::NotActivated"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "NotActivated" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::StackUnderflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "StackUnderflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::StackOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "StackOverflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::OutOfOffset"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OutOfOffset" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::CreateCollision"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateCollision" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::PrecompileError"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "PrecompileError" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::NonceOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "NonceOverflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::CreateContractSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateContractSizeLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::CreateContractStartingWithEF"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateContractStartingWithEF" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateInitCodeSizeLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::OverflowPayment"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OverflowPayment" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::StateChangeDuringStaticCall"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "StateChangeDuringStaticCall" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::CallNotAllowedInsideStatic"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallNotAllowedInsideStatic" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::OutOfFunds"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OutOfFunds" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_primitives::result::HaltReason::CallTooDeep"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallTooDeep" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_HaltReason.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_HaltReason.
  
  Module Impl_core_marker_Copy_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_primitives_result_HaltReason.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_HaltReason.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::HaltReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::HaltReason" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_primitives::result::HaltReason::OutOfGas",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_primitives::result::HaltReason::OutOfGas",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "revm_primitives::result::OutOfGasError",
                                  [ Ty.path "revm_primitives::result::OutOfGasError" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_HaltReason.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_HaltReason.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_HaltReason.
  
  Module Impl_core_hash_Hash_for_revm_primitives_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::HaltReason".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::HaltReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_primitives::result::HaltReason::OutOfGas",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_primitives::result::OutOfGasError",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_primitives_result_HaltReason.
  
  (*
  Enum OutOfGasError
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Basic";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "MemoryLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Memory";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Precompile";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidOperand";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::OutOfGasError::Basic"
                          |) in
                        M.alloc (| M.read (| Value.String "Basic" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::OutOfGasError::MemoryLimit"
                          |) in
                        M.alloc (| M.read (| Value.String "MemoryLimit" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::OutOfGasError::Memory"
                          |) in
                        M.alloc (| M.read (| Value.String "Memory" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::OutOfGasError::Precompile"
                          |) in
                        M.alloc (| M.read (| Value.String "Precompile" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_primitives::result::OutOfGasError::InvalidOperand"
                          |) in
                        M.alloc (| M.read (| Value.String "InvalidOperand" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_primitives_result_OutOfGasError.
  
  Module Impl_core_marker_Copy_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_primitives_result_OutOfGasError.
  
  Module Impl_core_clone_Clone_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_primitives_result_OutOfGasError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_primitives_result_OutOfGasError.
  
  Module Impl_core_cmp_PartialEq_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::OutOfGasError" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::OutOfGasError" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_primitives_result_OutOfGasError.
  
  Module Impl_core_marker_StructuralEq_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_revm_primitives_result_OutOfGasError.
  
  Module Impl_core_cmp_Eq_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_primitives_result_OutOfGasError.
  
  Module Impl_core_hash_Hash_for_revm_primitives_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_primitives::result::OutOfGasError".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_primitives::result::OutOfGasError" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_tag; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_primitives_result_OutOfGasError.
End result.
