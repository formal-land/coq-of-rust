(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module db.
  Module in_memory_db.
    Axiom InMemoryDB :
      (Ty.path "revm::db::in_memory_db::InMemoryDB") =
        (Ty.apply
          (Ty.path "revm::db::in_memory_db::CacheDB")
          [
            Ty.apply
              (Ty.path "revm::db::emptydb::EmptyDBTyped")
              [ Ty.path "core::convert::Infallible" ]
          ]).
    
    (* StructRecord
      {
        name := "CacheDB";
        ty_params := [ "ExtDB" ];
        fields :=
          [
            ("accounts",
              Ty.apply
                (Ty.path "std::collections::hash::map::HashMap")
                [
                  Ty.path "alloy_primitives::bits::address::Address";
                  Ty.path "revm::db::in_memory_db::DbAccount";
                  Ty.path "std::hash::random::RandomState"
                ]);
            ("contracts",
              Ty.apply
                (Ty.path "std::collections::hash::map::HashMap")
                [
                  Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                  Ty.path "revm_primitives::bytecode::Bytecode";
                  Ty.path "std::hash::random::RandomState"
                ]);
            ("logs",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::log::Log")
                    [ Ty.path "alloy_primitives::log::LogData" ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("block_hashes",
              Ty.apply
                (Ty.path "std::collections::hash::map::HashMap")
                [
                  Ty.path "ruint::Uint";
                  Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                  Ty.path "std::hash::random::RandomState"
                ]);
            ("db", ExtDB)
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
      Definition Self (ExtDB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ].
      
      (* Debug *)
      Definition fmt (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field5_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "CacheDB" |);
                M.read (| Value.String "accounts" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::db::in_memory_db::CacheDB",
                    "accounts"
                  |));
                M.read (| Value.String "contracts" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::db::in_memory_db::CacheDB",
                    "contracts"
                  |));
                M.read (| Value.String "logs" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::db::in_memory_db::CacheDB",
                    "logs"
                  |));
                M.read (| Value.String "block_hashes" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::db::in_memory_db::CacheDB",
                    "block_hashes"
                  |));
                M.read (| Value.String "db" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm::db::in_memory_db::CacheDB",
                      "db"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (ExtDB : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self ExtDB)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt ExtDB)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
      Definition Self (ExtDB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ].
      
      (* Clone *)
      Definition clone (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "revm::db::in_memory_db::CacheDB"
              [
                ("accounts",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::address::Address";
                          Ty.path "revm::db::in_memory_db::DbAccount";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "accounts"
                      |)
                    ]
                  |));
                ("contracts",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                          Ty.path "revm_primitives::bytecode::Bytecode";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "contracts"
                      |)
                    ]
                  |));
                ("logs",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::log::Log")
                            [ Ty.path "alloy_primitives::log::LogData" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "logs"
                      |)
                    ]
                  |));
                ("block_hashes",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "ruint::Uint";
                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "block_hashes"
                      |)
                    ]
                  |));
                ("db",
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", ExtDB, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "db"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (ExtDB : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self ExtDB)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone ExtDB)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
    
    Module Impl_core_default_Default_where_core_default_Default_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
      Definition Self (ExtDB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ].
      
      (*
          fn default() -> Self {
              Self::new(ExtDB::default())
          }
      *)
      Definition default (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ],
                "new",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::default::Default", ExtDB, [], "default", [] |),
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (ExtDB : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self ExtDB)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default ExtDB)) ].
    End Impl_core_default_Default_where_core_default_Default_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
    
    Module Impl_revm_db_in_memory_db_CacheDB_ExtDB.
      Definition Self (ExtDB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ].
      
      (*
          pub fn new(db: ExtDB) -> Self {
              let mut contracts = HashMap::new();
              contracts.insert(KECCAK_EMPTY, Bytecode::default());
              contracts.insert(B256::ZERO, Bytecode::default());
              Self {
                  accounts: HashMap::new(),
                  contracts,
                  logs: Vec::default(),
                  block_hashes: HashMap::new(),
                  db,
              }
          }
      *)
      Definition new (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ db ] =>
          ltac:(M.monadic
            (let db := M.alloc (| db |) in
            M.read (|
              let~ contracts :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                          Ty.path "revm_primitives::bytecode::Bytecode";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      "new",
                      []
                    |),
                    []
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                          Ty.path "revm_primitives::bytecode::Bytecode";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      "insert",
                      []
                    |),
                    [
                      contracts;
                      M.read (| M.get_constant (| "revm_primitives::utilities::KECCAK_EMPTY" |) |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.path "revm_primitives::bytecode::Bytecode",
                          [],
                          "default",
                          []
                        |),
                        []
                      |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                          Ty.path "revm_primitives::bytecode::Bytecode";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      "insert",
                      []
                    |),
                    [
                      contracts;
                      M.read (| M.get_constant (| "alloy_primitives::bits::fixed::ZERO" |) |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.path "revm_primitives::bytecode::Bytecode",
                          [],
                          "default",
                          []
                        |),
                        []
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "revm::db::in_memory_db::CacheDB"
                  [
                    ("accounts",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::collections::hash::map::HashMap")
                            [
                              Ty.path "alloy_primitives::bits::address::Address";
                              Ty.path "revm::db::in_memory_db::DbAccount";
                              Ty.path "std::hash::random::RandomState"
                            ],
                          "new",
                          []
                        |),
                        []
                      |));
                    ("contracts", M.read (| contracts |));
                    ("logs",
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::log::Log")
                                [ Ty.path "alloy_primitives::log::LogData" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "default",
                          []
                        |),
                        []
                      |));
                    ("block_hashes",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::collections::hash::map::HashMap")
                            [
                              Ty.path "ruint::Uint";
                              Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                              Ty.path "std::hash::random::RandomState"
                            ],
                          "new",
                          []
                        |),
                        []
                      |));
                    ("db", M.read (| db |))
                  ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new :
        forall (ExtDB : Ty.t),
        M.IsAssociatedFunction (Self ExtDB) "new" (new ExtDB).
      
      (*
          pub fn insert_contract(&mut self, account: &mut AccountInfo) {
              if let Some(code) = &account.code {
                  if !code.is_empty() {
                      if account.code_hash == KECCAK_EMPTY {
                          account.code_hash = code.hash_slow();
                      }
                      self.contracts
                          .entry(account.code_hash)
                          .or_insert_with(|| code.clone());
                  }
              }
              if account.code_hash == B256::ZERO {
                  account.code_hash = KECCAK_EMPTY;
              }
          }
      *)
      Definition insert_contract (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; account ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let account := M.alloc (| account |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| account |),
                              "revm_primitives::state::AccountInfo",
                              "code"
                            |)
                          |) in
                        let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let code := M.alloc (| γ1_0 |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "revm_primitives::bytecode::Bytecode",
                                            "is_empty",
                                            []
                                          |),
                                          [ M.read (| code |) ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialEq",
                                                    Ty.path
                                                      "alloy_primitives::bits::fixed::FixedBytes",
                                                    [
                                                      Ty.path
                                                        "alloy_primitives::bits::fixed::FixedBytes"
                                                    ],
                                                    "eq",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| account |),
                                                      "revm_primitives::state::AccountInfo",
                                                      "code_hash"
                                                    |);
                                                    M.get_constant (|
                                                      "revm_primitives::utilities::KECCAK_EMPTY"
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| account |),
                                                "revm_primitives::state::AccountInfo",
                                                "code_hash"
                                              |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "revm_primitives::bytecode::Bytecode",
                                                  "hash_slow",
                                                  []
                                                |),
                                                [ M.read (| code |) ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::Entry")
                                          [
                                            Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                                            Ty.path "revm_primitives::bytecode::Bytecode"
                                          ],
                                        "or_insert_with",
                                        [
                                          Ty.function
                                            [ Ty.tuple [] ]
                                            (Ty.path "revm_primitives::bytecode::Bytecode")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "std::collections::hash::map::HashMap")
                                              [
                                                Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                                                Ty.path "revm_primitives::bytecode::Bytecode";
                                                Ty.path "std::hash::random::RandomState"
                                              ],
                                            "entry",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "revm::db::in_memory_db::CacheDB",
                                              "contracts"
                                            |);
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| account |),
                                                "revm_primitives::state::AccountInfo",
                                                "code_hash"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    M.alloc (| α0 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::clone::Clone",
                                                              Ty.path
                                                                "revm_primitives::bytecode::Bytecode",
                                                              [],
                                                              "clone",
                                                              []
                                                            |),
                                                            [ M.read (| code |) ]
                                                          |)))
                                                    ]
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end))
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.path "alloy_primitives::bits::fixed::FixedBytes",
                                [ Ty.path "alloy_primitives::bits::fixed::FixedBytes" ],
                                "eq",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| account |),
                                  "revm_primitives::state::AccountInfo",
                                  "code_hash"
                                |);
                                M.get_constant (| "alloy_primitives::bits::fixed::ZERO" |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| account |),
                            "revm_primitives::state::AccountInfo",
                            "code_hash"
                          |),
                          M.read (|
                            M.get_constant (| "revm_primitives::utilities::KECCAK_EMPTY" |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_insert_contract :
        forall (ExtDB : Ty.t),
        M.IsAssociatedFunction (Self ExtDB) "insert_contract" (insert_contract ExtDB).
      
      (*
          pub fn insert_account_info(&mut self, address: Address, mut info: AccountInfo) {
              self.insert_contract(&mut info);
              self.accounts.entry(address).or_default().info = info;
          }
      *)
      Definition insert_account_info (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address; info ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let info := M.alloc (| info |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ],
                      "insert_contract",
                      []
                    |),
                    [ M.read (| self |); info ]
                  |)
                |) in
              let~ _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "std::collections::hash::map::Entry")
                          [
                            Ty.path "alloy_primitives::bits::address::Address";
                            Ty.path "revm::db::in_memory_db::DbAccount"
                          ],
                        "or_default",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "std::collections::hash::map::HashMap")
                              [
                                Ty.path "alloy_primitives::bits::address::Address";
                                Ty.path "revm::db::in_memory_db::DbAccount";
                                Ty.path "std::hash::random::RandomState"
                              ],
                            "entry",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm::db::in_memory_db::CacheDB",
                              "accounts"
                            |);
                            M.read (| address |)
                          ]
                        |)
                      ]
                    |),
                    "revm::db::in_memory_db::DbAccount",
                    "info"
                  |),
                  M.read (| info |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_insert_account_info :
        forall (ExtDB : Ty.t),
        M.IsAssociatedFunction (Self ExtDB) "insert_account_info" (insert_account_info ExtDB).
      (*
          pub fn load_account(&mut self, address: Address) -> Result<&mut DbAccount, ExtDB::Error> {
              let db = &self.db;
              match self.accounts.entry(address) {
                  Entry::Occupied(entry) => Ok(entry.into_mut()),
                  Entry::Vacant(entry) => Ok(entry.insert(
                      db.basic_ref(address)?
                          .map(|info| DbAccount {
                              info,
                              ..Default::default()
                          })
                          .unwrap_or_else(DbAccount::new_not_existing),
                  )),
              }
          }
      *)
      Definition load_account (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ db :=
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "db"
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::collections::hash::map::HashMap")
                            [
                              Ty.path "alloy_primitives::bits::address::Address";
                              Ty.path "revm::db::in_memory_db::DbAccount";
                              Ty.path "std::hash::random::RandomState"
                            ],
                          "entry",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "revm::db::in_memory_db::CacheDB",
                            "accounts"
                          |);
                          M.read (| address |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Occupied",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::OccupiedEntry")
                                      [
                                        Ty.path "alloy_primitives::bits::address::Address";
                                        Ty.path "revm::db::in_memory_db::DbAccount"
                                      ],
                                    "into_mut",
                                    []
                                  |),
                                  [ M.read (| entry |) ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::VacantEntry")
                                      [
                                        Ty.path "alloy_primitives::bits::address::Address";
                                        Ty.path "revm::db::in_memory_db::DbAccount"
                                      ],
                                    "insert",
                                    []
                                  |),
                                  [
                                    M.read (| entry |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "revm::db::in_memory_db::DbAccount" ],
                                        "unwrap_or_else",
                                        [
                                          Ty.function
                                            []
                                            (Ty.path "revm::db::in_memory_db::DbAccount")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "revm_primitives::state::AccountInfo" ],
                                            "map",
                                            [
                                              Ty.path "revm::db::in_memory_db::DbAccount";
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [ Ty.path "revm_primitives::state::AccountInfo"
                                                    ]
                                                ]
                                                (Ty.path "revm::db::in_memory_db::DbAccount")
                                            ]
                                          |),
                                          [
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.path
                                                                "revm_primitives::state::AccountInfo"
                                                            ];
                                                          Ty.associated
                                                        ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "revm_primitives::db::DatabaseRef",
                                                          ExtDB,
                                                          [],
                                                          "basic_ref",
                                                          []
                                                        |),
                                                        [ M.read (| db |); M.read (| address |) ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&mut")
                                                                        [
                                                                          Ty.path
                                                                            "revm::db::in_memory_db::DbAccount"
                                                                        ];
                                                                      Ty.associated
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.associated
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)
                                            |);
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    ltac:(M.monadic
                                                      (M.match_operator (|
                                                        M.alloc (| α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let info := M.copy (| γ |) in
                                                              M.struct_record_update
                                                                (M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::default::Default",
                                                                    Ty.path
                                                                      "revm::db::in_memory_db::DbAccount",
                                                                    [],
                                                                    "default",
                                                                    []
                                                                  |),
                                                                  []
                                                                |))
                                                                [ ("info", M.read (| info |)) ]))
                                                        ]
                                                      |)))
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end))
                                          ]
                                        |);
                                        M.get_associated_function (|
                                          Ty.path "revm::db::in_memory_db::DbAccount",
                                          "new_not_existing",
                                          []
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_load_account :
        forall (ExtDB : Ty.t),
        M.IsAssociatedFunction (Self ExtDB) "load_account" (load_account ExtDB).
      
      (*
          pub fn insert_account_storage(
              &mut self,
              address: Address,
              slot: U256,
              value: U256,
          ) -> Result<(), ExtDB::Error> {
              let account = self.load_account(address)?;
              account.storage.insert(slot, value);
              Ok(())
          }
      *)
      Definition insert_account_storage (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address; slot; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let slot := M.alloc (| slot |) in
            let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ account :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    [ Ty.path "revm::db::in_memory_db::DbAccount" ];
                                  Ty.associated
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ],
                                  "load_account",
                                  []
                                |),
                                [ M.read (| self |); M.read (| address |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.tuple []; Ty.associated ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::collections::hash::map::HashMap")
                            [
                              Ty.path "ruint::Uint";
                              Ty.path "ruint::Uint";
                              Ty.path "std::hash::random::RandomState"
                            ],
                          "insert",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| account |),
                            "revm::db::in_memory_db::DbAccount",
                            "storage"
                          |);
                          M.read (| slot |);
                          M.read (| value |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_insert_account_storage :
        forall (ExtDB : Ty.t),
        M.IsAssociatedFunction (Self ExtDB) "insert_account_storage" (insert_account_storage ExtDB).
      
      (*
          pub fn replace_account_storage(
              &mut self,
              address: Address,
              storage: HashMap<U256, U256>,
          ) -> Result<(), ExtDB::Error> {
              let account = self.load_account(address)?;
              account.account_state = AccountState::StorageCleared;
              account.storage = storage.into_iter().collect();
              Ok(())
          }
      *)
      Definition replace_account_storage (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address; storage ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let storage := M.alloc (| storage |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ account :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    [ Ty.path "revm::db::in_memory_db::DbAccount" ];
                                  Ty.associated
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ],
                                  "load_account",
                                  []
                                |),
                                [ M.read (| self |); M.read (| address |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.tuple []; Ty.associated ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| account |),
                        "revm::db::in_memory_db::DbAccount",
                        "account_state"
                      |),
                      Value.StructTuple "revm::db::in_memory_db::AccountState::StorageCleared" []
                    |) in
                  let~ _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| account |),
                        "revm::db::in_memory_db::DbAccount",
                        "storage"
                      |),
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "std::collections::hash::map::IntoIter")
                            [ Ty.path "ruint::Uint"; Ty.path "ruint::Uint" ],
                          [],
                          "collect",
                          [
                            Ty.apply
                              (Ty.path "std::collections::hash::map::HashMap")
                              [
                                Ty.path "ruint::Uint";
                                Ty.path "ruint::Uint";
                                Ty.path "std::hash::random::RandomState"
                              ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "std::collections::hash::map::HashMap")
                                [
                                  Ty.path "ruint::Uint";
                                  Ty.path "ruint::Uint";
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [ M.read (| storage |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_replace_account_storage :
        forall (ExtDB : Ty.t),
        M.IsAssociatedFunction
          (Self ExtDB)
          "replace_account_storage"
          (replace_account_storage ExtDB).
    End Impl_revm_db_in_memory_db_CacheDB_ExtDB.
    
    
    Module Impl_revm_primitives_db_DatabaseCommit_for_revm_db_in_memory_db_CacheDB_ExtDB.
      Definition Self (ExtDB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ].
      
      (*
          fn commit(&mut self, changes: HashMap<Address, Account>) {
              for (address, mut account) in changes {
                  if !account.is_touched() {
                      continue;
                  }
                  if account.is_selfdestructed() {
                      let db_account = self.accounts.entry(address).or_default();
                      db_account.storage.clear();
                      db_account.account_state = AccountState::NotExisting;
                      db_account.info = AccountInfo::default();
                      continue;
                  }
                  let is_newly_created = account.is_created();
                  self.insert_contract(&mut account.info);
      
                  let db_account = self.accounts.entry(address).or_default();
                  db_account.info = account.info;
      
                  db_account.account_state = if is_newly_created {
                      db_account.storage.clear();
                      AccountState::StorageCleared
                  } else if db_account.account_state.is_storage_cleared() {
                      // Preserve old account state if it already exists
                      AccountState::StorageCleared
                  } else {
                      AccountState::Touched
                  };
                  db_account.storage.extend(
                      account
                          .storage
                          .into_iter()
                          .map(|(key, value)| (key, value.present_value())),
                  );
              }
          }
      *)
      Definition commit (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; changes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let changes := M.alloc (| changes |) in
            M.read (|
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "std::collections::hash::map::HashMap")
                          [
                            Ty.path "alloy_primitives::bits::address::Address";
                            Ty.path "revm_primitives::state::Account";
                            Ty.path "std::hash::random::RandomState"
                          ],
                        [],
                        "into_iter",
                        []
                      |),
                      [ M.read (| changes |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let~ _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "std::collections::hash::map::IntoIter")
                                        [
                                          Ty.path "alloy_primitives::bits::address::Address";
                                          Ty.path "revm_primitives::state::Account"
                                        ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let address := M.copy (| γ1_0 |) in
                                      let account := M.copy (| γ1_1 |) in
                                      let~ _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path
                                                              "revm_primitives::state::Account",
                                                            "is_touched",
                                                            []
                                                          |),
                                                          [ account ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.continue (||) |) |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      let~ _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "revm_primitives::state::Account",
                                                          "is_selfdestructed",
                                                          []
                                                        |),
                                                        [ account ]
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      let~ db_account :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "std::collections::hash::map::Entry")
                                                                [
                                                                  Ty.path
                                                                    "alloy_primitives::bits::address::Address";
                                                                  Ty.path
                                                                    "revm::db::in_memory_db::DbAccount"
                                                                ],
                                                              "or_default",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "std::collections::hash::map::HashMap")
                                                                    [
                                                                      Ty.path
                                                                        "alloy_primitives::bits::address::Address";
                                                                      Ty.path
                                                                        "revm::db::in_memory_db::DbAccount";
                                                                      Ty.path
                                                                        "std::hash::random::RandomState"
                                                                    ],
                                                                  "entry",
                                                                  []
                                                                |),
                                                                [
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.read (| self |),
                                                                    "revm::db::in_memory_db::CacheDB",
                                                                    "accounts"
                                                                  |);
                                                                  M.read (| address |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "std::collections::hash::map::HashMap")
                                                                [
                                                                  Ty.path "ruint::Uint";
                                                                  Ty.path "ruint::Uint";
                                                                  Ty.path
                                                                    "std::hash::random::RandomState"
                                                                ],
                                                              "clear",
                                                              []
                                                            |),
                                                            [
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.read (| db_account |),
                                                                "revm::db::in_memory_db::DbAccount",
                                                                "storage"
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ :=
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| db_account |),
                                                            "revm::db::in_memory_db::DbAccount",
                                                            "account_state"
                                                          |),
                                                          Value.StructTuple
                                                            "revm::db::in_memory_db::AccountState::NotExisting"
                                                            []
                                                        |) in
                                                      let~ _ :=
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| db_account |),
                                                            "revm::db::in_memory_db::DbAccount",
                                                            "info"
                                                          |),
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::default::Default",
                                                              Ty.path
                                                                "revm_primitives::state::AccountInfo",
                                                              [],
                                                              "default",
                                                              []
                                                            |),
                                                            []
                                                          |)
                                                        |) in
                                                      M.continue (||)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      let~ is_newly_created :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "revm_primitives::state::Account",
                                              "is_created",
                                              []
                                            |),
                                            [ account ]
                                          |)
                                        |) in
                                      let~ _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "revm::db::in_memory_db::CacheDB")
                                                [ ExtDB ],
                                              "insert_contract",
                                              []
                                            |),
                                            [
                                              M.read (| self |);
                                              M.SubPointer.get_struct_record_field (|
                                                account,
                                                "revm_primitives::state::Account",
                                                "info"
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let~ db_account :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::Entry")
                                                [
                                                  Ty.path
                                                    "alloy_primitives::bits::address::Address";
                                                  Ty.path "revm::db::in_memory_db::DbAccount"
                                                ],
                                              "or_default",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "std::collections::hash::map::HashMap")
                                                    [
                                                      Ty.path
                                                        "alloy_primitives::bits::address::Address";
                                                      Ty.path "revm::db::in_memory_db::DbAccount";
                                                      Ty.path "std::hash::random::RandomState"
                                                    ],
                                                  "entry",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "revm::db::in_memory_db::CacheDB",
                                                    "accounts"
                                                  |);
                                                  M.read (| address |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| db_account |),
                                            "revm::db::in_memory_db::DbAccount",
                                            "info"
                                          |),
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              account,
                                              "revm_primitives::state::Account",
                                              "info"
                                            |)
                                          |)
                                        |) in
                                      let~ _ :=
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| db_account |),
                                            "revm::db::in_memory_db::DbAccount",
                                            "account_state"
                                          |),
                                          M.read (|
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ := M.use is_newly_created in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let~ _ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "std::collections::hash::map::HashMap")
                                                              [
                                                                Ty.path "ruint::Uint";
                                                                Ty.path "ruint::Uint";
                                                                Ty.path
                                                                  "std::hash::random::RandomState"
                                                              ],
                                                            "clear",
                                                            []
                                                          |),
                                                          [
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.read (| db_account |),
                                                              "revm::db::in_memory_db::DbAccount",
                                                              "storage"
                                                            |)
                                                          ]
                                                        |)
                                                      |) in
                                                    M.alloc (|
                                                      Value.StructTuple
                                                        "revm::db::in_memory_db::AccountState::StorageCleared"
                                                        []
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "revm::db::in_memory_db::AccountState",
                                                                      "is_storage_cleared",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        M.read (| db_account |),
                                                                        "revm::db::in_memory_db::DbAccount",
                                                                        "account_state"
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              M.is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.alloc (|
                                                              Value.StructTuple
                                                                "revm::db::in_memory_db::AccountState::StorageCleared"
                                                                []
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (|
                                                              Value.StructTuple
                                                                "revm::db::in_memory_db::AccountState::Touched"
                                                                []
                                                            |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          |)
                                        |) in
                                      let~ _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::collect::Extend",
                                              Ty.apply
                                                (Ty.path "std::collections::hash::map::HashMap")
                                                [
                                                  Ty.path "ruint::Uint";
                                                  Ty.path "ruint::Uint";
                                                  Ty.path "std::hash::random::RandomState"
                                                ],
                                              [
                                                Ty.tuple
                                                  [ Ty.path "ruint::Uint"; Ty.path "ruint::Uint" ]
                                              ],
                                              "extend",
                                              [
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::map::Map")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "std::collections::hash::map::IntoIter")
                                                      [
                                                        Ty.path "ruint::Uint";
                                                        Ty.path
                                                          "revm_primitives::state::StorageSlot"
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.path "ruint::Uint";
                                                                Ty.path
                                                                  "revm_primitives::state::StorageSlot"
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.tuple
                                                        [
                                                          Ty.path "ruint::Uint";
                                                          Ty.path "ruint::Uint"
                                                        ])
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| db_account |),
                                                "revm::db::in_memory_db::DbAccount",
                                                "storage"
                                              |);
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "std::collections::hash::map::IntoIter")
                                                    [
                                                      Ty.path "ruint::Uint";
                                                      Ty.path "revm_primitives::state::StorageSlot"
                                                    ],
                                                  [],
                                                  "map",
                                                  [
                                                    Ty.tuple
                                                      [ Ty.path "ruint::Uint"; Ty.path "ruint::Uint"
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.path "ruint::Uint";
                                                                Ty.path
                                                                  "revm_primitives::state::StorageSlot"
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.tuple
                                                        [
                                                          Ty.path "ruint::Uint";
                                                          Ty.path "ruint::Uint"
                                                        ])
                                                  ]
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::collect::IntoIterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "std::collections::hash::map::HashMap")
                                                        [
                                                          Ty.path "ruint::Uint";
                                                          Ty.path
                                                            "revm_primitives::state::StorageSlot";
                                                          Ty.path "std::hash::random::RandomState"
                                                        ],
                                                      [],
                                                      "into_iter",
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          account,
                                                          "revm_primitives::state::Account",
                                                          "storage"
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.closure
                                                    (fun γ =>
                                                      ltac:(M.monadic
                                                        match γ with
                                                        | [ α0 ] =>
                                                          ltac:(M.monadic
                                                            (M.match_operator (|
                                                              M.alloc (| α0 |),
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let γ0_0 :=
                                                                      M.SubPointer.get_tuple_field (|
                                                                        γ,
                                                                        0
                                                                      |) in
                                                                    let γ0_1 :=
                                                                      M.SubPointer.get_tuple_field (|
                                                                        γ,
                                                                        1
                                                                      |) in
                                                                    let key := M.copy (| γ0_0 |) in
                                                                    let value :=
                                                                      M.copy (| γ0_1 |) in
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (| key |);
                                                                        M.call_closure (|
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "revm_primitives::state::StorageSlot",
                                                                            "present_value",
                                                                            []
                                                                          |),
                                                                          [ value ]
                                                                        |)
                                                                      ]))
                                                              ]
                                                            |)))
                                                        | _ =>
                                                          M.impossible "wrong number of arguments"
                                                        end))
                                                ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (ExtDB : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseCommit"
          (Self ExtDB)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("commit", InstanceField.Method (commit ExtDB)) ].
    End Impl_revm_primitives_db_DatabaseCommit_for_revm_db_in_memory_db_CacheDB_ExtDB.
    
    Module Impl_revm_primitives_db_Database_where_revm_primitives_db_DatabaseRef_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
      Definition Self (ExtDB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ].
      
      (*     type Error = ExtDB::Error; *)
      Definition _Error (ExtDB : Ty.t) : Ty.t := Ty.associated.
      
      (*
          fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
              let basic = match self.accounts.entry(address) {
                  Entry::Occupied(entry) => entry.into_mut(),
                  Entry::Vacant(entry) => entry.insert(
                      self.db
                          .basic_ref(address)?
                          .map(|info| DbAccount {
                              info,
                              ..Default::default()
                          })
                          .unwrap_or_else(DbAccount::new_not_existing),
                  ),
              };
              Ok(basic.info())
          }
      *)
      Definition basic (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ basic :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::map::HashMap")
                                [
                                  Ty.path "alloy_primitives::bits::address::Address";
                                  Ty.path "revm::db::in_memory_db::DbAccount";
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "entry",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "revm::db::in_memory_db::CacheDB",
                                "accounts"
                              |);
                              M.read (| address |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "std::collections::hash::map::Entry::Occupied",
                                  0
                                |) in
                              let entry := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::OccupiedEntry")
                                      [
                                        Ty.path "alloy_primitives::bits::address::Address";
                                        Ty.path "revm::db::in_memory_db::DbAccount"
                                      ],
                                    "into_mut",
                                    []
                                  |),
                                  [ M.read (| entry |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "std::collections::hash::map::Entry::Vacant",
                                  0
                                |) in
                              let entry := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::map::VacantEntry")
                                      [
                                        Ty.path "alloy_primitives::bits::address::Address";
                                        Ty.path "revm::db::in_memory_db::DbAccount"
                                      ],
                                    "insert",
                                    []
                                  |),
                                  [
                                    M.read (| entry |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "revm::db::in_memory_db::DbAccount" ],
                                        "unwrap_or_else",
                                        [
                                          Ty.function
                                            []
                                            (Ty.path "revm::db::in_memory_db::DbAccount")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "revm_primitives::state::AccountInfo" ],
                                            "map",
                                            [
                                              Ty.path "revm::db::in_memory_db::DbAccount";
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [ Ty.path "revm_primitives::state::AccountInfo"
                                                    ]
                                                ]
                                                (Ty.path "revm::db::in_memory_db::DbAccount")
                                            ]
                                          |),
                                          [
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.path
                                                                "revm_primitives::state::AccountInfo"
                                                            ];
                                                          Ty.associated
                                                        ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "revm_primitives::db::DatabaseRef",
                                                          ExtDB,
                                                          [],
                                                          "basic_ref",
                                                          []
                                                        |),
                                                        [
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| self |),
                                                            "revm::db::in_memory_db::CacheDB",
                                                            "db"
                                                          |);
                                                          M.read (| address |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        [
                                                                          Ty.path
                                                                            "revm_primitives::state::AccountInfo"
                                                                        ];
                                                                      Ty.associated
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.associated
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)
                                            |);
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    ltac:(M.monadic
                                                      (M.match_operator (|
                                                        M.alloc (| α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let info := M.copy (| γ |) in
                                                              M.struct_record_update
                                                                (M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::default::Default",
                                                                    Ty.path
                                                                      "revm::db::in_memory_db::DbAccount",
                                                                    [],
                                                                    "default",
                                                                    []
                                                                  |),
                                                                  []
                                                                |))
                                                                [ ("info", M.read (| info |)) ]))
                                                        ]
                                                      |)))
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end))
                                          ]
                                        |);
                                        M.get_associated_function (|
                                          Ty.path "revm::db::in_memory_db::DbAccount",
                                          "new_not_existing",
                                          []
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "revm::db::in_memory_db::DbAccount",
                            "info",
                            []
                          |),
                          [ M.read (| basic |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
              match self.contracts.entry(code_hash) {
                  Entry::Occupied(entry) => Ok(entry.get().clone()),
                  Entry::Vacant(entry) => {
                      // if you return code bytes when basic fn is called this function is not needed.
                      Ok(entry.insert(self.db.code_by_hash_ref(code_hash)?).clone())
                  }
              }
          }
      *)
      Definition code_by_hash (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::collections::hash::map::HashMap")
                            [
                              Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                              Ty.path "revm_primitives::bytecode::Bytecode";
                              Ty.path "std::hash::random::RandomState"
                            ],
                          "entry",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "revm::db::in_memory_db::CacheDB",
                            "contracts"
                          |);
                          M.read (| code_hash |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Occupied",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    Ty.path "revm_primitives::bytecode::Bytecode",
                                    [],
                                    "clone",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::OccupiedEntry")
                                          [
                                            Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                                            Ty.path "revm_primitives::bytecode::Bytecode"
                                          ],
                                        "get",
                                        []
                                      |),
                                      [ entry ]
                                    |)
                                  ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    Ty.path "revm_primitives::bytecode::Bytecode",
                                    [],
                                    "clone",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "std::collections::hash::map::VacantEntry")
                                          [
                                            Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                                            Ty.path "revm_primitives::bytecode::Bytecode"
                                          ],
                                        "insert",
                                        []
                                      |),
                                      [
                                        M.read (| entry |);
                                        M.read (|
                                          M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::Try",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path "revm_primitives::bytecode::Bytecode";
                                                      Ty.associated
                                                    ],
                                                  [],
                                                  "branch",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "revm_primitives::db::DatabaseRef",
                                                      ExtDB,
                                                      [],
                                                      "code_by_hash_ref",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "revm::db::in_memory_db::CacheDB",
                                                        "db"
                                                      |);
                                                      M.read (| code_hash |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Break",
                                                      0
                                                    |) in
                                                  let residual := M.copy (| γ0_0 |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::try_trait::FromResidual",
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "revm_primitives::bytecode::Bytecode";
                                                                  Ty.associated
                                                                ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  [
                                                                    Ty.path
                                                                      "core::convert::Infallible";
                                                                    Ty.associated
                                                                  ]
                                                              ],
                                                              "from_residual",
                                                              []
                                                            |),
                                                            [ M.read (| residual |) ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                      0
                                                    |) in
                                                  let val := M.copy (| γ0_0 |) in
                                                  val))
                                            ]
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
              match self.accounts.entry(address) {
                  Entry::Occupied(mut acc_entry) => {
                      let acc_entry = acc_entry.get_mut();
                      match acc_entry.storage.entry(index) {
                          Entry::Occupied(entry) => Ok( *entry.get()),
                          Entry::Vacant(entry) => {
                              if matches!(
                                  acc_entry.account_state,
                                  AccountState::StorageCleared | AccountState::NotExisting
                              ) {
                                  Ok(U256::ZERO)
                              } else {
                                  let slot = self.db.storage_ref(address, index)?;
                                  entry.insert(slot);
                                  Ok(slot)
                              }
                          }
                      }
                  }
                  Entry::Vacant(acc_entry) => {
                      // acc needs to be loaded for us to access slots.
                      let info = self.db.basic_ref(address)?;
                      let (account, value) = if info.is_some() {
                          let value = self.db.storage_ref(address, index)?;
                          let mut account: DbAccount = info.into();
                          account.storage.insert(index, value);
                          (account, value)
                      } else {
                          (info.into(), U256::ZERO)
                      };
                      acc_entry.insert(account);
                      Ok(value)
                  }
              }
          }
      *)
      Definition storage (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::collections::hash::map::HashMap")
                            [
                              Ty.path "alloy_primitives::bits::address::Address";
                              Ty.path "revm::db::in_memory_db::DbAccount";
                              Ty.path "std::hash::random::RandomState"
                            ],
                          "entry",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "revm::db::in_memory_db::CacheDB",
                            "accounts"
                          |);
                          M.read (| address |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Occupied",
                              0
                            |) in
                          let acc_entry := M.copy (| γ0_0 |) in
                          let~ acc_entry :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "std::collections::hash::map::OccupiedEntry")
                                    [
                                      Ty.path "alloy_primitives::bits::address::Address";
                                      Ty.path "revm::db::in_memory_db::DbAccount"
                                    ],
                                  "get_mut",
                                  []
                                |),
                                [ acc_entry ]
                              |)
                            |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "std::collections::hash::map::HashMap")
                                    [
                                      Ty.path "ruint::Uint";
                                      Ty.path "ruint::Uint";
                                      Ty.path "std::hash::random::RandomState"
                                    ],
                                  "entry",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| acc_entry |),
                                    "revm::db::in_memory_db::DbAccount",
                                    "storage"
                                  |);
                                  M.read (| index |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "std::collections::hash::map::Entry::Occupied",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      [
                                        M.read (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "std::collections::hash::map::OccupiedEntry")
                                                [ Ty.path "ruint::Uint"; Ty.path "ruint::Uint" ],
                                              "get",
                                              []
                                            |),
                                            [ entry ]
                                          |)
                                        |)
                                      ]
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "std::collections::hash::map::Entry::Vacant",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.match_operator (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| acc_entry |),
                                                  "revm::db::in_memory_db::DbAccount",
                                                  "account_state"
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.find_or_pattern (|
                                                        γ,
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ,
                                                                  "revm::db::in_memory_db::AccountState::StorageCleared"
                                                                |) in
                                                              Value.Tuple []));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ,
                                                                  "revm::db::in_memory_db::AccountState::NotExisting"
                                                                |) in
                                                              Value.Tuple []))
                                                        ],
                                                        M.closure
                                                          (fun γ =>
                                                            ltac:(M.monadic
                                                              match γ with
                                                              | [] =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (| Value.Bool true |)))
                                                              | _ =>
                                                                M.impossible
                                                                  "wrong number of arguments"
                                                              end))
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (| Value.Bool false |)))
                                                ]
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            Value.StructTuple
                                              "core::result::Result::Ok"
                                              [ M.read (| M.get_constant (| "ruint::ZERO" |) |) ]
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let~ slot :=
                                            M.copy (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [ Ty.path "ruint::Uint"; Ty.associated ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "revm_primitives::db::DatabaseRef",
                                                          ExtDB,
                                                          [],
                                                          "storage_ref",
                                                          []
                                                        |),
                                                        [
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| self |),
                                                            "revm::db::in_memory_db::CacheDB",
                                                            "db"
                                                          |);
                                                          M.read (| address |);
                                                          M.read (| index |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.path "ruint::Uint";
                                                                      Ty.associated
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.associated
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "std::collections::hash::map::VacantEntry")
                                                    [ Ty.path "ruint::Uint"; Ty.path "ruint::Uint"
                                                    ],
                                                  "insert",
                                                  []
                                                |),
                                                [ M.read (| entry |); M.read (| slot |) ]
                                              |)
                                            |) in
                                          M.alloc (|
                                            Value.StructTuple
                                              "core::result::Result::Ok"
                                              [ M.read (| slot |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Vacant",
                              0
                            |) in
                          let acc_entry := M.copy (| γ0_0 |) in
                          let~ info :=
                            M.copy (|
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::Try",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "revm_primitives::state::AccountInfo" ];
                                          Ty.associated
                                        ],
                                      [],
                                      "branch",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "revm_primitives::db::DatabaseRef",
                                          ExtDB,
                                          [],
                                          "basic_ref",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "revm::db::in_memory_db::CacheDB",
                                            "db"
                                          |);
                                          M.read (| address |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Break",
                                          0
                                        |) in
                                      let residual := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [ Ty.path "ruint::Uint"; Ty.associated ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.associated
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Continue",
                                          0
                                        |) in
                                      let val := M.copy (| γ0_0 |) in
                                      val))
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.path "revm_primitives::state::AccountInfo" ],
                                              "is_some",
                                              []
                                            |),
                                            [ info ]
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ value :=
                                      M.copy (|
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [ Ty.path "ruint::Uint"; Ty.associated ],
                                                [],
                                                "branch",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "revm_primitives::db::DatabaseRef",
                                                    ExtDB,
                                                    [],
                                                    "storage_ref",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "revm::db::in_memory_db::CacheDB",
                                                      "db"
                                                    |);
                                                    M.read (| address |);
                                                    M.read (| index |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [ Ty.path "ruint::Uint"; Ty.associated
                                                              ],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "core::convert::Infallible";
                                                                  Ty.associated
                                                                ]
                                                            ],
                                                            "from_residual",
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |)
                                      |) in
                                    let~ account :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::convert::Into",
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "revm_primitives::state::AccountInfo" ],
                                            [ Ty.path "revm::db::in_memory_db::DbAccount" ],
                                            "into",
                                            []
                                          |),
                                          [ M.read (| info |) ]
                                        |)
                                      |) in
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "std::collections::hash::map::HashMap")
                                              [
                                                Ty.path "ruint::Uint";
                                                Ty.path "ruint::Uint";
                                                Ty.path "std::hash::random::RandomState"
                                              ],
                                            "insert",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              account,
                                              "revm::db::in_memory_db::DbAccount",
                                              "storage"
                                            |);
                                            M.read (| index |);
                                            M.read (| value |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (|
                                      Value.Tuple [ M.read (| account |); M.read (| value |) ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      Value.Tuple
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::Into",
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.path "revm_primitives::state::AccountInfo" ],
                                              [ Ty.path "revm::db::in_memory_db::DbAccount" ],
                                              "into",
                                              []
                                            |),
                                            [ M.read (| info |) ]
                                          |);
                                          M.read (| M.get_constant (| "ruint::ZERO" |) |)
                                        ]
                                    |)))
                              ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let account := M.copy (| γ0_0 |) in
                                  let value := M.copy (| γ0_1 |) in
                                  let~ _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "std::collections::hash::map::VacantEntry")
                                            [
                                              Ty.path "alloy_primitives::bits::address::Address";
                                              Ty.path "revm::db::in_memory_db::DbAccount"
                                            ],
                                          "insert",
                                          []
                                        |),
                                        [ M.read (| acc_entry |); M.read (| account |) ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      [ M.read (| value |) ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn block_hash(&mut self, number: U256) -> Result<B256, Self::Error> {
              match self.block_hashes.entry(number) {
                  Entry::Occupied(entry) => Ok( *entry.get()),
                  Entry::Vacant(entry) => {
                      let hash = self.db.block_hash_ref(number)?;
                      entry.insert(hash);
                      Ok(hash)
                  }
              }
          }
      *)
      Definition block_hash (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "std::collections::hash::map::HashMap")
                            [
                              Ty.path "ruint::Uint";
                              Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                              Ty.path "std::hash::random::RandomState"
                            ],
                          "entry",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "revm::db::in_memory_db::CacheDB",
                            "block_hashes"
                          |);
                          M.read (| number |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Occupied",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                M.read (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "std::collections::hash::map::OccupiedEntry")
                                        [
                                          Ty.path "ruint::Uint";
                                          Ty.path "alloy_primitives::bits::fixed::FixedBytes"
                                        ],
                                      "get",
                                      []
                                    |),
                                    [ entry ]
                                  |)
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "std::collections::hash::map::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          let~ hash :=
                            M.copy (|
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::Try",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                                          Ty.associated
                                        ],
                                      [],
                                      "branch",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "revm_primitives::db::DatabaseRef",
                                          ExtDB,
                                          [],
                                          "block_hash_ref",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "revm::db::in_memory_db::CacheDB",
                                            "db"
                                          |);
                                          M.read (| number |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Break",
                                          0
                                        |) in
                                      let residual := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path
                                                        "alloy_primitives::bits::fixed::FixedBytes";
                                                      Ty.associated
                                                    ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.associated
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Continue",
                                          0
                                        |) in
                                      let val := M.copy (| γ0_0 |) in
                                      val))
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "std::collections::hash::map::VacantEntry")
                                    [
                                      Ty.path "ruint::Uint";
                                      Ty.path "alloy_primitives::bits::fixed::FixedBytes"
                                    ],
                                  "insert",
                                  []
                                |),
                                [ M.read (| entry |); M.read (| hash |) ]
                              |)
                            |) in
                          M.alloc (|
                            Value.StructTuple "core::result::Result::Ok" [ M.read (| hash |) ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (ExtDB : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::Database"
          (Self ExtDB)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error ExtDB));
            ("basic", InstanceField.Method (basic ExtDB));
            ("code_by_hash", InstanceField.Method (code_by_hash ExtDB));
            ("storage", InstanceField.Method (storage ExtDB));
            ("block_hash", InstanceField.Method (block_hash ExtDB))
          ].
    End Impl_revm_primitives_db_Database_where_revm_primitives_db_DatabaseRef_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
    
    Module Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
      Definition Self (ExtDB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "revm::db::in_memory_db::CacheDB") [ ExtDB ].
      
      (*     type Error = ExtDB::Error; *)
      Definition _Error (ExtDB : Ty.t) : Ty.t := Ty.associated.
      
      (*
          fn basic_ref(&self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
              match self.accounts.get(&address) {
                  Some(acc) => Ok(acc.info()),
                  None => self.db.basic_ref(address),
              }
          }
      *)
      Definition basic_ref (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::address::Address";
                          Ty.path "revm::db::in_memory_db::DbAccount";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      "get",
                      [ Ty.path "alloy_primitives::bits::address::Address" ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "accounts"
                      |);
                      address
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let acc := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "revm::db::in_memory_db::DbAccount",
                                "info",
                                []
                              |),
                              [ M.read (| acc |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_primitives::db::DatabaseRef",
                            ExtDB,
                            [],
                            "basic_ref",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm::db::in_memory_db::CacheDB",
                              "db"
                            |);
                            M.read (| address |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn code_by_hash_ref(&self, code_hash: B256) -> Result<Bytecode, Self::Error> {
              match self.contracts.get(&code_hash) {
                  Some(entry) => Ok(entry.clone()),
                  None => self.db.code_by_hash_ref(code_hash),
              }
          }
      *)
      Definition code_by_hash_ref (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                          Ty.path "revm_primitives::bytecode::Bytecode";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      "get",
                      [ Ty.path "alloy_primitives::bits::fixed::FixedBytes" ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "contracts"
                      |);
                      code_hash
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let entry := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_primitives::bytecode::Bytecode",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| entry |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_primitives::db::DatabaseRef",
                            ExtDB,
                            [],
                            "code_by_hash_ref",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm::db::in_memory_db::CacheDB",
                              "db"
                            |);
                            M.read (| code_hash |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn storage_ref(&self, address: Address, index: U256) -> Result<U256, Self::Error> {
              match self.accounts.get(&address) {
                  Some(acc_entry) => match acc_entry.storage.get(&index) {
                      Some(entry) => Ok( *entry),
                      None => {
                          if matches!(
                              acc_entry.account_state,
                              AccountState::StorageCleared | AccountState::NotExisting
                          ) {
                              Ok(U256::ZERO)
                          } else {
                              self.db.storage_ref(address, index)
                          }
                      }
                  },
                  None => self.db.storage_ref(address, index),
              }
          }
      *)
      Definition storage_ref (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "alloy_primitives::bits::address::Address";
                          Ty.path "revm::db::in_memory_db::DbAccount";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      "get",
                      [ Ty.path "alloy_primitives::bits::address::Address" ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "accounts"
                      |);
                      address
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let acc_entry := M.copy (| γ0_0 |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "std::collections::hash::map::HashMap")
                                [
                                  Ty.path "ruint::Uint";
                                  Ty.path "ruint::Uint";
                                  Ty.path "std::hash::random::RandomState"
                                ],
                              "get",
                              [ Ty.path "ruint::Uint" ]
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| acc_entry |),
                                "revm::db::in_memory_db::DbAccount",
                                "storage"
                              |);
                              index
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let entry := M.copy (| γ0_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Ok"
                                  [ M.read (| M.read (| entry |) |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.match_operator (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| acc_entry |),
                                              "revm::db::in_memory_db::DbAccount",
                                              "account_state"
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.find_or_pattern (|
                                                    γ,
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "revm::db::in_memory_db::AccountState::StorageCleared"
                                                            |) in
                                                          Value.Tuple []));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let _ :=
                                                            M.is_struct_tuple (|
                                                              γ,
                                                              "revm::db::in_memory_db::AccountState::NotExisting"
                                                            |) in
                                                          Value.Tuple []))
                                                    ],
                                                    M.closure
                                                      (fun γ =>
                                                        ltac:(M.monadic
                                                          match γ with
                                                          | [] =>
                                                            ltac:(M.monadic
                                                              (M.alloc (| Value.Bool true |)))
                                                          | _ =>
                                                            M.impossible "wrong number of arguments"
                                                          end))
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                                            ]
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        Value.StructTuple
                                          "core::result::Result::Ok"
                                          [ M.read (| M.get_constant (| "ruint::ZERO" |) |) ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "revm_primitives::db::DatabaseRef",
                                            ExtDB,
                                            [],
                                            "storage_ref",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "revm::db::in_memory_db::CacheDB",
                                              "db"
                                            |);
                                            M.read (| address |);
                                            M.read (| index |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_primitives::db::DatabaseRef",
                            ExtDB,
                            [],
                            "storage_ref",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm::db::in_memory_db::CacheDB",
                              "db"
                            |);
                            M.read (| address |);
                            M.read (| index |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn block_hash_ref(&self, number: U256) -> Result<B256, Self::Error> {
              match self.block_hashes.get(&number) {
                  Some(entry) => Ok( *entry),
                  None => self.db.block_hash_ref(number),
              }
          }
      *)
      Definition block_hash_ref (ExtDB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self ExtDB in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "ruint::Uint";
                          Ty.path "alloy_primitives::bits::fixed::FixedBytes";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      "get",
                      [ Ty.path "ruint::Uint" ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::CacheDB",
                        "block_hashes"
                      |);
                      number
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let entry := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.read (| M.read (| entry |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_primitives::db::DatabaseRef",
                            ExtDB,
                            [],
                            "block_hash_ref",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm::db::in_memory_db::CacheDB",
                              "db"
                            |);
                            M.read (| number |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (ExtDB : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseRef"
          (Self ExtDB)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error ExtDB));
            ("basic_ref", InstanceField.Method (basic_ref ExtDB));
            ("code_by_hash_ref", InstanceField.Method (code_by_hash_ref ExtDB));
            ("storage_ref", InstanceField.Method (storage_ref ExtDB));
            ("block_hash_ref", InstanceField.Method (block_hash_ref ExtDB))
          ].
    End Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_ExtDB_for_revm_db_in_memory_db_CacheDB_ExtDB.
    
    (* StructRecord
      {
        name := "DbAccount";
        ty_params := [];
        fields :=
          [
            ("info", Ty.path "revm_primitives::state::AccountInfo");
            ("account_state", Ty.path "revm::db::in_memory_db::AccountState");
            ("storage",
              Ty.apply
                (Ty.path "std::collections::hash::map::HashMap")
                [
                  Ty.path "ruint::Uint";
                  Ty.path "ruint::Uint";
                  Ty.path "std::hash::random::RandomState"
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_for_revm_db_in_memory_db_DbAccount.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::DbAccount".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "DbAccount" |);
                M.read (| Value.String "info" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::db::in_memory_db::DbAccount",
                    "info"
                  |));
                M.read (| Value.String "account_state" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::db::in_memory_db::DbAccount",
                    "account_state"
                  |));
                M.read (| Value.String "storage" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm::db::in_memory_db::DbAccount",
                      "storage"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_revm_db_in_memory_db_DbAccount.
    
    Module Impl_core_clone_Clone_for_revm_db_in_memory_db_DbAccount.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::DbAccount".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "revm::db::in_memory_db::DbAccount"
              [
                ("info",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "revm_primitives::state::AccountInfo",
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::DbAccount",
                        "info"
                      |)
                    ]
                  |));
                ("account_state",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "revm::db::in_memory_db::AccountState",
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::DbAccount",
                        "account_state"
                      |)
                    ]
                  |));
                ("storage",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "ruint::Uint";
                          Ty.path "ruint::Uint";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::in_memory_db::DbAccount",
                        "storage"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_revm_db_in_memory_db_DbAccount.
    
    Module Impl_core_default_Default_for_revm_db_in_memory_db_DbAccount.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::DbAccount".
      
      (* Default *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "revm::db::in_memory_db::DbAccount"
              [
                ("info",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "revm_primitives::state::AccountInfo",
                      [],
                      "default",
                      []
                    |),
                    []
                  |));
                ("account_state",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "revm::db::in_memory_db::AccountState",
                      [],
                      "default",
                      []
                    |),
                    []
                  |));
                ("storage",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "ruint::Uint";
                          Ty.path "ruint::Uint";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      [],
                      "default",
                      []
                    |),
                    []
                  |))
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_revm_db_in_memory_db_DbAccount.
    
    Module Impl_revm_db_in_memory_db_DbAccount.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::DbAccount".
      
      (*
          pub fn new_not_existing() -> Self {
              Self {
                  account_state: AccountState::NotExisting,
                  ..Default::default()
              }
          }
      *)
      Definition new_not_existing (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.struct_record_update
              (M.call_closure (|
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "revm::db::in_memory_db::DbAccount",
                  [],
                  "default",
                  []
                |),
                []
              |))
              [
                ("account_state",
                  Value.StructTuple "revm::db::in_memory_db::AccountState::NotExisting" [])
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_not_existing :
        M.IsAssociatedFunction Self "new_not_existing" new_not_existing.
      
      (*
          pub fn info(&self) -> Option<AccountInfo> {
              if matches!(self.account_state, AccountState::NotExisting) {
                  None
              } else {
                  Some(self.info.clone())
              }
          }
      *)
      Definition info (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.match_operator (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm::db::in_memory_db::DbAccount",
                              "account_state"
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm::db::in_memory_db::AccountState::NotExisting"
                                    |) in
                                  M.alloc (| Value.Bool true |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                            ]
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_primitives::state::AccountInfo",
                                [],
                                "clone",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "revm::db::in_memory_db::DbAccount",
                                  "info"
                                |)
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_info : M.IsAssociatedFunction Self "info" info.
    End Impl_revm_db_in_memory_db_DbAccount.
    
    Module Impl_core_convert_From_core_option_Option_revm_primitives_state_AccountInfo_for_revm_db_in_memory_db_DbAccount.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::DbAccount".
      
      (*
          fn from(from: Option<AccountInfo>) -> Self {
              from.map(Self::from).unwrap_or_else(Self::new_not_existing)
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ from ] =>
          ltac:(M.monadic
            (let from := M.alloc (| from |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  [ Ty.path "revm::db::in_memory_db::DbAccount" ],
                "unwrap_or_else",
                [ Ty.function [] (Ty.path "revm::db::in_memory_db::DbAccount") ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "revm_primitives::state::AccountInfo" ],
                    "map",
                    [
                      Ty.path "revm::db::in_memory_db::DbAccount";
                      Ty.function
                        [ Ty.path "revm_primitives::state::AccountInfo" ]
                        (Ty.path "revm::db::in_memory_db::DbAccount")
                    ]
                  |),
                  [
                    M.read (| from |);
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.path "revm::db::in_memory_db::DbAccount",
                      [ Ty.path "revm_primitives::state::AccountInfo" ],
                      "from",
                      []
                    |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "revm::db::in_memory_db::DbAccount",
                  "new_not_existing",
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *)
          [
            (* T *)
            Ty.apply
              (Ty.path "core::option::Option")
              [ Ty.path "revm_primitives::state::AccountInfo" ]
          ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_option_Option_revm_primitives_state_AccountInfo_for_revm_db_in_memory_db_DbAccount.
    
    Module Impl_core_convert_From_revm_primitives_state_AccountInfo_for_revm_db_in_memory_db_DbAccount.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::DbAccount".
      
      (*
          fn from(info: AccountInfo) -> Self {
              Self {
                  info,
                  account_state: AccountState::None,
                  ..Default::default()
              }
          }
      *)
      Definition from (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ info ] =>
          ltac:(M.monadic
            (let info := M.alloc (| info |) in
            M.struct_record_update
              (M.call_closure (|
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "revm::db::in_memory_db::DbAccount",
                  [],
                  "default",
                  []
                |),
                []
              |))
              [
                ("info", M.read (| info |));
                ("account_state", Value.StructTuple "revm::db::in_memory_db::AccountState::None" [])
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          Self
          (* Trait polymorphic types *) [ (* T *) Ty.path "revm_primitives::state::AccountInfo" ]
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_revm_primitives_state_AccountInfo_for_revm_db_in_memory_db_DbAccount.
    
    (*
    Enum AccountState
    {
      ty_params := [];
      variants :=
        [
          {
            name := "NotExisting";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Touched";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "StorageCleared";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "None";
            item := StructTuple [];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_fmt_Debug_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [
                M.read (| f |);
                M.read (|
                  M.match_operator (|
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm::db::in_memory_db::AccountState::NotExisting"
                            |) in
                          M.alloc (| M.read (| Value.String "NotExisting" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm::db::in_memory_db::AccountState::Touched"
                            |) in
                          M.alloc (| M.read (| Value.String "Touched" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm::db::in_memory_db::AccountState::StorageCleared"
                            |) in
                          M.alloc (| M.read (| Value.String "StorageCleared" |) |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm::db::in_memory_db::AccountState::None"
                            |) in
                          M.alloc (| M.read (| Value.String "None" |) |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_core_clone_Clone_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm::db::in_memory_db::AccountState::NotExisting"
                        |) in
                      M.alloc (|
                        Value.StructTuple "revm::db::in_memory_db::AccountState::NotExisting" []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm::db::in_memory_db::AccountState::Touched"
                        |) in
                      M.alloc (|
                        Value.StructTuple "revm::db::in_memory_db::AccountState::Touched" []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm::db::in_memory_db::AccountState::StorageCleared"
                        |) in
                      M.alloc (|
                        Value.StructTuple "revm::db::in_memory_db::AccountState::StorageCleared" []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm::db::in_memory_db::AccountState::None" |) in
                      M.alloc (|
                        Value.StructTuple "revm::db::in_memory_db::AccountState::None" []
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_core_default_Default_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      (* Default *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic (Value.StructTuple "revm::db::in_memory_db::AccountState::None" []))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_core_marker_StructuralPartialEq_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_core_cmp_PartialEq_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ __self_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "revm::db::in_memory_db::AccountState" ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ __arg1_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "revm::db::in_memory_db::AccountState" ]
                    |),
                    [ M.read (| other |) ]
                  |)
                |) in
              M.alloc (| BinOp.eq (| M.read (| __self_tag |), M.read (| __arg1_tag |) |) |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_core_marker_StructuralEq_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_core_cmp_Eq_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_core_hash_Hash_for_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      (* Hash *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ __self_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "revm::db::in_memory_db::AccountState" ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_revm_db_in_memory_db_AccountState.
    
    Module Impl_revm_db_in_memory_db_AccountState.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::AccountState".
      
      (*
          pub fn is_storage_cleared(&self) -> bool {
              matches!(self, AccountState::StorageCleared)
          }
      *)
      Definition is_storage_cleared (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm::db::in_memory_db::AccountState::StorageCleared"
                        |) in
                      M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_storage_cleared :
        M.IsAssociatedFunction Self "is_storage_cleared" is_storage_cleared.
    End Impl_revm_db_in_memory_db_AccountState.
    
    (* StructTuple
      {
        name := "BenchmarkDB";
        ty_params := [];
        fields :=
          [
            Ty.path "revm_primitives::bytecode::Bytecode";
            Ty.path "alloy_primitives::bits::fixed::FixedBytes"
          ];
      } *)
    
    Module Impl_core_fmt_Debug_for_revm_db_in_memory_db_BenchmarkDB.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::BenchmarkDB".
      
      (* Debug *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_tuple_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "BenchmarkDB" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "revm::db::in_memory_db::BenchmarkDB",
                    0
                  |));
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "revm::db::in_memory_db::BenchmarkDB",
                      1
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_revm_db_in_memory_db_BenchmarkDB.
    
    Module Impl_core_default_Default_for_revm_db_in_memory_db_BenchmarkDB.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::BenchmarkDB".
      
      (* Default *)
      Definition default (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "revm::db::in_memory_db::BenchmarkDB"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "revm_primitives::bytecode::Bytecode",
                    [],
                    "default",
                    []
                  |),
                  []
                |);
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "alloy_primitives::bits::fixed::FixedBytes",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_revm_db_in_memory_db_BenchmarkDB.
    
    Module Impl_core_clone_Clone_for_revm_db_in_memory_db_BenchmarkDB.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::BenchmarkDB".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "revm::db::in_memory_db::BenchmarkDB"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "revm_primitives::bytecode::Bytecode",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "revm::db::in_memory_db::BenchmarkDB",
                      0
                    |)
                  ]
                |);
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloy_primitives::bits::fixed::FixedBytes",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_tuple_field (|
                      M.read (| self |),
                      "revm::db::in_memory_db::BenchmarkDB",
                      1
                    |)
                  ]
                |)
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_revm_db_in_memory_db_BenchmarkDB.
    
    Module Impl_revm_db_in_memory_db_BenchmarkDB.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::BenchmarkDB".
      
      (*
          pub fn new_bytecode(bytecode: Bytecode) -> Self {
              let hash = bytecode.hash_slow();
              Self(bytecode, hash)
          }
      *)
      Definition new_bytecode (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ bytecode ] =>
          ltac:(M.monadic
            (let bytecode := M.alloc (| bytecode |) in
            M.read (|
              let~ hash :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "revm_primitives::bytecode::Bytecode",
                      "hash_slow",
                      []
                    |),
                    [ bytecode ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "revm::db::in_memory_db::BenchmarkDB"
                  [ M.read (| bytecode |); M.read (| hash |) ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new_bytecode :
        M.IsAssociatedFunction Self "new_bytecode" new_bytecode.
    End Impl_revm_db_in_memory_db_BenchmarkDB.
    
    Module Impl_revm_primitives_db_Database_for_revm_db_in_memory_db_BenchmarkDB.
      Definition Self : Ty.t := Ty.path "revm::db::in_memory_db::BenchmarkDB".
      
      (*     type Error = Infallible; *)
      Definition _Error : Ty.t := Ty.path "core::convert::Infallible".
      
      (*
          fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
              if address == Address::ZERO {
                  return Ok(Some(AccountInfo {
                      nonce: 1,
                      balance: U256::from(10000000),
                      code: Some(self.0.clone()),
                      code_hash: self.1,
                  }));
              }
              if address == Address::with_last_byte(1) {
                  return Ok(Some(AccountInfo {
                      nonce: 0,
                      balance: U256::from(10000000),
                      code: None,
                      code_hash: KECCAK_EMPTY,
                  }));
              }
              Ok(None)
          }
      *)
      Definition basic (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.path "alloy_primitives::bits::address::Address",
                                      [ Ty.path "alloy_primitives::bits::address::Address" ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      address;
                                      M.get_constant (| "alloy_primitives::bits::address::ZERO" |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      [
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            Value.StructRecord
                                              "revm_primitives::state::AccountInfo"
                                              [
                                                ("nonce", Value.Integer IntegerKind.U64 1);
                                                ("balance",
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "ruint::Uint",
                                                      "from",
                                                      [ Ty.path "i32" ]
                                                    |),
                                                    [ Value.Integer IntegerKind.I32 10000000 ]
                                                  |));
                                                ("code",
                                                  Value.StructTuple
                                                    "core::option::Option::Some"
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::clone::Clone",
                                                          Ty.path
                                                            "revm_primitives::bytecode::Bytecode",
                                                          [],
                                                          "clone",
                                                          []
                                                        |),
                                                        [
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            M.read (| self |),
                                                            "revm::db::in_memory_db::BenchmarkDB",
                                                            0
                                                          |)
                                                        ]
                                                      |)
                                                    ]);
                                                ("code_hash",
                                                  M.read (|
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      M.read (| self |),
                                                      "revm::db::in_memory_db::BenchmarkDB",
                                                      1
                                                    |)
                                                  |))
                                              ]
                                          ]
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.path "alloy_primitives::bits::address::Address",
                                      [ Ty.path "alloy_primitives::bits::address::Address" ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      address;
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "alloy_primitives::bits::address::Address",
                                            "with_last_byte",
                                            []
                                          |),
                                          [ Value.Integer IntegerKind.U8 1 ]
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      [
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [
                                            Value.StructRecord
                                              "revm_primitives::state::AccountInfo"
                                              [
                                                ("nonce", Value.Integer IntegerKind.U64 0);
                                                ("balance",
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "ruint::Uint",
                                                      "from",
                                                      [ Ty.path "i32" ]
                                                    |),
                                                    [ Value.Integer IntegerKind.I32 10000000 ]
                                                  |));
                                                ("code",
                                                  Value.StructTuple
                                                    "core::option::Option::None"
                                                    []);
                                                ("code_hash",
                                                  M.read (|
                                                    M.get_constant (|
                                                      "revm_primitives::utilities::KECCAK_EMPTY"
                                                    |)
                                                  |))
                                              ]
                                          ]
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [ Value.StructTuple "core::option::Option::None" [] ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn code_by_hash(&mut self, _code_hash: B256) -> Result<Bytecode, Self::Error> {
              Ok(Bytecode::default())
          }
      *)
      Definition code_by_hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; _code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let _code_hash := M.alloc (| _code_hash |) in
            Value.StructTuple
              "core::result::Result::Ok"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "revm_primitives::bytecode::Bytecode",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn storage(&mut self, _address: Address, _index: U256) -> Result<U256, Self::Error> {
              Ok(U256::default())
          }
      *)
      Definition storage (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; _address; _index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let _address := M.alloc (| _address |) in
            let _index := M.alloc (| _index |) in
            Value.StructTuple
              "core::result::Result::Ok"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "ruint::Uint",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn block_hash(&mut self, _number: U256) -> Result<B256, Self::Error> {
              Ok(B256::default())
          }
      *)
      Definition block_hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; _number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let _number := M.alloc (| _number |) in
            Value.StructTuple
              "core::result::Result::Ok"
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "alloy_primitives::bits::fixed::FixedBytes",
                    [],
                    "default",
                    []
                  |),
                  []
                |)
              ]))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "revm_primitives::db::Database"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty _Error);
            ("basic", InstanceField.Method basic);
            ("code_by_hash", InstanceField.Method code_by_hash);
            ("storage", InstanceField.Method storage);
            ("block_hash", InstanceField.Method block_hash)
          ].
    End Impl_revm_primitives_db_Database_for_revm_db_in_memory_db_BenchmarkDB.
  End in_memory_db.
End db.
