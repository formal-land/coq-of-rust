(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module db.
  Module states.
    Module plain_account.
      (* StructRecord
        {
          name := "PlainAccount";
          ty_params := [];
          fields :=
            [
              ("info", Ty.path "revm_primitives::state::AccountInfo");
              ("storage",
                Ty.apply
                  (Ty.path "std::collections::hash::map::HashMap")
                  [
                    Ty.path "ruint::Uint";
                    Ty.path "ruint::Uint";
                    Ty.path "std::hash::random::RandomState"
                  ])
            ];
        } *)
      
      Module Impl_core_clone_Clone_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        (* Clone *)
        Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "revm::db::states::plain_account::PlainAccount"
                [
                  ("info",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "revm_primitives::state::AccountInfo",
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm::db::states::plain_account::PlainAccount",
                          "info"
                        |)
                      ]
                    |));
                  ("storage",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "std::collections::hash::map::HashMap")
                          [
                            Ty.path "ruint::Uint";
                            Ty.path "ruint::Uint";
                            Ty.path "std::hash::random::RandomState"
                          ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm::db::states::plain_account::PlainAccount",
                          "storage"
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_revm_db_states_plain_account_PlainAccount.
      
      Module Impl_core_fmt_Debug_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        (* Debug *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field2_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "PlainAccount" |);
                  M.read (| Value.String "info" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm::db::states::plain_account::PlainAccount",
                      "info"
                    |));
                  M.read (| Value.String "storage" |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::states::plain_account::PlainAccount",
                        "storage"
                      |)
                    |))
                ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_revm_db_states_plain_account_PlainAccount.
      
      Module Impl_core_default_Default_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        (* Default *)
        Definition default (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "revm::db::states::plain_account::PlainAccount"
                [
                  ("info",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "revm_primitives::state::AccountInfo",
                        [],
                        "default",
                        []
                      |),
                      []
                    |));
                  ("storage",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "std::collections::hash::map::HashMap")
                          [
                            Ty.path "ruint::Uint";
                            Ty.path "ruint::Uint";
                            Ty.path "std::hash::random::RandomState"
                          ],
                        [],
                        "default",
                        []
                      |),
                      []
                    |))
                ]))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::default::Default"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("default", InstanceField.Method default) ].
      End Impl_core_default_Default_for_revm_db_states_plain_account_PlainAccount.
      
      Module Impl_core_marker_StructuralPartialEq_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_revm_db_states_plain_account_PlainAccount.
      
      Module Impl_core_cmp_PartialEq_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        (* PartialEq *)
        Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              LogicalOp.and (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "revm_primitives::state::AccountInfo",
                    [ Ty.path "revm_primitives::state::AccountInfo" ],
                    "eq",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm::db::states::plain_account::PlainAccount",
                      "info"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "revm::db::states::plain_account::PlainAccount",
                      "info"
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.apply
                        (Ty.path "std::collections::hash::map::HashMap")
                        [
                          Ty.path "ruint::Uint";
                          Ty.path "ruint::Uint";
                          Ty.path "std::hash::random::RandomState"
                        ],
                      [
                        Ty.apply
                          (Ty.path "std::collections::hash::map::HashMap")
                          [
                            Ty.path "ruint::Uint";
                            Ty.path "ruint::Uint";
                            Ty.path "std::hash::random::RandomState"
                          ]
                      ],
                      "eq",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm::db::states::plain_account::PlainAccount",
                        "storage"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "revm::db::states::plain_account::PlainAccount",
                        "storage"
                      |)
                    ]
                  |)))
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_for_revm_db_states_plain_account_PlainAccount.
      
      Module Impl_core_marker_StructuralEq_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralEq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_StructuralEq_for_revm_db_states_plain_account_PlainAccount.
      
      Module Impl_core_cmp_Eq_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        (* Eq *)
        Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Value.DeclaredButUndefined,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Value.DeclaredButUndefined,
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::Eq"
            Self
            (* Trait polymorphic types *) []
            (* Instance *)
            [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
      End Impl_core_cmp_Eq_for_revm_db_states_plain_account_PlainAccount.
      
      Module Impl_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        (*
            pub fn new_empty_with_storage(storage: PlainStorage) -> Self {
                Self {
                    info: AccountInfo::default(),
                    storage,
                }
            }
        *)
        Definition new_empty_with_storage (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ storage ] =>
            ltac:(M.monadic
              (let storage := M.alloc (| storage |) in
              Value.StructRecord
                "revm::db::states::plain_account::PlainAccount"
                [
                  ("info",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "revm_primitives::state::AccountInfo",
                        [],
                        "default",
                        []
                      |),
                      []
                    |));
                  ("storage", M.read (| storage |))
                ]))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom AssociatedFunction_new_empty_with_storage :
          M.IsAssociatedFunction Self "new_empty_with_storage" new_empty_with_storage.
        
        (*
            pub fn into_components(self) -> (AccountInfo, PlainStorage) {
                (self.info, self.storage)
            }
        *)
        Definition into_components (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.Tuple
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "revm::db::states::plain_account::PlainAccount",
                      "info"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "revm::db::states::plain_account::PlainAccount",
                      "storage"
                    |)
                  |)
                ]))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom AssociatedFunction_into_components :
          M.IsAssociatedFunction Self "into_components" into_components.
      End Impl_revm_db_states_plain_account_PlainAccount.
      
      Axiom StorageWithOriginalValues :
        (Ty.path "revm::db::states::plain_account::StorageWithOriginalValues") =
          (Ty.apply
            (Ty.path "std::collections::hash::map::HashMap")
            [
              Ty.path "ruint::Uint";
              Ty.path "revm_primitives::state::StorageSlot";
              Ty.path "std::hash::random::RandomState"
            ]).
      
      Axiom PlainStorage :
        (Ty.path "revm::db::states::plain_account::PlainStorage") =
          (Ty.apply
            (Ty.path "std::collections::hash::map::HashMap")
            [ Ty.path "ruint::Uint"; Ty.path "ruint::Uint"; Ty.path "std::hash::random::RandomState"
            ]).
      
      Module Impl_core_convert_From_revm_primitives_state_AccountInfo_for_revm_db_states_plain_account_PlainAccount.
        Definition Self : Ty.t := Ty.path "revm::db::states::plain_account::PlainAccount".
        
        (*
            fn from(info: AccountInfo) -> Self {
                Self {
                    info,
                    storage: HashMap::new(),
                }
            }
        *)
        Definition from (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ info ] =>
            ltac:(M.monadic
              (let info := M.alloc (| info |) in
              Value.StructRecord
                "revm::db::states::plain_account::PlainAccount"
                [
                  ("info", M.read (| info |));
                  ("storage",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "std::collections::hash::map::HashMap")
                          [
                            Ty.path "ruint::Uint";
                            Ty.path "ruint::Uint";
                            Ty.path "std::hash::random::RandomState"
                          ],
                        "new",
                        []
                      |),
                      []
                    |))
                ]))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::From"
            Self
            (* Trait polymorphic types *) [ (* T *) Ty.path "revm_primitives::state::AccountInfo" ]
            (* Instance *) [ ("from", InstanceField.Method from) ].
      End Impl_core_convert_From_revm_primitives_state_AccountInfo_for_revm_db_states_plain_account_PlainAccount.
    End plain_account.
  End states.
End db.
