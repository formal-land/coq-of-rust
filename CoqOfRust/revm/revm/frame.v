(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module frame.
  (* StructRecord
    {
      name := "CallFrame";
      ty_params := [];
      fields :=
        [
          ("return_memory_range", Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ]);
          ("frame_data", Ty.path "revm::frame::FrameData")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_revm_frame_CallFrame.
    Definition Self : Ty.t := Ty.path "revm::frame::CallFrame".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "CallFrame" |);
              M.read (| Value.String "return_memory_range" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm::frame::CallFrame",
                  "return_memory_range"
                |));
              M.read (| Value.String "frame_data" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::frame::CallFrame",
                    "frame_data"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_frame_CallFrame.
  
  (* StructRecord
    {
      name := "CreateFrame";
      ty_params := [];
      fields :=
        [
          ("created_address", Ty.path "alloy_primitives::bits::address::Address");
          ("frame_data", Ty.path "revm::frame::FrameData")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_revm_frame_CreateFrame.
    Definition Self : Ty.t := Ty.path "revm::frame::CreateFrame".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "CreateFrame" |);
              M.read (| Value.String "created_address" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm::frame::CreateFrame",
                  "created_address"
                |));
              M.read (| Value.String "frame_data" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::frame::CreateFrame",
                    "frame_data"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_frame_CreateFrame.
  
  (* StructRecord
    {
      name := "EOFCreateFrame";
      ty_params := [];
      fields :=
        [
          ("created_address", Ty.path "alloy_primitives::bits::address::Address");
          ("return_memory_range", Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ]);
          ("frame_data", Ty.path "revm::frame::FrameData")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_revm_frame_EOFCreateFrame.
    Definition Self : Ty.t := Ty.path "revm::frame::EOFCreateFrame".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "EOFCreateFrame" |);
              M.read (| Value.String "created_address" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm::frame::EOFCreateFrame",
                  "created_address"
                |));
              M.read (| Value.String "return_memory_range" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm::frame::EOFCreateFrame",
                  "return_memory_range"
                |));
              M.read (| Value.String "frame_data" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::frame::EOFCreateFrame",
                    "frame_data"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_frame_EOFCreateFrame.
  
  (* StructRecord
    {
      name := "FrameData";
      ty_params := [];
      fields :=
        [
          ("checkpoint", Ty.path "revm::journaled_state::JournalCheckpoint");
          ("interpreter", Ty.path "revm_interpreter::interpreter::Interpreter")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_revm_frame_FrameData.
    Definition Self : Ty.t := Ty.path "revm::frame::FrameData".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "FrameData" |);
              M.read (| Value.String "checkpoint" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm::frame::FrameData",
                  "checkpoint"
                |));
              M.read (| Value.String "interpreter" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm::frame::FrameData",
                    "interpreter"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_frame_FrameData.
  
  (*
  Enum Frame
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Call";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.path "revm::frame::CallFrame"; Ty.path "alloc::alloc::Global" ]
              ];
          discriminant := None;
        };
        {
          name := "Create";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.path "revm::frame::CreateFrame"; Ty.path "alloc::alloc::Global" ]
              ];
          discriminant := None;
        };
        {
          name := "EOFCreate";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.path "revm::frame::EOFCreateFrame"; Ty.path "alloc::alloc::Global" ]
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_frame_Frame.
    Definition Self : Ty.t := Ty.path "revm::frame::Frame".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "revm::frame::Frame::Call", 0 |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Call" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::Create",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Create" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::EOFCreate",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "EOFCreate" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_frame_Frame.
  
  (*
  Enum FrameResult
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Call";
          item :=
            StructTuple
              [ Ty.path "revm_interpreter::interpreter_action::call_outcome::CallOutcome" ];
          discriminant := None;
        };
        {
          name := "Create";
          item :=
            StructTuple
              [ Ty.path "revm_interpreter::interpreter_action::create_outcome::CreateOutcome" ];
          discriminant := None;
        };
        {
          name := "EOFCreate";
          item :=
            StructTuple
              [ Ty.path "revm_interpreter::interpreter_action::eof_create_outcome::EOFCreateOutcome"
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_revm_frame_FrameResult.
    Definition Self : Ty.t := Ty.path "revm::frame::FrameResult".
    
    (*
        pub fn into_interpreter_result(self) -> InterpreterResult {
            match self {
                FrameResult::Call(outcome) => outcome.result,
                FrameResult::Create(outcome) => outcome.result,
                FrameResult::EOFCreate(outcome) => outcome.result,
            }
        }
    *)
    Definition into_interpreter_result (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Call",
                        0
                      |) in
                    let outcome := M.copy (| γ0_0 |) in
                    M.SubPointer.get_struct_record_field (|
                      outcome,
                      "revm_interpreter::interpreter_action::call_outcome::CallOutcome",
                      "result"
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Create",
                        0
                      |) in
                    let outcome := M.copy (| γ0_0 |) in
                    M.SubPointer.get_struct_record_field (|
                      outcome,
                      "revm_interpreter::interpreter_action::create_outcome::CreateOutcome",
                      "result"
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::EOFCreate",
                        0
                      |) in
                    let outcome := M.copy (| γ0_0 |) in
                    M.SubPointer.get_struct_record_field (|
                      outcome,
                      "revm_interpreter::interpreter_action::eof_create_outcome::EOFCreateOutcome",
                      "result"
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_interpreter_result :
      M.IsAssociatedFunction Self "into_interpreter_result" into_interpreter_result.
    
    (*
        pub fn output(&self) -> Output {
            match self {
                FrameResult::Call(outcome) => Output::Call(outcome.result.output.clone()),
                FrameResult::Create(outcome) => {
                    Output::Create(outcome.result.output.clone(), outcome.address)
                }
                FrameResult::EOFCreate(_) => {
                    panic!("EOFCreate can't be called from external world.");
                }
            }
        }
    *)
    Definition output (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Call",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::Output::Call"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              "clone",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| outcome |),
                                  "revm_interpreter::interpreter_action::call_outcome::CallOutcome",
                                  "result"
                                |),
                                "revm_interpreter::interpreter::InterpreterResult",
                                "output"
                              |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Create",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_primitives::result::Output::Create"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              "clone",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| outcome |),
                                  "revm_interpreter::interpreter_action::create_outcome::CreateOutcome",
                                  "result"
                                |),
                                "revm_interpreter::interpreter::InterpreterResult",
                                "output"
                              |)
                            ]
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| outcome |),
                              "revm_interpreter::interpreter_action::create_outcome::CreateOutcome",
                              "address"
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::EOFCreate",
                        0
                      |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.read (|
                                          Value.String
                                            "EOFCreate can't be called from external world."
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_output : M.IsAssociatedFunction Self "output" output.
    
    (*
        pub fn gas(&self) -> &Gas {
            match self {
                FrameResult::Call(outcome) => &outcome.result.gas,
                FrameResult::Create(outcome) => &outcome.result.gas,
                FrameResult::EOFCreate(outcome) => &outcome.result.gas,
            }
        }
    *)
    Definition gas (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Call",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| outcome |),
                          "revm_interpreter::interpreter_action::call_outcome::CallOutcome",
                          "result"
                        |),
                        "revm_interpreter::interpreter::InterpreterResult",
                        "gas"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Create",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| outcome |),
                          "revm_interpreter::interpreter_action::create_outcome::CreateOutcome",
                          "result"
                        |),
                        "revm_interpreter::interpreter::InterpreterResult",
                        "gas"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::EOFCreate",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| outcome |),
                          "revm_interpreter::interpreter_action::eof_create_outcome::EOFCreateOutcome",
                          "result"
                        |),
                        "revm_interpreter::interpreter::InterpreterResult",
                        "gas"
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_gas : M.IsAssociatedFunction Self "gas" gas.
    
    (*
        pub fn gas_mut(&mut self) -> &mut Gas {
            match self {
                FrameResult::Call(outcome) => &mut outcome.result.gas,
                FrameResult::Create(outcome) => &mut outcome.result.gas,
                FrameResult::EOFCreate(outcome) => &mut outcome.result.gas,
            }
        }
    *)
    Definition gas_mut (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Call",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| outcome |),
                          "revm_interpreter::interpreter_action::call_outcome::CallOutcome",
                          "result"
                        |),
                        "revm_interpreter::interpreter::InterpreterResult",
                        "gas"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Create",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| outcome |),
                          "revm_interpreter::interpreter_action::create_outcome::CreateOutcome",
                          "result"
                        |),
                        "revm_interpreter::interpreter::InterpreterResult",
                        "gas"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::EOFCreate",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| outcome |),
                          "revm_interpreter::interpreter_action::eof_create_outcome::EOFCreateOutcome",
                          "result"
                        |),
                        "revm_interpreter::interpreter::InterpreterResult",
                        "gas"
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_gas_mut : M.IsAssociatedFunction Self "gas_mut" gas_mut.
    
    (*
        pub fn interpreter_result(&self) -> &InterpreterResult {
            match self {
                FrameResult::Call(outcome) => &outcome.result,
                FrameResult::Create(outcome) => &outcome.result,
                FrameResult::EOFCreate(outcome) => &outcome.result,
            }
        }
    *)
    Definition interpreter_result (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Call",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| outcome |),
                        "revm_interpreter::interpreter_action::call_outcome::CallOutcome",
                        "result"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Create",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| outcome |),
                        "revm_interpreter::interpreter_action::create_outcome::CreateOutcome",
                        "result"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::EOFCreate",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| outcome |),
                        "revm_interpreter::interpreter_action::eof_create_outcome::EOFCreateOutcome",
                        "result"
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_interpreter_result :
      M.IsAssociatedFunction Self "interpreter_result" interpreter_result.
    
    (*
        pub fn interpreter_result_mut(&mut self) -> &InterpreterResult {
            match self {
                FrameResult::Call(outcome) => &mut outcome.result,
                FrameResult::Create(outcome) => &mut outcome.result,
                FrameResult::EOFCreate(outcome) => &mut outcome.result,
            }
        }
    *)
    Definition interpreter_result_mut (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Call",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| outcome |),
                        "revm_interpreter::interpreter_action::call_outcome::CallOutcome",
                        "result"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::Create",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| outcome |),
                        "revm_interpreter::interpreter_action::create_outcome::CreateOutcome",
                        "result"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::FrameResult::EOFCreate",
                        0
                      |) in
                    let outcome := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| outcome |),
                        "revm_interpreter::interpreter_action::eof_create_outcome::EOFCreateOutcome",
                        "result"
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_interpreter_result_mut :
      M.IsAssociatedFunction Self "interpreter_result_mut" interpreter_result_mut.
    
    (*
        pub fn instruction_result(&self) -> InstructionResult {
            self.interpreter_result().result
        }
    *)
    Definition instruction_result (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "revm::frame::FrameResult",
                  "interpreter_result",
                  []
                |),
                [ M.read (| self |) ]
              |),
              "revm_interpreter::interpreter::InterpreterResult",
              "result"
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_instruction_result :
      M.IsAssociatedFunction Self "instruction_result" instruction_result.
  End Impl_revm_frame_FrameResult.
  
  (*
  Enum FrameOrResult
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Frame";
          item := StructTuple [ Ty.path "revm::frame::Frame" ];
          discriminant := None;
        };
        {
          name := "Result";
          item := StructTuple [ Ty.path "revm::frame::FrameResult" ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_revm_frame_Frame.
    Definition Self : Ty.t := Ty.path "revm::frame::Frame".
    
    (*
        pub fn new_create(
            created_address: Address,
            checkpoint: JournalCheckpoint,
            interpreter: Interpreter,
        ) -> Self {
            Frame::Create(Box::new(CreateFrame {
                created_address,
                frame_data: FrameData {
                    checkpoint,
                    interpreter,
                },
            }))
        }
    *)
    Definition new_create (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ created_address; checkpoint; interpreter ] =>
        ltac:(M.monadic
          (let created_address := M.alloc (| created_address |) in
          let checkpoint := M.alloc (| checkpoint |) in
          let interpreter := M.alloc (| interpreter |) in
          Value.StructTuple
            "revm::frame::Frame::Create"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.path "revm::frame::CreateFrame"; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [
                  Value.StructRecord
                    "revm::frame::CreateFrame"
                    [
                      ("created_address", M.read (| created_address |));
                      ("frame_data",
                        Value.StructRecord
                          "revm::frame::FrameData"
                          [
                            ("checkpoint", M.read (| checkpoint |));
                            ("interpreter", M.read (| interpreter |))
                          ])
                    ]
                ]
              |)
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_create : M.IsAssociatedFunction Self "new_create" new_create.
    
    (*
        pub fn new_call(
            return_memory_range: Range<usize>,
            checkpoint: JournalCheckpoint,
            interpreter: Interpreter,
        ) -> Self {
            Frame::Call(Box::new(CallFrame {
                return_memory_range,
                frame_data: FrameData {
                    checkpoint,
                    interpreter,
                },
            }))
        }
    *)
    Definition new_call (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ return_memory_range; checkpoint; interpreter ] =>
        ltac:(M.monadic
          (let return_memory_range := M.alloc (| return_memory_range |) in
          let checkpoint := M.alloc (| checkpoint |) in
          let interpreter := M.alloc (| interpreter |) in
          Value.StructTuple
            "revm::frame::Frame::Call"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.path "revm::frame::CallFrame"; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [
                  Value.StructRecord
                    "revm::frame::CallFrame"
                    [
                      ("return_memory_range", M.read (| return_memory_range |));
                      ("frame_data",
                        Value.StructRecord
                          "revm::frame::FrameData"
                          [
                            ("checkpoint", M.read (| checkpoint |));
                            ("interpreter", M.read (| interpreter |))
                          ])
                    ]
                ]
              |)
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_call : M.IsAssociatedFunction Self "new_call" new_call.
    
    (*
        pub fn is_call(&self) -> bool {
            matches!(self, Frame::Call { .. })
        }
    *)
    Definition is_call (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ := M.is_struct_tuple (| γ, "revm::frame::Frame::Call" |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_call : M.IsAssociatedFunction Self "is_call" is_call.
    
    (*
        pub fn is_create(&self) -> bool {
            matches!(self, Frame::Create { .. })
        }
    *)
    Definition is_create (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ := M.is_struct_tuple (| γ, "revm::frame::Frame::Create" |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_create : M.IsAssociatedFunction Self "is_create" is_create.
    
    (*
        pub fn created_address(&self) -> Option<Address> {
            match self {
                Frame::Create(create_frame) => Some(create_frame.created_address),
                _ => None,
            }
        }
    *)
    Definition created_address (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::Create",
                        0
                      |) in
                    let create_frame := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| M.read (| create_frame |) |),
                              "revm::frame::CreateFrame",
                              "created_address"
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_created_address :
      M.IsAssociatedFunction Self "created_address" created_address.
    
    (*
        pub fn into_frame_data(self) -> FrameData {
            match self {
                Frame::Call(call_frame) => call_frame.frame_data,
                Frame::Create(create_frame) => create_frame.frame_data,
                Frame::EOFCreate(eof_create_frame) => eof_create_frame.frame_data,
            }
        }
    *)
    Definition into_frame_data (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "revm::frame::Frame::Call", 0 |) in
                    let call_frame := M.copy (| γ0_0 |) in
                    M.SubPointer.get_struct_record_field (|
                      M.read (| call_frame |),
                      "revm::frame::CallFrame",
                      "frame_data"
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::Create",
                        0
                      |) in
                    let create_frame := M.copy (| γ0_0 |) in
                    M.SubPointer.get_struct_record_field (|
                      M.read (| create_frame |),
                      "revm::frame::CreateFrame",
                      "frame_data"
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::EOFCreate",
                        0
                      |) in
                    let eof_create_frame := M.copy (| γ0_0 |) in
                    M.SubPointer.get_struct_record_field (|
                      M.read (| eof_create_frame |),
                      "revm::frame::EOFCreateFrame",
                      "frame_data"
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_frame_data :
      M.IsAssociatedFunction Self "into_frame_data" into_frame_data.
    
    (*
        pub fn frame_data(&self) -> &FrameData {
            match self {
                Self::Call(call_frame) => &call_frame.frame_data,
                Self::Create(create_frame) => &create_frame.frame_data,
                Self::EOFCreate(eof_create_frame) => &eof_create_frame.frame_data,
            }
        }
    *)
    Definition frame_data (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "revm::frame::Frame::Call", 0 |) in
                    let call_frame := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| M.read (| call_frame |) |),
                        "revm::frame::CallFrame",
                        "frame_data"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::Create",
                        0
                      |) in
                    let create_frame := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| M.read (| create_frame |) |),
                        "revm::frame::CreateFrame",
                        "frame_data"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::EOFCreate",
                        0
                      |) in
                    let eof_create_frame := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| M.read (| eof_create_frame |) |),
                        "revm::frame::EOFCreateFrame",
                        "frame_data"
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_frame_data : M.IsAssociatedFunction Self "frame_data" frame_data.
    
    (*
        pub fn frame_data_mut(&mut self) -> &mut FrameData {
            match self {
                Self::Call(call_frame) => &mut call_frame.frame_data,
                Self::Create(create_frame) => &mut create_frame.frame_data,
                Self::EOFCreate(eof_create_frame) => &mut eof_create_frame.frame_data,
            }
        }
    *)
    Definition frame_data_mut (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "revm::frame::Frame::Call", 0 |) in
                    let call_frame := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| M.read (| call_frame |) |),
                        "revm::frame::CallFrame",
                        "frame_data"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::Create",
                        0
                      |) in
                    let create_frame := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| M.read (| create_frame |) |),
                        "revm::frame::CreateFrame",
                        "frame_data"
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm::frame::Frame::EOFCreate",
                        0
                      |) in
                    let eof_create_frame := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| M.read (| eof_create_frame |) |),
                        "revm::frame::EOFCreateFrame",
                        "frame_data"
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_frame_data_mut :
      M.IsAssociatedFunction Self "frame_data_mut" frame_data_mut.
    
    (*
        pub fn interpreter(&self) -> &Interpreter {
            &self.frame_data().interpreter
        }
    *)
    Definition interpreter (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "revm::frame::Frame", "frame_data", [] |),
              [ M.read (| self |) ]
            |),
            "revm::frame::FrameData",
            "interpreter"
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_interpreter : M.IsAssociatedFunction Self "interpreter" interpreter.
    
    (*
        pub fn interpreter_mut(&mut self) -> &mut Interpreter {
            &mut self.frame_data_mut().interpreter
        }
    *)
    Definition interpreter_mut (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (| Ty.path "revm::frame::Frame", "frame_data_mut", [] |),
              [ M.read (| self |) ]
            |),
            "revm::frame::FrameData",
            "interpreter"
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_interpreter_mut :
      M.IsAssociatedFunction Self "interpreter_mut" interpreter_mut.
  End Impl_revm_frame_Frame.
  
  Module Impl_revm_frame_FrameOrResult.
    Definition Self : Ty.t := Ty.path "revm::frame::FrameOrResult".
    
    (*
        pub fn new_create_frame(
            created_address: Address,
            checkpoint: JournalCheckpoint,
            interpreter: Interpreter,
        ) -> Self {
            Self::Frame(Frame::new_create(created_address, checkpoint, interpreter))
        }
    *)
    Definition new_create_frame (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ created_address; checkpoint; interpreter ] =>
        ltac:(M.monadic
          (let created_address := M.alloc (| created_address |) in
          let checkpoint := M.alloc (| checkpoint |) in
          let interpreter := M.alloc (| interpreter |) in
          Value.StructTuple
            "revm::frame::FrameOrResult::Frame"
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "revm::frame::Frame", "new_create", [] |),
                [ M.read (| created_address |); M.read (| checkpoint |); M.read (| interpreter |) ]
              |)
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_create_frame :
      M.IsAssociatedFunction Self "new_create_frame" new_create_frame.
    
    (*
        pub fn new_eofcreate_frame(
            created_address: Address,
            return_memory_range: Range<usize>,
            checkpoint: JournalCheckpoint,
            interpreter: Interpreter,
        ) -> Self {
            Self::Frame(Frame::EOFCreate(Box::new(EOFCreateFrame {
                created_address,
                return_memory_range,
                frame_data: FrameData {
                    checkpoint,
                    interpreter,
                },
            })))
        }
    *)
    Definition new_eofcreate_frame (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ created_address; return_memory_range; checkpoint; interpreter ] =>
        ltac:(M.monadic
          (let created_address := M.alloc (| created_address |) in
          let return_memory_range := M.alloc (| return_memory_range |) in
          let checkpoint := M.alloc (| checkpoint |) in
          let interpreter := M.alloc (| interpreter |) in
          Value.StructTuple
            "revm::frame::FrameOrResult::Frame"
            [
              Value.StructTuple
                "revm::frame::Frame::EOFCreate"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [ Ty.path "revm::frame::EOFCreateFrame"; Ty.path "alloc::alloc::Global" ],
                      "new",
                      []
                    |),
                    [
                      Value.StructRecord
                        "revm::frame::EOFCreateFrame"
                        [
                          ("created_address", M.read (| created_address |));
                          ("return_memory_range", M.read (| return_memory_range |));
                          ("frame_data",
                            Value.StructRecord
                              "revm::frame::FrameData"
                              [
                                ("checkpoint", M.read (| checkpoint |));
                                ("interpreter", M.read (| interpreter |))
                              ])
                        ]
                    ]
                  |)
                ]
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_eofcreate_frame :
      M.IsAssociatedFunction Self "new_eofcreate_frame" new_eofcreate_frame.
    
    (*
        pub fn new_call_frame(
            return_memory_range: Range<usize>,
            checkpoint: JournalCheckpoint,
            interpreter: Interpreter,
        ) -> Self {
            Self::Frame(Frame::new_call(
                return_memory_range,
                checkpoint,
                interpreter,
            ))
        }
    *)
    Definition new_call_frame (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ return_memory_range; checkpoint; interpreter ] =>
        ltac:(M.monadic
          (let return_memory_range := M.alloc (| return_memory_range |) in
          let checkpoint := M.alloc (| checkpoint |) in
          let interpreter := M.alloc (| interpreter |) in
          Value.StructTuple
            "revm::frame::FrameOrResult::Frame"
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "revm::frame::Frame", "new_call", [] |),
                [
                  M.read (| return_memory_range |);
                  M.read (| checkpoint |);
                  M.read (| interpreter |)
                ]
              |)
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_call_frame :
      M.IsAssociatedFunction Self "new_call_frame" new_call_frame.
    
    (*
        pub fn new_create_result(
            interpreter_result: InterpreterResult,
            address: Option<Address>,
        ) -> Self {
            FrameOrResult::Result(FrameResult::Create(CreateOutcome {
                result: interpreter_result,
                address,
            }))
        }
    *)
    Definition new_create_result (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ interpreter_result; address ] =>
        ltac:(M.monadic
          (let interpreter_result := M.alloc (| interpreter_result |) in
          let address := M.alloc (| address |) in
          Value.StructTuple
            "revm::frame::FrameOrResult::Result"
            [
              Value.StructTuple
                "revm::frame::FrameResult::Create"
                [
                  Value.StructRecord
                    "revm_interpreter::interpreter_action::create_outcome::CreateOutcome"
                    [ ("result", M.read (| interpreter_result |)); ("address", M.read (| address |))
                    ]
                ]
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_create_result :
      M.IsAssociatedFunction Self "new_create_result" new_create_result.
    
    (*
        pub fn new_eofcreate_result(
            interpreter_result: InterpreterResult,
            address: Address,
            return_memory_range: Range<usize>,
        ) -> Self {
            FrameOrResult::Result(FrameResult::EOFCreate(EOFCreateOutcome {
                result: interpreter_result,
                address,
                return_memory_range,
            }))
        }
    *)
    Definition new_eofcreate_result (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ interpreter_result; address; return_memory_range ] =>
        ltac:(M.monadic
          (let interpreter_result := M.alloc (| interpreter_result |) in
          let address := M.alloc (| address |) in
          let return_memory_range := M.alloc (| return_memory_range |) in
          Value.StructTuple
            "revm::frame::FrameOrResult::Result"
            [
              Value.StructTuple
                "revm::frame::FrameResult::EOFCreate"
                [
                  Value.StructRecord
                    "revm_interpreter::interpreter_action::eof_create_outcome::EOFCreateOutcome"
                    [
                      ("result", M.read (| interpreter_result |));
                      ("address", M.read (| address |));
                      ("return_memory_range", M.read (| return_memory_range |))
                    ]
                ]
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_eofcreate_result :
      M.IsAssociatedFunction Self "new_eofcreate_result" new_eofcreate_result.
    
    (*
        pub fn new_call_result(
            interpreter_result: InterpreterResult,
            memory_offset: Range<usize>,
        ) -> Self {
            FrameOrResult::Result(FrameResult::Call(CallOutcome {
                result: interpreter_result,
                memory_offset,
            }))
        }
    *)
    Definition new_call_result (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ interpreter_result; memory_offset ] =>
        ltac:(M.monadic
          (let interpreter_result := M.alloc (| interpreter_result |) in
          let memory_offset := M.alloc (| memory_offset |) in
          Value.StructTuple
            "revm::frame::FrameOrResult::Result"
            [
              Value.StructTuple
                "revm::frame::FrameResult::Call"
                [
                  Value.StructRecord
                    "revm_interpreter::interpreter_action::call_outcome::CallOutcome"
                    [
                      ("result", M.read (| interpreter_result |));
                      ("memory_offset", M.read (| memory_offset |))
                    ]
                ]
            ]))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_call_result :
      M.IsAssociatedFunction Self "new_call_result" new_call_result.
  End Impl_revm_frame_FrameOrResult.
End frame.
