(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module legacy.
  Module analyzed.
    (* StructRecord
      {
        name := "LegacyAnalyzedBytecode";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("bytecode", Ty.path "alloy_primitives::bytes_::Bytes");
            ("original_len", Ty.path "usize");
            ("jump_table", Ty.path "revm_bytecode::legacy::jump_map::JumpTable")
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            Value.mkStructRecord
              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode"
              []
              []
              [
                ("bytecode",
                  M.call_closure (|
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "alloy_primitives::bytes_::Bytes",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "bytecode"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("original_len",
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "usize",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "original_len"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("jump_table",
                  M.call_closure (|
                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "jump_table"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_fmt_Debug_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "LegacyAnalyzedBytecode" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "bytecode" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "bytecode"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "original_len" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "jump_table" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "revm_bytecode::legacy::jump_map::JumpTable" ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "jump_table"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_marker_StructuralPartialEq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_PartialEq_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                other
              |) in
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    [],
                    [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "bytecode"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "bytecode"
                      |)
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                    [],
                    [ Ty.path "revm_bytecode::legacy::jump_map::JumpTable" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "jump_table"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "jump_table"
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_Eq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            M.match_operator (|
              Ty.tuple [],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.tuple [],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.tuple [],
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_hash_Hash_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "bytecode"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "usize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "original_len"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |) in
              M.alloc (|
                Ty.tuple [],
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "jump_table"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_Ord_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Ord *)
      Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                other
              |) in
            M.match_operator (|
              Ty.path "core::cmp::Ordering",
              M.alloc (|
                Ty.path "core::cmp::Ordering",
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "bytecode"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "bytecode"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.path "core::cmp::Ordering",
                      M.alloc (|
                        Ty.path "core::cmp::Ordering",
                        M.call_closure (|
                          Ty.path "core::cmp::Ordering",
                          M.get_trait_method (|
                            "core::cmp::Ord",
                            Ty.path "usize",
                            [],
                            [],
                            "cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                    "original_len"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                    "original_len"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                            M.call_closure (|
                              Ty.path "core::cmp::Ordering",
                              M.get_trait_method (|
                                "core::cmp::Ord",
                                Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                                [],
                                [],
                                "cmp",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                        "jump_table"
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| other |) |),
                                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                        "jump_table"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| Ty.path "core::cmp::Ordering", γ |) in
                            M.read (| cmp |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| Ty.path "core::cmp::Ordering", γ |) in
                    M.read (| cmp |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_PartialOrd_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* PartialOrd *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                other
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    [],
                    [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                    "partial_cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "bytecode"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "bytecode"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "core::cmp::Ordering" ],
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::cmp::Ordering" ],
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "usize",
                            [],
                            [ Ty.path "usize" ],
                            "partial_cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                    "original_len"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                    "original_len"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::cmp::Ordering" ],
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                                [],
                                [ Ty.path "revm_bytecode::legacy::jump_map::JumpTable" ],
                                "partial_cmp",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                        "jump_table"
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| other |) |),
                                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                        "jump_table"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::cmp::Ordering" ],
                                γ
                              |) in
                            M.read (| cmp |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        γ
                      |) in
                    M.read (| cmp |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_default_Default_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (*
          fn default() -> Self {
              Self {
                  bytecode: Bytes::from_static(&[0]),
                  original_len: 0,
                  jump_table: JumpTable(Arc::new(bitvec![u8, Lsb0; 0])),
              }
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode"
              []
              []
              [
                ("bytecode",
                  M.call_closure (|
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    M.get_associated_function (|
                      Ty.path "alloy_primitives::bytes_::Bytes",
                      "from_static",
                      [],
                      []
                    |),
                    [
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 1 ]
                                  [ Ty.path "u8" ],
                                Value.Array [ Value.Integer IntegerKind.U8 0 ]
                              |)
                            |)
                          |)
                        |))
                    ]
                  |));
                ("original_len", Value.Integer IntegerKind.Usize 0);
                ("jump_table",
                  Value.StructTuple
                    "revm_bytecode::legacy::jump_map::JumpTable"
                    []
                    []
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [
                            Ty.apply
                              (Ty.path "bitvec::vec::BitVec")
                              []
                              [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [
                              Ty.apply
                                (Ty.path "bitvec::vec::BitVec")
                                []
                                [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "bitvec::vec::BitVec")
                              []
                              [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "bitvec::vec::BitVec")
                                []
                                [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ],
                              "from_bitslice",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "bitvec::slice::BitSlice")
                                              []
                                              [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ]
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply
                                            (Ty.path "bitvec::array::BitArray")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.path "u8" ];
                                              Ty.path "bitvec::order::Lsb0"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeTo")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "bitvec::array::BitArray")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 1 ]
                                                    [ Ty.path "u8" ];
                                                  Ty.path "bitvec::order::Lsb0"
                                                ],
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "bitvec::array::BitArray")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "array")
                                                      [ Value.Integer IntegerKind.Usize 1 ]
                                                      [ Ty.path "u8" ];
                                                    Ty.path "bitvec::order::Lsb0"
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "bitvec::array::BitArray")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "array")
                                                        [ Value.Integer IntegerKind.Usize 1 ]
                                                        [ Ty.path "u8" ];
                                                      Ty.path "bitvec::order::Lsb0"
                                                    ],
                                                  "new",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  Value.Array
                                                    [
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "bitvec::mem::BitElement")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "bitvec::mem::BitElement")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "bitvec::mem::BitElement")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                "new",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (|
                                                                  get_constant (|
                                                                    "revm_bytecode::legacy::analyzed::default::ELEM",
                                                                    Ty.path "u8"
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          "bitvec::mem::BitElement",
                                                          "elem"
                                                        |)
                                                      |)
                                                    ]
                                                ]
                                              |)
                                            |)
                                          |);
                                          Value.mkStructRecord
                                            "core::ops::range::RangeTo"
                                            []
                                            [ Ty.path "usize" ]
                                            [
                                              ("end_",
                                                M.read (|
                                                  get_constant (|
                                                    "revm_bytecode::legacy::analyzed::default::BITS",
                                                    Ty.path "usize"
                                                  |)
                                                |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    ])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (*
          pub fn new(bytecode: Bytes, original_len: usize, jump_table: JumpTable) -> Self {
              Self {
                  bytecode,
                  original_len,
                  jump_table,
              }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ bytecode; original_len; jump_table ] =>
          ltac:(M.monadic
            (let bytecode := M.alloc (| Ty.path "alloy_primitives::bytes_::Bytes", bytecode |) in
            let original_len := M.alloc (| Ty.path "usize", original_len |) in
            let jump_table :=
              M.alloc (| Ty.path "revm_bytecode::legacy::jump_map::JumpTable", jump_table |) in
            Value.mkStructRecord
              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode"
              []
              []
              [
                ("bytecode", M.read (| bytecode |));
                ("original_len", M.read (| original_len |));
                ("jump_table", M.read (| jump_table |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn bytecode(&self) -> &Bytes {
              &self.bytecode
          }
      *)
      Definition bytecode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                    "bytecode"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bytecode :
        M.IsAssociatedFunction.C Self "bytecode" bytecode.
      Admitted.
      Global Typeclasses Opaque bytecode.
      
      (*
          pub fn original_len(&self) -> usize {
              self.original_len
          }
      *)
      Definition original_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                "original_len"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_original_len :
        M.IsAssociatedFunction.C Self "original_len" original_len.
      Admitted.
      Global Typeclasses Opaque original_len.
      
      (*
          pub fn original_bytes(&self) -> Bytes {
              self.bytecode.slice(..self.original_len)
          }
      *)
      Definition original_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bytes_::Bytes",
              M.get_associated_function (|
                Ty.path "alloy_primitives::bytes_::Bytes",
                "slice",
                [],
                [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                    "bytecode"
                  |)
                |);
                Value.mkStructRecord
                  "core::ops::range::RangeTo"
                  []
                  [ Ty.path "usize" ]
                  [
                    ("end_",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |))
                  ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_original_bytes :
        M.IsAssociatedFunction.C Self "original_bytes" original_bytes.
      Admitted.
      Global Typeclasses Opaque original_bytes.
      
      (*
          pub fn original_byte_slice(&self) -> &[u8] {
              &self.bytecode[..self.original_len]
          }
      *)
      Definition original_byte_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::ops::index::Index",
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ],
                        "index",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.path "bytes::bytes::Bytes",
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.path "alloy_primitives::bytes_::Bytes",
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                            "bytecode"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        Value.mkStructRecord
                          "core::ops::range::RangeTo"
                          []
                          [ Ty.path "usize" ]
                          [
                            ("end_",
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                  "original_len"
                                |)
                              |))
                          ]
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_original_byte_slice :
        M.IsAssociatedFunction.C Self "original_byte_slice" original_byte_slice.
      Admitted.
      Global Typeclasses Opaque original_byte_slice.
      
      (*
          pub fn jump_table(&self) -> &JumpTable {
              &self.jump_table
          }
      *)
      Definition jump_table (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                    "jump_table"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_jump_table :
        M.IsAssociatedFunction.C Self "jump_table" jump_table.
      Admitted.
      Global Typeclasses Opaque jump_table.
    End Impl_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
  End analyzed.
End legacy.
