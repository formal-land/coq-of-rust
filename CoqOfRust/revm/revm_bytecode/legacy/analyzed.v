(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module legacy.
  Module analyzed.
    (* StructRecord
      {
        name := "LegacyAnalyzedBytecode";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("bytecode", Ty.path "alloy_primitives::bytes_::Bytes");
            ("original_len", Ty.path "usize");
            ("jump_table", Ty.path "revm_bytecode::legacy::jump_map::JumpTable")
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode"
              [
                ("bytecode",
                  M.call_closure (|
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "alloy_primitives::bytes_::Bytes",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "bytecode"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("original_len",
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "usize",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "original_len"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("jump_table",
                  M.call_closure (|
                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "jump_table"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_fmt_Debug_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "LegacyAnalyzedBytecode" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "bytecode" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "bytecode"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "original_len" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "jump_table" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "jump_table"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_marker_StructuralPartialEq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_PartialEq_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    [],
                    [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "bytecode"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "bytecode"
                      |)
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                    [],
                    [ Ty.path "revm_bytecode::legacy::jump_map::JumpTable" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "jump_table"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                        "jump_table"
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_Eq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        None,
                        Value.DeclaredButUndefined,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                None,
                                Value.DeclaredButUndefined,
                                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_hash_Hash_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "alloy_primitives::bytes_::Bytes",
                      [],
                      [],
                      "hash",
                      [],
                      [ __H ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "bytecode"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "usize",
                      [],
                      [],
                      "hash",
                      [],
                      [ __H ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "original_len"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                            "jump_table"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_Ord_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* Ord *)
      Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "core::cmp::Ordering"),
                M.alloc (|
                  M.call_closure (|
                    Ty.path "core::cmp::Ordering",
                    M.get_trait_method (|
                      "core::cmp::Ord",
                      Ty.path "alloy_primitives::bytes_::Bytes",
                      [],
                      [],
                      "cmp",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "bytecode"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "bytecode"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                      M.match_operator (|
                        Some (Ty.path "core::cmp::Ordering"),
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "core::cmp::Ordering",
                            M.get_trait_method (|
                              "core::cmp::Ord",
                              Ty.path "usize",
                              [],
                              [],
                              "cmp",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                      "original_len"
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| other |) |),
                                      "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                      "original_len"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "core::cmp::Ordering",
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                                    [],
                                    [],
                                    "cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                            "jump_table"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                            "jump_table"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let cmp := M.copy (| γ |) in
                              cmp))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let cmp := M.copy (| γ |) in
                      cmp))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_cmp_PartialOrd_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (* PartialOrd *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                    M.get_trait_method (|
                      "core::cmp::PartialOrd",
                      Ty.path "alloy_primitives::bytes_::Bytes",
                      [],
                      [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                      "partial_cmp",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "bytecode"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                              "bytecode"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::cmp::Ordering" ]),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "core::cmp::Ordering" ],
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.path "usize",
                              [],
                              [ Ty.path "usize" ],
                              "partial_cmp",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                      "original_len"
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| other |) |),
                                      "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                      "original_len"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ],
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "revm_bytecode::legacy::jump_map::JumpTable",
                                    [],
                                    [ Ty.path "revm_bytecode::legacy::jump_map::JumpTable" ],
                                    "partial_cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                            "jump_table"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                            "jump_table"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let cmp := M.copy (| γ |) in
                              cmp))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let cmp := M.copy (| γ |) in
                      cmp))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_core_default_Default_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (*
          fn default() -> Self {
              Self {
                  bytecode: Bytes::from_static(&[0]),
                  original_len: 0,
                  jump_table: JumpTable(Arc::new(bitvec![u8, Lsb0; 0])),
              }
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode"
              [
                ("bytecode",
                  M.call_closure (|
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    M.get_associated_function (|
                      Ty.path "alloy_primitives::bytes_::Bytes",
                      "from_static",
                      [],
                      []
                    |),
                    [
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (| Value.Array [ Value.Integer IntegerKind.U8 0 ] |)
                            |)
                          |)
                        |))
                    ]
                  |));
                ("original_len", Value.Integer IntegerKind.Usize 0);
                ("jump_table",
                  Value.StructTuple
                    "revm_bytecode::legacy::jump_map::JumpTable"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [
                            Ty.apply
                              (Ty.path "bitvec::vec::BitVec")
                              []
                              [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [
                              Ty.apply
                                (Ty.path "bitvec::vec::BitVec")
                                []
                                [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "bitvec::vec::BitVec")
                              []
                              [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "bitvec::vec::BitVec")
                                []
                                [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ],
                              "from_bitslice",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "bitvec::slice::BitSlice")
                                              []
                                              [ Ty.path "u8"; Ty.path "bitvec::order::Lsb0" ]
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.apply
                                            (Ty.path "bitvec::array::BitArray")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.path "u8" ];
                                              Ty.path "bitvec::order::Lsb0"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeTo")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "bitvec::array::BitArray")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "array")
                                                      [ Value.Integer IntegerKind.Usize 1 ]
                                                      [ Ty.path "u8" ];
                                                    Ty.path "bitvec::order::Lsb0"
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "bitvec::array::BitArray")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "array")
                                                        [ Value.Integer IntegerKind.Usize 1 ]
                                                        [ Ty.path "u8" ];
                                                      Ty.path "bitvec::order::Lsb0"
                                                    ],
                                                  "new",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  Value.Array
                                                    [
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "bitvec::mem::BitElement")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "bitvec::mem::BitElement")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                "new",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (|
                                                                  get_constant (|
                                                                    "revm_bytecode::legacy::analyzed::default::ELEM",
                                                                    Ty.path "u8"
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          "bitvec::mem::BitElement",
                                                          "elem"
                                                        |)
                                                      |)
                                                    ]
                                                ]
                                              |)
                                            |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::RangeTo"
                                            [
                                              ("end_",
                                                M.read (|
                                                  get_constant (|
                                                    "revm_bytecode::legacy::analyzed::default::BITS",
                                                    Ty.path "usize"
                                                  |)
                                                |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    ])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
    
    Module Impl_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
      Definition Self : Ty.t := Ty.path "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode".
      
      (*
          pub fn new(bytecode: Bytes, original_len: usize, jump_table: JumpTable) -> Self {
              Self {
                  bytecode,
                  original_len,
                  jump_table,
              }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ bytecode; original_len; jump_table ] =>
          ltac:(M.monadic
            (let bytecode := M.alloc (| bytecode |) in
            let original_len := M.alloc (| original_len |) in
            let jump_table := M.alloc (| jump_table |) in
            Value.StructRecord
              "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode"
              [
                ("bytecode", M.read (| bytecode |));
                ("original_len", M.read (| original_len |));
                ("jump_table", M.read (| jump_table |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn bytecode(&self) -> &Bytes {
              &self.bytecode
          }
      *)
      Definition bytecode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                    "bytecode"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bytecode :
        M.IsAssociatedFunction.C Self "bytecode" bytecode.
      Admitted.
      Global Typeclasses Opaque bytecode.
      
      (*
          pub fn original_len(&self) -> usize {
              self.original_len
          }
      *)
      Definition original_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                "original_len"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_original_len :
        M.IsAssociatedFunction.C Self "original_len" original_len.
      Admitted.
      Global Typeclasses Opaque original_len.
      
      (*
          pub fn original_bytes(&self) -> Bytes {
              self.bytecode.slice(..self.original_len)
          }
      *)
      Definition original_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bytes_::Bytes",
              M.get_associated_function (|
                Ty.path "alloy_primitives::bytes_::Bytes",
                "slice",
                [],
                [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                    "bytecode"
                  |)
                |);
                Value.StructRecord
                  "core::ops::range::RangeTo"
                  [
                    ("end_",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                          "original_len"
                        |)
                      |))
                  ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_original_bytes :
        M.IsAssociatedFunction.C Self "original_bytes" original_bytes.
      Admitted.
      Global Typeclasses Opaque original_bytes.
      
      (*
          pub fn original_byte_slice(&self) -> &[u8] {
              &self.bytecode[..self.original_len]
          }
      *)
      Definition original_byte_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::ops::index::Index",
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ],
                        "index",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.path "bytes::bytes::Bytes",
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.path "alloy_primitives::bytes_::Bytes",
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                            "bytecode"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        Value.StructRecord
                          "core::ops::range::RangeTo"
                          [
                            ("end_",
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                                  "original_len"
                                |)
                              |))
                          ]
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_original_byte_slice :
        M.IsAssociatedFunction.C Self "original_byte_slice" original_byte_slice.
      Admitted.
      Global Typeclasses Opaque original_byte_slice.
      
      (*
          pub fn jump_table(&self) -> &JumpTable {
              &self.jump_table
          }
      *)
      Definition jump_table (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::legacy::analyzed::LegacyAnalyzedBytecode",
                    "jump_table"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_jump_table :
        M.IsAssociatedFunction.C Self "jump_table" jump_table.
      Admitted.
      Global Typeclasses Opaque jump_table.
    End Impl_revm_bytecode_legacy_analyzed_LegacyAnalyzedBytecode.
  End analyzed.
End legacy.
