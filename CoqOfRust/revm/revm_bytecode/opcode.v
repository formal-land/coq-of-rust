(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module opcode.
  (* StructTuple
    {
      name := "OpCode";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u8" ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCode" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OpCode" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCode",
                            0
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_default_Default_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "revm_bytecode::opcode::OpCode"
            [
              M.call_closure (|
                Ty.path "u8",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u8",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_PartialEq_revm_bytecode_opcode_OpCode_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_bytecode::opcode::OpCode",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "revm_bytecode::opcode::OpCode",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_bytecode::opcode::OpCode" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_bytecode_opcode_OpCode_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_PartialOrd_revm_bytecode_opcode_OpCode_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u8",
              [],
              [ Ty.path "u8" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_bytecode::opcode::OpCode" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_revm_bytecode_opcode_OpCode_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_fmt_Display_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let n = self.get();
            if let Some(val) = OPCODE_INFO[n as usize] {
                f.write_str(val.name())
            } else {
                write!(f, "UNKNOWN(0x{n:02X})")
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ n : Ty.apply (Ty.path "*") [] [ Ty.path "u8" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (|
                    Ty.path "revm_bytecode::opcode::OpCode",
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.SubPointer.get_array_field (|
                        get_constant (|
                          "revm_bytecode::opcode::OPCODE_INFO",
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
                            ]
                        |),
                        M.cast (Ty.path "usize") (M.read (| n |))
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let val := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                M.get_associated_function (|
                                  Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                  "name",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, val |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1_formatted",
                              [],
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array [ mk_str (| "UNKNOWN(0x" |); mk_str (| ")" |) ]
                                      |)
                                    |)
                                  |)
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.call_closure (|
                                              Ty.path "core::fmt::rt::Argument",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Argument",
                                                "new_upper_hex",
                                                [],
                                                [ Ty.path "u8" ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.call_closure (|
                                              Ty.path "core::fmt::rt::Placeholder",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Placeholder",
                                                "new",
                                                [],
                                                []
                                              |),
                                              [
                                                Value.Integer IntegerKind.Usize 0;
                                                Value.UnicodeChar 32;
                                                Value.StructTuple
                                                  "core::fmt::rt::Alignment::Unknown"
                                                  [];
                                                Value.Integer IntegerKind.U32 8;
                                                Value.StructTuple
                                                  "core::fmt::rt::Count::Implied"
                                                  [];
                                                Value.StructTuple
                                                  "core::fmt::rt::Count::Is"
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                              ]
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |));
                              M.call_closure (|
                                Ty.path "core::fmt::rt::UnsafeArg",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::UnsafeArg",
                                  "new",
                                  [],
                                  []
                                |),
                                []
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (*
        pub const fn new(opcode: u8) -> Option<Self> {
            match OPCODE_INFO[opcode as usize] {
                Some(_) => Some(Self(opcode)),
                None => None,
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "revm_bytecode::opcode::OpCode" ]
                ],
              M.SubPointer.get_array_field (|
                get_constant (|
                  "revm_bytecode::opcode::OPCODE_INFO",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
                    ]
                |),
                M.cast (Ty.path "usize") (M.read (| opcode |))
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ Value.StructTuple "revm_bytecode::opcode::OpCode" [ M.read (| opcode |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub const fn is_jumpdest(&self) -> bool {
            false
        }
    *)
    Definition is_jumpdest (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_jumpdest :
      M.IsAssociatedFunction.C Self "is_jumpdest" is_jumpdest.
    Admitted.
    Global Typeclasses Opaque is_jumpdest.
    
    (*
        pub const fn is_jumpdest_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_jumpdest()
            } else {
                false
            }
        }
    *)
    Definition is_jumpdest_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "is_jumpdest",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_jumpdest_by_op :
      M.IsAssociatedFunction.C Self "is_jumpdest_by_op" is_jumpdest_by_op.
    Admitted.
    Global Typeclasses Opaque is_jumpdest_by_op.
    
    (*
        pub const fn is_jump(self) -> bool {
            false
        }
    *)
    Definition is_jump (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_jump : M.IsAssociatedFunction.C Self "is_jump" is_jump.
    Admitted.
    Global Typeclasses Opaque is_jump.
    
    (*
        pub const fn is_jump_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_jump()
            } else {
                false
            }
        }
    *)
    Definition is_jump_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "is_jump",
                          [],
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_jump_by_op :
      M.IsAssociatedFunction.C Self "is_jump_by_op" is_jump_by_op.
    Admitted.
    Global Typeclasses Opaque is_jump_by_op.
    
    (*
        pub const fn is_push(self) -> bool {
            false
        }
    *)
    Definition is_push (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_push : M.IsAssociatedFunction.C Self "is_push" is_push.
    Admitted.
    Global Typeclasses Opaque is_push.
    
    (*
        pub fn is_push_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_push()
            } else {
                false
            }
        }
    *)
    Definition is_push_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "is_push",
                          [],
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_push_by_op :
      M.IsAssociatedFunction.C Self "is_push_by_op" is_push_by_op.
    Admitted.
    Global Typeclasses Opaque is_push_by_op.
    
    (*
        pub unsafe fn new_unchecked(opcode: u8) -> Self {
            Self(opcode)
        }
    *)
    Definition new_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          Value.StructTuple "revm_bytecode::opcode::OpCode" [ M.read (| opcode |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_unchecked :
      M.IsAssociatedFunction.C Self "new_unchecked" new_unchecked.
    Admitted.
    Global Typeclasses Opaque new_unchecked.
    
    (*
        pub const fn as_str(self) -> &'static str {
            self.info().name()
        }
    *)
    Definition as_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "name",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_str : M.IsAssociatedFunction.C Self "as_str" as_str.
    Admitted.
    Global Typeclasses Opaque as_str.
    
    (*
        pub const fn name_by_op(opcode: u8) -> &'static str {
            if let Some(opcode) = Self::new(opcode) {
                opcode.as_str()
            } else {
                "Unknown"
            }
        }
    *)
    Definition name_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "as_str",
                          [],
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| mk_str (| "Unknown" |) |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_name_by_op :
      M.IsAssociatedFunction.C Self "name_by_op" name_by_op.
    Admitted.
    Global Typeclasses Opaque name_by_op.
    
    (*
        pub const fn inputs(&self) -> u8 {
            self.info().inputs()
        }
    *)
    Definition inputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u8",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "inputs",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inputs : M.IsAssociatedFunction.C Self "inputs" inputs.
    Admitted.
    Global Typeclasses Opaque inputs.
    
    (*
        pub const fn outputs(&self) -> u8 {
            self.info().outputs()
        }
    *)
    Definition outputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u8",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "outputs",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_outputs : M.IsAssociatedFunction.C Self "outputs" outputs.
    Admitted.
    Global Typeclasses Opaque outputs.
    
    (*
        pub const fn io_diff(&self) -> i16 {
            self.info().io_diff()
        }
    *)
    Definition io_diff (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "i16",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "io_diff",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_io_diff : M.IsAssociatedFunction.C Self "io_diff" io_diff.
    Admitted.
    Global Typeclasses Opaque io_diff.
    
    (*
        pub const fn info_by_op(opcode: u8) -> Option<OpCodeInfo> {
            if let Some(opcode) = Self::new(opcode) {
                Some(opcode.info())
            } else {
                None
            }
        }
    *)
    Definition info_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            Ty.path "revm_bytecode::opcode::OpCodeInfo",
                            M.get_associated_function (|
                              Ty.path "revm_bytecode::opcode::OpCode",
                              "info",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, opcode |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_info_by_op :
      M.IsAssociatedFunction.C Self "info_by_op" info_by_op.
    Admitted.
    Global Typeclasses Opaque info_by_op.
    
    (*
        pub const fn as_usize(&self) -> usize {
            self.0 as usize
        }
    *)
    Definition as_usize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "revm_bytecode::opcode::OpCode",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_usize : M.IsAssociatedFunction.C Self "as_usize" as_usize.
    Admitted.
    Global Typeclasses Opaque as_usize.
    
    (*
        pub const fn info(&self) -> OpCodeInfo {
            if let Some(t) = OPCODE_INFO[self.0 as usize] {
                t
            } else {
                panic!("opcode not found")
            }
        }
    *)
    Definition info (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.SubPointer.get_array_field (|
                        get_constant (|
                          "revm_bytecode::opcode::OPCODE_INFO",
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
                            ]
                        |),
                        M.cast
                          (Ty.path "usize")
                          (M.read (|
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::opcode::OpCode",
                              0
                            |)
                          |))
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let t := M.copy (| γ0_0 |) in
                    t));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [ Value.Integer IntegerKind.Usize 1 ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (| Value.Array [ mk_str (| "opcode not found" |) ] |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_info : M.IsAssociatedFunction.C Self "info" info.
    Admitted.
    Global Typeclasses Opaque info.
    
    (*
        pub const fn input_output(&self) -> (u8, u8) {
            let info = self.info();
            (info.inputs, info.outputs)
        }
    *)
    Definition input_output (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "revm_bytecode::opcode::OpCodeInfo",
                  M.get_associated_function (|
                    Ty.path "revm_bytecode::opcode::OpCode",
                    "info",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      info,
                      "revm_bytecode::opcode::OpCodeInfo",
                      "inputs"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      info,
                      "revm_bytecode::opcode::OpCodeInfo",
                      "outputs"
                    |)
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_input_output :
      M.IsAssociatedFunction.C Self "input_output" input_output.
    Admitted.
    Global Typeclasses Opaque input_output.
    
    (*
        pub const fn get(self) -> u8 {
            self.0
        }
    *)
    Definition get (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_tuple_field (| self, "revm_bytecode::opcode::OpCode", 0 |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get : M.IsAssociatedFunction.C Self "get" get.
    Admitted.
    Global Typeclasses Opaque get.
    
    (*
        pub const fn modifies_memory(&self) -> bool {
            false
        }
    *)
    Definition modifies_memory (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_modifies_memory :
      M.IsAssociatedFunction.C Self "modifies_memory" modifies_memory.
    Admitted.
    Global Typeclasses Opaque modifies_memory.
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_STOP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 0 ]
        |))).
    
    Global Instance AssociatedConstant_value_STOP : M.IsAssociatedFunction.C Self "STOP" value_STOP.
    Admitted.
    Global Typeclasses Opaque value_STOP.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_ADD (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 1 ]
        |))).
    
    Global Instance AssociatedConstant_value_ADD : M.IsAssociatedFunction.C Self "ADD" value_ADD.
    Admitted.
    Global Typeclasses Opaque value_ADD.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_BALANCE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 49 ]
        |))).
    
    Global Instance AssociatedConstant_value_BALANCE :
      M.IsAssociatedFunction.C Self "BALANCE" value_BALANCE.
    Admitted.
    Global Typeclasses Opaque value_BALANCE.
  End Impl_revm_bytecode_opcode_OpCode.
  
  (* StructRecord
    {
      name := "OpCodeInfo";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("name_ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ]);
          ("name_len", Ty.path "u8");
          ("inputs", Ty.path "u8");
          ("outputs", Ty.path "u8");
          ("immediate_size", Ty.path "u8");
          ("not_eof", Ty.path "bool");
          ("terminating", Ty.path "bool")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ],
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_PartialEq_revm_bytecode_opcode_OpCodeInfo_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  LogicalOp.and (|
                    LogicalOp.and (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_trait_method (|
                          "core::cmp::PartialEq",
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ],
                          "eq",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_ptr"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_ptr"
                            |)
                          |)
                        ]
                      |),
                      ltac:(M.monadic
                        (M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "revm_bytecode::opcode::OpCodeInfo",
                                "name_len"
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| other |) |),
                                "revm_bytecode::opcode::OpCodeInfo",
                                "name_len"
                              |)
                            |)
                          ]
                        |)))
                    |),
                    ltac:(M.monadic
                      (M.call_closure (|
                        Ty.path "bool",
                        BinOp.eq,
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "inputs"
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "inputs"
                            |)
                          |)
                        ]
                      |)))
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      BinOp.eq,
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "outputs"
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "outputs"
                          |)
                        |)
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "immediate_size"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "immediate_size"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_bytecode::opcode::OpCodeInfo",
                        "not_eof"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_bytecode::opcode::OpCodeInfo",
                        "not_eof"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCodeInfo",
                      "terminating"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_bytecode::opcode::OpCodeInfo",
                      "terminating"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_bytecode_opcode_OpCodeInfo_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_PartialOrd_revm_bytecode_opcode_OpCodeInfo_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ],
                    "partial_cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::cmp::Ordering" ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::cmp::Ordering" ],
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "u8",
                            [],
                            [ Ty.path "u8" ],
                            "partial_cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ],
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "u8",
                                    [],
                                    [ Ty.path "u8" ],
                                    "partial_cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::cmp::Ordering" ]
                                        ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::cmp::Ordering" ],
                                          M.get_trait_method (|
                                            "core::cmp::PartialOrd",
                                            Ty.path "u8",
                                            [],
                                            [ Ty.path "u8" ],
                                            "partial_cmp",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| other |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let _ :=
                                              M.is_struct_tuple (|
                                                γ0_0,
                                                "core::cmp::Ordering::Equal"
                                              |) in
                                            M.match_operator (|
                                              Ty.apply
                                                (Ty.path "*")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.path "core::cmp::Ordering" ]
                                                ],
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.path "core::cmp::Ordering" ],
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialOrd",
                                                    Ty.path "u8",
                                                    [],
                                                    [ Ty.path "u8" ],
                                                    "partial_cmp",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| other |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let _ :=
                                                      M.is_struct_tuple (|
                                                        γ0_0,
                                                        "core::cmp::Ordering::Equal"
                                                      |) in
                                                    M.match_operator (|
                                                      Ty.apply
                                                        (Ty.path "*")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "core::cmp::Ordering" ]
                                                        ],
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "core::cmp::Ordering" ],
                                                          M.get_trait_method (|
                                                            "core::cmp::PartialOrd",
                                                            Ty.path "bool",
                                                            [],
                                                            [ Ty.path "bool" ],
                                                            "partial_cmp",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (|
                                                                      M.read (| other |)
                                                                    |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::option::Option::Some",
                                                                0
                                                              |) in
                                                            let _ :=
                                                              M.is_struct_tuple (|
                                                                γ0_0,
                                                                "core::cmp::Ordering::Equal"
                                                              |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [ Ty.path "core::cmp::Ordering" ],
                                                                M.get_trait_method (|
                                                                  "core::cmp::PartialOrd",
                                                                  Ty.path "bool",
                                                                  [],
                                                                  [ Ty.path "bool" ],
                                                                  "partial_cmp",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| self |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| other |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let cmp := M.copy (| γ |) in
                                                            cmp))
                                                      ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let cmp := M.copy (| γ |) in
                                                    cmp))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_revm_bytecode_opcode_OpCodeInfo_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::cmp::Ordering",
                          M.get_trait_method (|
                            "core::cmp::Ord",
                            Ty.path "u8",
                            [],
                            [],
                            "cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "core::cmp::Ordering",
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "u8",
                                    [],
                                    [],
                                    "cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "core::cmp::Ordering",
                                          M.get_trait_method (|
                                            "core::cmp::Ord",
                                            Ty.path "u8",
                                            [],
                                            [],
                                            "cmp",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| other |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::cmp::Ordering::Equal"
                                              |) in
                                            M.match_operator (|
                                              Ty.apply
                                                (Ty.path "*")
                                                []
                                                [ Ty.path "core::cmp::Ordering" ],
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "core::cmp::Ordering",
                                                  M.get_trait_method (|
                                                    "core::cmp::Ord",
                                                    Ty.path "u8",
                                                    [],
                                                    [],
                                                    "cmp",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| other |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let _ :=
                                                      M.is_struct_tuple (|
                                                        γ,
                                                        "core::cmp::Ordering::Equal"
                                                      |) in
                                                    M.match_operator (|
                                                      Ty.apply
                                                        (Ty.path "*")
                                                        []
                                                        [ Ty.path "core::cmp::Ordering" ],
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "core::cmp::Ordering",
                                                          M.get_trait_method (|
                                                            "core::cmp::Ord",
                                                            Ty.path "bool",
                                                            [],
                                                            [],
                                                            "cmp",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (|
                                                                      M.read (| other |)
                                                                    |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let _ :=
                                                              M.is_struct_tuple (|
                                                                γ,
                                                                "core::cmp::Ordering::Equal"
                                                              |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "core::cmp::Ordering",
                                                                M.get_trait_method (|
                                                                  "core::cmp::Ord",
                                                                  Ty.path "bool",
                                                                  [],
                                                                  [],
                                                                  "cmp",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| self |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| other |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let cmp := M.copy (| γ |) in
                                                            cmp))
                                                      ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let cmp := M.copy (| γ |) in
                                                    cmp))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_len"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "inputs"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "outputs"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "immediate_size"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "bool",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "not_eof"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "bool",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "terminating"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("OpCodeInfo")
                .field("name", &self.name())
                .field("inputs", &self.inputs())
                .field("outputs", &self.outputs())
                .field("not_eof", &self.is_disabled_in_eof())
                .field("terminating", &self.is_terminating())
                .field("immediate_size", &self.immediate_size())
                .finish()
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugStruct",
              "finish",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      "field",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugStruct" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::builders::DebugStruct",
                                              "field",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.path "core::fmt::builders::DebugStruct"
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::builders::DebugStruct",
                                                      "field",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&mut")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "core::fmt::builders::DebugStruct"
                                                              ],
                                                            M.get_associated_function (|
                                                              Ty.path
                                                                "core::fmt::builders::DebugStruct",
                                                              "field",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    Ty.path
                                                                      "core::fmt::builders::DebugStruct",
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "core::fmt::Formatter",
                                                                      "debug_struct",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (| M.read (| f |) |)
                                                                      |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          mk_str (| "OpCodeInfo" |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| mk_str (| "name" |) |)
                                                              |);
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ Ty.path "str" ],
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "revm_bytecode::opcode::OpCodeInfo",
                                                                            "name",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.read (| self |)
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |))
                                                            ]
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| mk_str (| "inputs" |) |)
                                                      |);
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path "u8",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "revm_bytecode::opcode::OpCodeInfo",
                                                                    "inputs",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| self |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |))
                                                    ]
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| mk_str (| "outputs" |) |)
                                              |);
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "u8",
                                                          M.get_associated_function (|
                                                            Ty.path
                                                              "revm_bytecode::opcode::OpCodeInfo",
                                                            "outputs",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| self |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |))
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "not_eof" |) |)
                                      |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_associated_function (|
                                                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                                    "is_disabled_in_eof",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| self |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |))
                                    ]
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| mk_str (| "terminating" |) |)
                              |);
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                            "is_terminating",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |))
                            ]
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "immediate_size" |) |) |);
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "u8",
                                  M.get_associated_function (|
                                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                    "immediate_size",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |))
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (*
        pub const fn new(name: &'static str) -> Self {
            assert!(name.len() < 256, "opcode name is too long");
            Self {
                name_ptr: unsafe { NonNull::new_unchecked(name.as_ptr().cast_mut()) },
                name_len: name.len() as u8,
                inputs: 0,
                outputs: 0,
                not_eof: false,
                terminating: false,
                immediate_size: 0,
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ name ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (| Ty.path "str", "len", [], [] |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| name |) |)
                                      |)
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 256
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [ Value.Integer IntegerKind.Usize 1 ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array [ mk_str (| "opcode name is too long" |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "revm_bytecode::opcode::OpCodeInfo"
                [
                  ("name_ptr",
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                            "cast_mut",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                              M.get_associated_function (| Ty.path "str", "as_ptr", [], [] |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| name |) |) |) ]
                            |)
                          ]
                        |)
                      ]
                    |));
                  ("name_len",
                    M.cast
                      (Ty.path "u8")
                      (M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (| Ty.path "str", "len", [], [] |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| name |) |) |) ]
                      |)));
                  ("inputs", Value.Integer IntegerKind.U8 0);
                  ("outputs", Value.Integer IntegerKind.U8 0);
                  ("not_eof", Value.Bool false);
                  ("terminating", Value.Bool false);
                  ("immediate_size", Value.Integer IntegerKind.U8 0)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub const fn name(&self) -> &'static str {
            // SAFETY: `self.name_*` can only be initialized with a valid `&'static str`.
            unsafe {
                // TODO : Use `str::from_raw_parts` when it's stable.
                let slice = core::slice::from_raw_parts(self.name_ptr.as_ptr(), self.name_len as usize);
                core::str::from_utf8_unchecked(slice)
            }
        }
    *)
    Definition name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ slice :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_function (| "core::slice::raw::from_raw_parts", [], [ Ty.path "u8" ] |),
                  [
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_ptr"
                            |)
                          |)
                        ]
                      |));
                    M.cast
                      (Ty.path "usize")
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "name_len"
                        |)
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                    M.get_function (| "core::str::converts::from_utf8_unchecked", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_name : M.IsAssociatedFunction.C Self "name" name.
    Admitted.
    Global Typeclasses Opaque name.
    
    (*
        pub const fn io_diff(&self) -> i16 {
            self.outputs as i16 - self.inputs as i16
        }
    *)
    Definition io_diff (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "i16",
            BinOp.Wrap.sub,
            [
              M.cast
                (Ty.path "i16")
                (M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::opcode::OpCodeInfo",
                    "outputs"
                  |)
                |));
              M.cast
                (Ty.path "i16")
                (M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::opcode::OpCodeInfo",
                    "inputs"
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_io_diff : M.IsAssociatedFunction.C Self "io_diff" io_diff.
    Admitted.
    Global Typeclasses Opaque io_diff.
    
    (*
        pub const fn inputs(&self) -> u8 {
            self.inputs
        }
    *)
    Definition inputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "inputs"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inputs : M.IsAssociatedFunction.C Self "inputs" inputs.
    Admitted.
    Global Typeclasses Opaque inputs.
    
    (*
        pub const fn outputs(&self) -> u8 {
            self.outputs
        }
    *)
    Definition outputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "outputs"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_outputs : M.IsAssociatedFunction.C Self "outputs" outputs.
    Admitted.
    Global Typeclasses Opaque outputs.
    
    (*
        pub const fn is_disabled_in_eof(&self) -> bool {
            self.not_eof
        }
    *)
    Definition is_disabled_in_eof (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "not_eof"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_disabled_in_eof :
      M.IsAssociatedFunction.C Self "is_disabled_in_eof" is_disabled_in_eof.
    Admitted.
    Global Typeclasses Opaque is_disabled_in_eof.
    
    (*
        pub const fn is_terminating(&self) -> bool {
            self.terminating
        }
    *)
    Definition is_terminating (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "terminating"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_terminating :
      M.IsAssociatedFunction.C Self "is_terminating" is_terminating.
    Admitted.
    Global Typeclasses Opaque is_terminating.
    
    (*
        pub const fn immediate_size(&self) -> u8 {
            self.immediate_size
        }
    *)
    Definition immediate_size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "immediate_size"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_immediate_size :
      M.IsAssociatedFunction.C Self "immediate_size" immediate_size.
    Admitted.
    Global Typeclasses Opaque immediate_size.
  End Impl_revm_bytecode_opcode_OpCodeInfo.
  
  (*
  pub const fn not_eof(mut op: OpCodeInfo) -> OpCodeInfo {
      op.not_eof = true;
      op
  }
  *)
  Definition not_eof (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "not_eof"
                |),
                Value.Bool true
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_not_eof :
    M.IsFunction.C "revm_bytecode::opcode::not_eof" not_eof.
  Admitted.
  Global Typeclasses Opaque not_eof.
  
  (*
  pub const fn immediate_size(mut op: OpCodeInfo, n: u8) -> OpCodeInfo {
      op.immediate_size = n;
      op
  }
  *)
  Definition immediate_size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op; n ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        let n := M.alloc (| n |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "immediate_size"
                |),
                M.read (| n |)
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_immediate_size :
    M.IsFunction.C "revm_bytecode::opcode::immediate_size" immediate_size.
  Admitted.
  Global Typeclasses Opaque immediate_size.
  
  (*
  pub const fn terminating(mut op: OpCodeInfo) -> OpCodeInfo {
      op.terminating = true;
      op
  }
  *)
  Definition terminating (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "terminating"
                |),
                Value.Bool true
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_terminating :
    M.IsFunction.C "revm_bytecode::opcode::terminating" terminating.
  Admitted.
  Global Typeclasses Opaque terminating.
  
  (*
  pub const fn stack_io(mut op: OpCodeInfo, inputs: u8, outputs: u8) -> OpCodeInfo {
      op.inputs = inputs;
      op.outputs = outputs;
      op
  }
  *)
  Definition stack_io (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op; inputs; outputs ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        let inputs := M.alloc (| inputs |) in
        let outputs := M.alloc (| outputs |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "inputs"
                |),
                M.read (| inputs |)
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "outputs"
                |),
                M.read (| outputs |)
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_stack_io :
    M.IsFunction.C "revm_bytecode::opcode::stack_io" stack_io.
  Admitted.
  Global Typeclasses Opaque stack_io.
  
  Definition value_STOP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 0 |))).
  
  Global Instance Instance_IsConstant_value_STOP :
    M.IsFunction.C "revm_bytecode::opcode::STOP" value_STOP.
  Admitted.
  Global Typeclasses Opaque value_STOP.
  
  Definition value_ADD (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 1 |))).
  
  Global Instance Instance_IsConstant_value_ADD :
    M.IsFunction.C "revm_bytecode::opcode::ADD" value_ADD.
  Admitted.
  Global Typeclasses Opaque value_ADD.
  
  Definition value_BALANCE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 49 |))).
  
  Global Instance Instance_IsConstant_value_BALANCE :
    M.IsFunction.C "revm_bytecode::opcode::BALANCE" value_BALANCE.
  Admitted.
  Global Typeclasses Opaque value_BALANCE.
  
  
  Definition value_OPCODE_INFO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (let~ map :
          Ty.apply
            (Ty.path "*")
            []
            [
              Ty.apply
                (Ty.path "array")
                [ Value.Integer IntegerKind.Usize 256 ]
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
                ]
            ] :=
        M.alloc (|
          repeat (|
            Value.StructTuple "core::option::Option::None" [],
            Value.Integer IntegerKind.Usize 256
          |)
        |) in
      let~ prev : Ty.apply (Ty.path "*") [] [ Ty.path "u8" ] :=
        M.alloc (| Value.Integer IntegerKind.U8 0 |) in
      let~ val : Ty.apply (Ty.path "*") [] [ Ty.path "u8" ] :=
        M.alloc (| Value.Integer IntegerKind.U8 0 |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.match_operator (|
          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
          M.alloc (| Value.Tuple [] |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ :=
                  M.use
                    (M.alloc (|
                      UnOp.not (|
                        LogicalOp.or (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [ M.read (| val |); Value.Integer IntegerKind.U8 0 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [ M.read (| val |); M.read (| prev |) ]
                            |)))
                        |)
                      |)
                    |)) in
                let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                M.alloc (|
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_fmt", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Value.Array
                                      [ mk_str (| "opcodes must be sorted in ascending order" |) ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)
                |)));
            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
          ]
        |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.alloc (| M.write (| prev, M.read (| val |) |) |) in
      let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
        M.alloc (|
          M.call_closure (|
            Ty.path "revm_bytecode::opcode::OpCodeInfo",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "new",
              [],
              []
            |),
            [ mk_str (| "STOP" |) ]
          |)
        |) in
      let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
        M.alloc (|
          M.call_closure (|
            Ty.path "revm_bytecode::opcode::OpCodeInfo",
            M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
            [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
          |)
        |) in
      let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
        M.alloc (|
          M.call_closure (|
            Ty.path "revm_bytecode::opcode::OpCodeInfo",
            M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
            [ M.read (| info |) ]
          |)
        |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.alloc (|
          M.write (|
            M.SubPointer.get_array_field (| map, Value.Integer IntegerKind.Usize 0 |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |)
        |) in
      let~ val : Ty.apply (Ty.path "*") [] [ Ty.path "u8" ] :=
        M.alloc (| Value.Integer IntegerKind.U8 1 |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.match_operator (|
          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
          M.alloc (| Value.Tuple [] |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ :=
                  M.use
                    (M.alloc (|
                      UnOp.not (|
                        LogicalOp.or (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [ M.read (| val |); Value.Integer IntegerKind.U8 0 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [ M.read (| val |); M.read (| prev |) ]
                            |)))
                        |)
                      |)
                    |)) in
                let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                M.alloc (|
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_fmt", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Value.Array
                                      [ mk_str (| "opcodes must be sorted in ascending order" |) ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)
                |)));
            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
          ]
        |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.alloc (| M.write (| prev, M.read (| val |) |) |) in
      let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
        M.alloc (|
          M.call_closure (|
            Ty.path "revm_bytecode::opcode::OpCodeInfo",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "new",
              [],
              []
            |),
            [ mk_str (| "ADD" |) ]
          |)
        |) in
      let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
        M.alloc (|
          M.call_closure (|
            Ty.path "revm_bytecode::opcode::OpCodeInfo",
            M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
            [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
          |)
        |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.alloc (|
          M.write (|
            M.SubPointer.get_array_field (| map, Value.Integer IntegerKind.Usize 1 |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |)
        |) in
      let~ val : Ty.apply (Ty.path "*") [] [ Ty.path "u8" ] :=
        M.alloc (| Value.Integer IntegerKind.U8 49 |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.match_operator (|
          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
          M.alloc (| Value.Tuple [] |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ :=
                  M.use
                    (M.alloc (|
                      UnOp.not (|
                        LogicalOp.or (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [ M.read (| val |); Value.Integer IntegerKind.U8 0 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [ M.read (| val |); M.read (| prev |) ]
                            |)))
                        |)
                      |)
                    |)) in
                let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                M.alloc (|
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_fmt", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Value.Array
                                      [ mk_str (| "opcodes must be sorted in ascending order" |) ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)
                |)));
            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
          ]
        |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.alloc (| M.write (| prev, M.read (| val |) |) |) in
      let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
        M.alloc (|
          M.call_closure (|
            Ty.path "revm_bytecode::opcode::OpCodeInfo",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "new",
              [],
              []
            |),
            [ mk_str (| "BALANCE" |) ]
          |)
        |) in
      let~ info : Ty.apply (Ty.path "*") [] [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ] :=
        M.alloc (|
          M.call_closure (|
            Ty.path "revm_bytecode::opcode::OpCodeInfo",
            M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
            [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
          |)
        |) in
      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
        M.alloc (|
          M.write (|
            M.SubPointer.get_array_field (| map, Value.Integer IntegerKind.Usize 49 |),
            Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
          |)
        |) in
      M.match_operator (|
        Ty.apply
          (Ty.path "*")
          []
          [
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 256 ]
              [
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
              ]
          ],
        prev,
        [ fun γ => ltac:(M.monadic map) ]
      |))).
  
  Global Instance Instance_IsConstant_value_OPCODE_INFO :
    M.IsFunction.C "revm_bytecode::opcode::OPCODE_INFO" value_OPCODE_INFO.
  Admitted.
  Global Typeclasses Opaque value_OPCODE_INFO.
  
  Definition value_NAME_TO_OPCODE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.alloc (|
          Value.StructRecord
            "phf::map::Map"
            [
              ("key", Value.Integer IntegerKind.U64 15467950696543387533);
              ("disps",
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 0 ]
                            ]
                        |)
                      |)
                    |)
                  |)));
              ("entries",
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "STOP" |) |)
                                  |);
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "revm_bytecode::opcode::OpCode",
                                      "STOP",
                                      Ty.path "revm_bytecode::opcode::OpCode"
                                    |)
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ADD" |) |) |);
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "revm_bytecode::opcode::OpCode",
                                      "ADD",
                                      Ty.path "revm_bytecode::opcode::OpCode"
                                    |)
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "BALANCE" |) |)
                                  |);
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "revm_bytecode::opcode::OpCode",
                                      "BALANCE",
                                      Ty.path "revm_bytecode::opcode::OpCode"
                                    |)
                                  |)
                                ]
                            ]
                        |)
                      |)
                    |)
                  |)))
            ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_NAME_TO_OPCODE :
    M.IsFunction.C "revm_bytecode::opcode::NAME_TO_OPCODE" value_NAME_TO_OPCODE.
  Admitted.
  Global Typeclasses Opaque value_NAME_TO_OPCODE.
End opcode.
