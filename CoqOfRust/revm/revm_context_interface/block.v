(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module block.
  (* Trait *)
  Module Block.
    Definition blob_gasprice
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              "map",
              [],
              [
                Ty.path "u128";
                Ty.function
                  [
                    Ty.tuple
                      [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ]
                  ]
                  (Ty.path "u128")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
                M.get_trait_method (|
                  "revm_context_interface::block::Block",
                  Self,
                  [],
                  [],
                  "blob_excess_gas_and_price",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.path
                                      "revm_context_interface::block::blob::BlobExcessGasAndPrice"
                                  ]
                              ]
                              (Ty.path "u128")),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let a := M.copy (| γ |) in
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    a,
                                    "revm_context_interface::block::blob::BlobExcessGasAndPrice",
                                    "blob_gasprice"
                                  |)
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_blob_gasprice :
      M.IsProvidedMethod "revm_context_interface::block::Block" "blob_gasprice" blob_gasprice.
    Definition blob_excess_gas
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              "map",
              [],
              [
                Ty.path "u64";
                Ty.function
                  [
                    Ty.tuple
                      [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ]
                  ]
                  (Ty.path "u64")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
                M.get_trait_method (|
                  "revm_context_interface::block::Block",
                  Self,
                  [],
                  [],
                  "blob_excess_gas_and_price",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.path
                                      "revm_context_interface::block::blob::BlobExcessGasAndPrice"
                                  ]
                              ]
                              (Ty.path "u64")),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let a := M.copy (| γ |) in
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    a,
                                    "revm_context_interface::block::blob::BlobExcessGasAndPrice",
                                    "excess_blob_gas"
                                  |)
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_blob_excess_gas :
      M.IsProvidedMethod "revm_context_interface::block::Block" "blob_excess_gas" blob_excess_gas.
  End Block.
  
  Module underscore.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "number",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bits::address::Address",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "beneficiary",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "timestamp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "gas_limit",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "basefee",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "difficulty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "prevrandao",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas_and_price",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_gasprice",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref__T.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "number",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bits::address::Address",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "beneficiary",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "timestamp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "gas_limit",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "basefee",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "difficulty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "prevrandao",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas_and_price",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_gasprice",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "number",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bits::address::Address",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "beneficiary",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "timestamp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "gas_limit",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "basefee",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "difficulty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "prevrandao",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas_and_price",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_gasprice",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "number",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bits::address::Address",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "beneficiary",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "timestamp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "gas_limit",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "basefee",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "difficulty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "prevrandao",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas_and_price",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_gasprice",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                [],
                "blob_excess_gas",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::block::BlockGetter" [] [] T "Block".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "revm_context_interface::block::BlockGetter"
                        []
                        []
                        T
                        "Block"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::block::BlockGetter",
                    T,
                    [],
                    [],
                    "block",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref__T.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::block::BlockGetter" [] [] T "Block".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "revm_context_interface::block::BlockGetter"
                        []
                        []
                        T
                        "Block"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::block::BlockGetter",
                    T,
                    [],
                    [],
                    "block",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::block::BlockGetter" [] [] T "Block".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "revm_context_interface::block::BlockGetter"
                        []
                        []
                        T
                        "Block"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::block::BlockGetter",
                    T,
                    [],
                    [],
                    "block",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::block::BlockGetter" [] [] T "Block".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "revm_context_interface::block::BlockGetter"
                        []
                        []
                        T
                        "Block"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::block::BlockGetter",
                    T,
                    [],
                    [],
                    "block",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ T ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  End underscore.
  
  
  
  
  (* Trait *)
  (* Empty module 'BlockGetter' *)
  
  
  
  
  
  (* Trait *)
  (* Empty module 'BlockSetter' *)
  
  Module Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_ref_mut_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
    
    (*
        fn set_block(&mut self, block: <Self as BlockGetter>::Block) {
            ( **self).set_block(block)
        }
    *)
    Definition set_block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; block ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let block := M.alloc (| block |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "revm_context_interface::block::BlockSetter",
              T,
              [],
              [],
              "set_block",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| block |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::block::BlockSetter"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("set_block", InstanceField.Method (set_block T)) ].
  End Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_ref_mut_T.
  
  Module Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn set_block(&mut self, block: <Self as BlockGetter>::Block) {
            ( **self).set_block(block)
        }
    *)
    Definition set_block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; block ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let block := M.alloc (| block |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "revm_context_interface::block::BlockSetter",
              T,
              [],
              [],
              "set_block",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| block |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::block::BlockSetter"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("set_block", InstanceField.Method (set_block T)) ].
  End Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
End block.
