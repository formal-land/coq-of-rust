(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module cfg.
  (* Trait *)
  (* Empty module 'Cfg' *)
  
  Module underscore.
    Module Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Spec (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition chain_id (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "chain_id",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition spec (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "spec",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition max_code_size
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "max_code_size",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_eip3607_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_eip3607_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_balance_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_balance_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_gas_refund_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_gas_refund_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_block_gas_limit_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_block_gas_limit_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_nonce_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_nonce_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_base_fee_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_base_fee_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::Cfg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Spec", InstanceField.Ty (_Spec T));
            ("chain_id", InstanceField.Method (chain_id T));
            ("spec", InstanceField.Method (spec T));
            ("max_code_size", InstanceField.Method (max_code_size T));
            ("is_eip3607_disabled", InstanceField.Method (is_eip3607_disabled T));
            ("is_balance_check_disabled", InstanceField.Method (is_balance_check_disabled T));
            ("is_gas_refund_disabled", InstanceField.Method (is_gas_refund_disabled T));
            ("is_block_gas_limit_disabled", InstanceField.Method (is_block_gas_limit_disabled T));
            ("is_nonce_check_disabled", InstanceField.Method (is_nonce_check_disabled T));
            ("is_base_fee_check_disabled", InstanceField.Method (is_base_fee_check_disabled T))
          ].
    End Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_ref__T.
    Module Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Spec (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition chain_id (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "chain_id",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition spec (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "spec",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition max_code_size
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "max_code_size",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_eip3607_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_eip3607_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_balance_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_balance_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_gas_refund_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_gas_refund_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_block_gas_limit_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_block_gas_limit_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_nonce_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_nonce_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_base_fee_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_base_fee_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::Cfg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Spec", InstanceField.Ty (_Spec T));
            ("chain_id", InstanceField.Method (chain_id T));
            ("spec", InstanceField.Method (spec T));
            ("max_code_size", InstanceField.Method (max_code_size T));
            ("is_eip3607_disabled", InstanceField.Method (is_eip3607_disabled T));
            ("is_balance_check_disabled", InstanceField.Method (is_balance_check_disabled T));
            ("is_gas_refund_disabled", InstanceField.Method (is_gas_refund_disabled T));
            ("is_block_gas_limit_disabled", InstanceField.Method (is_block_gas_limit_disabled T));
            ("is_nonce_check_disabled", InstanceField.Method (is_nonce_check_disabled T));
            ("is_base_fee_check_disabled", InstanceField.Method (is_base_fee_check_disabled T))
          ].
    End Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Spec (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition chain_id (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "chain_id",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition spec (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "spec",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition max_code_size
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "max_code_size",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_eip3607_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_eip3607_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_balance_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_balance_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_gas_refund_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_gas_refund_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_block_gas_limit_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_block_gas_limit_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_nonce_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_nonce_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_base_fee_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_base_fee_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::Cfg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Spec", InstanceField.Ty (_Spec T));
            ("chain_id", InstanceField.Method (chain_id T));
            ("spec", InstanceField.Method (spec T));
            ("max_code_size", InstanceField.Method (max_code_size T));
            ("is_eip3607_disabled", InstanceField.Method (is_eip3607_disabled T));
            ("is_balance_check_disabled", InstanceField.Method (is_balance_check_disabled T));
            ("is_gas_refund_disabled", InstanceField.Method (is_gas_refund_disabled T));
            ("is_block_gas_limit_disabled", InstanceField.Method (is_block_gas_limit_disabled T));
            ("is_nonce_check_disabled", InstanceField.Method (is_nonce_check_disabled T));
            ("is_base_fee_check_disabled", InstanceField.Method (is_base_fee_check_disabled T))
          ].
    End Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Spec (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition chain_id (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "chain_id",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition spec (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait "revm_context_interface::cfg::Cfg" [] [] T "Spec",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "spec",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition max_code_size
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "max_code_size",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_eip3607_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_eip3607_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_balance_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_balance_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_gas_refund_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_gas_refund_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_block_gas_limit_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_block_gas_limit_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_nonce_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_nonce_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition is_base_fee_check_disabled
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "revm_context_interface::cfg::Cfg",
                T,
                [],
                [],
                "is_base_fee_check_disabled",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ T ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::Cfg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Spec", InstanceField.Ty (_Spec T));
            ("chain_id", InstanceField.Method (chain_id T));
            ("spec", InstanceField.Method (spec T));
            ("max_code_size", InstanceField.Method (max_code_size T));
            ("is_eip3607_disabled", InstanceField.Method (is_eip3607_disabled T));
            ("is_balance_check_disabled", InstanceField.Method (is_balance_check_disabled T));
            ("is_gas_refund_disabled", InstanceField.Method (is_gas_refund_disabled T));
            ("is_block_gas_limit_disabled", InstanceField.Method (is_block_gas_limit_disabled T));
            ("is_nonce_check_disabled", InstanceField.Method (is_nonce_check_disabled T));
            ("is_base_fee_check_disabled", InstanceField.Method (is_base_fee_check_disabled T))
          ].
    End Impl_revm_context_interface_cfg_Cfg_where_revm_context_interface_cfg_Cfg_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Cfg (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition cfg (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::cfg::CfgGetter",
                    T,
                    [],
                    [],
                    "cfg",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::CfgGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Cfg", InstanceField.Ty (_Cfg T)); ("cfg", InstanceField.Method (cfg T)) ].
    End Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_ref__T.
    Module Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Cfg (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition cfg (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::cfg::CfgGetter",
                    T,
                    [],
                    [],
                    "cfg",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::CfgGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Cfg", InstanceField.Ty (_Cfg T)); ("cfg", InstanceField.Method (cfg T)) ].
    End Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Cfg (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition cfg (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::cfg::CfgGetter",
                    T,
                    [],
                    [],
                    "cfg",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::CfgGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Cfg", InstanceField.Ty (_Cfg T)); ("cfg", InstanceField.Method (cfg T)) ].
    End Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Cfg (T : Ty.t) : Ty.t :=
        Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg".
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition cfg (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.associated_in_trait "revm_context_interface::cfg::CfgGetter" [] [] T "Cfg"
                    ],
                  M.get_trait_method (|
                    "revm_context_interface::cfg::CfgGetter",
                    T,
                    [],
                    [],
                    "cfg",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ T ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::cfg::CfgGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [ ("Cfg", InstanceField.Ty (_Cfg T)); ("cfg", InstanceField.Method (cfg T)) ].
    End Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_CfgGetter_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  End underscore.
  
  
  
  
  (*
  Enum AnalysisKind
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Raw";
          item := StructTuple [];
        };
        {
          name := "Analyse";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_AnalysisKind_Raw :
    M.IsDiscriminant "revm_context_interface::cfg::AnalysisKind::Raw" 0.
  Axiom IsDiscriminant_AnalysisKind_Analyse :
    M.IsDiscriminant "revm_context_interface::cfg::AnalysisKind::Analyse" 1.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_cfg_AnalysisKind.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::AnalysisKind".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "revm_context_interface::cfg::AnalysisKind"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "revm_context_interface::cfg::AnalysisKind::Raw" |) in
                    M.alloc (|
                      Value.StructTuple "revm_context_interface::cfg::AnalysisKind::Raw" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::cfg::AnalysisKind::Analyse"
                      |) in
                    M.alloc (|
                      Value.StructTuple "revm_context_interface::cfg::AnalysisKind::Analyse" []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_cfg_AnalysisKind.
  
  Module Impl_core_default_Default_for_revm_context_interface_cfg_AnalysisKind.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::AnalysisKind".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic (Value.StructTuple "revm_context_interface::cfg::AnalysisKind::Analyse" []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_context_interface_cfg_AnalysisKind.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_cfg_AnalysisKind.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::AnalysisKind".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Some (Ty.apply (Ty.path "&") [] [ Ty.path "str" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::cfg::AnalysisKind::Raw"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Raw" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::cfg::AnalysisKind::Analyse"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Analyse" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_cfg_AnalysisKind.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_cfg_AnalysisKind.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::AnalysisKind".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_cfg_AnalysisKind.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_cfg_AnalysisKind.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::AnalysisKind".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_cfg_AnalysisKind.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_cfg_AnalysisKind_for_revm_context_interface_cfg_AnalysisKind.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::AnalysisKind".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::cfg::AnalysisKind" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::cfg::AnalysisKind" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::cfg::AnalysisKind" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_cfg_AnalysisKind_for_revm_context_interface_cfg_AnalysisKind.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_cfg_AnalysisKind.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::AnalysisKind".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::cfg::AnalysisKind" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_cfg_AnalysisKind.
  
  Axiom TransactTo :
    (Ty.path "revm_context_interface::cfg::TransactTo") =
      (Ty.path "alloy_primitives::common::TxKind").
  
  (*
  Enum CreateScheme
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Create";
          item := StructTuple [];
        };
        {
          name := "Create2";
          item :=
            StructRecord
              [
                ("salt",
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [])
              ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_CreateScheme_Create :
    M.IsDiscriminant "revm_context_interface::cfg::CreateScheme::Create" 0.
  Axiom IsDiscriminant_CreateScheme_Create2 :
    M.IsDiscriminant "revm_context_interface::cfg::CreateScheme::Create2" 1.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_cfg_CreateScheme.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::CreateScheme".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_cfg_CreateScheme.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_cfg_CreateScheme.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::CreateScheme".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_cfg_CreateScheme.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_cfg_CreateScheme.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::CreateScheme".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::cfg::CreateScheme::Create"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Create" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::cfg::CreateScheme::Create2",
                        "salt"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Create2" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "salt" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_cfg_CreateScheme.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_cfg_CreateScheme.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::CreateScheme".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_cfg_CreateScheme.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_cfg_CreateScheme.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::CreateScheme".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_cfg_CreateScheme.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_cfg_CreateScheme_for_revm_context_interface_cfg_CreateScheme.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::CreateScheme".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::cfg::CreateScheme" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::cfg::CreateScheme" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::cfg::CreateScheme::Create2",
                                "salt"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::cfg::CreateScheme::Create2",
                                "salt"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        []
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          []
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::cfg::CreateScheme" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_cfg_CreateScheme_for_revm_context_interface_cfg_CreateScheme.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_cfg_CreateScheme.
    Definition Self : Ty.t := Ty.path "revm_context_interface::cfg::CreateScheme".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::cfg::CreateScheme" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::cfg::CreateScheme::Create2",
                        "salt"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            [],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_cfg_CreateScheme.
  
  (* Trait *)
  (* Empty module 'CfgGetter' *)
  
  
  
  
End cfg.
