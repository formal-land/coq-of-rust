(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module host.
  (* Trait *)
  (* Empty module 'Host' *)
  
  Module underscore.
    Module Impl_revm_context_interface_host_Host_where_revm_context_interface_host_Host_T_where_core_marker_Sized_T_where_revm_context_interface_transaction_TransactionGetter_ref_mut_T_where_revm_context_interface_block_BlockGetter_ref_mut_T_where_revm_context_interface_cfg_CfgGetter_ref_mut_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (* #[auto_impl(&mut, Box)] *)
      Definition load_account_delegated
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::journaled_state::AccountLoad" ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "load_account_delegated",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition block_hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "block_hash",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| number |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition balance (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "balance",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition code (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                    []
                    [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "code",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition code_hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "code_hash",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition sload (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "sload",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition sstore (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [ Ty.path "revm_context_interface::host::SStoreResult" ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "sstore",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |);
                M.read (| value |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition tload (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "tload",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition tstore (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "tstore",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |);
                M.read (| value |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition log (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; log ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let log := M.alloc (| log |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "log",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| log |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition selfdestruct
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; target ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let target := M.alloc (| target |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [ Ty.path "revm_context_interface::host::SelfDestructResult" ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "selfdestruct",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| target |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::host::Host"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("load_account_delegated", InstanceField.Method (load_account_delegated T));
            ("block_hash", InstanceField.Method (block_hash T));
            ("balance", InstanceField.Method (balance T));
            ("code", InstanceField.Method (code T));
            ("code_hash", InstanceField.Method (code_hash T));
            ("sload", InstanceField.Method (sload T));
            ("sstore", InstanceField.Method (sstore T));
            ("tload", InstanceField.Method (tload T));
            ("tstore", InstanceField.Method (tstore T));
            ("log", InstanceField.Method (log T));
            ("selfdestruct", InstanceField.Method (selfdestruct T))
          ].
    End Impl_revm_context_interface_host_Host_where_revm_context_interface_host_Host_T_where_core_marker_Sized_T_where_revm_context_interface_transaction_TransactionGetter_ref_mut_T_where_revm_context_interface_block_BlockGetter_ref_mut_T_where_revm_context_interface_cfg_CfgGetter_ref_mut_T_for_ref_mut_T.
    Module Impl_revm_context_interface_host_Host_where_revm_context_interface_host_Host_T_where_core_marker_Sized_T_where_revm_context_interface_transaction_TransactionGetter_alloc_boxed_Box_T_alloc_alloc_Global_where_revm_context_interface_block_BlockGetter_alloc_boxed_Box_T_alloc_alloc_Global_where_revm_context_interface_cfg_CfgGetter_alloc_boxed_Box_T_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&mut, Box)] *)
      Definition load_account_delegated
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::journaled_state::AccountLoad" ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "load_account_delegated",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition block_hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "block_hash",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| number |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition balance (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "balance",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition code (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                    []
                    [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "code",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition code_hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "code_hash",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition sload (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "sload",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition sstore (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [ Ty.path "revm_context_interface::host::SStoreResult" ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "sstore",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |);
                M.read (| value |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition tload (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "tload",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition tstore (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; index; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "tstore",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| index |);
                M.read (| value |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition log (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; log ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let log := M.alloc (| log |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "log",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| log |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition selfdestruct
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; address; target ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let target := M.alloc (| target |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [ Ty.path "revm_context_interface::host::SelfDestructResult" ]
                ],
              M.get_trait_method (|
                "revm_context_interface::host::Host",
                T,
                [],
                [],
                "selfdestruct",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| address |);
                M.read (| target |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::host::Host"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("load_account_delegated", InstanceField.Method (load_account_delegated T));
            ("block_hash", InstanceField.Method (block_hash T));
            ("balance", InstanceField.Method (balance T));
            ("code", InstanceField.Method (code T));
            ("code_hash", InstanceField.Method (code_hash T));
            ("sload", InstanceField.Method (sload T));
            ("sstore", InstanceField.Method (sstore T));
            ("tload", InstanceField.Method (tload T));
            ("tstore", InstanceField.Method (tstore T));
            ("log", InstanceField.Method (log T));
            ("selfdestruct", InstanceField.Method (selfdestruct T))
          ].
    End Impl_revm_context_interface_host_Host_where_revm_context_interface_host_Host_T_where_core_marker_Sized_T_where_revm_context_interface_transaction_TransactionGetter_alloc_boxed_Box_T_alloc_alloc_Global_where_revm_context_interface_block_BlockGetter_alloc_boxed_Box_T_alloc_alloc_Global_where_revm_context_interface_cfg_CfgGetter_alloc_boxed_Box_T_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
  End underscore.
  
  
  (* StructRecord
    {
      name := "SStoreResult";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("original_value",
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
              []);
          ("present_value",
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
              []);
          ("new_value",
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
              [])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_context_interface_host_SStoreResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SStoreResult".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "revm_context_interface::host::SStoreResult"
            [
              ("original_value",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SStoreResult",
                            "original_value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("present_value",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SStoreResult",
                            "present_value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("new_value",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SStoreResult",
                            "new_value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_host_SStoreResult.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_host_SStoreResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SStoreResult".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "SStoreResult" |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "original_value" |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::host::SStoreResult",
                      "original_value"
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "present_value" |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::host::SStoreResult",
                      "present_value"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "new_value" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_context_interface::host::SStoreResult",
                          "new_value"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_host_SStoreResult.
  
  Module Impl_core_default_Default_for_revm_context_interface_host_SStoreResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SStoreResult".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "revm_context_interface::host::SStoreResult"
            [
              ("original_value",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("present_value",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("new_value",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_context_interface_host_SStoreResult.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_host_SStoreResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SStoreResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_host_SStoreResult.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_host_SStoreResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SStoreResult".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  [],
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      []
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::host::SStoreResult",
                      "original_value"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_context_interface::host::SStoreResult",
                      "original_value"
                    |)
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_context_interface::host::SStoreResult",
                        "present_value"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_context_interface::host::SStoreResult",
                        "present_value"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [],
                  [],
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      []
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::host::SStoreResult",
                      "new_value"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_context_interface::host::SStoreResult",
                      "new_value"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_host_SStoreResult.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_host_SStoreResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SStoreResult".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_host_SStoreResult.
  
  Module Impl_revm_context_interface_host_SStoreResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SStoreResult".
    
    (*
        pub fn is_new_eq_present(&self) -> bool {
            self.new_value == self.present_value
        }
    *)
    Definition is_new_eq_present (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              [],
              [
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                  []
              ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "new_value"
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "present_value"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_new_eq_present :
      M.IsAssociatedFunction.Trait Self "is_new_eq_present" is_new_eq_present.
    Admitted.
    Global Typeclasses Opaque is_new_eq_present.
    
    (*
        pub fn is_original_eq_present(&self) -> bool {
            self.original_value == self.present_value
        }
    *)
    Definition is_original_eq_present (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              [],
              [
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                  []
              ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "original_value"
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "present_value"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_original_eq_present :
      M.IsAssociatedFunction.Trait Self "is_original_eq_present" is_original_eq_present.
    Admitted.
    Global Typeclasses Opaque is_original_eq_present.
    
    (*
        pub fn is_original_eq_new(&self) -> bool {
            self.original_value == self.new_value
        }
    *)
    Definition is_original_eq_new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              [],
              [
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                  []
              ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "original_value"
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "new_value"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_original_eq_new :
      M.IsAssociatedFunction.Trait Self "is_original_eq_new" is_original_eq_new.
    Admitted.
    Global Typeclasses Opaque is_original_eq_new.
    
    (*
        pub fn is_original_zero(&self) -> bool {
            self.original_value.is_zero()
        }
    *)
    Definition is_original_zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              "is_zero",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "original_value"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_original_zero :
      M.IsAssociatedFunction.Trait Self "is_original_zero" is_original_zero.
    Admitted.
    Global Typeclasses Opaque is_original_zero.
    
    (*
        pub fn is_present_zero(&self) -> bool {
            self.present_value.is_zero()
        }
    *)
    Definition is_present_zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              "is_zero",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "present_value"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_present_zero :
      M.IsAssociatedFunction.Trait Self "is_present_zero" is_present_zero.
    Admitted.
    Global Typeclasses Opaque is_present_zero.
    
    (*
        pub fn is_new_zero(&self) -> bool {
            self.new_value.is_zero()
        }
    *)
    Definition is_new_zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              "is_zero",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_context_interface::host::SStoreResult",
                  "new_value"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_new_zero :
      M.IsAssociatedFunction.Trait Self "is_new_zero" is_new_zero.
    Admitted.
    Global Typeclasses Opaque is_new_zero.
  End Impl_revm_context_interface_host_SStoreResult.
  
  (* StructRecord
    {
      name := "SelfDestructResult";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("had_value", Ty.path "bool");
          ("target_exists", Ty.path "bool");
          ("previously_destroyed", Ty.path "bool")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_context_interface_host_SelfDestructResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SelfDestructResult".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "revm_context_interface::host::SelfDestructResult"
            [
              ("had_value",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "bool",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SelfDestructResult",
                            "had_value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("target_exists",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "bool",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SelfDestructResult",
                            "target_exists"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("previously_destroyed",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "bool",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SelfDestructResult",
                            "previously_destroyed"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_host_SelfDestructResult.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_host_SelfDestructResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SelfDestructResult".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "SelfDestructResult" |) |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "had_value" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::host::SelfDestructResult",
                      "had_value"
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "target_exists" |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::host::SelfDestructResult",
                      "target_exists"
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "previously_destroyed" |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_context_interface::host::SelfDestructResult",
                          "previously_destroyed"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_host_SelfDestructResult.
  
  Module Impl_core_default_Default_for_revm_context_interface_host_SelfDestructResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SelfDestructResult".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "revm_context_interface::host::SelfDestructResult"
            [
              ("had_value",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "bool",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("target_exists",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "bool",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("previously_destroyed",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "bool",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_context_interface_host_SelfDestructResult.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_host_SelfDestructResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SelfDestructResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_host_SelfDestructResult.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_host_SelfDestructResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SelfDestructResult".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_context_interface::host::SelfDestructResult",
                    "had_value"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "revm_context_interface::host::SelfDestructResult",
                    "had_value"
                  |)
                |)
              |),
              ltac:(M.monadic
                (BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::host::SelfDestructResult",
                      "target_exists"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_context_interface::host::SelfDestructResult",
                      "target_exists"
                    |)
                  |)
                |)))
            |),
            ltac:(M.monadic
              (BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_context_interface::host::SelfDestructResult",
                    "previously_destroyed"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "revm_context_interface::host::SelfDestructResult",
                    "previously_destroyed"
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_host_SelfDestructResult.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_host_SelfDestructResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SelfDestructResult".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_host_SelfDestructResult.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_host_SelfDestructResult.
    Definition Self : Ty.t := Ty.path "revm_context_interface::host::SelfDestructResult".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "bool",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SelfDestructResult",
                            "had_value"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "bool",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::host::SelfDestructResult",
                            "target_exists"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "bool",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_context_interface::host::SelfDestructResult",
                          "previously_destroyed"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_host_SelfDestructResult.
End host.
