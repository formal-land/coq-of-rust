(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module result.
  (* Trait *)
  (* Empty module 'HaltReasonTrait' *)
  
  Module Impl_revm_context_interface_result_HaltReasonTrait_where_core_clone_Clone_HaltReasonT_where_core_fmt_Debug_HaltReasonT_where_core_cmp_PartialEq_HaltReasonT_where_core_cmp_Eq_HaltReasonT_where_core_convert_From_HaltReasonT_revm_context_interface_result_HaltReason_for_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t := HaltReasonT.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::result::HaltReasonTrait"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [].
  End Impl_revm_context_interface_result_HaltReasonTrait_where_core_clone_Clone_HaltReasonT_where_core_fmt_Debug_HaltReasonT_where_core_cmp_PartialEq_HaltReasonT_where_core_cmp_Eq_HaltReasonT_where_core_convert_From_HaltReasonT_revm_context_interface_result_HaltReason_for_HaltReasonT.
  
  (* StructRecord
    {
      name := "ResultAndState";
      const_params := [];
      ty_params := [ "HaltReasonT" ];
      fields :=
        [
          ("result",
            Ty.apply
              (Ty.path "revm_context_interface::result::ExecutionResult")
              []
              [ HaltReasonT ]);
          ("state",
            Ty.apply
              (Ty.path "hashbrown::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.path "revm_state::Account";
                Ty.path "foldhash::seed::fast::RandomState";
                Ty.path "hashbrown::raw::alloc::inner::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* Debug *)
    Definition fmt (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ResultAndState" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "result" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::result::ResultAndState",
                      "result"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "state" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_context_interface::result::ResultAndState",
                          "state"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt HaltReasonT)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* Clone *)
    Definition clone
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "revm_context_interface::result::ResultAndState"
            [
              ("result",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "revm_context_interface::result::ExecutionResult")
                    []
                    [ HaltReasonT ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "revm_context_interface::result::ExecutionResult")
                      []
                      [ HaltReasonT ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::result::ResultAndState",
                            "result"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("state",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "hashbrown::map::HashMap")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.path "revm_state::Account";
                      Ty.path "foldhash::seed::fast::RandomState";
                      Ty.path "hashbrown::raw::alloc::inner::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "hashbrown::map::HashMap")
                      []
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.path "revm_state::Account";
                        Ty.path "foldhash::seed::fast::RandomState";
                        Ty.path "hashbrown::raw::alloc::inner::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_context_interface::result::ResultAndState",
                            "state"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("clone", InstanceField.Method (clone HaltReasonT)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_context_interface_result_ResultAndState_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* PartialEq *)
    Definition eq (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "revm_context_interface::result::ExecutionResult")
                  []
                  [ HaltReasonT ],
                [],
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::result::ExecutionResult")
                    []
                    [ HaltReasonT ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_context_interface::result::ResultAndState",
                    "result"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "revm_context_interface::result::ResultAndState",
                    "result"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "hashbrown::map::HashMap")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.path "revm_state::Account";
                      Ty.path "foldhash::seed::fast::RandomState";
                      Ty.path "hashbrown::raw::alloc::inner::Global"
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "hashbrown::map::HashMap")
                      []
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.path "revm_state::Account";
                        Ty.path "foldhash::seed::fast::RandomState";
                        Ty.path "hashbrown::raw::alloc::inner::Global"
                      ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_context_interface::result::ResultAndState",
                      "state"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_context_interface::result::ResultAndState",
                      "state"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ] ]
        (Self HaltReasonT)
        (* Instance *) [ ("eq", InstanceField.Method (eq HaltReasonT)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_context_interface_result_ResultAndState_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq HaltReasonT))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  (*
  Enum ExecutionResult
  {
    const_params := [];
    ty_params := [ "HaltReasonT" ];
    variants :=
      [
        {
          name := "Success";
          item :=
            StructRecord
              [
                ("reason", Ty.path "revm_context_interface::result::SuccessReason");
                ("gas_used", Ty.path "u64");
                ("gas_refunded", Ty.path "u64");
                ("logs",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::log::Log")
                        []
                        [ Ty.path "alloy_primitives::log::LogData" ];
                      Ty.path "alloc::alloc::Global"
                    ]);
                ("output", Ty.path "revm_context_interface::result::Output")
              ];
        };
        {
          name := "Revert";
          item :=
            StructRecord
              [ ("gas_used", Ty.path "u64"); ("output", Ty.path "alloy_primitives::bytes_::Bytes")
              ];
        };
        {
          name := "Halt";
          item := StructRecord [ ("reason", HaltReasonT); ("gas_used", Ty.path "u64") ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_ExecutionResult_Success :
    M.IsDiscriminant "revm_context_interface::result::ExecutionResult::Success" 0.
  Axiom IsDiscriminant_ExecutionResult_Revert :
    M.IsDiscriminant "revm_context_interface::result::ExecutionResult::Revert" 1.
  Axiom IsDiscriminant_ExecutionResult_Halt :
    M.IsDiscriminant "revm_context_interface::result::ExecutionResult::Halt" 2.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Clone *)
    Definition clone
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "revm_context_interface::result::ExecutionResult")
                  []
                  [ HaltReasonT ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::ExecutionResult::Success"
                        [
                          ("reason",
                            M.call_closure (|
                              Ty.path "revm_context_interface::result::SuccessReason",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_context_interface::result::SuccessReason",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |));
                          ("gas_used",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |)
                              ]
                            |));
                          ("gas_refunded",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |)
                              ]
                            |));
                          ("logs",
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::log::Log")
                                    []
                                    [ Ty.path "alloy_primitives::log::LogData" ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::log::Log")
                                      []
                                      [ Ty.path "alloy_primitives::log::LogData" ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_3 |) |) |)
                              ]
                            |));
                          ("output",
                            M.call_closure (|
                              Ty.path "revm_context_interface::result::Output",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_context_interface::result::Output",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_4 |) |) |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::ExecutionResult::Revert"
                        [
                          ("gas_used",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |));
                          ("output",
                            M.call_closure (|
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "alloy_primitives::bytes_::Bytes",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::ExecutionResult::Halt"
                        [
                          ("reason",
                            M.call_closure (|
                              HaltReasonT,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                HaltReasonT,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |));
                          ("gas_used",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |)
                              ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("clone", InstanceField.Method (clone HaltReasonT)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Debug *)
    Definition fmt (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field5_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Success" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "reason" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "gas_used" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "gas_refunded" |) |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "logs" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_3 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "output" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_4 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Revert" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "gas_used" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "output" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Halt" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "reason" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "gas_used" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt HaltReasonT)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_context_interface_result_ExecutionResult_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* PartialEq *)
    Definition eq (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::ExecutionResult")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::ExecutionResult")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let γ2_2 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_refunded"
                              |) in
                            let γ2_3 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "logs"
                              |) in
                            let γ2_4 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "output"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let __self_2 := M.alloc (| γ2_2 |) in
                            let __self_3 := M.alloc (| γ2_3 |) in
                            let __self_4 := M.alloc (| γ2_4 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let γ2_2 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_refunded"
                              |) in
                            let γ2_3 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "logs"
                              |) in
                            let γ2_4 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "output"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            let __arg1_2 := M.alloc (| γ2_2 |) in
                            let __arg1_3 := M.alloc (| γ2_3 |) in
                            let __arg1_4 := M.alloc (| γ2_4 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    LogicalOp.and (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "revm_context_interface::result::SuccessReason"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "revm_context_interface::result::SuccessReason"
                                              ]
                                          ],
                                          "eq",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                          M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                        ]
                                      |),
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                            "eq",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                            M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                          ]
                                        |)))
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                          [],
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                          "eq",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (| Pointer.Kind.Ref, __self_2 |);
                                          M.borrow (| Pointer.Kind.Ref, __arg1_2 |)
                                        ]
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::log::Log")
                                                  []
                                                  [ Ty.path "alloy_primitives::log::LogData" ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloy_primitives::log::Log")
                                                    []
                                                    [ Ty.path "alloy_primitives::log::LogData" ];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, __self_3 |);
                                        M.borrow (| Pointer.Kind.Ref, __arg1_3 |)
                                      ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "revm_context_interface::result::Output" ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "revm_context_interface::result::Output" ]
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_4 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_4 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "output"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "output"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ HaltReasonT ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ HaltReasonT ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::intrinsics::unreachable", [], [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ] ]
        (Self HaltReasonT)
        (* Instance *) [ ("eq", InstanceField.Method (eq HaltReasonT)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_context_interface_result_ExecutionResult_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              None,
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      None,
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              None,
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      None,
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq HaltReasonT))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Hash *)
    Definition hash
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::ExecutionResult")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "revm_context_interface::result::SuccessReason",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::log::Log")
                                  []
                                  [ Ty.path "alloy_primitives::log::LogData" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_3 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_context_interface::result::Output",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_4 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloy_primitives::bytes_::Bytes",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            HaltReasonT,
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("hash", InstanceField.Method (hash HaltReasonT)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (*
        pub fn is_success(&self) -> bool {
            matches!(self, Self::Success { .. })
        }
    *)
    Definition is_success
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "bool"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_success :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "is_success" (is_success HaltReasonT).
    Admitted.
    Global Typeclasses Opaque is_success.
    
    (*
        pub fn created_address(&self) -> Option<Address> {
            match self {
                Self::Success { output, .. } => output.address().cloned(),
                _ => None,
            }
        }
    *)
    Definition created_address
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "alloy_primitives::bits::address::Address" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "alloy_primitives::bits::address::Address" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "alloy_primitives::bits::address::Address" ]
                            ],
                          "cloned",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloy_primitives::bits::address::Address" ]
                              ],
                            M.get_associated_function (|
                              Ty.path "revm_context_interface::result::Output",
                              "address",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| output |) |) |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_created_address :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "created_address" (created_address HaltReasonT).
    Admitted.
    Global Typeclasses Opaque created_address.
    
    (*
        pub fn is_halt(&self) -> bool {
            matches!(self, Self::Halt { .. })
        }
    *)
    Definition is_halt
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "bool"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_halt :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "is_halt" (is_halt HaltReasonT).
    Admitted.
    Global Typeclasses Opaque is_halt.
    
    (*
        pub fn output(&self) -> Option<&Bytes> {
            match self {
                Self::Success { output, .. } => Some(output.data()),
                Self::Revert { output, .. } => Some(output),
                _ => None,
            }
        }
    *)
    Definition output
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ] ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                M.get_associated_function (|
                                  Ty.path "revm_context_interface::result::Output",
                                  "data",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| output |) |) |)
                                ]
                              |)
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| output |) |) |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_output :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "output" (output HaltReasonT).
    Admitted.
    Global Typeclasses Opaque output.
    
    (*
        pub fn into_output(self) -> Option<Bytes> {
            match self {
                Self::Success { output, .. } => Some(output.into_data()),
                Self::Revert { output, .. } => Some(output),
                _ => None,
            }
        }
    *)
    Definition into_output
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "alloy_primitives::bytes_::Bytes" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            Ty.path "alloy_primitives::bytes_::Bytes",
                            M.get_associated_function (|
                              Ty.path "revm_context_interface::result::Output",
                              "into_data",
                              [],
                              []
                            |),
                            [ M.read (| output |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let output := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| output |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_output :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "into_output" (into_output HaltReasonT).
    Admitted.
    Global Typeclasses Opaque into_output.
    
    (*
        pub fn logs(&self) -> &[Log] {
            match self {
                Self::Success { logs, .. } => logs.as_slice(),
                _ => &[],
            }
        }
    *)
    Definition logs
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.read (|
                M.match_operator (|
                  Some
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::log::Log")
                              []
                              [ Ty.path "alloy_primitives::log::LogData" ]
                          ]
                      ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "revm_context_interface::result::ExecutionResult::Success",
                            "logs"
                          |) in
                        let logs := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::log::Log")
                                          []
                                          [ Ty.path "alloy_primitives::log::LogData" ]
                                      ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::log::Log")
                                        []
                                        [ Ty.path "alloy_primitives::log::LogData" ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "as_slice",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| logs |) |) |) ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [] |) |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_logs :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "logs" (logs HaltReasonT).
    Admitted.
    Global Typeclasses Opaque logs.
    
    (*
        pub fn into_logs(self) -> Vec<Log> {
            match self {
                Self::Success { logs, .. } => logs,
                _ => Vec::new(),
            }
        }
    *)
    Definition into_logs
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::log::Log")
                      []
                      [ Ty.path "alloy_primitives::log::LogData" ];
                    Ty.path "alloc::alloc::Global"
                  ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let logs := M.copy (| γ0_0 |) in
                    logs));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::log::Log")
                              []
                              [ Ty.path "alloy_primitives::log::LogData" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::log::Log")
                                []
                                [ Ty.path "alloy_primitives::log::LogData" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        []
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_logs :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "into_logs" (into_logs HaltReasonT).
    Admitted.
    Global Typeclasses Opaque into_logs.
    
    (*
        pub fn gas_used(&self) -> u64 {
            match *self {
                Self::Success { gas_used, .. }
                | Self::Revert { gas_used, .. }
                | Self::Halt { gas_used, .. } => gas_used,
            }
        }
    *)
    Definition gas_used
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "u64"),
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ gas_used ] => ltac:(M.monadic gas_used)
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_gas_used :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "gas_used" (gas_used HaltReasonT).
    Admitted.
    Global Typeclasses Opaque gas_used.
  End Impl_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  (*
  Enum Output
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Call";
          item := StructTuple [ Ty.path "alloy_primitives::bytes_::Bytes" ];
        };
        {
          name := "Create";
          item :=
            StructTuple
              [
                Ty.path "alloy_primitives::bytes_::Bytes";
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "alloy_primitives::bits::address::Address" ]
              ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_Output_Call :
    M.IsDiscriminant "revm_context_interface::result::Output::Call" 0.
  Axiom IsDiscriminant_Output_Create :
    M.IsDiscriminant "revm_context_interface::result::Output::Create" 1.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Call" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Create" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_Output.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "revm_context_interface::result::Output"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::Output::Call"
                        [
                          M.call_closure (|
                            Ty.path "alloy_primitives::bytes_::Bytes",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::Output::Create"
                        [
                          M.call_closure (|
                            Ty.path "alloy_primitives::bytes_::Bytes",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |);
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "alloy_primitives::bits::address::Address" ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "alloy_primitives::bits::address::Address" ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_Output.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_Output.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_result_Output_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::Output" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::Output" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::Output::Call",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::Output::Call",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::Output::Create",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::Output::Create",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::Output::Create",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::Output::Create",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "alloy_primitives::bits::address::Address" ]
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "alloy_primitives::bits::address::Address" ]
                                          ]
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::intrinsics::unreachable", [], [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::Output" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_result_Output_for_revm_context_interface_result_Output.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_Output.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::Output" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloy_primitives::bytes_::Bytes",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "alloy_primitives::bytes_::Bytes",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_Output.
  
  Module Impl_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (*
        pub fn into_data(self) -> Bytes {
            match self {
                Output::Call(data) => data,
                Output::Create(data, _) => data,
            }
        }
    *)
    Definition into_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "alloy_primitives::bytes_::Bytes"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    data));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ0_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    data))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_data :
      M.IsAssociatedFunction.C Self "into_data" into_data.
    Admitted.
    Global Typeclasses Opaque into_data.
    
    (*
        pub fn data(&self) -> &Bytes {
            match self {
                Output::Call(data) => data,
                Output::Create(data, _) => data,
            }
        }
    *)
    Definition data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.read (|
                M.match_operator (|
                  Some (Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "revm_context_interface::result::Output::Call",
                            0
                          |) in
                        let data := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "revm_context_interface::result::Output::Create",
                            0
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "revm_context_interface::result::Output::Create",
                            1
                          |) in
                        let data := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |)
                        |)))
                  ]
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_data : M.IsAssociatedFunction.C Self "data" data.
    Admitted.
    Global Typeclasses Opaque data.
    
    (*
        pub fn address(&self) -> Option<&Address> {
            match self {
                Output::Call(_) => None,
                Output::Create(_, address) => address.as_ref(),
            }
        }
    *)
    Definition address (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ]
                  ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let address := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloy_primitives::bits::address::Address" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                          "as_ref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_address : M.IsAssociatedFunction.C Self "address" address.
    Admitted.
    Global Typeclasses Opaque address.
  End Impl_revm_context_interface_result_Output.
  
  (*
  Enum EVMError
  {
    const_params := [];
    ty_params := [ "DBError"; "TransactionError" ];
    variants :=
      [
        {
          name := "Transaction";
          item := StructTuple [ TransactionError ];
        };
        {
          name := "Header";
          item := StructTuple [ Ty.path "revm_context_interface::result::InvalidHeader" ];
        };
        {
          name := "Database";
          item := StructTuple [ DBError ];
        };
        {
          name := "Custom";
          item := StructTuple [ Ty.path "alloc::string::String" ];
        };
        {
          name := "Precompile";
          item := StructTuple [ Ty.path "alloc::string::String" ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_EVMError_Transaction :
    M.IsDiscriminant "revm_context_interface::result::EVMError::Transaction" 0.
  Axiom IsDiscriminant_EVMError_Header :
    M.IsDiscriminant "revm_context_interface::result::EVMError::Header" 1.
  Axiom IsDiscriminant_EVMError_Database :
    M.IsDiscriminant "revm_context_interface::result::EVMError::Database" 2.
  Axiom IsDiscriminant_EVMError_Custom :
    M.IsDiscriminant "revm_context_interface::result::EVMError::Custom" 3.
  Axiom IsDiscriminant_EVMError_Precompile :
    M.IsDiscriminant "revm_context_interface::result::EVMError::Precompile" 4.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_DBError_where_core_fmt_Debug_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* Debug *)
    Definition fmt
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Transaction" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Header" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Database" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Custom",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Custom" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Precompile",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Precompile" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self DBError TransactionError)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt DBError TransactionError)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_DBError_where_core_fmt_Debug_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_DBError_where_core_clone_Clone_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* Clone *)
    Definition clone
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "revm_context_interface::result::EVMError")
                  []
                  [ DBError; TransactionError ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Transaction"
                        [
                          M.call_closure (|
                            TransactionError,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              TransactionError,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Header"
                        [
                          M.call_closure (|
                            Ty.path "revm_context_interface::result::InvalidHeader",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "revm_context_interface::result::InvalidHeader",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Database"
                        [
                          M.call_closure (|
                            DBError,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              DBError,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Custom",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Custom"
                        [
                          M.call_closure (|
                            Ty.path "alloc::string::String",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloc::string::String",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Precompile",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Precompile"
                        [
                          M.call_closure (|
                            Ty.path "alloc::string::String",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloc::string::String",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self DBError TransactionError)
        (* Instance *) [ ("clone", InstanceField.Method (clone DBError TransactionError)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_DBError_where_core_clone_Clone_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self DBError TransactionError)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_DBError_where_core_cmp_PartialEq_TransactionError_revm_context_interface_result_EVMError_DBError_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* PartialEq *)
    Definition eq
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::EVMError")
                        []
                        [ DBError; TransactionError ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::EVMError")
                        []
                        [ DBError; TransactionError ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Transaction",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Transaction",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ TransactionError ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ TransactionError ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Header",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Header",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "revm_context_interface::result::InvalidHeader" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Database",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Database",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ DBError ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ DBError ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::intrinsics::unreachable", [], [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "revm_context_interface::result::EVMError")
            []
            [ DBError; TransactionError ]
        ]
        (Self DBError TransactionError)
        (* Instance *) [ ("eq", InstanceField.Method (eq DBError TransactionError)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_DBError_where_core_cmp_PartialEq_TransactionError_revm_context_interface_result_EVMError_DBError_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_DBError_where_core_cmp_Eq_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              None,
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      None,
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self DBError TransactionError)
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq DBError TransactionError))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_DBError_where_core_cmp_Eq_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_convert_From_where_revm_database_interface_DBErrorMarker_DBError_DBError_for_revm_context_interface_result_EVMError_DBError_TX.
    Definition Self (DBError TX : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::EVMError") [] [ DBError; TX ].
    
    (*
        fn from(value: DBError) -> Self {
            Self::Database(value)
        }
    *)
    Definition from (DBError TX : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError TX in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Database"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TX : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ DBError ]
        (Self DBError TX)
        (* Instance *) [ ("from", InstanceField.Method (from DBError TX)) ].
  End Impl_core_convert_From_where_revm_database_interface_DBErrorMarker_DBError_DBError_for_revm_context_interface_result_EVMError_DBError_TX.
  
  (* Trait *)
  (* Empty module 'FromStringError' *)
  
  Module Impl_revm_context_interface_result_FromStringError_for_revm_context_interface_result_EVMError_DB_TX.
    Definition Self (DB TX : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::EVMError") [] [ DB; TX ].
    
    (*
        fn from_string(value: String) -> Self {
            Self::Custom(value)
        }
    *)
    Definition from_string
        (DB TX : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DB TX in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Custom"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DB TX : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::result::FromStringError"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self DB TX)
        (* Instance *) [ ("from_string", InstanceField.Method (from_string DB TX)) ].
  End Impl_revm_context_interface_result_FromStringError_for_revm_context_interface_result_EVMError_DB_TX.
  
  Module Impl_core_convert_From_revm_context_interface_result_InvalidTransaction_for_revm_context_interface_result_EVMError_DB_revm_context_interface_result_InvalidTransaction.
    Definition Self (DB : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DB; Ty.path "revm_context_interface::result::InvalidTransaction" ].
    
    (*
        fn from(value: InvalidTransaction) -> Self {
            Self::Transaction(value)
        }
    *)
    Definition from (DB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DB in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Transaction"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DB : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
        (Self DB)
        (* Instance *) [ ("from", InstanceField.Method (from DB)) ].
  End Impl_core_convert_From_revm_context_interface_result_InvalidTransaction_for_revm_context_interface_result_EVMError_DB_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        pub fn map_db_err<F, E>(self, op: F) -> EVMError<E, TransactionValidationErrorT>
        where
            F: FnOnce(DBError) -> E,
        {
            match self {
                Self::Transaction(e) => EVMError::Transaction(e),
                Self::Header(e) => EVMError::Header(e),
                Self::Database(e) => EVMError::Database(op(e)),
                Self::Precompile(e) => EVMError::Precompile(e),
                Self::Custom(e) => EVMError::Custom(e),
            }
        }
    *)
    Definition map_db_err
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [ F; E ], [ self; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let op := M.alloc (| op |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "revm_context_interface::result::EVMError")
                  []
                  [ E; TransactionValidationErrorT ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Transaction"
                        [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Header"
                        [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Database"
                        [
                          M.call_closure (|
                            E,
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [],
                              [ Ty.tuple [ DBError ] ],
                              "call_once",
                              [],
                              []
                            |),
                            [ M.read (| op |); Value.Tuple [ M.read (| e |) ] ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Precompile",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Precompile"
                        [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Custom",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Custom"
                        [ M.read (| e |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_map_db_err :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsAssociatedFunction.C
        (Self DBError TransactionValidationErrorT)
        "map_db_err"
        (map_db_err DBError TransactionValidationErrorT).
    Admitted.
    Global Typeclasses Opaque map_db_err.
  End Impl_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  Module Impl_core_error_Error_where_core_error_Error_DBError_where_core_error_Error_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {
            match self {
                Self::Transaction(e) => Some(e),
                Self::Header(e) => Some(e),
                Self::Database(e) => Some(e),
                Self::Precompile(_) | Self::Custom(_) => None,
            }
        }
    *)
    Definition source
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| e |) |) |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| e |) |) |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| e |) |) |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self DBError TransactionValidationErrorT)
        (* Instance *)
        [ ("source", InstanceField.Method (source DBError TransactionValidationErrorT)) ].
  End Impl_core_error_Error_where_core_error_Error_DBError_where_core_error_Error_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_DBError_where_core_fmt_Display_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Transaction(e) => write!(f, "transaction validation error: {e}"),
                Self::Header(e) => write!(f, "header validation error: {e}"),
                Self::Database(e) => write!(f, "database error: {e}"),
                Self::Precompile(e) | Self::Custom(e) => f.write_str(e),
            }
        }
    *)
    Definition fmt
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "transaction validation error: " |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ TransactionValidationErrorT ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, e |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "header validation error: " |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "revm_context_interface::result::InvalidHeader"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, e |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "database error: " |) ] |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ DBError ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, e |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            let e := M.alloc (| γ1_0 |) in
                            Value.Tuple [ e ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            let e := M.alloc (| γ1_0 |) in
                            Value.Tuple [ e ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ e ] =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_str",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| f |) |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.path "alloc::string::String",
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| e |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self DBError TransactionValidationErrorT)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt DBError TransactionValidationErrorT)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_DBError_where_core_fmt_Display_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  Module Impl_core_convert_From_revm_context_interface_result_InvalidHeader_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        fn from(value: InvalidHeader) -> Self {
            Self::Header(value)
        }
    *)
    Definition from
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Header"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::InvalidHeader" ]
        (Self DBError TransactionValidationErrorT)
        (* Instance *)
        [ ("from", InstanceField.Method (from DBError TransactionValidationErrorT)) ].
  End Impl_core_convert_From_revm_context_interface_result_InvalidHeader_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  (*
  Enum InvalidTransaction
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "PriorityFeeGreaterThanMaxFee";
          item := StructTuple [];
        };
        {
          name := "GasPriceLessThanBasefee";
          item := StructTuple [];
        };
        {
          name := "CallerGasLimitMoreThanBlock";
          item := StructTuple [];
        };
        {
          name := "CallGasCostMoreThanGasLimit";
          item := StructTuple [];
        };
        {
          name := "RejectCallerWithCode";
          item := StructTuple [];
        };
        {
          name := "LackOfFundForMaxFee";
          item :=
            StructRecord
              [
                ("fee",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        [];
                      Ty.path "alloc::alloc::Global"
                    ]);
                ("balance",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        [];
                      Ty.path "alloc::alloc::Global"
                    ])
              ];
        };
        {
          name := "OverflowPaymentInTransaction";
          item := StructTuple [];
        };
        {
          name := "NonceOverflowInTransaction";
          item := StructTuple [];
        };
        {
          name := "NonceTooHigh";
          item := StructRecord [ ("tx", Ty.path "u64"); ("state", Ty.path "u64") ];
        };
        {
          name := "NonceTooLow";
          item := StructRecord [ ("tx", Ty.path "u64"); ("state", Ty.path "u64") ];
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
        };
        {
          name := "InvalidChainId";
          item := StructTuple [];
        };
        {
          name := "AccessListNotSupported";
          item := StructTuple [];
        };
        {
          name := "MaxFeePerBlobGasNotSupported";
          item := StructTuple [];
        };
        {
          name := "BlobVersionedHashesNotSupported";
          item := StructTuple [];
        };
        {
          name := "BlobGasPriceGreaterThanMax";
          item := StructTuple [];
        };
        {
          name := "EmptyBlobs";
          item := StructTuple [];
        };
        {
          name := "BlobCreateTransaction";
          item := StructTuple [];
        };
        {
          name := "TooManyBlobs";
          item := StructRecord [ ("max", Ty.path "usize"); ("have", Ty.path "usize") ];
        };
        {
          name := "BlobVersionNotSupported";
          item := StructTuple [];
        };
        {
          name := "EofCrateShouldHaveToAddress";
          item := StructTuple [];
        };
        {
          name := "AuthorizationListNotSupported";
          item := StructTuple [];
        };
        {
          name := "AuthorizationListInvalidFields";
          item := StructTuple [];
        };
        {
          name := "EmptyAuthorizationList";
          item := StructTuple [];
        };
        {
          name := "InvalidAuthorizationList";
          item :=
            StructTuple
              [ Ty.path "revm_specification::eip7702::authorization_list::InvalidAuthorization" ];
        };
        {
          name := "Eip2930NotSupported";
          item := StructTuple [];
        };
        {
          name := "Eip1559NotSupported";
          item := StructTuple [];
        };
        {
          name := "Eip4844NotSupported";
          item := StructTuple [];
        };
        {
          name := "Eip7702NotSupported";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_InvalidTransaction_PriorityFeeGreaterThanMaxFee :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
      0.
  Axiom IsDiscriminant_InvalidTransaction_GasPriceLessThanBasefee :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
      1.
  Axiom IsDiscriminant_InvalidTransaction_CallerGasLimitMoreThanBlock :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
      2.
  Axiom IsDiscriminant_InvalidTransaction_CallGasCostMoreThanGasLimit :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
      3.
  Axiom IsDiscriminant_InvalidTransaction_RejectCallerWithCode :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode" 4.
  Axiom IsDiscriminant_InvalidTransaction_LackOfFundForMaxFee :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee" 5.
  Axiom IsDiscriminant_InvalidTransaction_OverflowPaymentInTransaction :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
      6.
  Axiom IsDiscriminant_InvalidTransaction_NonceOverflowInTransaction :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
      7.
  Axiom IsDiscriminant_InvalidTransaction_NonceTooHigh :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::NonceTooHigh" 8.
  Axiom IsDiscriminant_InvalidTransaction_NonceTooLow :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::NonceTooLow" 9.
  Axiom IsDiscriminant_InvalidTransaction_CreateInitCodeSizeLimit :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
      10.
  Axiom IsDiscriminant_InvalidTransaction_InvalidChainId :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::InvalidChainId" 11.
  Axiom IsDiscriminant_InvalidTransaction_AccessListNotSupported :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
      12.
  Axiom IsDiscriminant_InvalidTransaction_MaxFeePerBlobGasNotSupported :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
      13.
  Axiom IsDiscriminant_InvalidTransaction_BlobVersionedHashesNotSupported :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
      14.
  Axiom IsDiscriminant_InvalidTransaction_BlobGasPriceGreaterThanMax :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
      15.
  Axiom IsDiscriminant_InvalidTransaction_EmptyBlobs :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::EmptyBlobs" 16.
  Axiom IsDiscriminant_InvalidTransaction_BlobCreateTransaction :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction" 17.
  Axiom IsDiscriminant_InvalidTransaction_TooManyBlobs :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::TooManyBlobs" 18.
  Axiom IsDiscriminant_InvalidTransaction_BlobVersionNotSupported :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
      19.
  Axiom IsDiscriminant_InvalidTransaction_EofCrateShouldHaveToAddress :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
      20.
  Axiom IsDiscriminant_InvalidTransaction_AuthorizationListNotSupported :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
      21.
  Axiom IsDiscriminant_InvalidTransaction_AuthorizationListInvalidFields :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
      22.
  Axiom IsDiscriminant_InvalidTransaction_EmptyAuthorizationList :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
      23.
  Axiom IsDiscriminant_InvalidTransaction_InvalidAuthorizationList :
    M.IsDiscriminant
      "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList"
      24.
  Axiom IsDiscriminant_InvalidTransaction_Eip2930NotSupported :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported" 25.
  Axiom IsDiscriminant_InvalidTransaction_Eip1559NotSupported :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported" 26.
  Axiom IsDiscriminant_InvalidTransaction_Eip4844NotSupported :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported" 27.
  Axiom IsDiscriminant_InvalidTransaction_Eip7702NotSupported :
    M.IsDiscriminant "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported" 28.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "PriorityFeeGreaterThanMaxFee" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "GasPriceLessThanBasefee" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CallerGasLimitMoreThanBlock" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CallGasCostMoreThanGasLimit" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "RejectCallerWithCode" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "LackOfFundForMaxFee" |) |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "fee" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "balance" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "OverflowPaymentInTransaction" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "NonceOverflowInTransaction" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "NonceTooHigh" |) |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "tx" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "state" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NonceTooLow" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "tx" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "state" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CreateInitCodeSizeLimit" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "InvalidChainId" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "AccessListNotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "MaxFeePerBlobGasNotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "BlobVersionedHashesNotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "BlobGasPriceGreaterThanMax" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "EmptyBlobs" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "BlobCreateTransaction" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "TooManyBlobs" |) |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "max" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "have" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "BlobVersionNotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "EofCrateShouldHaveToAddress" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "AuthorizationListNotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "AuthorizationListInvalidFields" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "EmptyAuthorizationList" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "InvalidAuthorizationList" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Eip2930NotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Eip1559NotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Eip4844NotSupported" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Eip7702NotSupported" |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "revm_context_interface::result::InvalidTransaction"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee"
                        [
                          ("fee",
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    [];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      [];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |));
                          ("balance",
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    [];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      [];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh"
                        [
                          ("tx",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |));
                          ("state",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow"
                        [
                          ("tx",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |));
                          ("state",
                            M.call_closure (|
                              Ty.path "u64",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs"
                        [
                          ("max",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "usize",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |));
                          ("have",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "usize",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList"
                        [
                          M.call_closure (|
                            Ty.path
                              "revm_specification::eip7702::authorization_list::InvalidAuthorization",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "revm_specification::eip7702::authorization_list::InvalidAuthorization",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_result_InvalidTransaction_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "fee"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "balance"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "fee"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "balance"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::Uint")
                                              [
                                                Value.Integer IntegerKind.Usize 256;
                                                Value.Integer IntegerKind.Usize 4
                                              ]
                                              [];
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "ruint::Uint")
                                                [
                                                  Value.Integer IntegerKind.Usize 256;
                                                  Value.Integer IntegerKind.Usize 4
                                                ]
                                                [];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ]
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "ruint::Uint")
                                                [
                                                  Value.Integer IntegerKind.Usize 256;
                                                  Value.Integer IntegerKind.Usize 4
                                                ]
                                                [];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "ruint::Uint")
                                                  [
                                                    Value.Integer IntegerKind.Usize 256;
                                                    Value.Integer IntegerKind.Usize 4
                                                  ]
                                                  [];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "state"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "state"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "state"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "state"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "max"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "have"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "max"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "have"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "revm_specification::eip7702::authorization_list::InvalidAuthorization"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "revm_specification::eip7702::authorization_list::InvalidAuthorization"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_result_InvalidTransaction_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              None,
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      None,
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              None,
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  [];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                [];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "usize",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "usize",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path
                            "revm_specification::eip7702::authorization_list::InvalidAuthorization",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_revm_context_interface_transaction_TransactionError_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "revm_context_interface::transaction::TransactionError"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_revm_context_interface_transaction_TransactionError_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_convert_From_revm_specification_eip7702_authorization_list_InvalidAuthorization_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (*
        fn from(value: InvalidAuthorization) -> Self {
            Self::InvalidAuthorizationList(value)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_specification::eip7702::authorization_list::InvalidAuthorization" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_specification_eip7702_authorization_list_InvalidAuthorization_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_error_Error_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_fmt_Display_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::PriorityFeeGreaterThanMaxFee => {
                    write!(f, "priority fee is greater than max fee")
                }
                Self::GasPriceLessThanBasefee => {
                    write!(f, "gas price is less than basefee")
                }
                Self::CallerGasLimitMoreThanBlock => {
                    write!(f, "caller gas limit exceeds the block gas limit")
                }
                Self::CallGasCostMoreThanGasLimit => {
                    write!(f, "call gas cost exceeds the gas limit")
                }
                Self::RejectCallerWithCode => {
                    write!(f, "reject transactions from senders with deployed code")
                }
                Self::LackOfFundForMaxFee { fee, balance } => {
                    write!(f, "lack of funds ({balance}) for max fee ({fee})")
                }
                Self::OverflowPaymentInTransaction => {
                    write!(f, "overflow payment in transaction")
                }
                Self::NonceOverflowInTransaction => {
                    write!(f, "nonce overflow in transaction")
                }
                Self::NonceTooHigh { tx, state } => {
                    write!(f, "nonce {tx} too high, expected {state}")
                }
                Self::NonceTooLow { tx, state } => {
                    write!(f, "nonce {tx} too low, expected {state}")
                }
                Self::CreateInitCodeSizeLimit => {
                    write!(f, "create initcode size limit")
                }
                Self::InvalidChainId => write!(f, "invalid chain ID"),
                Self::AccessListNotSupported => write!(f, "access list not supported"),
                Self::MaxFeePerBlobGasNotSupported => {
                    write!(f, "max fee per blob gas not supported")
                }
                Self::BlobVersionedHashesNotSupported => {
                    write!(f, "blob versioned hashes not supported")
                }
                Self::BlobGasPriceGreaterThanMax => {
                    write!(f, "blob gas price is greater than max fee per blob gas")
                }
                Self::EmptyBlobs => write!(f, "empty blobs"),
                Self::BlobCreateTransaction => write!(f, "blob create transaction"),
                Self::TooManyBlobs { max, have } => {
                    write!(f, "too many blobs, have {have}, max {max}")
                }
                Self::BlobVersionNotSupported => write!(f, "blob version not supported"),
                Self::EofCrateShouldHaveToAddress => write!(f, "EOF crate should have `to` address"),
                Self::AuthorizationListNotSupported => write!(f, "authorization list not supported"),
                Self::AuthorizationListInvalidFields => {
                    write!(f, "authorization list tx has invalid fields")
                }
                Self::EmptyAuthorizationList => write!(f, "empty authorization list"),
                Self::Eip2930NotSupported => write!(f, "Eip2930 is not supported"),
                Self::Eip1559NotSupported => write!(f, "Eip1559 is not supported"),
                Self::Eip4844NotSupported => write!(f, "Eip4844 is not supported"),
                Self::Eip7702NotSupported => write!(f, "Eip7702 is not supported"),
                Self::InvalidAuthorizationList(i) => fmt::Display::fmt(i, f),
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "priority fee is greater than max fee" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "gas price is less than basefee" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (|
                                            "caller gas limit exceeds the block gas limit"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "call gas cost exceeds the gas limit" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (|
                                            "reject transactions from senders with deployed code"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let fee := M.alloc (| γ1_0 |) in
                    let balance := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (| "lack of funds (" |);
                                          mk_str (| ") for max fee (" |);
                                          mk_str (| ")" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [
                                                            Value.Integer IntegerKind.Usize 256;
                                                            Value.Integer IntegerKind.Usize 4
                                                          ]
                                                          [];
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.Ref, balance |)
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [
                                                            Value.Integer IntegerKind.Usize 256;
                                                            Value.Integer IntegerKind.Usize 4
                                                          ]
                                                          [];
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, fee |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "overflow payment in transaction" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "nonce overflow in transaction" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let tx := M.alloc (| γ1_0 |) in
                    let state := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "nonce " |); mk_str (| " too high, expected " |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, tx |) |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, state |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let tx := M.alloc (| γ1_0 |) in
                    let state := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "nonce " |); mk_str (| " too low, expected " |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, tx |) |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, state |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "create initcode size limit" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "invalid chain ID" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "access list not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "max fee per blob gas not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "blob versioned hashes not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (|
                                            "blob gas price is greater than max fee per blob gas"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "empty blobs" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "blob create transaction" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let max := M.alloc (| γ1_0 |) in
                    let have := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (| "too many blobs, have " |);
                                          mk_str (| ", max " |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, have |) |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, max |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "blob version not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "EOF crate should have `to` address" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "authorization list not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "authorization list tx has invalid fields" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "empty authorization list" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Eip2930 is not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Eip1559 is not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Eip4844 is not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Eip7702 is not supported" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_trait_method (|
                          "core::fmt::Display",
                          Ty.path
                            "revm_specification::eip7702::authorization_list::InvalidAuthorization",
                          [],
                          [],
                          "fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| i |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_context_interface_result_InvalidTransaction.
  
  (*
  Enum InvalidHeader
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "PrevrandaoNotSet";
          item := StructTuple [];
        };
        {
          name := "ExcessBlobGasNotSet";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_InvalidHeader_PrevrandaoNotSet :
    M.IsDiscriminant "revm_context_interface::result::InvalidHeader::PrevrandaoNotSet" 0.
  Axiom IsDiscriminant_InvalidHeader_ExcessBlobGasNotSet :
    M.IsDiscriminant "revm_context_interface::result::InvalidHeader::ExcessBlobGasNotSet" 1.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Some (Ty.apply (Ty.path "&") [] [ Ty.path "str" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::InvalidHeader::PrevrandaoNotSet"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "PrevrandaoNotSet" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::InvalidHeader::ExcessBlobGasNotSet"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "ExcessBlobGasNotSet" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_result_InvalidHeader_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::InvalidHeader" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_result_InvalidHeader_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_error_Error_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_fmt_Display_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::PrevrandaoNotSet => write!(f, "`prevrandao` not set"),
                Self::ExcessBlobGasNotSet => write!(f, "`excess_blob_gas` not set"),
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidHeader::PrevrandaoNotSet"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "`prevrandao` not set" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidHeader::ExcessBlobGasNotSet"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "`excess_blob_gas` not set" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_context_interface_result_InvalidHeader.
  
  (*
  Enum SuccessReason
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Stop";
          item := StructTuple [];
        };
        {
          name := "Return";
          item := StructTuple [];
        };
        {
          name := "SelfDestruct";
          item := StructTuple [];
        };
        {
          name := "EofReturnContract";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_SuccessReason_Stop :
    M.IsDiscriminant "revm_context_interface::result::SuccessReason::Stop" 0.
  Axiom IsDiscriminant_SuccessReason_Return :
    M.IsDiscriminant "revm_context_interface::result::SuccessReason::Return" 1.
  Axiom IsDiscriminant_SuccessReason_SelfDestruct :
    M.IsDiscriminant "revm_context_interface::result::SuccessReason::SelfDestruct" 2.
  Axiom IsDiscriminant_SuccessReason_EofReturnContract :
    M.IsDiscriminant "revm_context_interface::result::SuccessReason::EofReturnContract" 3.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Some (Ty.apply (Ty.path "&") [] [ Ty.path "str" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::Stop"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Stop" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::Return"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Return" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::SelfDestruct"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "SelfDestruct" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::EofReturnContract"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "EofReturnContract" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_result_SuccessReason_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::SuccessReason" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_result_SuccessReason_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_SuccessReason.
  
  (*
  Enum HaltReason
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "OutOfGas";
          item := StructTuple [ Ty.path "revm_context_interface::result::OutOfGasError" ];
        };
        {
          name := "OpcodeNotFound";
          item := StructTuple [];
        };
        {
          name := "InvalidFEOpcode";
          item := StructTuple [];
        };
        {
          name := "InvalidJump";
          item := StructTuple [];
        };
        {
          name := "NotActivated";
          item := StructTuple [];
        };
        {
          name := "StackUnderflow";
          item := StructTuple [];
        };
        {
          name := "StackOverflow";
          item := StructTuple [];
        };
        {
          name := "OutOfOffset";
          item := StructTuple [];
        };
        {
          name := "CreateCollision";
          item := StructTuple [];
        };
        {
          name := "PrecompileError";
          item := StructTuple [];
        };
        {
          name := "NonceOverflow";
          item := StructTuple [];
        };
        {
          name := "CreateContractSizeLimit";
          item := StructTuple [];
        };
        {
          name := "CreateContractStartingWithEF";
          item := StructTuple [];
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
        };
        {
          name := "OverflowPayment";
          item := StructTuple [];
        };
        {
          name := "StateChangeDuringStaticCall";
          item := StructTuple [];
        };
        {
          name := "CallNotAllowedInsideStatic";
          item := StructTuple [];
        };
        {
          name := "OutOfFunds";
          item := StructTuple [];
        };
        {
          name := "CallTooDeep";
          item := StructTuple [];
        };
        {
          name := "EofAuxDataOverflow";
          item := StructTuple [];
        };
        {
          name := "EofAuxDataTooSmall";
          item := StructTuple [];
        };
        {
          name := "SubRoutineStackOverflow";
          item := StructTuple [];
        };
        {
          name := "InvalidEXTCALLTarget";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_HaltReason_OutOfGas :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::OutOfGas" 0.
  Axiom IsDiscriminant_HaltReason_OpcodeNotFound :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::OpcodeNotFound" 1.
  Axiom IsDiscriminant_HaltReason_InvalidFEOpcode :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::InvalidFEOpcode" 2.
  Axiom IsDiscriminant_HaltReason_InvalidJump :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::InvalidJump" 3.
  Axiom IsDiscriminant_HaltReason_NotActivated :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::NotActivated" 4.
  Axiom IsDiscriminant_HaltReason_StackUnderflow :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::StackUnderflow" 5.
  Axiom IsDiscriminant_HaltReason_StackOverflow :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::StackOverflow" 6.
  Axiom IsDiscriminant_HaltReason_OutOfOffset :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::OutOfOffset" 7.
  Axiom IsDiscriminant_HaltReason_CreateCollision :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::CreateCollision" 8.
  Axiom IsDiscriminant_HaltReason_PrecompileError :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::PrecompileError" 9.
  Axiom IsDiscriminant_HaltReason_NonceOverflow :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::NonceOverflow" 10.
  Axiom IsDiscriminant_HaltReason_CreateContractSizeLimit :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::CreateContractSizeLimit" 11.
  Axiom IsDiscriminant_HaltReason_CreateContractStartingWithEF :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::CreateContractStartingWithEF" 12.
  Axiom IsDiscriminant_HaltReason_CreateInitCodeSizeLimit :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::CreateInitCodeSizeLimit" 13.
  Axiom IsDiscriminant_HaltReason_OverflowPayment :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::OverflowPayment" 14.
  Axiom IsDiscriminant_HaltReason_StateChangeDuringStaticCall :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::StateChangeDuringStaticCall" 15.
  Axiom IsDiscriminant_HaltReason_CallNotAllowedInsideStatic :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::CallNotAllowedInsideStatic" 16.
  Axiom IsDiscriminant_HaltReason_OutOfFunds :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::OutOfFunds" 17.
  Axiom IsDiscriminant_HaltReason_CallTooDeep :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::CallTooDeep" 18.
  Axiom IsDiscriminant_HaltReason_EofAuxDataOverflow :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::EofAuxDataOverflow" 19.
  Axiom IsDiscriminant_HaltReason_EofAuxDataTooSmall :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::EofAuxDataTooSmall" 20.
  Axiom IsDiscriminant_HaltReason_SubRoutineStackOverflow :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::SubRoutineStackOverflow" 21.
  Axiom IsDiscriminant_HaltReason_InvalidEXTCALLTarget :
    M.IsDiscriminant "revm_context_interface::result::HaltReason::InvalidEXTCALLTarget" 22.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfGas",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OutOfGas" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OpcodeNotFound"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "OpcodeNotFound" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidFEOpcode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "InvalidFEOpcode" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidJump"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "InvalidJump" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::NotActivated"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NotActivated" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StackUnderflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "StackUnderflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StackOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "StackOverflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfOffset"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OutOfOffset" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateCollision"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CreateCollision" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::PrecompileError"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "PrecompileError" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::NonceOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "NonceOverflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateContractSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CreateContractSizeLimit" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateContractStartingWithEF"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CreateContractStartingWithEF" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CreateInitCodeSizeLimit" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OverflowPayment"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "OverflowPayment" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StateChangeDuringStaticCall"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "StateChangeDuringStaticCall" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CallNotAllowedInsideStatic"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "CallNotAllowedInsideStatic" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfFunds"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OutOfFunds" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CallTooDeep"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CallTooDeep" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::EofAuxDataOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "EofAuxDataOverflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::EofAuxDataTooSmall"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "EofAuxDataTooSmall" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::SubRoutineStackOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "SubRoutineStackOverflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidEXTCALLTarget"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "InvalidEXTCALLTarget" |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_result_HaltReason_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::HaltReason" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::HaltReason" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::HaltReason::OutOfGas",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::HaltReason::OutOfGas",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "revm_context_interface::result::OutOfGasError" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::HaltReason" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_result_HaltReason_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::HaltReason" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfGas",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_context_interface::result::OutOfGasError",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_HaltReason.
  
  (*
  Enum OutOfGasError
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Basic";
          item := StructTuple [];
        };
        {
          name := "MemoryLimit";
          item := StructTuple [];
        };
        {
          name := "Memory";
          item := StructTuple [];
        };
        {
          name := "Precompile";
          item := StructTuple [];
        };
        {
          name := "InvalidOperand";
          item := StructTuple [];
        };
        {
          name := "ReentrancySentry";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_OutOfGasError_Basic :
    M.IsDiscriminant "revm_context_interface::result::OutOfGasError::Basic" 0.
  Axiom IsDiscriminant_OutOfGasError_MemoryLimit :
    M.IsDiscriminant "revm_context_interface::result::OutOfGasError::MemoryLimit" 1.
  Axiom IsDiscriminant_OutOfGasError_Memory :
    M.IsDiscriminant "revm_context_interface::result::OutOfGasError::Memory" 2.
  Axiom IsDiscriminant_OutOfGasError_Precompile :
    M.IsDiscriminant "revm_context_interface::result::OutOfGasError::Precompile" 3.
  Axiom IsDiscriminant_OutOfGasError_InvalidOperand :
    M.IsDiscriminant "revm_context_interface::result::OutOfGasError::InvalidOperand" 4.
  Axiom IsDiscriminant_OutOfGasError_ReentrancySentry :
    M.IsDiscriminant "revm_context_interface::result::OutOfGasError::ReentrancySentry" 5.
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Some (Ty.apply (Ty.path "&") [] [ Ty.path "str" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::Basic"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Basic" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::MemoryLimit"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "MemoryLimit" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::Memory"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Memory" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::Precompile"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Precompile" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::InvalidOperand"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "InvalidOperand" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::ReentrancySentry"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "ReentrancySentry" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_cmp_PartialEq_revm_context_interface_result_OutOfGasError_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::OutOfGasError" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_context_interface_result_OutOfGasError_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_OutOfGasError.
End result.
