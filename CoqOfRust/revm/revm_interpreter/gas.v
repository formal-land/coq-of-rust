(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module gas.
  (* StructRecord
    {
      name := "Gas";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("limit", Ty.path "u64");
          ("remaining", Ty.path "u64");
          ("refunded", Ty.path "i64");
          ("memory", Ty.path "revm_interpreter::gas::MemoryGas")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field4_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "Gas" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "limit" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::gas::Gas",
                      "limit"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "remaining" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::gas::Gas",
                      "remaining"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "refunded" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::gas::Gas",
                      "refunded"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "memory" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::gas::Gas",
                          "memory"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_default_Default_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "revm_interpreter::gas::Gas"
            [
              ("limit",
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("remaining",
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("refunded",
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "i64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("memory",
                M.call_closure (|
                  Ty.path "revm_interpreter::gas::MemoryGas",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "revm_interpreter::gas::MemoryGas",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::gas::Gas",
                      "limit"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_interpreter::gas::Gas",
                      "limit"
                    |)
                  |)
                |),
                ltac:(M.monadic
                  (BinOp.eq (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::gas::Gas",
                        "remaining"
                      |)
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_interpreter::gas::Gas",
                        "remaining"
                      |)
                    |)
                  |)))
              |),
              ltac:(M.monadic
                (BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::gas::Gas",
                      "refunded"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_interpreter::gas::Gas",
                      "refunded"
                    |)
                  |)
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "revm_interpreter::gas::MemoryGas",
                  [],
                  [ Ty.path "revm_interpreter::gas::MemoryGas" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::gas::Gas",
                      "memory"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_interpreter::gas::Gas",
                      "memory"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_gas_Gas.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u64",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::gas::Gas",
                            "limit"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u64",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::gas::Gas",
                            "remaining"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "i64",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::gas::Gas",
                            "refunded"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "revm_interpreter::gas::MemoryGas",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::gas::Gas",
                          "memory"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_gas_Gas.
  
  Module Impl_revm_interpreter_gas_Gas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::Gas".
    
    (*
        pub const fn new(limit: u64) -> Self {
            Self {
                limit,
                remaining: limit,
                refunded: 0,
                memory: MemoryGas::new(),
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ limit ] =>
        ltac:(M.monadic
          (let limit := M.alloc (| limit |) in
          Value.StructRecord
            "revm_interpreter::gas::Gas"
            [
              ("limit", M.read (| limit |));
              ("remaining", M.read (| limit |));
              ("refunded", Value.Integer IntegerKind.I64 0);
              ("memory",
                M.call_closure (|
                  Ty.path "revm_interpreter::gas::MemoryGas",
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::gas::MemoryGas",
                    "new",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    Smpl Add apply AssociatedFunction_new : is_associated.
    
    (*
        pub const fn new_spent(limit: u64) -> Self {
            Self {
                limit,
                remaining: 0,
                refunded: 0,
                memory: MemoryGas::new(),
            }
        }
    *)
    Definition new_spent (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ limit ] =>
        ltac:(M.monadic
          (let limit := M.alloc (| limit |) in
          Value.StructRecord
            "revm_interpreter::gas::Gas"
            [
              ("limit", M.read (| limit |));
              ("remaining", Value.Integer IntegerKind.U64 0);
              ("refunded", Value.Integer IntegerKind.I64 0);
              ("memory",
                M.call_closure (|
                  Ty.path "revm_interpreter::gas::MemoryGas",
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::gas::MemoryGas",
                    "new",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_spent : M.IsAssociatedFunction Self "new_spent" new_spent.
    Smpl Add apply AssociatedFunction_new_spent : is_associated.
    
    (*
        pub const fn limit(&self) -> u64 {
            self.limit
        }
    *)
    Definition limit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_interpreter::gas::Gas",
              "limit"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_limit : M.IsAssociatedFunction Self "limit" limit.
    Smpl Add apply AssociatedFunction_limit : is_associated.
    
    (*
        pub const fn memory(&self) -> u64 {
            0
        }
    *)
    Definition memory (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Integer IntegerKind.U64 0))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_memory : M.IsAssociatedFunction Self "memory" memory.
    Smpl Add apply AssociatedFunction_memory : is_associated.
    
    (*
        pub const fn refunded(&self) -> i64 {
            self.refunded
        }
    *)
    Definition refunded (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_interpreter::gas::Gas",
              "refunded"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_refunded : M.IsAssociatedFunction Self "refunded" refunded.
    Smpl Add apply AssociatedFunction_refunded : is_associated.
    
    (*
        pub const fn spent(&self) -> u64 {
            self.limit - self.remaining
        }
    *)
    Definition spent (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.sub (|
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_interpreter::gas::Gas",
                "limit"
              |)
            |),
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_interpreter::gas::Gas",
                "remaining"
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_spent : M.IsAssociatedFunction Self "spent" spent.
    Smpl Add apply AssociatedFunction_spent : is_associated.
    
    (*
        pub const fn remaining(&self) -> u64 {
            self.remaining
        }
    *)
    Definition remaining (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_interpreter::gas::Gas",
              "remaining"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_remaining : M.IsAssociatedFunction Self "remaining" remaining.
    Smpl Add apply AssociatedFunction_remaining : is_associated.
    
    (*
        pub const fn remaining_63_of_64_parts(&self) -> u64 {
            self.remaining - self.remaining / 64
        }
    *)
    Definition remaining_63_of_64_parts (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.sub (|
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_interpreter::gas::Gas",
                "remaining"
              |)
            |),
            BinOp.Wrap.div (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_interpreter::gas::Gas",
                  "remaining"
                |)
              |),
              Value.Integer IntegerKind.U64 64
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_remaining_63_of_64_parts :
      M.IsAssociatedFunction Self "remaining_63_of_64_parts" remaining_63_of_64_parts.
    Smpl Add apply AssociatedFunction_remaining_63_of_64_parts : is_associated.
    
    (*
        pub fn erase_cost(&mut self, returned: u64) {
            self.remaining += returned;
        }
    *)
    Definition erase_cost (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; returned ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let returned := M.alloc (| returned |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::gas::Gas",
                    "remaining"
                  |) in
                M.write (| β, BinOp.Wrap.add (| M.read (| β |), M.read (| returned |) |) |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_erase_cost : M.IsAssociatedFunction Self "erase_cost" erase_cost.
    Smpl Add apply AssociatedFunction_erase_cost : is_associated.
    
    (*
        pub fn spend_all(&mut self) {
            self.remaining = 0;
        }
    *)
    Definition spend_all (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::gas::Gas",
                    "remaining"
                  |),
                  Value.Integer IntegerKind.U64 0
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_spend_all : M.IsAssociatedFunction Self "spend_all" spend_all.
    Smpl Add apply AssociatedFunction_spend_all : is_associated.
    
    (*
        pub fn record_refund(&mut self, refund: i64) {
            self.refunded += refund;
        }
    *)
    Definition record_refund (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; refund ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let refund := M.alloc (| refund |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::gas::Gas",
                    "refunded"
                  |) in
                M.write (| β, BinOp.Wrap.add (| M.read (| β |), M.read (| refund |) |) |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_record_refund :
      M.IsAssociatedFunction Self "record_refund" record_refund.
    Smpl Add apply AssociatedFunction_record_refund : is_associated.
    
    (*
        pub fn set_final_refund(&mut self, is_london: bool) {
            let max_refund_quotient = if is_london { 5 } else { 2 };
            self.refunded = (self.refunded() as u64).min(self.spent() / max_refund_quotient) as i64;
        }
    *)
    Definition set_final_refund (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; is_london ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let is_london := M.alloc (| is_london |) in
          M.read (|
            let~ max_refund_quotient : Ty.path "u64" :=
              M.copy (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use is_london in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (| Value.Integer IntegerKind.U64 5 |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U64 2 |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::gas::Gas",
                    "refunded"
                  |),
                  M.cast
                    (Ty.path "i64")
                    (M.call_closure (|
                      Ty.path "u64",
                      M.get_trait_method (|
                        "core::cmp::Ord",
                        Ty.path "u64",
                        [],
                        [],
                        "min",
                        [],
                        []
                      |),
                      [
                        M.cast
                          (Ty.path "u64")
                          (M.call_closure (|
                            Ty.path "i64",
                            M.get_associated_function (|
                              Ty.path "revm_interpreter::gas::Gas",
                              "refunded",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |));
                        BinOp.Wrap.div (|
                          M.call_closure (|
                            Ty.path "u64",
                            M.get_associated_function (|
                              Ty.path "revm_interpreter::gas::Gas",
                              "spent",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |),
                          M.read (| max_refund_quotient |)
                        |)
                      ]
                    |))
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_set_final_refund :
      M.IsAssociatedFunction Self "set_final_refund" set_final_refund.
    Smpl Add apply AssociatedFunction_set_final_refund : is_associated.
    
    (*
        pub fn set_refund(&mut self, refund: i64) {
            self.refunded = refund;
        }
    *)
    Definition set_refund (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; refund ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let refund := M.alloc (| refund |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::gas::Gas",
                    "refunded"
                  |),
                  M.read (| refund |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_set_refund : M.IsAssociatedFunction Self "set_refund" set_refund.
    Smpl Add apply AssociatedFunction_set_refund : is_associated.
    
    (*
        pub fn record_cost(&mut self, cost: u64) -> bool {
            let (remaining, overflow) = self.remaining.overflowing_sub(cost);
            let success = !overflow;
            if success {
                self.remaining = remaining;
            }
            success
        }
    *)
    Definition record_cost (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; cost ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cost := M.alloc (| cost |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.path "u64"; Ty.path "bool" ],
                  M.get_associated_function (| Ty.path "u64", "overflowing_sub", [], [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::gas::Gas",
                        "remaining"
                      |)
                    |);
                    M.read (| cost |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let remaining := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    let~ success : Ty.path "bool" :=
                      M.alloc (| UnOp.not (| M.read (| overflow |) |) |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use success in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "revm_interpreter::gas::Gas",
                                      "remaining"
                                    |),
                                    M.read (| remaining |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    success))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_record_cost : M.IsAssociatedFunction Self "record_cost" record_cost.
    Smpl Add apply AssociatedFunction_record_cost : is_associated.
    
    (*
        pub fn record_memory_expansion(&mut self, new_len: usize) -> MemoryExtensionResult {
            let Some(additional_cost) = self.memory.record_new_len(new_len) else {
                return MemoryExtensionResult::Same;
            };
    
            if !self.record_cost(additional_cost) {
                return MemoryExtensionResult::OutOfGas;
            }
    
            MemoryExtensionResult::Extended
        }
    *)
    Definition record_memory_expansion (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; new_len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let new_len := M.alloc (| new_len |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.path "revm_interpreter::gas::MemoryGas",
                        "record_new_len",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::gas::Gas",
                            "memory"
                          |)
                        |);
                        M.read (| new_len |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let additional_cost := M.copy (| γ0_0 |) in
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_associated_function (|
                                              Ty.path "revm_interpreter::gas::Gas",
                                              "record_cost",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| self |) |)
                                              |);
                                              M.read (| additional_cost |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "revm_interpreter::gas::MemoryExtensionResult::OutOfGas"
                                            []
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "revm_interpreter::gas::MemoryExtensionResult::Extended"
                            []
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_record_memory_expansion :
      M.IsAssociatedFunction Self "record_memory_expansion" record_memory_expansion.
    Smpl Add apply AssociatedFunction_record_memory_expansion : is_associated.
  End Impl_revm_interpreter_gas_Gas.
  
  (*
  Enum MemoryExtensionResult
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Extended";
          item := StructTuple [];
        };
        {
          name := "Same";
          item := StructTuple [];
        };
        {
          name := "OutOfGas";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_MemoryExtensionResult_Extended :
    M.IsDiscriminant "revm_interpreter::gas::MemoryExtensionResult::Extended" 0.
  Axiom IsDiscriminant_MemoryExtensionResult_Same :
    M.IsDiscriminant "revm_interpreter::gas::MemoryExtensionResult::Same" 1.
  Axiom IsDiscriminant_MemoryExtensionResult_OutOfGas :
    M.IsDiscriminant "revm_interpreter::gas::MemoryExtensionResult::OutOfGas" 2.
  
  (* StructRecord
    {
      name := "MemoryGas";
      const_params := [];
      ty_params := [];
      fields := [ ("words_num", Ty.path "usize"); ("expansion_cost", Ty.path "u64") ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_core_default_Default_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "revm_interpreter::gas::MemoryGas"
            [
              ("words_num",
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "usize",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("expansion_cost",
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "MemoryGas" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "words_num" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::gas::MemoryGas",
                      "words_num"
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "expansion_cost" |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::gas::MemoryGas",
                          "expansion_cost"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_interpreter::gas::MemoryGas",
                  "words_num"
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| other |) |),
                  "revm_interpreter::gas::MemoryGas",
                  "words_num"
                |)
              |)
            |),
            ltac:(M.monadic
              (BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::gas::MemoryGas",
                    "expansion_cost"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "revm_interpreter::gas::MemoryGas",
                    "expansion_cost"
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "usize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::gas::MemoryGas",
                            "words_num"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "u64",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::gas::MemoryGas",
                          "expansion_cost"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_gas_MemoryGas.
  
  Module Impl_revm_interpreter_gas_MemoryGas.
    Definition Self : Ty.t := Ty.path "revm_interpreter::gas::MemoryGas".
    
    (*
        pub const fn new() -> Self {
            Self {
                words_num: 0,
                expansion_cost: 0,
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "revm_interpreter::gas::MemoryGas"
            [
              ("words_num", Value.Integer IntegerKind.Usize 0);
              ("expansion_cost", Value.Integer IntegerKind.U64 0)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    Smpl Add apply AssociatedFunction_new : is_associated.
    
    (*
        pub fn record_new_len(&mut self, new_num: usize) -> Option<u64> {
            if new_num <= self.words_num {
                return None;
            }
            self.words_num = new_num;
            let mut cost = crate::gas::calc::memory_gas(new_num);
            core::mem::swap(&mut self.expansion_cost, &mut cost);
            // Safe to subtract because we know that new_len > length
            // Notice the swap above.
            Some(self.expansion_cost - cost)
        }
    *)
    Definition record_new_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; new_num ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let new_num := M.alloc (| new_num |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.le (|
                                  M.read (| new_num |),
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "revm_interpreter::gas::MemoryGas",
                                      "words_num"
                                    |)
                                  |)
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::gas::MemoryGas",
                        "words_num"
                      |),
                      M.read (| new_num |)
                    |)
                  |) in
                let~ cost : Ty.path "u64" :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_function (| "revm_interpreter::gas::calc::memory_gas", [], [] |),
                      [ M.read (| new_num |) ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "core::mem::swap", [], [ Ty.path "u64" ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "revm_interpreter::gas::MemoryGas",
                                "expansion_cost"
                              |)
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (| M.borrow (| Pointer.Kind.MutRef, cost |) |)
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      BinOp.Wrap.sub (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::gas::MemoryGas",
                            "expansion_cost"
                          |)
                        |),
                        M.read (| cost |)
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_record_new_len :
      M.IsAssociatedFunction Self "record_new_len" record_new_len.
    Smpl Add apply AssociatedFunction_record_new_len : is_associated.
  End Impl_revm_interpreter_gas_MemoryGas.
End gas.
