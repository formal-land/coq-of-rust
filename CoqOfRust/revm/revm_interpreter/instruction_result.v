(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module instruction_result.
  (*
  Enum InstructionResult
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Continue";
          item := StructTuple [];
        };
        {
          name := "Stop";
          item := StructTuple [];
        };
        {
          name := "Return";
          item := StructTuple [];
        };
        {
          name := "SelfDestruct";
          item := StructTuple [];
        };
        {
          name := "ReturnContract";
          item := StructTuple [];
        };
        {
          name := "Revert";
          item := StructTuple [];
        };
        {
          name := "CallTooDeep";
          item := StructTuple [];
        };
        {
          name := "OutOfFunds";
          item := StructTuple [];
        };
        {
          name := "CreateInitCodeStartingEF00";
          item := StructTuple [];
        };
        {
          name := "InvalidEOFInitCode";
          item := StructTuple [];
        };
        {
          name := "InvalidExtDelegateCallTarget";
          item := StructTuple [];
        };
        {
          name := "CallOrCreate";
          item := StructTuple [];
        };
        {
          name := "OutOfGas";
          item := StructTuple [];
        };
        {
          name := "MemoryOOG";
          item := StructTuple [];
        };
        {
          name := "MemoryLimitOOG";
          item := StructTuple [];
        };
        {
          name := "PrecompileOOG";
          item := StructTuple [];
        };
        {
          name := "InvalidOperandOOG";
          item := StructTuple [];
        };
        {
          name := "ReentrancySentryOOG";
          item := StructTuple [];
        };
        {
          name := "OpcodeNotFound";
          item := StructTuple [];
        };
        {
          name := "CallNotAllowedInsideStatic";
          item := StructTuple [];
        };
        {
          name := "StateChangeDuringStaticCall";
          item := StructTuple [];
        };
        {
          name := "InvalidFEOpcode";
          item := StructTuple [];
        };
        {
          name := "InvalidJump";
          item := StructTuple [];
        };
        {
          name := "NotActivated";
          item := StructTuple [];
        };
        {
          name := "StackUnderflow";
          item := StructTuple [];
        };
        {
          name := "StackOverflow";
          item := StructTuple [];
        };
        {
          name := "OutOfOffset";
          item := StructTuple [];
        };
        {
          name := "CreateCollision";
          item := StructTuple [];
        };
        {
          name := "OverflowPayment";
          item := StructTuple [];
        };
        {
          name := "PrecompileError";
          item := StructTuple [];
        };
        {
          name := "NonceOverflow";
          item := StructTuple [];
        };
        {
          name := "CreateContractSizeLimit";
          item := StructTuple [];
        };
        {
          name := "CreateContractStartingWithEF";
          item := StructTuple [];
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
        };
        {
          name := "FatalExternalError";
          item := StructTuple [];
        };
        {
          name := "ReturnContractInNotInitEOF";
          item := StructTuple [];
        };
        {
          name := "EOFOpcodeDisabledInLegacy";
          item := StructTuple [];
        };
        {
          name := "SubRoutineStackOverflow";
          item := StructTuple [];
        };
        {
          name := "EofAuxDataOverflow";
          item := StructTuple [];
        };
        {
          name := "EofAuxDataTooSmall";
          item := StructTuple [];
        };
        {
          name := "InvalidEXTCALLTarget";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_InstructionResult_Continue :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Continue" 0.
  Axiom IsDiscriminant_InstructionResult_Stop :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Stop" 1.
  Axiom IsDiscriminant_InstructionResult_Return :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Return" 2.
  Axiom IsDiscriminant_InstructionResult_SelfDestruct :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::SelfDestruct" 3.
  Axiom IsDiscriminant_InstructionResult_ReturnContract :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::ReturnContract" 4.
  Axiom IsDiscriminant_InstructionResult_Revert :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Revert" 16.
  Axiom IsDiscriminant_InstructionResult_CallTooDeep :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::CallTooDeep" 17.
  Axiom IsDiscriminant_InstructionResult_OutOfFunds :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OutOfFunds" 18.
  Axiom IsDiscriminant_InstructionResult_CreateInitCodeStartingEF00 :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
      19.
  Axiom IsDiscriminant_InstructionResult_InvalidEOFInitCode :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
      20.
  Axiom IsDiscriminant_InstructionResult_InvalidExtDelegateCallTarget :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
      21.
  Axiom IsDiscriminant_InstructionResult_CallOrCreate :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::CallOrCreate" 32.
  Axiom IsDiscriminant_InstructionResult_OutOfGas :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OutOfGas" 80.
  Axiom IsDiscriminant_InstructionResult_MemoryOOG :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::MemoryOOG" 81.
  Axiom IsDiscriminant_InstructionResult_MemoryLimitOOG :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG" 82.
  Axiom IsDiscriminant_InstructionResult_PrecompileOOG :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG" 83.
  Axiom IsDiscriminant_InstructionResult_InvalidOperandOOG :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
      84.
  Axiom IsDiscriminant_InstructionResult_ReentrancySentryOOG :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
      85.
  Axiom IsDiscriminant_InstructionResult_OpcodeNotFound :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound" 86.
  Axiom IsDiscriminant_InstructionResult_CallNotAllowedInsideStatic :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
      87.
  Axiom IsDiscriminant_InstructionResult_StateChangeDuringStaticCall :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
      88.
  Axiom IsDiscriminant_InstructionResult_InvalidFEOpcode :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode" 89.
  Axiom IsDiscriminant_InstructionResult_InvalidJump :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::InvalidJump" 90.
  Axiom IsDiscriminant_InstructionResult_NotActivated :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::NotActivated" 91.
  Axiom IsDiscriminant_InstructionResult_StackUnderflow :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::StackUnderflow" 92.
  Axiom IsDiscriminant_InstructionResult_StackOverflow :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::StackOverflow" 93.
  Axiom IsDiscriminant_InstructionResult_OutOfOffset :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OutOfOffset" 94.
  Axiom IsDiscriminant_InstructionResult_CreateCollision :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::CreateCollision" 95.
  Axiom IsDiscriminant_InstructionResult_OverflowPayment :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OverflowPayment" 96.
  Axiom IsDiscriminant_InstructionResult_PrecompileError :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::PrecompileError" 97.
  Axiom IsDiscriminant_InstructionResult_NonceOverflow :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::NonceOverflow" 98.
  Axiom IsDiscriminant_InstructionResult_CreateContractSizeLimit :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
      99.
  Axiom IsDiscriminant_InstructionResult_CreateContractStartingWithEF :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
      100.
  Axiom IsDiscriminant_InstructionResult_CreateInitCodeSizeLimit :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
      101.
  Axiom IsDiscriminant_InstructionResult_FatalExternalError :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
      102.
  Axiom IsDiscriminant_InstructionResult_ReturnContractInNotInitEOF :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
      103.
  Axiom IsDiscriminant_InstructionResult_EOFOpcodeDisabledInLegacy :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
      104.
  Axiom IsDiscriminant_InstructionResult_SubRoutineStackOverflow :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
      105.
  Axiom IsDiscriminant_InstructionResult_EofAuxDataOverflow :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
      106.
  Axiom IsDiscriminant_InstructionResult_EofAuxDataTooSmall :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
      107.
  Axiom IsDiscriminant_InstructionResult_InvalidEXTCALLTarget :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
      108.
  
  Module Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ],
              self
            |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.match_operator (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::Continue"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Continue" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::Stop"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Stop" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::Return"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Return" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "SelfDestruct" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "ReturnContract" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::Revert"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Revert" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CallTooDeep" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OutOfFunds" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "CreateInitCodeStartingEF00" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InvalidEOFInitCode" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InvalidExtDelegateCallTarget" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CallOrCreate"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CallOrCreate" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OutOfGas" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "MemoryOOG" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "MemoryLimitOOG" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "PrecompileOOG" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InvalidOperandOOG" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "ReentrancySentryOOG" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "OpcodeNotFound" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "CallNotAllowedInsideStatic" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "StateChangeDuringStaticCall" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InvalidFEOpcode" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "InvalidJump" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NotActivated" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "StackUnderflow" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "StackOverflow" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OutOfOffset" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "CreateCollision" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "OverflowPayment" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "PrecompileError" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                        |) in
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NonceOverflow" |) |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "CreateContractSizeLimit" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "CreateContractStartingWithEF" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "CreateInitCodeSizeLimit" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "FatalExternalError" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "ReturnContractInNotInitEOF" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "EOFOpcodeDisabledInLegacy" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "SubRoutineStackOverflow" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "EofAuxDataOverflow" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "EofAuxDataTooSmall" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InvalidEXTCALLTarget" |) |)
                      |)))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_default_Default_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "revm_interpreter::instruction_result::InstructionResult::Continue"
            []
            []
            []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_cmp_PartialEq_revm_interpreter_instruction_result_InstructionResult_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ],
              self
            |) in
          let other :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ],
              other
            |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              Ty.path "bool",
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_interpreter_instruction_result_InstructionResult_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ],
              self
            |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ],
              self
            |) in
          let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            M.alloc (|
              Ty.tuple [],
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "u8",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_convert_From_revm_context_interface_journaled_state_TransferError_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (*
        fn from(e: TransferError) -> Self {
            match e {
                TransferError::OutOfFunds => InstructionResult::OutOfFunds,
                TransferError::OverflowPayment => InstructionResult::OverflowPayment,
                TransferError::CreateCollision => InstructionResult::CreateCollision,
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ e ] =>
        ltac:(M.monadic
          (let e :=
            M.alloc (| Ty.path "revm_context_interface::journaled_state::TransferError", e |) in
          M.match_operator (|
            Ty.path "revm_interpreter::instruction_result::InstructionResult",
            e,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::journaled_state::TransferError::OutOfFunds"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::journaled_state::TransferError::OverflowPayment"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::journaled_state::TransferError::CreateCollision"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                    []
                    []
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_context_interface::journaled_state::TransferError" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_context_interface_journaled_state_TransferError_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    (*
        pub const fn is_ok(self) -> bool {
            matches!(self, crate::return_ok!())
        }
    *)
    Definition is_ok (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.path "revm_interpreter::instruction_result::InstructionResult", self |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (Ty.tuple []) (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::Continue"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::Stop"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::Return"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] => ltac:(M.monadic (Value.Bool true))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_ok : M.IsAssociatedFunction.C Self "is_ok" is_ok.
    Admitted.
    Global Typeclasses Opaque is_ok.
    
    (*
        pub const fn is_ok_or_revert(self) -> bool {
            matches!(self, crate::return_ok!() | crate::return_revert!())
        }
    *)
    Definition is_ok_or_revert (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.path "revm_interpreter::instruction_result::InstructionResult", self |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (Ty.tuple []) (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.find_or_pattern (Ty.tuple []) (|
                            γ,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::Continue"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::Stop"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::Return"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                                    |) in
                                  Value.Tuple []))
                            ],
                            fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [] => ltac:(M.monadic (Value.Tuple []))
                                | _ => M.impossible "wrong number of arguments"
                                end)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.find_or_pattern (Ty.tuple []) (|
                            γ,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::Revert"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                                    |) in
                                  Value.Tuple []));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (|
                                      γ,
                                      "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                                    |) in
                                  Value.Tuple []))
                            ],
                            fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [] => ltac:(M.monadic (Value.Tuple []))
                                | _ => M.impossible "wrong number of arguments"
                                end)
                          |)))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] => ltac:(M.monadic (Value.Bool true))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_ok_or_revert :
      M.IsAssociatedFunction.C Self "is_ok_or_revert" is_ok_or_revert.
    Admitted.
    Global Typeclasses Opaque is_ok_or_revert.
    
    (*
        pub const fn is_continue(self) -> bool {
            matches!(self, InstructionResult::Continue)
        }
    *)
    Definition is_continue (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.path "revm_interpreter::instruction_result::InstructionResult", self |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::Continue"
                    |) in
                  Value.Bool true));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_continue :
      M.IsAssociatedFunction.C Self "is_continue" is_continue.
    Admitted.
    Global Typeclasses Opaque is_continue.
    
    (*
        pub const fn is_revert(self) -> bool {
            matches!(self, crate::return_revert!())
        }
    *)
    Definition is_revert (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.path "revm_interpreter::instruction_result::InstructionResult", self |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (Ty.tuple []) (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::Revert"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] => ltac:(M.monadic (Value.Bool true))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_revert :
      M.IsAssociatedFunction.C Self "is_revert" is_revert.
    Admitted.
    Global Typeclasses Opaque is_revert.
    
    (*
        pub const fn is_error(self) -> bool {
            matches!(self, return_error!())
        }
    *)
    Definition is_error (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.path "revm_interpreter::instruction_result::InstructionResult", self |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (Ty.tuple []) (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] => ltac:(M.monadic (Value.Bool true))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_error : M.IsAssociatedFunction.C Self "is_error" is_error.
    Admitted.
    Global Typeclasses Opaque is_error.
  End Impl_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_convert_From_revm_context_interface_result_SuccessReason_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (*
        fn from(value: SuccessReason) -> Self {
            match value {
                SuccessReason::Return => InstructionResult::Return,
                SuccessReason::Stop => InstructionResult::Stop,
                SuccessReason::SelfDestruct => InstructionResult::SelfDestruct,
                SuccessReason::EofReturnContract => InstructionResult::ReturnContract,
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value :=
            M.alloc (| Ty.path "revm_context_interface::result::SuccessReason", value |) in
          M.match_operator (|
            Ty.path "revm_interpreter::instruction_result::InstructionResult",
            value,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::SuccessReason::Return"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::Return"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::SuccessReason::Stop"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::Stop"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::SuccessReason::SelfDestruct"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::SuccessReason::EofReturnContract"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                    []
                    []
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::SuccessReason" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_context_interface_result_SuccessReason_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_convert_From_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (*
        fn from(value: HaltReason) -> Self {
            match value {
                HaltReason::OutOfGas(error) => match error {
                    OutOfGasError::Basic => Self::OutOfGas,
                    OutOfGasError::InvalidOperand => Self::InvalidOperandOOG,
                    OutOfGasError::Memory => Self::MemoryOOG,
                    OutOfGasError::MemoryLimit => Self::MemoryLimitOOG,
                    OutOfGasError::Precompile => Self::PrecompileOOG,
                    OutOfGasError::ReentrancySentry => Self::ReentrancySentryOOG,
                },
                HaltReason::OpcodeNotFound => Self::OpcodeNotFound,
                HaltReason::InvalidFEOpcode => Self::InvalidFEOpcode,
                HaltReason::InvalidJump => Self::InvalidJump,
                HaltReason::NotActivated => Self::NotActivated,
                HaltReason::StackOverflow => Self::StackOverflow,
                HaltReason::StackUnderflow => Self::StackUnderflow,
                HaltReason::OutOfOffset => Self::OutOfOffset,
                HaltReason::CreateCollision => Self::CreateCollision,
                HaltReason::PrecompileError => Self::PrecompileError,
                HaltReason::NonceOverflow => Self::NonceOverflow,
                HaltReason::CreateContractSizeLimit => Self::CreateContractSizeLimit,
                HaltReason::CreateContractStartingWithEF => Self::CreateContractStartingWithEF,
                HaltReason::CreateInitCodeSizeLimit => Self::CreateInitCodeSizeLimit,
                HaltReason::OverflowPayment => Self::OverflowPayment,
                HaltReason::StateChangeDuringStaticCall => Self::StateChangeDuringStaticCall,
                HaltReason::CallNotAllowedInsideStatic => Self::CallNotAllowedInsideStatic,
                HaltReason::OutOfFunds => Self::OutOfFunds,
                HaltReason::CallTooDeep => Self::CallTooDeep,
                HaltReason::EofAuxDataOverflow => Self::EofAuxDataOverflow,
                HaltReason::EofAuxDataTooSmall => Self::EofAuxDataTooSmall,
                HaltReason::SubRoutineStackOverflow => Self::SubRoutineStackOverflow,
                HaltReason::InvalidEXTCALLTarget => Self::InvalidEXTCALLTarget,
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| Ty.path "revm_context_interface::result::HaltReason", value |) in
          M.match_operator (|
            Ty.path "revm_interpreter::instruction_result::InstructionResult",
            value,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_context_interface::result::HaltReason::OutOfGas",
                      0
                    |) in
                  let error :=
                    M.copy (| Ty.path "revm_context_interface::result::OutOfGasError", γ0_0 |) in
                  M.match_operator (|
                    Ty.path "revm_interpreter::instruction_result::InstructionResult",
                    error,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_context_interface::result::OutOfGasError::Basic"
                            |) in
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                            []
                            []
                            []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_context_interface::result::OutOfGasError::InvalidOperand"
                            |) in
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                            []
                            []
                            []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_context_interface::result::OutOfGasError::Memory"
                            |) in
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                            []
                            []
                            []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_context_interface::result::OutOfGasError::MemoryLimit"
                            |) in
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                            []
                            []
                            []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_context_interface::result::OutOfGasError::Precompile"
                            |) in
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                            []
                            []
                            []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_context_interface::result::OutOfGasError::ReentrancySentry"
                            |) in
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                            []
                            []
                            []))
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::OpcodeNotFound"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::InvalidFEOpcode"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::InvalidJump"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::NotActivated"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::StackOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::StackUnderflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::OutOfOffset"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::CreateCollision"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::PrecompileError"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::NonceOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::CreateContractSizeLimit"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::CreateContractStartingWithEF"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::CreateInitCodeSizeLimit"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::OverflowPayment"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::StateChangeDuringStaticCall"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::CallNotAllowedInsideStatic"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::OutOfFunds"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::CallTooDeep"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::EofAuxDataOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::EofAuxDataTooSmall"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::SubRoutineStackOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                    []
                    []
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_context_interface::result::HaltReason::InvalidEXTCALLTarget"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                    []
                    []
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::HaltReason" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_InstructionResult.
  
  
  (*
  Enum InternalResult
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "InternalContinue";
          item := StructTuple [];
        };
        {
          name := "InternalCallOrCreate";
          item := StructTuple [];
        };
        {
          name := "CreateInitCodeStartingEF00";
          item := StructTuple [];
        };
        {
          name := "InvalidExtDelegateCallTarget";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_InternalResult_InternalContinue :
    M.IsDiscriminant "revm_interpreter::instruction_result::InternalResult::InternalContinue" 0.
  Axiom IsDiscriminant_InternalResult_InternalCallOrCreate :
    M.IsDiscriminant "revm_interpreter::instruction_result::InternalResult::InternalCallOrCreate" 1.
  Axiom IsDiscriminant_InternalResult_CreateInitCodeStartingEF00 :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InternalResult::CreateInitCodeStartingEF00"
      2.
  Axiom IsDiscriminant_InternalResult_InvalidExtDelegateCallTarget :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InternalResult::InvalidExtDelegateCallTarget"
      3.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.match_operator (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InternalResult::InternalContinue"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InternalContinue" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InternalResult::InternalCallOrCreate"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InternalCallOrCreate" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InternalResult::CreateInitCodeStartingEF00"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "CreateInitCodeStartingEF00" |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "revm_interpreter::instruction_result::InternalResult::InvalidExtDelegateCallTarget"
                        |) in
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "InvalidExtDelegateCallTarget" |) |)
                      |)))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
              self
            |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_cmp_PartialEq_revm_interpreter_instruction_result_InternalResult_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
              self
            |) in
          let other :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
              other
            |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              Ty.path "bool",
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_interpreter_instruction_result_InternalResult_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
              self
            |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
              self
            |) in
          let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            M.alloc (|
              Ty.tuple [],
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InternalResult.
  
  (*
  Enum SuccessOrHalt
  {
    const_params := [];
    ty_params := [ "HaltReasonT" ];
    variants :=
      [
        {
          name := "Success";
          item := StructTuple [ Ty.path "revm_context_interface::result::SuccessReason" ];
        };
        {
          name := "Revert";
          item := StructTuple [];
        };
        {
          name := "Halt";
          item := StructTuple [ HaltReasonT ];
        };
        {
          name := "FatalExternalError";
          item := StructTuple [];
        };
        {
          name := "Internal";
          item := StructTuple [ Ty.path "revm_interpreter::instruction_result::InternalResult" ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_SuccessOrHalt_Success :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Success" 0.
  Axiom IsDiscriminant_SuccessOrHalt_Revert :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Revert" 1.
  Axiom IsDiscriminant_SuccessOrHalt_Halt :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Halt" 2.
  Axiom IsDiscriminant_SuccessOrHalt_FatalExternalError :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError" 3.
  Axiom IsDiscriminant_SuccessOrHalt_Internal :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Internal" 4.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Clone *)
    Definition clone
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                    []
                    [ HaltReasonT ]
                ],
              self
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
              []
              [ HaltReasonT ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                      0
                    |) in
                  let __self_0 :=
                    M.alloc (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "revm_context_interface::result::SuccessReason" ],
                      γ1_0
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        Ty.path "revm_context_interface::result::SuccessReason",
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.path "revm_context_interface::result::SuccessReason",
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                    []
                    [ HaltReasonT ]
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                      0
                    |) in
                  let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ HaltReasonT ], γ1_0 |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::clone::Clone",
                          HaltReasonT,
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                    []
                    [ HaltReasonT ]
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                      0
                    |) in
                  let __self_0 :=
                    M.alloc (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
                      γ1_0
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        Ty.path "revm_interpreter::instruction_result::InternalResult",
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.path "revm_interpreter::instruction_result::InternalResult",
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                      |)
                    ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("clone", InstanceField.Method (clone HaltReasonT)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Debug *)
    Definition fmt (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                    []
                    [ HaltReasonT ]
                ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                      0
                    |) in
                  let __self_0 :=
                    M.alloc (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "revm_context_interface::result::SuccessReason" ],
                      γ1_0
                    |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_tuple_field1_finish",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Success" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_context_interface::result::SuccessReason" ]
                            ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                    |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "write_str",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Revert" |) |) |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                      0
                    |) in
                  let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ HaltReasonT ], γ1_0 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_tuple_field1_finish",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Halt" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ HaltReasonT ] ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                    |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "write_str",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| mk_str (| "FatalExternalError" |) |)
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                      0
                    |) in
                  let __self_0 :=
                    M.alloc (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
                      γ1_0
                    |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_tuple_field1_finish",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Internal" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                            ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt HaltReasonT)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* PartialEq *)
    Definition eq (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                    []
                    [ HaltReasonT ]
                ],
              self
            |) in
          let other :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                    []
                    [ HaltReasonT ]
                ],
              other
            |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [
                    Ty.apply
                      (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                      []
                      [ HaltReasonT ]
                  ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [
                    Ty.apply
                      (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                      []
                      [ HaltReasonT ]
                  ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              Ty.path "bool",
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                |),
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.path "bool",
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                                []
                                [ HaltReasonT ]
                            ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                                []
                                [ HaltReasonT ]
                            ]
                        ],
                      Value.Tuple [ M.read (| self |); M.read (| other |) ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                          let γ2_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ0_0,
                              "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                              0
                            |) in
                          let __self_0 :=
                            M.alloc (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_context_interface::result::SuccessReason" ],
                              γ2_0
                            |) in
                          let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                          let γ2_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ0_1,
                              "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                              0
                            |) in
                          let __arg1_0 :=
                            M.alloc (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_context_interface::result::SuccessReason" ],
                              γ2_0
                            |) in
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_context_interface::result::SuccessReason" ],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "revm_context_interface::result::SuccessReason" ]
                              ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, __self_0 |);
                              M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                            ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                          let γ2_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ0_0,
                              "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                              0
                            |) in
                          let __self_0 :=
                            M.alloc (| Ty.apply (Ty.path "&") [] [ HaltReasonT ], γ2_0 |) in
                          let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                          let γ2_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ0_1,
                              "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                              0
                            |) in
                          let __arg1_0 :=
                            M.alloc (| Ty.apply (Ty.path "&") [] [ HaltReasonT ], γ2_0 |) in
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              Ty.apply (Ty.path "&") [] [ HaltReasonT ],
                              [],
                              [ Ty.apply (Ty.path "&") [] [ HaltReasonT ] ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, __self_0 |);
                              M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                            ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                          let γ2_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ0_0,
                              "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                              0
                            |) in
                          let __self_0 :=
                            M.alloc (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
                              γ2_0
                            |) in
                          let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                          let γ2_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ0_1,
                              "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                              0
                            |) in
                          let __arg1_0 :=
                            M.alloc (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
                              γ2_0
                            |) in
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                              ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, __self_0 |);
                              M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                            ]
                          |)));
                      fun γ => ltac:(M.monadic (Value.Bool true))
                    ]
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
            []
            [ HaltReasonT ]
        ]
        (Self HaltReasonT)
        (* Instance *) [ ("eq", InstanceField.Method (eq HaltReasonT)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                    []
                    [ HaltReasonT ]
                ],
              self
            |) in
          M.match_operator (|
            Ty.tuple [],
            Value.DeclaredButUndefined,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.tuple [],
                    Value.DeclaredButUndefined,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.tuple [],
                            Value.DeclaredButUndefined,
                            [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                          |)))
                    ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq HaltReasonT))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Hash *)
    Definition hash
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                    []
                    [ HaltReasonT ]
                ],
              self
            |) in
          let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [
                    Ty.apply
                      (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                      []
                      [ HaltReasonT ]
                  ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              Ty.tuple [],
              M.match_operator (|
                Ty.tuple [],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                          0
                        |) in
                      let __self_0 :=
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "revm_context_interface::result::SuccessReason" ],
                          γ1_0
                        |) in
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_context_interface::result::SuccessReason",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                          0
                        |) in
                      let __self_0 :=
                        M.alloc (| Ty.apply (Ty.path "&") [] [ HaltReasonT ], γ1_0 |) in
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          HaltReasonT,
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.deref (| M.read (| γ |) |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                          0
                        |) in
                      let __self_0 :=
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "revm_interpreter::instruction_result::InternalResult" ],
                          γ1_0
                        |) in
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_interpreter::instruction_result::InternalResult",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("hash", InstanceField.Method (hash HaltReasonT)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (*
        pub fn is_success(self) -> bool {
            matches!(self, SuccessOrHalt::Success(_))
        }
    *)
    Definition is_success
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                []
                [ HaltReasonT ],
              self
            |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                      0
                    |) in
                  Value.Bool true));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_success :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "is_success" (is_success HaltReasonT).
    Admitted.
    Global Typeclasses Opaque is_success.
    
    (*
        pub fn to_success(self) -> Option<SuccessReason> {
            match self {
                SuccessOrHalt::Success(reason) => Some(reason),
                _ => None,
            }
        }
    *)
    Definition to_success
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                []
                [ HaltReasonT ],
              self
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.path "revm_context_interface::result::SuccessReason" ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                      0
                    |) in
                  let reason :=
                    M.copy (| Ty.path "revm_context_interface::result::SuccessReason", γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                    [ M.read (| reason |) ]));
              fun γ =>
                ltac:(M.monadic
                  (Value.StructTuple
                    "core::option::Option::None"
                    []
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                    []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_success :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "to_success" (to_success HaltReasonT).
    Admitted.
    Global Typeclasses Opaque to_success.
    
    (*
        pub fn is_revert(self) -> bool {
            matches!(self, SuccessOrHalt::Revert)
        }
    *)
    Definition is_revert
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                []
                [ HaltReasonT ],
              self
            |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                    |) in
                  Value.Bool true));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_revert :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "is_revert" (is_revert HaltReasonT).
    Admitted.
    Global Typeclasses Opaque is_revert.
    
    (*
        pub fn is_halt(self) -> bool {
            matches!(self, SuccessOrHalt::Halt(_))
        }
    *)
    Definition is_halt
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                []
                [ HaltReasonT ],
              self
            |) in
          M.match_operator (|
            Ty.path "bool",
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                      0
                    |) in
                  Value.Bool true));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_halt :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "is_halt" (is_halt HaltReasonT).
    Admitted.
    Global Typeclasses Opaque is_halt.
    
    (*
        pub fn to_halt(self) -> Option<HaltReasonT> {
            match self {
                SuccessOrHalt::Halt(reason) => Some(reason),
                _ => None,
            }
        }
    *)
    Definition to_halt
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                []
                [ HaltReasonT ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::option::Option") [] [ HaltReasonT ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                      0
                    |) in
                  let reason := M.copy (| HaltReasonT, γ0_0 |) in
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ HaltReasonT ]
                    [ M.read (| reason |) ]));
              fun γ =>
                ltac:(M.monadic
                  (Value.StructTuple "core::option::Option::None" [] [ HaltReasonT ] []))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_halt :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction.C (Self HaltReasonT) "to_halt" (to_halt HaltReasonT).
    Admitted.
    Global Typeclasses Opaque to_halt.
  End Impl_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HALT_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_SuccessOrHalt_HALT.
    Definition Self (HALT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HALT ].
    
    (*
        fn from(reason: HaltReason) -> Self {
            SuccessOrHalt::Halt(reason.into())
        }
    *)
    Definition from (HALT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HALT in
      match ε, τ, α with
      | [], [], [ reason ] =>
        ltac:(M.monadic
          (let reason :=
            M.alloc (| Ty.path "revm_context_interface::result::HaltReason", reason |) in
          Value.StructTuple
            "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
            []
            [ HALT ]
            [
              M.call_closure (|
                HALT,
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.path "revm_context_interface::result::HaltReason",
                  [],
                  [ HALT ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| reason |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HALT : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::HaltReason" ]
        (Self HALT)
        (* Instance *) [ ("from", InstanceField.Method (from HALT)) ].
  End Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HALT_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_SuccessOrHalt_HALT.
  
  Module Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_interpreter_instruction_result_InstructionResult_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (*
        fn from(result: InstructionResult) -> Self {
            match result {
                InstructionResult::Continue => Self::Internal(InternalResult::InternalContinue), // used only in interpreter loop
                InstructionResult::Stop => Self::Success(SuccessReason::Stop),
                InstructionResult::Return => Self::Success(SuccessReason::Return),
                InstructionResult::SelfDestruct => Self::Success(SuccessReason::SelfDestruct),
                InstructionResult::Revert => Self::Revert,
                InstructionResult::CreateInitCodeStartingEF00 => Self::Revert,
                InstructionResult::CallOrCreate => Self::Internal(InternalResult::InternalCallOrCreate), // used only in interpreter loop
                InstructionResult::CallTooDeep => Self::Halt(HaltReason::CallTooDeep.into()), // not gonna happen for first call
                InstructionResult::OutOfFunds => Self::Halt(HaltReason::OutOfFunds.into()), // Check for first call is done separately.
                InstructionResult::OutOfGas => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::Basic).into())
                }
                InstructionResult::MemoryLimitOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::MemoryLimit).into())
                }
                InstructionResult::MemoryOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::Memory).into())
                }
                InstructionResult::PrecompileOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::Precompile).into())
                }
                InstructionResult::InvalidOperandOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::InvalidOperand).into())
                }
                InstructionResult::ReentrancySentryOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::ReentrancySentry).into())
                }
                InstructionResult::OpcodeNotFound | InstructionResult::ReturnContractInNotInitEOF => {
                    Self::Halt(HaltReason::OpcodeNotFound.into())
                }
                InstructionResult::CallNotAllowedInsideStatic => {
                    Self::Halt(HaltReason::CallNotAllowedInsideStatic.into())
                } // first call is not static call
                InstructionResult::StateChangeDuringStaticCall => {
                    Self::Halt(HaltReason::StateChangeDuringStaticCall.into())
                }
                InstructionResult::InvalidFEOpcode => Self::Halt(HaltReason::InvalidFEOpcode.into()),
                InstructionResult::InvalidJump => Self::Halt(HaltReason::InvalidJump.into()),
                InstructionResult::NotActivated => Self::Halt(HaltReason::NotActivated.into()),
                InstructionResult::StackUnderflow => Self::Halt(HaltReason::StackUnderflow.into()),
                InstructionResult::StackOverflow => Self::Halt(HaltReason::StackOverflow.into()),
                InstructionResult::OutOfOffset => Self::Halt(HaltReason::OutOfOffset.into()),
                InstructionResult::CreateCollision => Self::Halt(HaltReason::CreateCollision.into()),
                InstructionResult::OverflowPayment => Self::Halt(HaltReason::OverflowPayment.into()), // Check for first call is done separately.
                InstructionResult::PrecompileError => Self::Halt(HaltReason::PrecompileError.into()),
                InstructionResult::NonceOverflow => Self::Halt(HaltReason::NonceOverflow.into()),
                InstructionResult::CreateContractSizeLimit
                | InstructionResult::CreateContractStartingWithEF => {
                    Self::Halt(HaltReason::CreateContractSizeLimit.into())
                }
                InstructionResult::CreateInitCodeSizeLimit => {
                    Self::Halt(HaltReason::CreateInitCodeSizeLimit.into())
                }
                // TODO : (EOF) Add proper Revert subtype.
                InstructionResult::InvalidEOFInitCode => Self::Revert,
                InstructionResult::FatalExternalError => Self::FatalExternalError,
                InstructionResult::EOFOpcodeDisabledInLegacy => {
                    Self::Halt(HaltReason::OpcodeNotFound.into())
                }
                InstructionResult::SubRoutineStackOverflow => {
                    Self::Halt(HaltReason::SubRoutineStackOverflow.into())
                }
                InstructionResult::ReturnContract => Self::Success(SuccessReason::EofReturnContract),
                InstructionResult::EofAuxDataOverflow => {
                    Self::Halt(HaltReason::EofAuxDataOverflow.into())
                }
                InstructionResult::EofAuxDataTooSmall => {
                    Self::Halt(HaltReason::EofAuxDataTooSmall.into())
                }
                InstructionResult::InvalidEXTCALLTarget => {
                    Self::Halt(HaltReason::InvalidEXTCALLTarget.into())
                }
                InstructionResult::InvalidExtDelegateCallTarget => {
                    Self::Internal(InternalResult::InvalidExtDelegateCallTarget)
                }
            }
        }
    *)
    Definition from
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ result ] =>
        ltac:(M.monadic
          (let result :=
            M.alloc (|
              Ty.path "revm_interpreter::instruction_result::InstructionResult",
              result
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
              []
              [ HaltReasonT ],
            result,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::Continue"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                    []
                    [ HaltReasonT ]
                    [
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InternalResult::InternalContinue"
                        []
                        []
                        []
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::Stop"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                    []
                    [ HaltReasonT ]
                    [
                      Value.StructTuple
                        "revm_context_interface::result::SuccessReason::Stop"
                        []
                        []
                        []
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::Return"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                    []
                    [ HaltReasonT ]
                    [
                      Value.StructTuple
                        "revm_context_interface::result::SuccessReason::Return"
                        []
                        []
                        []
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                    []
                    [ HaltReasonT ]
                    [
                      Value.StructTuple
                        "revm_context_interface::result::SuccessReason::SelfDestruct"
                        []
                        []
                        []
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::Revert"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                    []
                    [ HaltReasonT ]
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                    []
                    [ HaltReasonT ]
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::CallOrCreate"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                    []
                    [ HaltReasonT ]
                    [
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InternalResult::InternalCallOrCreate"
                        []
                        []
                        []
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::CallTooDeep"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfFunds"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfGas"
                            []
                            []
                            [
                              Value.StructTuple
                                "revm_context_interface::result::OutOfGasError::Basic"
                                []
                                []
                                []
                            ]
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfGas"
                            []
                            []
                            [
                              Value.StructTuple
                                "revm_context_interface::result::OutOfGasError::MemoryLimit"
                                []
                                []
                                []
                            ]
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfGas"
                            []
                            []
                            [
                              Value.StructTuple
                                "revm_context_interface::result::OutOfGasError::Memory"
                                []
                                []
                                []
                            ]
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfGas"
                            []
                            []
                            [
                              Value.StructTuple
                                "revm_context_interface::result::OutOfGasError::Precompile"
                                []
                                []
                                []
                            ]
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfGas"
                            []
                            []
                            [
                              Value.StructTuple
                                "revm_context_interface::result::OutOfGasError::InvalidOperand"
                                []
                                []
                                []
                            ]
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfGas"
                            []
                            []
                            [
                              Value.StructTuple
                                "revm_context_interface::result::OutOfGasError::ReentrancySentry"
                                []
                                []
                                []
                            ]
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (Ty.tuple []) (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] =>
                          ltac:(M.monadic
                            (Value.StructTuple
                              "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                              []
                              [ HaltReasonT ]
                              [
                                M.call_closure (|
                                  HaltReasonT,
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.path "revm_context_interface::result::HaltReason",
                                    [],
                                    [ HaltReasonT ],
                                    "into",
                                    [],
                                    []
                                  |),
                                  [
                                    Value.StructTuple
                                      "revm_context_interface::result::HaltReason::OpcodeNotFound"
                                      []
                                      []
                                      []
                                  ]
                                |)
                              ]))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::CallNotAllowedInsideStatic"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::StateChangeDuringStaticCall"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::InvalidFEOpcode"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::InvalidJump"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::NotActivated"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::StackUnderflow"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::StackOverflow"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OutOfOffset"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::CreateCollision"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OverflowPayment"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::PrecompileError"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::NonceOverflow"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (Ty.tuple []) (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] =>
                          ltac:(M.monadic
                            (Value.StructTuple
                              "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                              []
                              [ HaltReasonT ]
                              [
                                M.call_closure (|
                                  HaltReasonT,
                                  M.get_trait_method (|
                                    "core::convert::Into",
                                    Ty.path "revm_context_interface::result::HaltReason",
                                    [],
                                    [ HaltReasonT ],
                                    "into",
                                    [],
                                    []
                                  |),
                                  [
                                    Value.StructTuple
                                      "revm_context_interface::result::HaltReason::CreateContractSizeLimit"
                                      []
                                      []
                                      []
                                  ]
                                |)
                              ]))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::CreateInitCodeSizeLimit"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                    []
                    [ HaltReasonT ]
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                    []
                    [ HaltReasonT ]
                    []));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::OpcodeNotFound"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::SubRoutineStackOverflow"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                    []
                    [ HaltReasonT ]
                    [
                      Value.StructTuple
                        "revm_context_interface::result::SuccessReason::EofReturnContract"
                        []
                        []
                        []
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::EofAuxDataOverflow"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::EofAuxDataTooSmall"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                    []
                    [ HaltReasonT ]
                    [
                      M.call_closure (|
                        HaltReasonT,
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.path "revm_context_interface::result::HaltReason",
                          [],
                          [ HaltReasonT ],
                          "into",
                          [],
                          []
                        |),
                        [
                          Value.StructTuple
                            "revm_context_interface::result::HaltReason::InvalidEXTCALLTarget"
                            []
                            []
                            []
                        ]
                      |)
                    ]));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (|
                      γ,
                      "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                    |) in
                  Value.StructTuple
                    "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                    []
                    [ HaltReasonT ]
                    [
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InternalResult::InvalidExtDelegateCallTarget"
                        []
                        []
                        []
                    ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
        (Self HaltReasonT)
        (* Instance *) [ ("from", InstanceField.Method (from HaltReasonT)) ].
  End Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_interpreter_instruction_result_InstructionResult_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
End instruction_result.
