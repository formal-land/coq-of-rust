(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module instruction_result.
  (*
  Enum InstructionResult
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Continue";
          item := StructTuple [];
        };
        {
          name := "Stop";
          item := StructTuple [];
        };
        {
          name := "Return";
          item := StructTuple [];
        };
        {
          name := "SelfDestruct";
          item := StructTuple [];
        };
        {
          name := "ReturnContract";
          item := StructTuple [];
        };
        {
          name := "Revert";
          item := StructTuple [];
        };
        {
          name := "CallTooDeep";
          item := StructTuple [];
        };
        {
          name := "OutOfFunds";
          item := StructTuple [];
        };
        {
          name := "CreateInitCodeStartingEF00";
          item := StructTuple [];
        };
        {
          name := "InvalidEOFInitCode";
          item := StructTuple [];
        };
        {
          name := "InvalidExtDelegateCallTarget";
          item := StructTuple [];
        };
        {
          name := "CallOrCreate";
          item := StructTuple [];
        };
        {
          name := "OutOfGas";
          item := StructTuple [];
        };
        {
          name := "MemoryOOG";
          item := StructTuple [];
        };
        {
          name := "MemoryLimitOOG";
          item := StructTuple [];
        };
        {
          name := "PrecompileOOG";
          item := StructTuple [];
        };
        {
          name := "InvalidOperandOOG";
          item := StructTuple [];
        };
        {
          name := "ReentrancySentryOOG";
          item := StructTuple [];
        };
        {
          name := "OpcodeNotFound";
          item := StructTuple [];
        };
        {
          name := "CallNotAllowedInsideStatic";
          item := StructTuple [];
        };
        {
          name := "StateChangeDuringStaticCall";
          item := StructTuple [];
        };
        {
          name := "InvalidFEOpcode";
          item := StructTuple [];
        };
        {
          name := "InvalidJump";
          item := StructTuple [];
        };
        {
          name := "NotActivated";
          item := StructTuple [];
        };
        {
          name := "StackUnderflow";
          item := StructTuple [];
        };
        {
          name := "StackOverflow";
          item := StructTuple [];
        };
        {
          name := "OutOfOffset";
          item := StructTuple [];
        };
        {
          name := "CreateCollision";
          item := StructTuple [];
        };
        {
          name := "OverflowPayment";
          item := StructTuple [];
        };
        {
          name := "PrecompileError";
          item := StructTuple [];
        };
        {
          name := "NonceOverflow";
          item := StructTuple [];
        };
        {
          name := "CreateContractSizeLimit";
          item := StructTuple [];
        };
        {
          name := "CreateContractStartingWithEF";
          item := StructTuple [];
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
        };
        {
          name := "FatalExternalError";
          item := StructTuple [];
        };
        {
          name := "ReturnContractInNotInitEOF";
          item := StructTuple [];
        };
        {
          name := "EOFOpcodeDisabledInLegacy";
          item := StructTuple [];
        };
        {
          name := "SubRoutineStackOverflow";
          item := StructTuple [];
        };
        {
          name := "EofAuxDataOverflow";
          item := StructTuple [];
        };
        {
          name := "EofAuxDataTooSmall";
          item := StructTuple [];
        };
        {
          name := "InvalidEXTCALLTarget";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_InstructionResult_Continue :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Continue" 0.
  Axiom IsDiscriminant_InstructionResult_Stop :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Stop" 1.
  Axiom IsDiscriminant_InstructionResult_Return :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Return" 2.
  Axiom IsDiscriminant_InstructionResult_SelfDestruct :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::SelfDestruct" 3.
  Axiom IsDiscriminant_InstructionResult_ReturnContract :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::ReturnContract" 4.
  Axiom IsDiscriminant_InstructionResult_Revert :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::Revert" 16.
  Axiom IsDiscriminant_InstructionResult_CallTooDeep :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::CallTooDeep" 17.
  Axiom IsDiscriminant_InstructionResult_OutOfFunds :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OutOfFunds" 18.
  Axiom IsDiscriminant_InstructionResult_CreateInitCodeStartingEF00 :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
      19.
  Axiom IsDiscriminant_InstructionResult_InvalidEOFInitCode :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
      20.
  Axiom IsDiscriminant_InstructionResult_InvalidExtDelegateCallTarget :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
      21.
  Axiom IsDiscriminant_InstructionResult_CallOrCreate :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::CallOrCreate" 32.
  Axiom IsDiscriminant_InstructionResult_OutOfGas :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OutOfGas" 80.
  Axiom IsDiscriminant_InstructionResult_MemoryOOG :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::MemoryOOG" 81.
  Axiom IsDiscriminant_InstructionResult_MemoryLimitOOG :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG" 82.
  Axiom IsDiscriminant_InstructionResult_PrecompileOOG :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG" 83.
  Axiom IsDiscriminant_InstructionResult_InvalidOperandOOG :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
      84.
  Axiom IsDiscriminant_InstructionResult_ReentrancySentryOOG :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
      85.
  Axiom IsDiscriminant_InstructionResult_OpcodeNotFound :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound" 86.
  Axiom IsDiscriminant_InstructionResult_CallNotAllowedInsideStatic :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
      87.
  Axiom IsDiscriminant_InstructionResult_StateChangeDuringStaticCall :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
      88.
  Axiom IsDiscriminant_InstructionResult_InvalidFEOpcode :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode" 89.
  Axiom IsDiscriminant_InstructionResult_InvalidJump :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::InvalidJump" 90.
  Axiom IsDiscriminant_InstructionResult_NotActivated :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::NotActivated" 91.
  Axiom IsDiscriminant_InstructionResult_StackUnderflow :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::StackUnderflow" 92.
  Axiom IsDiscriminant_InstructionResult_StackOverflow :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::StackOverflow" 93.
  Axiom IsDiscriminant_InstructionResult_OutOfOffset :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OutOfOffset" 94.
  Axiom IsDiscriminant_InstructionResult_CreateCollision :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::CreateCollision" 95.
  Axiom IsDiscriminant_InstructionResult_OverflowPayment :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::OverflowPayment" 96.
  Axiom IsDiscriminant_InstructionResult_PrecompileError :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::PrecompileError" 97.
  Axiom IsDiscriminant_InstructionResult_NonceOverflow :
    M.IsDiscriminant "revm_interpreter::instruction_result::InstructionResult::NonceOverflow" 98.
  Axiom IsDiscriminant_InstructionResult_CreateContractSizeLimit :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
      99.
  Axiom IsDiscriminant_InstructionResult_CreateContractStartingWithEF :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
      100.
  Axiom IsDiscriminant_InstructionResult_CreateInitCodeSizeLimit :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
      101.
  Axiom IsDiscriminant_InstructionResult_FatalExternalError :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
      102.
  Axiom IsDiscriminant_InstructionResult_ReturnContractInNotInitEOF :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
      103.
  Axiom IsDiscriminant_InstructionResult_EOFOpcodeDisabledInLegacy :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
      104.
  Axiom IsDiscriminant_InstructionResult_SubRoutineStackOverflow :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
      105.
  Axiom IsDiscriminant_InstructionResult_EofAuxDataOverflow :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
      106.
  Axiom IsDiscriminant_InstructionResult_EofAuxDataTooSmall :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
      107.
  Axiom IsDiscriminant_InstructionResult_InvalidEXTCALLTarget :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
      108.
  
  Module Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::Continue"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Continue" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::Stop"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Stop" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::Return"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Return" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "SelfDestruct" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "ReturnContract" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::Revert"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Revert" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CallTooDeep" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "OutOfFunds" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CreateInitCodeStartingEF00" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InvalidEOFInitCode" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InvalidExtDelegateCallTarget" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CallOrCreate"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CallOrCreate" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "OutOfGas" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "MemoryOOG" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "MemoryLimitOOG" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "PrecompileOOG" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InvalidOperandOOG" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "ReentrancySentryOOG" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "OpcodeNotFound" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CallNotAllowedInsideStatic" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "StateChangeDuringStaticCall" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InvalidFEOpcode" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InvalidJump" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "NotActivated" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "StackUnderflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "StackOverflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "OutOfOffset" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CreateCollision" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "OverflowPayment" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "PrecompileError" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "NonceOverflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CreateContractSizeLimit" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CreateContractStartingWithEF" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CreateInitCodeSizeLimit" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "FatalExternalError" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "ReturnContractInNotInitEOF" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "EOFOpcodeDisabledInLegacy" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "SubRoutineStackOverflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "EofAuxDataOverflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "EofAuxDataTooSmall" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InvalidEXTCALLTarget" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_default_Default_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "revm_interpreter::instruction_result::InstructionResult::Continue"
            []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u8",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u8",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u8",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "u8",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_convert_From_revm_context_interface_journaled_state_TransferError_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (*
        fn from(e: TransferError) -> Self {
            match e {
                TransferError::OutOfFunds => InstructionResult::OutOfFunds,
                TransferError::OverflowPayment => InstructionResult::OverflowPayment,
                TransferError::CreateCollision => InstructionResult::CreateCollision,
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ e ] =>
        ltac:(M.monadic
          (let e := M.alloc (| e |) in
          M.read (|
            M.match_operator (|
              e,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::journaled_state::TransferError::OutOfFunds"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::journaled_state::TransferError::OverflowPayment"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::journaled_state::TransferError::CreateCollision"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_context_interface::journaled_state::TransferError" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_context_interface_journaled_state_TransferError_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    (*
        pub const fn is_ok(self) -> bool {
            matches!(self, crate::return_ok!())
        }
    *)
    Definition is_ok (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::Continue"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::Stop"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::Return"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_ok : M.IsAssociatedFunction Self "is_ok" is_ok.
    Smpl Add apply AssociatedFunction_is_ok : is_associated.
    
    (*
        pub const fn is_ok_or_revert(self) -> bool {
            matches!(self, crate::return_ok!() | crate::return_revert!())
        }
    *)
    Definition is_ok_or_revert (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.find_or_pattern (|
                              γ,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::Continue"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::Stop"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::Return"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                                      |) in
                                    Value.Tuple []))
                              ],
                              fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [] => ltac:(M.monadic (Value.Tuple []))
                                  | _ => M.impossible "wrong number of arguments"
                                  end)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.find_or_pattern (|
                              γ,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::Revert"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                                      |) in
                                    Value.Tuple []));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                                      |) in
                                    Value.Tuple []))
                              ],
                              fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [] => ltac:(M.monadic (Value.Tuple []))
                                  | _ => M.impossible "wrong number of arguments"
                                  end)
                            |)))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_ok_or_revert :
      M.IsAssociatedFunction Self "is_ok_or_revert" is_ok_or_revert.
    Smpl Add apply AssociatedFunction_is_ok_or_revert : is_associated.
    
    (*
        pub const fn is_continue(self) -> bool {
            matches!(self, InstructionResult::Continue)
        }
    *)
    Definition is_continue (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::Continue"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_continue : M.IsAssociatedFunction Self "is_continue" is_continue.
    Smpl Add apply AssociatedFunction_is_continue : is_associated.
    
    (*
        pub const fn is_revert(self) -> bool {
            matches!(self, crate::return_revert!())
        }
    *)
    Definition is_revert (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::Revert"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_revert : M.IsAssociatedFunction Self "is_revert" is_revert.
    Smpl Add apply AssociatedFunction_is_revert : is_associated.
    
    (*
        pub const fn is_error(self) -> bool {
            matches!(self, return_error!())
        }
    *)
    Definition is_error (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_error : M.IsAssociatedFunction Self "is_error" is_error.
    Smpl Add apply AssociatedFunction_is_error : is_associated.
  End Impl_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_convert_From_revm_context_interface_result_SuccessReason_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (*
        fn from(value: SuccessReason) -> Self {
            match value {
                SuccessReason::Return => InstructionResult::Return,
                SuccessReason::Stop => InstructionResult::Stop,
                SuccessReason::SelfDestruct => InstructionResult::SelfDestruct,
                SuccessReason::EofReturnContract => InstructionResult::ReturnContract,
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              value,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::SuccessReason::Return"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::Return"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::SuccessReason::Stop"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::Stop"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::SuccessReason::SelfDestruct"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::SuccessReason::EofReturnContract"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::SuccessReason" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_context_interface_result_SuccessReason_for_revm_interpreter_instruction_result_InstructionResult.
  
  Module Impl_core_convert_From_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_InstructionResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InstructionResult".
    
    (*
        fn from(value: HaltReason) -> Self {
            match value {
                HaltReason::OutOfGas(error) => match error {
                    OutOfGasError::Basic => Self::OutOfGas,
                    OutOfGasError::InvalidOperand => Self::InvalidOperandOOG,
                    OutOfGasError::Memory => Self::MemoryOOG,
                    OutOfGasError::MemoryLimit => Self::MemoryLimitOOG,
                    OutOfGasError::Precompile => Self::PrecompileOOG,
                    OutOfGasError::ReentrancySentry => Self::ReentrancySentryOOG,
                },
                HaltReason::OpcodeNotFound => Self::OpcodeNotFound,
                HaltReason::InvalidFEOpcode => Self::InvalidFEOpcode,
                HaltReason::InvalidJump => Self::InvalidJump,
                HaltReason::NotActivated => Self::NotActivated,
                HaltReason::StackOverflow => Self::StackOverflow,
                HaltReason::StackUnderflow => Self::StackUnderflow,
                HaltReason::OutOfOffset => Self::OutOfOffset,
                HaltReason::CreateCollision => Self::CreateCollision,
                HaltReason::PrecompileError => Self::PrecompileError,
                HaltReason::NonceOverflow => Self::NonceOverflow,
                HaltReason::CreateContractSizeLimit => Self::CreateContractSizeLimit,
                HaltReason::CreateContractStartingWithEF => Self::CreateContractStartingWithEF,
                HaltReason::CreateInitCodeSizeLimit => Self::CreateInitCodeSizeLimit,
                HaltReason::OverflowPayment => Self::OverflowPayment,
                HaltReason::StateChangeDuringStaticCall => Self::StateChangeDuringStaticCall,
                HaltReason::CallNotAllowedInsideStatic => Self::CallNotAllowedInsideStatic,
                HaltReason::OutOfFunds => Self::OutOfFunds,
                HaltReason::CallTooDeep => Self::CallTooDeep,
                HaltReason::EofAuxDataOverflow => Self::EofAuxDataOverflow,
                HaltReason::EofAuxDataTooSmall => Self::EofAuxDataTooSmall,
                HaltReason::SubRoutineStackOverflow => Self::SubRoutineStackOverflow,
                HaltReason::InvalidEXTCALLTarget => Self::InvalidEXTCALLTarget,
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              value,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfGas",
                        0
                      |) in
                    let error := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      error,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_context_interface::result::OutOfGasError::Basic"
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                                []
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_context_interface::result::OutOfGasError::InvalidOperand"
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                                []
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_context_interface::result::OutOfGasError::Memory"
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                                []
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_context_interface::result::OutOfGasError::MemoryLimit"
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                                []
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_context_interface::result::OutOfGasError::Precompile"
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                                []
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_context_interface::result::OutOfGasError::ReentrancySentry"
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                                []
                            |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OpcodeNotFound"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidFEOpcode"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidJump"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::NotActivated"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StackOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StackUnderflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfOffset"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateCollision"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::PrecompileError"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::NonceOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateContractSizeLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateContractStartingWithEF"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OverflowPayment"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StateChangeDuringStaticCall"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CallNotAllowedInsideStatic"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfFunds"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CallTooDeep"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::EofAuxDataOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::EofAuxDataTooSmall"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::SubRoutineStackOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidEXTCALLTarget"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::HaltReason" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_InstructionResult.
  
  
  (*
  Enum InternalResult
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "InternalContinue";
          item := StructTuple [];
        };
        {
          name := "InternalCallOrCreate";
          item := StructTuple [];
        };
        {
          name := "CreateInitCodeStartingEF00";
          item := StructTuple [];
        };
        {
          name := "InvalidExtDelegateCallTarget";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_InternalResult_InternalContinue :
    M.IsDiscriminant "revm_interpreter::instruction_result::InternalResult::InternalContinue" 0.
  Axiom IsDiscriminant_InternalResult_InternalCallOrCreate :
    M.IsDiscriminant "revm_interpreter::instruction_result::InternalResult::InternalCallOrCreate" 1.
  Axiom IsDiscriminant_InternalResult_CreateInitCodeStartingEF00 :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InternalResult::CreateInitCodeStartingEF00"
      2.
  Axiom IsDiscriminant_InternalResult_InvalidExtDelegateCallTarget :
    M.IsDiscriminant
      "revm_interpreter::instruction_result::InternalResult::InvalidExtDelegateCallTarget"
      3.
  
  Module Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InternalResult::InternalContinue"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InternalContinue" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InternalResult::InternalCallOrCreate"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InternalCallOrCreate" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InternalResult::CreateInitCodeStartingEF00"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "CreateInitCodeStartingEF00" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_interpreter::instruction_result::InternalResult::InvalidExtDelegateCallTarget"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "InvalidExtDelegateCallTarget" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_cmp_PartialEq_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_interpreter_instruction_result_InternalResult.
  
  Module Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InternalResult.
    Definition Self : Ty.t := Ty.path "revm_interpreter::instruction_result::InternalResult".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_interpreter::instruction_result::InternalResult" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_interpreter_instruction_result_InternalResult.
  
  (*
  Enum SuccessOrHalt
  {
    const_params := [];
    ty_params := [ "HaltReasonT" ];
    variants :=
      [
        {
          name := "Success";
          item := StructTuple [ Ty.path "revm_context_interface::result::SuccessReason" ];
        };
        {
          name := "Revert";
          item := StructTuple [];
        };
        {
          name := "Halt";
          item := StructTuple [ HaltReasonT ];
        };
        {
          name := "FatalExternalError";
          item := StructTuple [];
        };
        {
          name := "Internal";
          item := StructTuple [ Ty.path "revm_interpreter::instruction_result::InternalResult" ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_SuccessOrHalt_Success :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Success" 0.
  Axiom IsDiscriminant_SuccessOrHalt_Revert :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Revert" 1.
  Axiom IsDiscriminant_SuccessOrHalt_Halt :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Halt" 2.
  Axiom IsDiscriminant_SuccessOrHalt_FatalExternalError :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError" 3.
  Axiom IsDiscriminant_SuccessOrHalt_Internal :
    M.IsDiscriminant "revm_interpreter::instruction_result::SuccessOrHalt::Internal" 4.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Clone *)
    Definition clone
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                        [
                          M.call_closure (|
                            Ty.path "revm_context_interface::result::SuccessReason",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "revm_context_interface::result::SuccessReason",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              HaltReasonT,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                        [
                          M.call_closure (|
                            Ty.path "revm_interpreter::instruction_result::InternalResult",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "revm_interpreter::instruction_result::InternalResult",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("clone", InstanceField.Method (clone HaltReasonT)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Debug *)
    Definition fmt (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Success" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Revert" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Halt" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "FatalExternalError" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| Value.String "Internal" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt HaltReasonT)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* PartialEq *)
    Definition eq (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "revm_context_interface::result::SuccessReason" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "revm_context_interface::result::SuccessReason" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ HaltReasonT ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ HaltReasonT ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "revm_interpreter::instruction_result::InternalResult"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "revm_interpreter::instruction_result::InternalResult"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("eq", InstanceField.Method (eq HaltReasonT)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq HaltReasonT))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (* Hash *)
    Definition hash
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [
                      Ty.apply
                        (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_context_interface::result::SuccessReason",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          HaltReasonT,
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Internal",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_interpreter::instruction_result::InternalResult",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self HaltReasonT)
        (* Instance *) [ ("hash", InstanceField.Method (hash HaltReasonT)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (*
        pub fn is_success(self) -> bool {
            matches!(self, SuccessOrHalt::Success(_))
        }
    *)
    Definition is_success
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                        0
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_success :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "is_success" (is_success HaltReasonT).
    Smpl Add apply AssociatedFunction_is_success : is_associated.
    
    (*
        pub fn to_success(self) -> Option<SuccessReason> {
            match self {
                SuccessOrHalt::Success(reason) => Some(reason),
                _ => None,
            }
        }
    *)
    Definition to_success
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success",
                        0
                      |) in
                    let reason := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| reason |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_to_success :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "to_success" (to_success HaltReasonT).
    Smpl Add apply AssociatedFunction_to_success : is_associated.
    
    (*
        pub fn is_revert(self) -> bool {
            matches!(self, SuccessOrHalt::Revert)
        }
    *)
    Definition is_revert
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_revert :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "is_revert" (is_revert HaltReasonT).
    Smpl Add apply AssociatedFunction_is_revert : is_associated.
    
    (*
        pub fn is_halt(self) -> bool {
            matches!(self, SuccessOrHalt::Halt(_))
        }
    *)
    Definition is_halt
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                        0
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_halt :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "is_halt" (is_halt HaltReasonT).
    Smpl Add apply AssociatedFunction_is_halt : is_associated.
    
    (*
        pub fn to_halt(self) -> Option<HaltReasonT> {
            match self {
                SuccessOrHalt::Halt(reason) => Some(reason),
                _ => None,
            }
        }
    *)
    Definition to_halt
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt",
                        0
                      |) in
                    let reason := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| reason |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_to_halt :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "to_halt" (to_halt HaltReasonT).
    Smpl Add apply AssociatedFunction_to_halt : is_associated.
  End Impl_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
  
  Module Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HALT_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_SuccessOrHalt_HALT.
    Definition Self (HALT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HALT ].
    
    (*
        fn from(reason: HaltReason) -> Self {
            SuccessOrHalt::Halt(reason.into())
        }
    *)
    Definition from (HALT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HALT in
      match ε, τ, α with
      | [], [], [ reason ] =>
        ltac:(M.monadic
          (let reason := M.alloc (| reason |) in
          Value.StructTuple
            "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
            [
              M.call_closure (|
                HALT,
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.path "revm_context_interface::result::HaltReason",
                  [],
                  [ HALT ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| reason |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HALT : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_context_interface::result::HaltReason" ]
        (Self HALT)
        (* Instance *) [ ("from", InstanceField.Method (from HALT)) ].
  End Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HALT_revm_context_interface_result_HaltReason_for_revm_interpreter_instruction_result_SuccessOrHalt_HALT.
  
  Module Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_interpreter_instruction_result_InstructionResult_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::instruction_result::SuccessOrHalt") [] [ HaltReasonT ].
    
    (*
        fn from(result: InstructionResult) -> Self {
            match result {
                InstructionResult::Continue => Self::Internal(InternalResult::InternalContinue), // used only in interpreter loop
                InstructionResult::Stop => Self::Success(SuccessReason::Stop),
                InstructionResult::Return => Self::Success(SuccessReason::Return),
                InstructionResult::SelfDestruct => Self::Success(SuccessReason::SelfDestruct),
                InstructionResult::Revert => Self::Revert,
                InstructionResult::CreateInitCodeStartingEF00 => Self::Revert,
                InstructionResult::CallOrCreate => Self::Internal(InternalResult::InternalCallOrCreate), // used only in interpreter loop
                InstructionResult::CallTooDeep => Self::Halt(HaltReason::CallTooDeep.into()), // not gonna happen for first call
                InstructionResult::OutOfFunds => Self::Halt(HaltReason::OutOfFunds.into()), // Check for first call is done separately.
                InstructionResult::OutOfGas => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::Basic).into())
                }
                InstructionResult::MemoryLimitOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::MemoryLimit).into())
                }
                InstructionResult::MemoryOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::Memory).into())
                }
                InstructionResult::PrecompileOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::Precompile).into())
                }
                InstructionResult::InvalidOperandOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::InvalidOperand).into())
                }
                InstructionResult::ReentrancySentryOOG => {
                    Self::Halt(HaltReason::OutOfGas(OutOfGasError::ReentrancySentry).into())
                }
                InstructionResult::OpcodeNotFound | InstructionResult::ReturnContractInNotInitEOF => {
                    Self::Halt(HaltReason::OpcodeNotFound.into())
                }
                InstructionResult::CallNotAllowedInsideStatic => {
                    Self::Halt(HaltReason::CallNotAllowedInsideStatic.into())
                } // first call is not static call
                InstructionResult::StateChangeDuringStaticCall => {
                    Self::Halt(HaltReason::StateChangeDuringStaticCall.into())
                }
                InstructionResult::InvalidFEOpcode => Self::Halt(HaltReason::InvalidFEOpcode.into()),
                InstructionResult::InvalidJump => Self::Halt(HaltReason::InvalidJump.into()),
                InstructionResult::NotActivated => Self::Halt(HaltReason::NotActivated.into()),
                InstructionResult::StackUnderflow => Self::Halt(HaltReason::StackUnderflow.into()),
                InstructionResult::StackOverflow => Self::Halt(HaltReason::StackOverflow.into()),
                InstructionResult::OutOfOffset => Self::Halt(HaltReason::OutOfOffset.into()),
                InstructionResult::CreateCollision => Self::Halt(HaltReason::CreateCollision.into()),
                InstructionResult::OverflowPayment => Self::Halt(HaltReason::OverflowPayment.into()), // Check for first call is done separately.
                InstructionResult::PrecompileError => Self::Halt(HaltReason::PrecompileError.into()),
                InstructionResult::NonceOverflow => Self::Halt(HaltReason::NonceOverflow.into()),
                InstructionResult::CreateContractSizeLimit
                | InstructionResult::CreateContractStartingWithEF => {
                    Self::Halt(HaltReason::CreateContractSizeLimit.into())
                }
                InstructionResult::CreateInitCodeSizeLimit => {
                    Self::Halt(HaltReason::CreateInitCodeSizeLimit.into())
                }
                // TODO : (EOF) Add proper Revert subtype.
                InstructionResult::InvalidEOFInitCode => Self::Revert,
                InstructionResult::FatalExternalError => Self::FatalExternalError,
                InstructionResult::EOFOpcodeDisabledInLegacy => {
                    Self::Halt(HaltReason::OpcodeNotFound.into())
                }
                InstructionResult::SubRoutineStackOverflow => {
                    Self::Halt(HaltReason::SubRoutineStackOverflow.into())
                }
                InstructionResult::ReturnContract => Self::Success(SuccessReason::EofReturnContract),
                InstructionResult::EofAuxDataOverflow => {
                    Self::Halt(HaltReason::EofAuxDataOverflow.into())
                }
                InstructionResult::EofAuxDataTooSmall => {
                    Self::Halt(HaltReason::EofAuxDataTooSmall.into())
                }
                InstructionResult::InvalidEXTCALLTarget => {
                    Self::Halt(HaltReason::InvalidEXTCALLTarget.into())
                }
                InstructionResult::InvalidExtDelegateCallTarget => {
                    Self::Internal(InternalResult::InvalidExtDelegateCallTarget)
                }
            }
        }
    *)
    Definition from
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ result ] =>
        ltac:(M.monadic
          (let result := M.alloc (| result |) in
          M.read (|
            M.match_operator (|
              result,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::Continue"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                        [
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InternalResult::InternalContinue"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::Stop"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                        [ Value.StructTuple "revm_context_interface::result::SuccessReason::Stop" []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::Return"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                        [
                          Value.StructTuple
                            "revm_context_interface::result::SuccessReason::Return"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::SelfDestruct"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                        [
                          Value.StructTuple
                            "revm_context_interface::result::SuccessReason::SelfDestruct"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::Revert"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeStartingEF00"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::CallOrCreate"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                        [
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InternalResult::InternalCallOrCreate"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::CallTooDeep"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::CallTooDeep"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::OutOfFunds"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfFunds"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::OutOfGas"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfGas"
                                [
                                  Value.StructTuple
                                    "revm_context_interface::result::OutOfGasError::Basic"
                                    []
                                ]
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::MemoryLimitOOG"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfGas"
                                [
                                  Value.StructTuple
                                    "revm_context_interface::result::OutOfGasError::MemoryLimit"
                                    []
                                ]
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::MemoryOOG"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfGas"
                                [
                                  Value.StructTuple
                                    "revm_context_interface::result::OutOfGasError::Memory"
                                    []
                                ]
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::PrecompileOOG"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfGas"
                                [
                                  Value.StructTuple
                                    "revm_context_interface::result::OutOfGasError::Precompile"
                                    []
                                ]
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::InvalidOperandOOG"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfGas"
                                [
                                  Value.StructTuple
                                    "revm_context_interface::result::OutOfGasError::InvalidOperand"
                                    []
                                ]
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::ReentrancySentryOOG"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfGas"
                                [
                                  Value.StructTuple
                                    "revm_context_interface::result::OutOfGasError::ReentrancySentry"
                                    []
                                ]
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::OpcodeNotFound"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::ReturnContractInNotInitEOF"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple
                                  "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                                  [
                                    M.call_closure (|
                                      HaltReasonT,
                                      M.get_trait_method (|
                                        "core::convert::Into",
                                        Ty.path "revm_context_interface::result::HaltReason",
                                        [],
                                        [ HaltReasonT ],
                                        "into",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "revm_context_interface::result::HaltReason::OpcodeNotFound"
                                          []
                                      ]
                                    |)
                                  ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::CallNotAllowedInsideStatic"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::CallNotAllowedInsideStatic"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::StateChangeDuringStaticCall"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::StateChangeDuringStaticCall"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::InvalidFEOpcode"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::InvalidFEOpcode"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::InvalidJump"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::InvalidJump"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::NotActivated"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::NotActivated"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::StackUnderflow"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::StackOverflow"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::OutOfOffset"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OutOfOffset"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::CreateCollision"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::CreateCollision"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::OverflowPayment"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OverflowPayment"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::PrecompileError"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::PrecompileError"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::NonceOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::NonceOverflow"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CreateContractSizeLimit"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "revm_interpreter::instruction_result::InstructionResult::CreateContractStartingWithEF"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple
                                  "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                                  [
                                    M.call_closure (|
                                      HaltReasonT,
                                      M.get_trait_method (|
                                        "core::convert::Into",
                                        Ty.path "revm_context_interface::result::HaltReason",
                                        [],
                                        [ HaltReasonT ],
                                        "into",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "revm_context_interface::result::HaltReason::CreateContractSizeLimit"
                                          []
                                      ]
                                    |)
                                  ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::CreateInitCodeSizeLimit"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::InvalidEOFInitCode"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Revert"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::FatalExternalError"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::FatalExternalError"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::EOFOpcodeDisabledInLegacy"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::OpcodeNotFound"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::SubRoutineStackOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::SubRoutineStackOverflow"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::ReturnContract"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Success"
                        [
                          Value.StructTuple
                            "revm_context_interface::result::SuccessReason::EofReturnContract"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::EofAuxDataOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::EofAuxDataOverflow"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::EofAuxDataTooSmall"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::EofAuxDataTooSmall"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::InvalidEXTCALLTarget"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Halt"
                        [
                          M.call_closure (|
                            HaltReasonT,
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "revm_context_interface::result::HaltReason",
                              [],
                              [ HaltReasonT ],
                              "into",
                              [],
                              []
                            |),
                            [
                              Value.StructTuple
                                "revm_context_interface::result::HaltReason::InvalidEXTCALLTarget"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_interpreter::instruction_result::InstructionResult::InvalidExtDelegateCallTarget"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_interpreter::instruction_result::SuccessOrHalt::Internal"
                        [
                          Value.StructTuple
                            "revm_interpreter::instruction_result::InternalResult::InvalidExtDelegateCallTarget"
                            []
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
        (Self HaltReasonT)
        (* Instance *) [ ("from", InstanceField.Method (from HaltReasonT)) ].
  End Impl_core_convert_From_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_revm_interpreter_instruction_result_InstructionResult_for_revm_interpreter_instruction_result_SuccessOrHalt_HaltReasonT.
End instruction_result.
