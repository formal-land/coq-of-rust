(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module interpreter.
  Module shared_memory.
    (* StructRecord
      {
        name := "SharedMemory";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("buffer",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]);
            ("checkpoints",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]);
            ("last_checkpoint", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "revm_interpreter::interpreter::shared_memory::SharedMemory"
              [
                ("buffer",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "buffer"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("checkpoints",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "checkpoints"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("last_checkpoint",
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "usize",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "last_checkpoint"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    Module Impl_core_cmp_PartialEq_revm_interpreter_interpreter_shared_memory_SharedMemory_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                    ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::interpreter::shared_memory::SharedMemory",
                        "buffer"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_interpreter::interpreter::shared_memory::SharedMemory",
                        "buffer"
                      |)
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                      ],
                      "eq",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                          "checkpoints"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                          "checkpoints"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "last_checkpoint"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "last_checkpoint"
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_revm_interpreter_interpreter_shared_memory_SharedMemory_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    Module Impl_core_cmp_Eq_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        None,
                        Value.DeclaredButUndefined,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                None,
                                Value.DeclaredButUndefined,
                                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    Module Impl_core_hash_Hash_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "hash",
                      [],
                      [ __H ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "buffer"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "hash",
                      [],
                      [ __H ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "checkpoints"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "usize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::interpreter::shared_memory::SharedMemory",
                            "last_checkpoint"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    Definition value_EMPTY_SHARED_MEMORY : Value.t :=
      M.run_constant
        ltac:(M.monadic
          (M.alloc (|
            Value.StructRecord
              "revm_interpreter::interpreter::shared_memory::SharedMemory"
              [
                ("buffer",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |));
                ("checkpoints",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |));
                ("last_checkpoint", Value.Integer IntegerKind.Usize 0)
              ]
          |))).
    
    Axiom Constant_value_EMPTY_SHARED_MEMORY :
      (M.get_constant "revm_interpreter::interpreter::shared_memory::EMPTY_SHARED_MEMORY") =
        value_EMPTY_SHARED_MEMORY.
    Global Hint Rewrite Constant_value_EMPTY_SHARED_MEMORY : constant_rewrites.
    
    Module Impl_core_fmt_Debug_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("SharedMemory")
                  .field("current_len", &self.len())
                  .field("context_memory", &hex::encode(self.context_memory()))
                  .finish_non_exhaustive()
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish_non_exhaustive",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "SharedMemory" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| mk_str (| "current_len" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.path
                                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "context_memory" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "alloc::string::String",
                                  M.get_function (|
                                    "const_hex::encode",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_associated_function (|
                                        Ty.path
                                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                        "context_memory",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    Module Impl_core_default_Default_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (*
          fn default() -> Self {
              Self::new()
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                "new",
                [],
                []
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    (* Trait *)
    (* Empty module 'MemoryGetter' *)
    
    Module Impl_revm_interpreter_interpreter_shared_memory_MemoryGetter_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (*
          fn memory_mut(&mut self) -> &mut SharedMemory {
              self
          }
      *)
      Definition memory_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn memory(&self) -> &SharedMemory {
              self
          }
      *)
      Definition memory (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| self |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "revm_interpreter::interpreter::shared_memory::MemoryGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("memory_mut", InstanceField.Method memory_mut); ("memory", InstanceField.Method memory)
          ].
    End Impl_revm_interpreter_interpreter_shared_memory_MemoryGetter_for_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    Module Impl_revm_interpreter_interpreter_types_MemoryTrait_where_revm_interpreter_interpreter_shared_memory_MemoryGetter_T_for_alloc_rc_Rc_core_cell_RefCell_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::rc::Rc")
          []
          [ Ty.apply (Ty.path "core::cell::RefCell") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn set_data(&mut self, memory_offset: usize, data_offset: usize, len: usize, data: &[u8]) {
              self.borrow_mut()
                  .memory_mut()
                  .set_data(memory_offset, data_offset, len, data);
          }
      *)
      Definition set_data (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; memory_offset; data_offset; len; data ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let memory_offset := M.alloc (| memory_offset |) in
            let data_offset := M.alloc (| data_offset |) in
            let len := M.alloc (| len |) in
            let data := M.alloc (| data |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "set_data",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory"
                              ],
                            M.get_trait_method (|
                              "revm_interpreter::interpreter::shared_memory::MemoryGetter",
                              T,
                              [],
                              [],
                              "memory_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "&mut") [] [ T ],
                                    M.get_trait_method (|
                                      "core::ops::deref::DerefMut",
                                      Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                      [],
                                      [],
                                      "deref_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "core::cell::RefCell") [] [ T ],
                                              "borrow_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::cell::RefCell")
                                                          []
                                                          [ T ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::Rc")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::cell::RefCell")
                                                            []
                                                            [ T ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| self |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.read (| memory_offset |);
                      M.read (| data_offset |);
                      M.read (| len |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn set(&mut self, memory_offset: usize, data: &[u8]) {
              self.borrow_mut().memory_mut().set(memory_offset, data);
          }
      *)
      Definition set (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; memory_offset; data ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let memory_offset := M.alloc (| memory_offset |) in
            let data := M.alloc (| data |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "set",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory"
                              ],
                            M.get_trait_method (|
                              "revm_interpreter::interpreter::shared_memory::MemoryGetter",
                              T,
                              [],
                              [],
                              "memory_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "&mut") [] [ T ],
                                    M.get_trait_method (|
                                      "core::ops::deref::DerefMut",
                                      Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                      [],
                                      [],
                                      "deref_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "core::cell::RefCell") [] [ T ],
                                              "borrow_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::cell::RefCell")
                                                          []
                                                          [ T ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::Rc")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::cell::RefCell")
                                                            []
                                                            [ T ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| self |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.read (| memory_offset |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size(&self) -> usize {
              self.borrow().memory().len()
          }
      *)
      Definition size (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory" ],
                      M.get_trait_method (|
                        "revm_interpreter::interpreter::shared_memory::MemoryGetter",
                        T,
                        [],
                        [],
                        "memory",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ T ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply (Ty.path "core::cell::Ref") [] [ T ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::cell::Ref") [] [ T ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::cell::RefCell") [] [ T ],
                                        "borrow",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "core::cell::RefCell") [] [ T ]
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::cell::RefCell")
                                                      []
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                [],
                                                [],
                                                "deref",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn copy(&mut self, destination: usize, source: usize, len: usize) {
              self.borrow_mut()
                  .memory_mut()
                  .copy(destination, source, len);
          }
      *)
      Definition copy (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; destination; source; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let destination := M.alloc (| destination |) in
            let source := M.alloc (| source |) in
            let len := M.alloc (| len |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "copy",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory"
                              ],
                            M.get_trait_method (|
                              "revm_interpreter::interpreter::shared_memory::MemoryGetter",
                              T,
                              [],
                              [],
                              "memory_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "&mut") [] [ T ],
                                    M.get_trait_method (|
                                      "core::ops::deref::DerefMut",
                                      Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                      [],
                                      [],
                                      "deref_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "core::cell::RefCell") [] [ T ],
                                              "borrow_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::cell::RefCell")
                                                          []
                                                          [ T ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::Rc")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::cell::RefCell")
                                                            []
                                                            [ T ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| self |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.read (| destination |);
                      M.read (| source |);
                      M.read (| len |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn slice(&self, range: Range<usize>) -> impl Deref<Target = [u8]> + '_ {
              Ref::map(self.borrow(), |i| i.memory().slice_range(range))
          }
      *)
      Definition slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; range ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let range := M.alloc (| range |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::cell::Ref")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::cell::Ref") [] [ T ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                  Ty.function
                    [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                    (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::cell::Ref") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::RefCell") [] [ T ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::cell::RefCell") [] [ T ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::rc::Rc")
                              []
                              [
                                Ty.apply (Ty.path "core::cell::RefCell") [] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let i := M.copy (| γ |) in
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        M.get_associated_function (|
                                          Ty.path
                                            "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                          "slice_range",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "revm_interpreter::interpreter::shared_memory::SharedMemory"
                                                  ],
                                                M.get_trait_method (|
                                                  "revm_interpreter::interpreter::shared_memory::MemoryGetter",
                                                  T,
                                                  [],
                                                  [],
                                                  "memory",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| i |) |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |);
                                          M.read (| range |)
                                        ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn resize(&mut self, new_size: usize) -> bool {
              self.borrow_mut().memory_mut().resize(new_size);
              true
          }
      *)
      Definition resize (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; new_size ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let new_size := M.alloc (| new_size |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "resize",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory"
                              ],
                            M.get_trait_method (|
                              "revm_interpreter::interpreter::shared_memory::MemoryGetter",
                              T,
                              [],
                              [],
                              "memory_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "&mut") [] [ T ],
                                    M.get_trait_method (|
                                      "core::ops::deref::DerefMut",
                                      Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                      [],
                                      [],
                                      "deref_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply (Ty.path "core::cell::RefMut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "core::cell::RefCell") [] [ T ],
                                              "borrow_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::cell::RefCell")
                                                          []
                                                          [ T ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::Rc")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::cell::RefCell")
                                                            []
                                                            [ T ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| self |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.read (| new_size |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Bool true |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_interpreter::interpreter_types::MemoryTrait"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("set_data", InstanceField.Method (set_data T));
            ("set", InstanceField.Method (set T));
            ("size", InstanceField.Method (size T));
            ("copy", InstanceField.Method (copy T));
            ("slice", InstanceField.Method (slice T));
            ("resize", InstanceField.Method (resize T))
          ].
    End Impl_revm_interpreter_interpreter_types_MemoryTrait_where_revm_interpreter_interpreter_shared_memory_MemoryGetter_T_for_alloc_rc_Rc_core_cell_RefCell_T_alloc_alloc_Global.
    
    Module Impl_revm_interpreter_interpreter_shared_memory_SharedMemory.
      Definition Self : Ty.t :=
        Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory".
      
      (*
          pub fn new() -> Self {
              Self::with_capacity(4 * 1024) // from evmone
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                "with_capacity",
                [],
                []
              |),
              [
                BinOp.Wrap.mul (|
                  Value.Integer IntegerKind.Usize 4,
                  Value.Integer IntegerKind.Usize 1024
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.Trait Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn with_capacity(capacity: usize) -> Self {
              Self {
                  buffer: Vec::with_capacity(capacity),
                  checkpoints: Vec::with_capacity(32),
                  last_checkpoint: 0,
                  #[cfg(feature = "memory_limit")]
                  memory_limit: u64::MAX,
              }
          }
      *)
      Definition with_capacity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ capacity ] =>
          ltac:(M.monadic
            (let capacity := M.alloc (| capacity |) in
            Value.StructRecord
              "revm_interpreter::interpreter::shared_memory::SharedMemory"
              [
                ("buffer",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "with_capacity",
                      [],
                      []
                    |),
                    [ M.read (| capacity |) ]
                  |));
                ("checkpoints",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "with_capacity",
                      [],
                      []
                    |),
                    [ Value.Integer IntegerKind.Usize 32 ]
                  |));
                ("last_checkpoint", Value.Integer IntegerKind.Usize 0)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_capacity :
        M.IsAssociatedFunction.Trait Self "with_capacity" with_capacity.
      Admitted.
      Global Typeclasses Opaque with_capacity.
      
      (*
          pub fn new_context(&mut self) {
              let new_checkpoint = self.buffer.len();
              self.checkpoints.push(new_checkpoint);
              self.last_checkpoint = new_checkpoint;
          }
      *)
      Definition new_context (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ new_checkpoint : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "len",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                          "buffer"
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                      "push",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                          "checkpoints"
                        |)
                      |);
                      M.read (| new_checkpoint |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "last_checkpoint"
                    |),
                    M.read (| new_checkpoint |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new_context :
        M.IsAssociatedFunction.Trait Self "new_context" new_context.
      Admitted.
      Global Typeclasses Opaque new_context.
      
      (*
          pub fn free_context(&mut self) {
              if let Some(old_checkpoint) = self.checkpoints.pop() {
                  self.last_checkpoint = self.checkpoints.last().cloned().unwrap_or_default();
                  // SAFETY: `buffer` length is less than or equal `old_checkpoint`
                  unsafe { self.buffer.set_len(old_checkpoint) };
              }
          }
      *)
      Definition free_context (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                              "pop",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                  "checkpoints"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let old_checkpoint := M.copy (| γ0_0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "last_checkpoint"
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                "unwrap_or_default",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                    "cloned",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "usize" ],
                                        "last",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "usize" ]
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [ Ty.path "usize"; Ty.path "alloc::alloc::Global"
                                                  ],
                                                [],
                                                [],
                                                "deref",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                                    "checkpoints"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              "set_len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                  "buffer"
                                |)
                              |);
                              M.read (| old_checkpoint |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_free_context :
        M.IsAssociatedFunction.Trait Self "free_context" free_context.
      Admitted.
      Global Typeclasses Opaque free_context.
      
      (*
          pub fn len(&self) -> usize {
              self.buffer.len() - self.last_checkpoint
          }
      *)
      Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  "len",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "buffer"
                    |)
                  |)
                ]
              |),
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_interpreter::interpreter::shared_memory::SharedMemory",
                  "last_checkpoint"
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len : M.IsAssociatedFunction.Trait Self "len" len.
      Admitted.
      Global Typeclasses Opaque len.
      
      (*
          pub fn is_empty(&self) -> bool {
              self.len() == 0
          }
      *)
      Definition is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.eq (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                  "len",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |),
              Value.Integer IntegerKind.Usize 0
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_empty :
        M.IsAssociatedFunction.Trait Self "is_empty" is_empty.
      Admitted.
      Global Typeclasses Opaque is_empty.
      
      (*
          pub fn resize(&mut self, new_size: usize) {
              self.buffer.resize(self.last_checkpoint + new_size, 0);
          }
      *)
      Definition resize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; new_size ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let new_size := M.alloc (| new_size |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "resize",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                          "buffer"
                        |)
                      |);
                      BinOp.Wrap.add (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_interpreter::interpreter::shared_memory::SharedMemory",
                            "last_checkpoint"
                          |)
                        |),
                        M.read (| new_size |)
                      |);
                      Value.Integer IntegerKind.U8 0
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_resize : M.IsAssociatedFunction.Trait Self "resize" resize.
      Admitted.
      Global Typeclasses Opaque resize.
      
      (*
          pub fn slice_len(&self, offset: usize, size: usize) -> &[u8] {
              self.slice_range(offset..offset + size)
          }
      *)
      Definition slice_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset; size ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            let size := M.alloc (| size |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                    "slice_range",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    Value.StructRecord
                      "core::ops::range::Range"
                      [
                        ("start", M.read (| offset |));
                        ("end_", BinOp.Wrap.add (| M.read (| offset |), M.read (| size |) |))
                      ]
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_slice_len :
        M.IsAssociatedFunction.Trait Self "slice_len" slice_len.
      Admitted.
      Global Typeclasses Opaque slice_len.
      
      (*
          pub fn slice_range(&self, range @ Range { start, end }: Range<usize>) -> &[u8] {
              match self.context_memory().get(range) {
                  Some(slice) => slice,
                  None => debug_unreachable!("slice OOB: {start}..{end}; len: {}", self.len()),
              }
          }
      *)
      Definition slice_range (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let range := M.copy (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "core::ops::range::Range",
                        "start"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "core::ops::range::Range",
                        "end"
                      |) in
                    let start := M.copy (| γ1_0 |) in
                    let end_ := M.copy (| γ1_1 |) in
                    M.read (|
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              "get",
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    M.get_associated_function (|
                                      Ty.path
                                        "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                      "context_memory",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |);
                              M.read (| range |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let slice := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              M.match_operator (|
                                Some
                                  (Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (|
                                              "core::panicking::panic_fmt",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::Arguments",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::Arguments",
                                                  "new_v1",
                                                  [
                                                    Value.Integer IntegerKind.Usize 3;
                                                    Value.Integer IntegerKind.Usize 3
                                                  ],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          Value.Array
                                                            [
                                                              mk_str (|
                                                                "internal error: entered unreachable code: slice OOB: "
                                                              |);
                                                              mk_str (| ".." |);
                                                              mk_str (| "; len: " |)
                                                            ]
                                                        |)
                                                      |)
                                                    |)
                                                  |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.match_operator (|
                                                          Some
                                                            (Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 3 ]
                                                              [ Ty.path "core::fmt::rt::Argument"
                                                              ]),
                                                          M.alloc (|
                                                            Value.Tuple
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.alloc (|
                                                                    M.call_closure (|
                                                                      Ty.path "usize",
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                                                        "len",
                                                                        [],
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| self |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  start
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  end_
                                                                |)
                                                              ]
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let args := M.copy (| γ |) in
                                                                M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "core::fmt::rt::Argument",
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [],
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (|
                                                                                M.SubPointer.get_tuple_field (|
                                                                                  args,
                                                                                  1
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "core::fmt::rt::Argument",
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [],
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (|
                                                                                M.SubPointer.get_tuple_field (|
                                                                                  args,
                                                                                  2
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "core::fmt::rt::Argument",
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [],
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (|
                                                                                M.SubPointer.get_tuple_field (|
                                                                                  args,
                                                                                  0
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                |)))
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ _ : Ty.tuple [] :=
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::hint::unreachable_unchecked",
                                                      [],
                                                      []
                                                    |),
                                                    []
                                                  |)
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_slice_range :
        M.IsAssociatedFunction.Trait Self "slice_range" slice_range.
      Admitted.
      Global Typeclasses Opaque slice_range.
      
      (*
          pub fn slice_mut(&mut self, offset: usize, size: usize) -> &mut [u8] {
              let end = offset + size;
              match self.context_memory_mut().get_mut(offset..end) {
                  Some(slice) => slice,
                  None => debug_unreachable!("slice OOB: {offset}..{end}"),
              }
          }
      *)
      Definition slice_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset; size ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            let size := M.alloc (| size |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ end_ : Ty.path "usize" :=
                    M.alloc (| BinOp.Wrap.add (| M.read (| offset |), M.read (| size |) |) |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.match_operator (|
                            Some
                              (Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "get_mut",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        M.get_associated_function (|
                                          Ty.path
                                            "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                          "context_memory_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [ ("start", M.read (| offset |)); ("end_", M.read (| end_ |)) ]
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let slice := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| slice |) |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.match_operator (|
                                    Some
                                      (Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.call_closure (|
                                                Ty.path "never",
                                                M.get_function (|
                                                  "core::panicking::panic_fmt",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::Arguments",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Arguments",
                                                      "new_v1",
                                                      [
                                                        Value.Integer IntegerKind.Usize 2;
                                                        Value.Integer IntegerKind.Usize 2
                                                      ],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Value.Array
                                                                [
                                                                  mk_str (|
                                                                    "internal error: entered unreachable code: slice OOB: "
                                                                  |);
                                                                  mk_str (| ".." |)
                                                                ]
                                                            |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Value.Array
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "core::fmt::rt::Argument",
                                                                      "new_display",
                                                                      [],
                                                                      [ Ty.path "usize" ]
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            offset
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  M.call_closure (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "core::fmt::rt::Argument",
                                                                      "new_display",
                                                                      [],
                                                                      [ Ty.path "usize" ]
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            end_
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::hint::unreachable_unchecked",
                                                          [],
                                                          []
                                                        |),
                                                        []
                                                      |)
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_slice_mut :
        M.IsAssociatedFunction.Trait Self "slice_mut" slice_mut.
      Admitted.
      Global Typeclasses Opaque slice_mut.
      
      (*
          pub fn get_byte(&self, offset: usize) -> u8 {
              self.slice_len(offset, 1)[0]
          }
      *)
      Definition get_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            M.read (|
              M.SubPointer.get_array_field (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "slice_len",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (| offset |);
                      Value.Integer IntegerKind.Usize 1
                    ]
                  |)
                |),
                Value.Integer IntegerKind.Usize 0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_get_byte :
        M.IsAssociatedFunction.Trait Self "get_byte" get_byte.
      Admitted.
      Global Typeclasses Opaque get_byte.
      
      (*
          pub fn get_word(&self, offset: usize) -> B256 {
              self.slice_len(offset, 32).try_into().unwrap()
          }
      *)
      Definition get_word (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 32 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        [];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryInto",
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ],
                    "try_into",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                            "slice_len",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            M.read (| offset |);
                            Value.Integer IntegerKind.Usize 32
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_get_word :
        M.IsAssociatedFunction.Trait Self "get_word" get_word.
      Admitted.
      Global Typeclasses Opaque get_word.
      
      (*
          pub fn get_u256(&self, offset: usize) -> U256 {
              self.get_word(offset).into()
          }
      *)
      Definition get_u256 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_trait_method (|
                "core::convert::Into",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    []
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_associated_function (|
                    Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                    "get_word",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.read (| offset |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_get_u256 :
        M.IsAssociatedFunction.Trait Self "get_u256" get_u256.
      Admitted.
      Global Typeclasses Opaque get_u256.
      
      (*
          pub fn set_byte(&mut self, offset: usize, byte: u8) {
              self.set(offset, &[byte]);
          }
      *)
      Definition set_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset; byte ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            let byte := M.alloc (| byte |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "set",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| offset |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Value.Array [ M.read (| byte |) ] |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_set_byte :
        M.IsAssociatedFunction.Trait Self "set_byte" set_byte.
      Admitted.
      Global Typeclasses Opaque set_byte.
      
      (*
          pub fn set_word(&mut self, offset: usize, value: &B256) {
              self.set(offset, &value[..]);
          }
      *)
      Definition set_word (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            let value := M.alloc (| value |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "set",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| offset |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                    [ Value.Integer IntegerKind.Usize 32 ]
                                    [],
                                  [],
                                  [ Ty.path "core::ops::range::RangeFull" ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |);
                                  Value.StructTuple "core::ops::range::RangeFull" []
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_set_word :
        M.IsAssociatedFunction.Trait Self "set_word" set_word.
      Admitted.
      Global Typeclasses Opaque set_word.
      
      (*
          pub fn set_u256(&mut self, offset: usize, value: U256) {
              self.set(offset, &value.to_be_bytes::<32>());
          }
      *)
      Definition set_u256 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            let value := M.alloc (| value |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                      "set",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| offset |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 32 ]
                                  [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    [],
                                  "to_be_bytes",
                                  [ Value.Integer IntegerKind.Usize 32 ],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, value |) ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_set_u256 :
        M.IsAssociatedFunction.Trait Self "set_u256" set_u256.
      Admitted.
      Global Typeclasses Opaque set_u256.
      
      (*
          pub fn set(&mut self, offset: usize, value: &[u8]) {
              if !value.is_empty() {
                  self.slice_mut(offset, value.len()).copy_from_slice(value);
              }
          }
      *)
      Definition set (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; offset; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let offset := M.alloc (| offset |) in
            let value := M.alloc (| value |) in
            M.read (|
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "is_empty",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              "copy_from_slice",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    M.get_associated_function (|
                                      Ty.path
                                        "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                      "slice_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      M.read (| offset |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| value |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_set : M.IsAssociatedFunction.Trait Self "set" set.
      Admitted.
      Global Typeclasses Opaque set.
      
      (*
          pub fn set_data(&mut self, memory_offset: usize, data_offset: usize, len: usize, data: &[u8]) {
              if data_offset >= data.len() {
                  // Nullify all memory slots
                  self.slice_mut(memory_offset, len).fill(0);
                  return;
              }
              let data_end = min(data_offset + len, data.len());
              let data_len = data_end - data_offset;
              debug_assert!(data_offset < data.len() && data_end <= data.len());
              let data = unsafe { data.get_unchecked(data_offset..data_end) };
              self.slice_mut(memory_offset, data_len)
                  .copy_from_slice(data);
      
              // Nullify rest of memory slots
              // SAFETY: Memory is assumed to be valid, and it is commented where this assumption is made.
              self.slice_mut(memory_offset + data_len, len - data_len)
                  .fill(0);
          }
      *)
      Definition set_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; memory_offset; data_offset; len; data ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let memory_offset := M.alloc (| memory_offset |) in
            let data_offset := M.alloc (| data_offset |) in
            let len := M.alloc (| len |) in
            let data := M.alloc (| data |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.ge (|
                                    M.read (| data_offset |),
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| data |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "fill",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.path
                                                    "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                                  "slice_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| self |) |)
                                                  |);
                                                  M.read (| memory_offset |);
                                                  M.read (| len |)
                                                ]
                                              |)
                                            |)
                                          |);
                                          Value.Integer IntegerKind.U8 0
                                        ]
                                      |)
                                    |) in
                                  M.return_ (| Value.Tuple [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ data_end : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                        [
                          BinOp.Wrap.add (| M.read (| data_offset |), M.read (| len |) |);
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                          |)
                        ]
                      |)
                    |) in
                  let~ data_len : Ty.path "usize" :=
                    M.alloc (|
                      BinOp.Wrap.sub (| M.read (| data_end |), M.read (| data_offset |) |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              LogicalOp.and (|
                                                BinOp.lt (|
                                                  M.read (| data_offset |),
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [ Ty.path "u8" ],
                                                      "len",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| data |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                ltac:(M.monadic
                                                  (BinOp.le (|
                                                    M.read (| data_end |),
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        "len",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| data |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)))
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (| "core::panicking::panic", [], [] |),
                                            [
                                              mk_str (|
                                                "assertion failed: data_offset < data.len() && data_end <= data.len()"
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ data :
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "get_unchecked",
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                          Value.StructRecord
                            "core::ops::range::Range"
                            [ ("start", M.read (| data_offset |)); ("end_", M.read (| data_end |)) ]
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "copy_from_slice",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_associated_function (|
                                  Ty.path
                                    "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                  "slice_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |);
                                  M.read (| memory_offset |);
                                  M.read (| data_len |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "fill",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_associated_function (|
                                  Ty.path
                                    "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                  "slice_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |);
                                  BinOp.Wrap.add (|
                                    M.read (| memory_offset |),
                                    M.read (| data_len |)
                                  |);
                                  BinOp.Wrap.sub (| M.read (| len |), M.read (| data_len |) |)
                                ]
                              |)
                            |)
                          |);
                          Value.Integer IntegerKind.U8 0
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_set_data :
        M.IsAssociatedFunction.Trait Self "set_data" set_data.
      Admitted.
      Global Typeclasses Opaque set_data.
      
      (*
          pub fn copy(&mut self, dst: usize, src: usize, len: usize) {
              self.context_memory_mut().copy_within(src..src + len, dst);
          }
      *)
      Definition copy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; dst; src; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dst := M.alloc (| dst |) in
            let src := M.alloc (| src |) in
            let len := M.alloc (| len |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "copy_within",
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_associated_function (|
                              Ty.path "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "context_memory_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |);
                      Value.StructRecord
                        "core::ops::range::Range"
                        [
                          ("start", M.read (| src |));
                          ("end_", BinOp.Wrap.add (| M.read (| src |), M.read (| len |) |))
                        ];
                      M.read (| dst |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_copy : M.IsAssociatedFunction.Trait Self "copy" copy.
      Admitted.
      Global Typeclasses Opaque copy.
      
      (*
          pub fn context_memory(&self) -> &[u8] {
              // SAFETY: Access bounded by buffer length
              unsafe {
                  self.buffer
                      .get_unchecked(self.last_checkpoint..self.buffer.len())
              }
          }
      *)
      Definition context_memory (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "get_unchecked",
                    [],
                    [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                "buffer"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |);
                    Value.StructRecord
                      "core::ops::range::Range"
                      [
                        ("start",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "last_checkpoint"
                            |)
                          |));
                        ("end_",
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                  "buffer"
                                |)
                              |)
                            ]
                          |))
                      ]
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_context_memory :
        M.IsAssociatedFunction.Trait Self "context_memory" context_memory.
      Admitted.
      Global Typeclasses Opaque context_memory.
      
      (*
          pub fn context_memory_mut(&mut self) -> &mut [u8] {
              let buf_len = self.buffer.len();
              // SAFETY: Access bounded by buffer length
              unsafe { self.buffer.get_unchecked_mut(self.last_checkpoint..buf_len) }
          }
      *)
      Definition context_memory_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ buf_len : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::shared_memory::SharedMemory",
                              "buffer"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                "get_unchecked_mut",
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ]
                                ]
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::DerefMut",
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                        [],
                                        [],
                                        "deref_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                            "buffer"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [
                                    ("start",
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "revm_interpreter::interpreter::shared_memory::SharedMemory",
                                          "last_checkpoint"
                                        |)
                                      |));
                                    ("end_", M.read (| buf_len |))
                                  ]
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_context_memory_mut :
        M.IsAssociatedFunction.Trait Self "context_memory_mut" context_memory_mut.
      Admitted.
      Global Typeclasses Opaque context_memory_mut.
    End Impl_revm_interpreter_interpreter_shared_memory_SharedMemory.
    
    (*
    pub const fn num_words(len: usize) -> usize {
        len.saturating_add(31) / 32
    }
    *)
    Definition num_words (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          BinOp.Wrap.div (|
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (| Ty.path "usize", "saturating_add", [], [] |),
              [ M.read (| len |); Value.Integer IntegerKind.Usize 31 ]
            |),
            Value.Integer IntegerKind.Usize 32
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_num_words :
      M.IsFunction.Trait "revm_interpreter::interpreter::shared_memory::num_words" num_words.
    Admitted.
    Global Typeclasses Opaque num_words.
  End shared_memory.
End interpreter.
