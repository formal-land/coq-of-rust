(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module interpreter.
  Module stack.
    Definition value_STACK_LIMIT (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1024 |))).
    
    Global Instance Instance_IsConstant_value_STACK_LIMIT :
      M.IsFunction.C "revm_interpreter::interpreter::stack::STACK_LIMIT" value_STACK_LIMIT.
    Admitted.
    Global Typeclasses Opaque value_STACK_LIMIT.
    
    (* StructRecord
      {
        name := "Stack";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("data",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Stack" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "data" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::stack::Stack",
                              "data"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_core_marker_StructuralPartialEq_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_core_cmp_PartialEq_revm_interpreter_interpreter_stack_Stack_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [];
                    Ty.path "alloc::alloc::Global"
                  ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        [];
                      Ty.path "alloc::alloc::Global"
                    ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::interpreter::stack::Stack",
                    "data"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "revm_interpreter::interpreter::stack::Stack",
                    "data"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "revm_interpreter::interpreter::stack::Stack" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_revm_interpreter_interpreter_stack_Stack_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_core_cmp_Eq_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_core_hash_Hash_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [];
                    Ty.path "alloc::alloc::Global"
                  ],
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::interpreter::stack::Stack",
                        "data"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_core_fmt_Display_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.write_str("[")?;
              for (i, x) in self.data.iter().enumerate() {
                  if i > 0 {
                      f.write_str(", ")?;
                  }
                  write!(f, "{x}")?;
              }
              f.write_str("]")
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_str",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "[" |) |) |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.use
                      (M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        []
                                    ]
                                ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          []
                                      ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        []
                                    ],
                                  [],
                                  [],
                                  "enumerate",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          []
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [
                                              Value.Integer IntegerKind.Usize 256;
                                              Value.Integer IntegerKind.Usize 4
                                            ]
                                            []
                                        ],
                                      "iter",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [
                                                        Value.Integer IntegerKind.Usize 256;
                                                        Value.Integer IntegerKind.Usize 4
                                                      ]
                                                      []
                                                  ]
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [
                                                      Value.Integer IntegerKind.Usize 256;
                                                      Value.Integer IntegerKind.Usize 4
                                                    ]
                                                    [];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              [],
                                              "deref",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "revm_interpreter::interpreter::stack::Stack",
                                                  "data"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                ltac:(M.monadic
                                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "usize";
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "ruint::Uint")
                                                        [
                                                          Value.Integer IntegerKind.Usize 256;
                                                          Value.Integer IntegerKind.Usize 4
                                                        ]
                                                        []
                                                    ]
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [
                                                        Value.Integer IntegerKind.Usize 256;
                                                        Value.Integer IntegerKind.Usize 4
                                                      ]
                                                      []
                                                  ]
                                              ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                            let i := M.copy (| γ1_0 |) in
                                            let x := M.copy (| γ1_1 |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.match_operator (|
                                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              BinOp.gt,
                                                              [
                                                                M.read (| i |);
                                                                Value.Integer IntegerKind.Usize 0
                                                              ]
                                                            |)
                                                          |)) in
                                                      let _ :=
                                                        is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      let~ _ :
                                                          Ty.apply
                                                            (Ty.path "*")
                                                            []
                                                            [ Ty.tuple [] ] :=
                                                        M.match_operator (|
                                                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::ops::control_flow::ControlFlow")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "core::convert::Infallible";
                                                                      Ty.path "core::fmt::Error"
                                                                    ];
                                                                  Ty.tuple []
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::try_trait::Try",
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  []
                                                                  [
                                                                    Ty.tuple [];
                                                                    Ty.path "core::fmt::Error"
                                                                  ],
                                                                [],
                                                                [],
                                                                "branch",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    []
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path "core::fmt::Error"
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.path "core::fmt::Formatter",
                                                                    "write_str",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (| M.read (| f |) |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        mk_str (| ", " |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                    0
                                                                  |) in
                                                                let residual := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (|
                                                                      M.return_ (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::result::Result")
                                                                            []
                                                                            [
                                                                              Ty.tuple [];
                                                                              Ty.path
                                                                                "core::fmt::Error"
                                                                            ],
                                                                          M.get_trait_method (|
                                                                            "core::ops::try_trait::FromResidual",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::result::Result")
                                                                              []
                                                                              [
                                                                                Ty.tuple [];
                                                                                Ty.path
                                                                                  "core::fmt::Error"
                                                                              ],
                                                                            [],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                []
                                                                                [
                                                                                  Ty.path
                                                                                    "core::convert::Infallible";
                                                                                  Ty.path
                                                                                    "core::fmt::Error"
                                                                                ]
                                                                            ],
                                                                            "from_residual",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [ M.read (| residual |) ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                    0
                                                                  |) in
                                                                let val := M.copy (| γ0_0 |) in
                                                                val))
                                                          ]
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.match_operator (|
                                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::ops::control_flow::ControlFlow")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path "core::fmt::Error"
                                                          ];
                                                        Ty.tuple []
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                      [],
                                                      [],
                                                      "branch",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [ Ty.tuple []; Ty.path "core::fmt::Error"
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Formatter",
                                                          "write_fmt",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (| M.read (| f |) |)
                                                          |);
                                                          M.call_closure (|
                                                            Ty.path "core::fmt::Arguments",
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_v1",
                                                              [
                                                                Value.Integer IntegerKind.Usize 1;
                                                                Value.Integer IntegerKind.Usize 1
                                                              ],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      Value.Array
                                                                        [ mk_str (| "" |) ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      Value.Array
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path
                                                                              "core::fmt::rt::Argument",
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::rt::Argument",
                                                                              "new_display",
                                                                              [],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "ruint::Uint")
                                                                                      [
                                                                                        Value.Integer
                                                                                          IntegerKind.Usize
                                                                                          256;
                                                                                        Value.Integer
                                                                                          IntegerKind.Usize
                                                                                          4
                                                                                      ]
                                                                                      []
                                                                                  ]
                                                                              ]
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    x
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  []
                                                                  [
                                                                    Ty.tuple [];
                                                                    Ty.path "core::fmt::Error"
                                                                  ],
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    []
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path "core::fmt::Error"
                                                                    ],
                                                                  [],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.path "core::fmt::Error"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  [],
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |)) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "]" |) |) |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_core_default_Default_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (*
          fn default() -> Self {
              Self::new()
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "revm_interpreter::interpreter::stack::Stack",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::stack::Stack",
                "new",
                [],
                []
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_core_clone_Clone_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (*
          fn clone(&self) -> Self {
              // Use `Self::new()` to ensure the cloned Stack maintains the STACK_LIMIT capacity,
              // and then copy the data. This preserves the invariant that Stack always has
              // STACK_LIMIT capacity, which is crucial for the safety and correctness of other methods.
              let mut new_stack = Self::new();
              new_stack.data.extend_from_slice(&self.data);
              new_stack
          }
      *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ new_stack :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.path "revm_interpreter::interpreter::stack::Stack" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_interpreter::interpreter::stack::Stack",
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::stack::Stack",
                      "new",
                      [],
                      []
                    |),
                    []
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            [];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "extend_from_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          new_stack,
                          "revm_interpreter::interpreter::stack::Stack",
                          "data"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    [];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "revm_interpreter::interpreter::stack::Stack",
                                      "data"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              new_stack
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_revm_interpreter_interpreter_types_StackTrait_for_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (*
          fn len(&self) -> usize {
              self.len()
          }
      *)
      Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::stack::Stack",
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn popn<const N: usize>(&mut self) -> Option<[U256; N]> {
              if self.len() < N {
                  return None;
              }
              // SAFETY: Stack length is checked above.
              Some(unsafe { self.popn::<N>() })
          }
      *)
      Definition popn (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [ N ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "array")
                    [ N ]
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ]
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.path "revm_interpreter::interpreter::stack::Stack",
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      N
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ N ]
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::Uint")
                                              [
                                                Value.Integer IntegerKind.Usize 256;
                                                Value.Integer IntegerKind.Usize 4
                                              ]
                                              []
                                          ]
                                      ]
                                      []
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ N ]
                          [
                            Ty.apply
                              (Ty.path "ruint::Uint")
                              [
                                Value.Integer IntegerKind.Usize 256;
                                Value.Integer IntegerKind.Usize 4
                              ]
                              []
                          ]
                      ]
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "array")
                            [ N ]
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::interpreter::stack::Stack",
                            "popn",
                            [ N ],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn popn_top<const POPN: usize>(&mut self) -> Option<([U256; POPN], &mut U256)> {
              if self.len() < POPN + 1 {
                  return None;
              }
              // SAFETY: Stack length is checked above.
              Some(unsafe { self.popn_top::<POPN>() })
          }
      *)
      Definition popn_top (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [ POPN ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ POPN ]
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            []
                        ];
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            []
                        ]
                    ]
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.path "revm_interpreter::interpreter::stack::Stack",
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ POPN; Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ POPN ]
                                              [
                                                Ty.apply
                                                  (Ty.path "ruint::Uint")
                                                  [
                                                    Value.Integer IntegerKind.Usize 256;
                                                    Value.Integer IntegerKind.Usize 4
                                                  ]
                                                  []
                                              ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "ruint::Uint")
                                                  [
                                                    Value.Integer IntegerKind.Usize 256;
                                                    Value.Integer IntegerKind.Usize 4
                                                  ]
                                                  []
                                              ]
                                          ]
                                      ]
                                      []
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ POPN ]
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  []
                              ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  []
                              ]
                          ]
                      ]
                      [
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ POPN ]
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ]
                            ],
                          M.get_associated_function (|
                            Ty.path "revm_interpreter::interpreter::stack::Stack",
                            "popn_top",
                            [ POPN ],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn exchange(&mut self, n: usize, m: usize) -> bool {
              self.exchange(n, m)
          }
      *)
      Definition exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n; m ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let m := M.alloc (| m |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::stack::Stack",
                "exchange",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                M.read (| n |);
                M.read (| m |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn dup(&mut self, n: usize) -> bool {
              self.dup(n)
          }
      *)
      Definition dup (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::stack::Stack",
                "dup",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |); M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn push(&mut self, value: U256) -> bool {
              self.push(value)
          }
      *)
      Definition push (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::stack::Stack",
                "push",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                M.read (| value |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "revm_interpreter::interpreter_types::StackTrait"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("len", InstanceField.Method len);
            ("popn", InstanceField.Method popn);
            ("popn_top", InstanceField.Method popn_top);
            ("exchange", InstanceField.Method exchange);
            ("dup", InstanceField.Method dup);
            ("push", InstanceField.Method push)
          ].
    End Impl_revm_interpreter_interpreter_types_StackTrait_for_revm_interpreter_interpreter_stack_Stack.
    
    Module Impl_revm_interpreter_interpreter_stack_Stack.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::stack::Stack".
      
      (*
          pub fn new() -> Self {
              Self {
                  // SAFETY: Expansion functions assume that capacity is `STACK_LIMIT`.
                  data: Vec::with_capacity(STACK_LIMIT),
              }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "revm_interpreter::interpreter::stack::Stack"
              []
              []
              [
                ("data",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          [];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            [];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "with_capacity",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        get_constant (|
                          "revm_interpreter::interpreter::stack::STACK_LIMIT",
                          Ty.path "usize"
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn len(&self) -> usize {
              self.data.len()
          }
      *)
      Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [];
                    Ty.path "alloc::alloc::Global"
                  ],
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::interpreter::stack::Stack",
                    "data"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len : M.IsAssociatedFunction.C Self "len" len.
      Admitted.
      Global Typeclasses Opaque len.
      
      (*
          pub fn is_empty(&self) -> bool {
              self.data.is_empty()
          }
      *)
      Definition is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [];
                    Ty.path "alloc::alloc::Global"
                  ],
                "is_empty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::interpreter::stack::Stack",
                    "data"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_empty :
        M.IsAssociatedFunction.C Self "is_empty" is_empty.
      Admitted.
      Global Typeclasses Opaque is_empty.
      
      (*
          pub fn data(&self) -> &Vec<U256> {
              &self.data
          }
      *)
      Definition data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::interpreter::stack::Stack",
                    "data"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_data : M.IsAssociatedFunction.C Self "data" data.
      Admitted.
      Global Typeclasses Opaque data.
      
      (*
          pub fn data_mut(&mut self) -> &mut Vec<U256> {
              &mut self.data
          }
      *)
      Definition data_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::interpreter::stack::Stack",
                        "data"
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_data_mut :
        M.IsAssociatedFunction.C Self "data_mut" data_mut.
      Admitted.
      Global Typeclasses Opaque data_mut.
      
      (*
          pub fn into_data(self) -> Vec<U256> {
              self.data
          }
      *)
      Definition into_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "revm_interpreter::interpreter::stack::Stack",
                "data"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_data :
        M.IsAssociatedFunction.C Self "into_data" into_data.
      Admitted.
      Global Typeclasses Opaque into_data.
      
      (*
          pub fn pop(&mut self) -> Result<U256, InstructionResult> {
              self.data.pop().ok_or(InstructionResult::StackUnderflow)
          }
      *)
      Definition pop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    [];
                  Ty.path "revm_interpreter::instruction_result::InstructionResult"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      []
                  ],
                "ok_or",
                [],
                [ Ty.path "revm_interpreter::instruction_result::InstructionResult" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          [];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "pop",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::interpreter::stack::Stack",
                        "data"
                      |)
                    |)
                  ]
                |);
                Value.StructTuple
                  "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                  []
                  []
                  []
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop : M.IsAssociatedFunction.C Self "pop" pop.
      Admitted.
      Global Typeclasses Opaque pop.
      
      (*
          pub unsafe fn pop_unsafe(&mut self) -> U256 {
              self.data.pop().unwrap_unchecked()
          }
      *)
      Definition pop_unsafe (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      []
                  ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          [];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "pop",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::interpreter::stack::Stack",
                        "data"
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop_unsafe :
        M.IsAssociatedFunction.C Self "pop_unsafe" pop_unsafe.
      Admitted.
      Global Typeclasses Opaque pop_unsafe.
      
      (*
          pub unsafe fn top_unsafe(&mut self) -> &mut U256 {
              let len = self.data.len();
              self.data.get_unchecked_mut(len - 1)
          }
      *)
      Definition top_unsafe (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                [];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::stack::Stack",
                              "data"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  []
                              ],
                            "get_unchecked_mut",
                            [],
                            [ Ty.path "usize" ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [
                                              Value.Integer IntegerKind.Usize 256;
                                              Value.Integer IntegerKind.Usize 4
                                            ]
                                            []
                                        ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          [];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [],
                                    "deref_mut",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_interpreter::interpreter::stack::Stack",
                                        "data"
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.sub,
                              [ M.read (| len |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_top_unsafe :
        M.IsAssociatedFunction.C Self "top_unsafe" top_unsafe.
      Admitted.
      Global Typeclasses Opaque top_unsafe.
      
      (*
          pub unsafe fn popn<const N: usize>(&mut self) -> [U256; N] {
              if N == 0 {
                  return [U256::ZERO; N];
              }
              let mut result = [U256::ZERO; N];
              for v in result.iter_mut() {
                  *v = self.data.pop().unwrap_unchecked();
              }
              result
          }
      *)
      Definition popn (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [ N ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return
              (Ty.apply
                (Ty.path "array")
                [ N ]
                [
                  Ty.apply
                    (Ty.path "ruint::Uint")
                    [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                    []
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ N; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    repeat (|
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [
                                              Value.Integer IntegerKind.Usize 256;
                                              Value.Integer IntegerKind.Usize 4
                                            ]
                                            [],
                                          "ZERO",
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [
                                              Value.Integer IntegerKind.Usize 256;
                                              Value.Integer IntegerKind.Usize 4
                                            ]
                                            []
                                        |)
                                      |),
                                      N
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ result :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ N ]
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                []
                            ]
                        ] :=
                    M.alloc (|
                      repeat (|
                        M.read (|
                          get_associated_constant (|
                            Ty.apply
                              (Ty.path "ruint::Uint")
                              [
                                Value.Integer IntegerKind.Usize 256;
                                Value.Integer IntegerKind.Usize 4
                              ]
                              [],
                            "ZERO",
                            Ty.apply
                              (Ty.path "ruint::Uint")
                              [
                                Value.Integer IntegerKind.Usize 256;
                                Value.Integer IntegerKind.Usize 4
                              ]
                              []
                          |)
                        |),
                        N
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.use
                      (M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::slice::iter::IterMut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  []
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::slice::iter::IterMut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::IterMut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        []
                                    ],
                                  "iter_mut",
                                  [],
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion (M.borrow (| Pointer.Kind.MutRef, result |))
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                ltac:(M.monadic
                                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [
                                                      Value.Integer IntegerKind.Usize 256;
                                                      Value.Integer IntegerKind.Usize 4
                                                    ]
                                                    []
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::slice::iter::IterMut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "ruint::Uint")
                                                  [
                                                    Value.Integer IntegerKind.Usize 256;
                                                    Value.Integer IntegerKind.Usize 4
                                                  ]
                                                  []
                                              ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let v := M.copy (| γ0_0 |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.write (|
                                                  M.deref (| M.read (| v |) |),
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [
                                                        Value.Integer IntegerKind.Usize 256;
                                                        Value.Integer IntegerKind.Usize 4
                                                      ]
                                                      [],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "ruint::Uint")
                                                            [
                                                              Value.Integer IntegerKind.Usize 256;
                                                              Value.Integer IntegerKind.Usize 4
                                                            ]
                                                            []
                                                        ],
                                                      "unwrap_unchecked",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [
                                                                Value.Integer IntegerKind.Usize 256;
                                                                Value.Integer IntegerKind.Usize 4
                                                              ]
                                                              []
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "ruint::Uint")
                                                                [
                                                                  Value.Integer
                                                                    IntegerKind.Usize
                                                                    256;
                                                                  Value.Integer IntegerKind.Usize 4
                                                                ]
                                                                [];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          "pop",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "revm_interpreter::interpreter::stack::Stack",
                                                              "data"
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |)) in
                  result
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_popn : M.IsAssociatedFunction.C Self "popn" popn.
      Admitted.
      Global Typeclasses Opaque popn.
      
      (*
          pub unsafe fn popn_top<const POPN: usize>(&mut self) -> ([U256; POPN], &mut U256) {
              let result = self.popn::<POPN>();
              let top = self.top_unsafe();
              (result, top)
          }
      *)
      Definition popn_top (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [ POPN ], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ result :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ POPN ]
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            []
                        ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ POPN ]
                      [
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          []
                      ],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::stack::Stack",
                      "popn",
                      [ POPN ],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ top :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            []
                        ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          []
                      ],
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::interpreter::stack::Stack",
                      "top_unsafe",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| result |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| top |) |) |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_popn_top :
        M.IsAssociatedFunction.C Self "popn_top" popn_top.
      Admitted.
      Global Typeclasses Opaque popn_top.
      
      (*
          pub fn push(&mut self, value: U256) -> bool {
              // Allows the compiler to optimize out the `Vec::push` capacity check.
              assume!(self.data.capacity() == STACK_LIMIT);
              if self.data.len() == STACK_LIMIT {
                  return false;
              }
              self.data.push(value);
              true
          }
      *)
      Definition push (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let value := M.alloc (| value |) in
            M.catch_return (Ty.path "bool") (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "ruint::Uint")
                                                  [
                                                    Value.Integer IntegerKind.Usize 256;
                                                    Value.Integer IntegerKind.Usize 4
                                                  ]
                                                  [];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "capacity",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "revm_interpreter::interpreter::stack::Stack",
                                                "data"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.read (|
                                          get_constant (|
                                            "revm_interpreter::interpreter::stack::STACK_LIMIT",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::panic_fmt",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::Arguments",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1",
                                                        [
                                                          Value.Integer IntegerKind.Usize 1;
                                                          Value.Integer IntegerKind.Usize 0
                                                        ],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Value.Array
                                                                  [
                                                                    mk_str (|
                                                                      "internal error: entered unreachable code: self.data.capacity() == STACK_LIMIT"
                                                                    |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        0
                                                                    ]
                                                                    [
                                                                      Ty.path
                                                                        "core::fmt::rt::Argument"
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "none",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  []
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let~ _ :
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.call_closure (|
                                                          Ty.path "never",
                                                          M.get_function (|
                                                            "core::hint::unreachable_unchecked",
                                                            [],
                                                            []
                                                          |),
                                                          []
                                                        |)
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "ruint::Uint")
                                                [
                                                  Value.Integer IntegerKind.Usize 256;
                                                  Value.Integer IntegerKind.Usize 4
                                                ]
                                                [];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "revm_interpreter::interpreter::stack::Stack",
                                              "data"
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.read (|
                                        get_constant (|
                                          "revm_interpreter::interpreter::stack::STACK_LIMIT",
                                          Ty.path "usize"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                [];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "push",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::stack::Stack",
                              "data"
                            |)
                          |);
                          M.read (| value |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Bool true |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push : M.IsAssociatedFunction.C Self "push" push.
      Admitted.
      Global Typeclasses Opaque push.
      
      (*
          pub fn peek(&self, no_from_top: usize) -> Result<U256, InstructionResult> {
              if self.data.len() > no_from_top {
                  Ok(self.data[self.data.len() - no_from_top - 1])
              } else {
                  Err(InstructionResult::StackUnderflow)
              }
          }
      *)
      Definition peek (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; no_from_top ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let no_from_top := M.alloc (| no_from_top |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          [];
                        Ty.path "revm_interpreter::instruction_result::InstructionResult"
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          [];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_interpreter::interpreter::stack::Stack",
                                        "data"
                                      |)
                                    |)
                                  ]
                                |);
                                M.read (| no_from_top |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.apply
                              (Ty.path "ruint::Uint")
                              [
                                Value.Integer IntegerKind.Usize 256;
                                Value.Integer IntegerKind.Usize 4
                              ]
                              [];
                            Ty.path "revm_interpreter::instruction_result::InstructionResult"
                          ]
                          [
                            M.read (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        []
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          [];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [ Ty.path "usize" ],
                                    "index",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_interpreter::interpreter::stack::Stack",
                                        "data"
                                      |)
                                    |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.sub,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.sub,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [
                                                        Value.Integer IntegerKind.Usize 256;
                                                        Value.Integer IntegerKind.Usize 4
                                                      ]
                                                      [];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "revm_interpreter::interpreter::stack::Stack",
                                                    "data"
                                                  |)
                                                |)
                                              ]
                                            |);
                                            M.read (| no_from_top |)
                                          ]
                                        |);
                                        Value.Integer IntegerKind.Usize 1
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.apply
                              (Ty.path "ruint::Uint")
                              [
                                Value.Integer IntegerKind.Usize 256;
                                Value.Integer IntegerKind.Usize 4
                              ]
                              [];
                            Ty.path "revm_interpreter::instruction_result::InstructionResult"
                          ]
                          [
                            Value.StructTuple
                              "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                              []
                              []
                              []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_peek : M.IsAssociatedFunction.C Self "peek" peek.
      Admitted.
      Global Typeclasses Opaque peek.
      
      (*
          pub fn dup(&mut self, n: usize) -> bool {
              assume!(n > 0, "attempted to dup 0");
              let len = self.data.len();
              if len < n || len + 1 > STACK_LIMIT {
                  false
              } else {
                  // SAFETY: Check for out of bounds is done above and it makes this safe to do.
                  unsafe {
                      let ptr = self.data.as_mut_ptr().add(len);
                      ptr::copy_nonoverlapping(ptr.sub(n), ptr, 1);
                      self.data.set_len(len + 1);
                  }
                  true
              }
          }
      *)
      Definition dup (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| n |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.call_closure (|
                                              Ty.path "never",
                                              M.get_function (|
                                                "core::panicking::panic_fmt",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::Arguments",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    [
                                                      Value.Integer IntegerKind.Usize 1;
                                                      Value.Integer IntegerKind.Usize 0
                                                    ],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Value.Array
                                                              [
                                                                mk_str (|
                                                                  "internal error: entered unreachable code: attempted to dup 0"
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Value.Integer IntegerKind.Usize 0
                                                                ]
                                                                [ Ty.path "core::fmt::rt::Argument"
                                                                ],
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::rt::Argument",
                                                                "none",
                                                                [],
                                                                []
                                                              |),
                                                              []
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.call_closure (|
                                                      Ty.path "never",
                                                      M.get_function (|
                                                        "core::hint::unreachable_unchecked",
                                                        [],
                                                        []
                                                      |),
                                                      []
                                                    |)
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            [];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "len",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_interpreter::interpreter::stack::Stack",
                          "data"
                        |)
                      |)
                    ]
                  |)
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| len |); M.read (| n |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.add,
                                      [ M.read (| len |); Value.Integer IntegerKind.Usize 1 ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "revm_interpreter::interpreter::stack::STACK_LIMIT",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.Bool false |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        let~ ptr :
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ]
                              ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ],
                                "add",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        []
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          [];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "as_mut_ptr",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_interpreter::interpreter::stack::Stack",
                                        "data"
                                      |)
                                    |)
                                  ]
                                |);
                                M.read (| len |)
                              ]
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_function (|
                                "core::intrinsics::copy_nonoverlapping",
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ]
                              |),
                              [
                                (* MutToConstPointer *)
                                M.pointer_coercion
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          []
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [
                                              Value.Integer IntegerKind.Usize 256;
                                              Value.Integer IntegerKind.Usize 4
                                            ]
                                            []
                                        ],
                                      "sub",
                                      [],
                                      []
                                    |),
                                    [ M.read (| ptr |); M.read (| n |) ]
                                  |));
                                M.read (| ptr |);
                                Value.Integer IntegerKind.Usize 1
                              ]
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      [];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "set_len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_interpreter::interpreter::stack::Stack",
                                    "data"
                                  |)
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| len |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |) in
                      M.alloc (| Value.Bool true |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_dup : M.IsAssociatedFunction.C Self "dup" dup.
      Admitted.
      Global Typeclasses Opaque dup.
      
      (*
          pub fn swap(&mut self, n: usize) -> bool {
              self.exchange(0, n)
          }
      *)
      Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "revm_interpreter::interpreter::stack::Stack",
                "exchange",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                Value.Integer IntegerKind.Usize 0;
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_swap : M.IsAssociatedFunction.C Self "swap" swap.
      Admitted.
      Global Typeclasses Opaque swap.
      
      (*
          pub fn exchange(&mut self, n: usize, m: usize) -> bool {
              assume!(m > 0, "overlapping exchange");
              let len = self.data.len();
              let n_m_index = n + m;
              if n_m_index >= len {
                  return false;
              }
              // SAFETY: `n` and `n_m` are checked to be within bounds, and they don't overlap.
              unsafe {
                  // Note: `ptr::swap_nonoverlapping` is more efficient than `slice::swap` or `ptr::swap`
                  // because it operates under the assumption that the pointers do not overlap,
                  // eliminating an intemediate copy,
                  // which is a condition we know to be true in this context.
                  let top = self.data.as_mut_ptr().add(len - 1);
                  core::ptr::swap_nonoverlapping(top.sub(n), top.sub(n_m_index), 1);
              }
              true
          }
      *)
      Definition exchange (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n; m ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let m := M.alloc (| m |) in
            M.catch_return (Ty.path "bool") (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.gt,
                                      [ M.read (| m |); Value.Integer IntegerKind.Usize 0 ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::panic_fmt",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::Arguments",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1",
                                                        [
                                                          Value.Integer IntegerKind.Usize 1;
                                                          Value.Integer IntegerKind.Usize 0
                                                        ],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Value.Array
                                                                  [
                                                                    mk_str (|
                                                                      "internal error: entered unreachable code: overlapping exchange"
                                                                    |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        0
                                                                    ]
                                                                    [
                                                                      Ty.path
                                                                        "core::fmt::rt::Argument"
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "none",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  []
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let~ _ :
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.call_closure (|
                                                          Ty.path "never",
                                                          M.get_function (|
                                                            "core::hint::unreachable_unchecked",
                                                            [],
                                                            []
                                                          |),
                                                          []
                                                        |)
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)
                                                |)
                                              |)
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                [];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_interpreter::interpreter::stack::Stack",
                              "data"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ n_m_index : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [ M.read (| n |); M.read (| m |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [ M.read (| n_m_index |); M.read (| len |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    let~ top :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  []
                              ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  []
                              ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      [];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "as_mut_ptr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_interpreter::interpreter::stack::Stack",
                                    "data"
                                  |)
                                |)
                              ]
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.sub,
                              [ M.read (| len |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "core::ptr::swap_nonoverlapping",
                            [],
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                []
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ],
                                "sub",
                                [],
                                []
                              |),
                              [ M.read (| top |); M.read (| n |) ]
                            |);
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ],
                                "sub",
                                [],
                                []
                              |),
                              [ M.read (| top |); M.read (| n_m_index |) ]
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |) in
                  M.alloc (| Value.Bool true |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_exchange :
        M.IsAssociatedFunction.C Self "exchange" exchange.
      Admitted.
      Global Typeclasses Opaque exchange.
      
      (*
          pub fn push_slice(&mut self, slice: &[u8]) -> Result<(), InstructionResult> {
              if slice.is_empty() {
                  return Ok(());
              }
      
              let n_words = (slice.len() + 31) / 32;
              let new_len = self.data.len() + n_words;
              if new_len > STACK_LIMIT {
                  return Err(InstructionResult::StackOverflow);
              }
      
              // SAFETY: Length checked above.
              unsafe {
                  let dst = self.data.as_mut_ptr().add(self.data.len()).cast::<u64>();
                  self.data.set_len(new_len);
      
                  let mut i = 0;
      
                  // Write full words
                  let words = slice.chunks_exact(32);
                  let partial_last_word = words.remainder();
                  for word in words {
                      // Note: We unroll `U256::from_be_bytes` here to write directly into the buffer,
                      // instead of creating a 32 byte array on the stack and then copying it over.
                      for l in word.rchunks_exact(8) {
                          dst.add(i).write(u64::from_be_bytes(l.try_into().unwrap()));
                          i += 1;
                      }
                  }
      
                  if partial_last_word.is_empty() {
                      return Ok(());
                  }
      
                  // Write limbs of partial last word
                  let limbs = partial_last_word.rchunks_exact(8);
                  let partial_last_limb = limbs.remainder();
                  for l in limbs {
                      dst.add(i).write(u64::from_be_bytes(l.try_into().unwrap()));
                      i += 1;
                  }
      
                  // Write partial last limb by padding with zeros
                  if !partial_last_limb.is_empty() {
                      let mut tmp = [0u8; 8];
                      tmp[8 - partial_last_limb.len()..].copy_from_slice(partial_last_limb);
                      dst.add(i).write(u64::from_be_bytes(tmp));
                      i += 1;
                  }
      
                  debug_assert_eq!((i + 3) / 4, n_words, "wrote too much");
      
                  // Zero out upper bytes of last word
                  let m = i % 4; // 32 / 8
                  if m != 0 {
                      dst.add(i).write_bytes(0, 4 - m);
                  }
              }
      
              Ok(())
          }
      *)
      Definition push_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; slice ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let slice := M.alloc (| slice |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "revm_interpreter::instruction_result::InstructionResult"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| slice |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      []
                                      [
                                        Ty.tuple [];
                                        Ty.path
                                          "revm_interpreter::instruction_result::InstructionResult"
                                      ]
                                      [ Value.Tuple [] ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ n_words : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.div,
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 31
                            ]
                          |);
                          Value.Integer IntegerKind.Usize 32
                        ]
                      |)
                    |) in
                  let~ new_len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    [];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "revm_interpreter::interpreter::stack::Stack",
                                  "data"
                                |)
                              |)
                            ]
                          |);
                          M.read (| n_words |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [
                                      M.read (| new_len |);
                                      M.read (|
                                        get_constant (|
                                          "revm_interpreter::interpreter::stack::STACK_LIMIT",
                                          Ty.path "usize"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Err"
                                      []
                                      [
                                        Ty.tuple [];
                                        Ty.path
                                          "revm_interpreter::instruction_result::InstructionResult"
                                      ]
                                      [
                                        Value.StructTuple
                                          "revm_interpreter::instruction_result::InstructionResult::StackOverflow"
                                          []
                                          []
                                          []
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    let~ dst :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  []
                              ],
                            "cast",
                            [],
                            [ Ty.path "u64" ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    []
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ],
                                "add",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        []
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          [];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "as_mut_ptr",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_interpreter::interpreter::stack::Stack",
                                        "data"
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          [];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_interpreter::interpreter::stack::Stack",
                                        "data"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  [];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "set_len",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "revm_interpreter::interpreter::stack::Stack",
                                "data"
                              |)
                            |);
                            M.read (| new_len |)
                          ]
                        |)
                      |) in
                    let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                    let~ words :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ Ty.path "u8" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                            "chunks_exact",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |);
                            Value.Integer IntegerKind.Usize 32
                          ]
                        |)
                      |) in
                    let~ partial_last_word :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ Ty.path "u8" ],
                            "remainder",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, words |) ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.use
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::slice::iter::ChunksExact")
                                []
                                [ Ty.path "u8" ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::slice::iter::ChunksExact")
                                  []
                                  [ Ty.path "u8" ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [ M.read (| words |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::ChunksExact")
                                                []
                                                [ Ty.path "u8" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let word := M.copy (| γ0_0 |) in
                                              M.use
                                                (M.match_operator (|
                                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::RChunksExact")
                                                        []
                                                        [ Ty.path "u8" ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::collect::IntoIterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::slice::iter::RChunksExact")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        [],
                                                        [],
                                                        "into_iter",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::slice::iter::RChunksExact")
                                                            []
                                                            [ Ty.path "u8" ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            "rchunks_exact",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| word |) |)
                                                            |);
                                                            Value.Integer IntegerKind.Usize 8
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let iter := M.copy (| γ |) in
                                                        M.loop (|
                                                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                          ltac:(M.monadic
                                                            (let~ _ :
                                                                Ty.apply
                                                                  (Ty.path "*")
                                                                  []
                                                                  [ Ty.tuple [] ] :=
                                                              M.match_operator (|
                                                                Ty.apply
                                                                  (Ty.path "*")
                                                                  []
                                                                  [ Ty.tuple [] ],
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "slice")
                                                                              []
                                                                              [ Ty.path "u8" ]
                                                                          ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::slice::iter::RChunksExact")
                                                                        []
                                                                        [ Ty.path "u8" ],
                                                                      [],
                                                                      [],
                                                                      "next",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            iter
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let _ :=
                                                                        M.is_struct_tuple (|
                                                                          γ,
                                                                          "core::option::Option::None"
                                                                        |) in
                                                                      M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (| M.break (||) |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ0_0 :=
                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                          γ,
                                                                          "core::option::Option::Some",
                                                                          0
                                                                        |) in
                                                                      let l := M.copy (| γ0_0 |) in
                                                                      let~ _ :
                                                                          Ty.apply
                                                                            (Ty.path "*")
                                                                            []
                                                                            [ Ty.tuple [] ] :=
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            Ty.tuple [],
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "*mut")
                                                                                []
                                                                                [ Ty.path "u64" ],
                                                                              "write",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                Ty.apply
                                                                                  (Ty.path "*mut")
                                                                                  []
                                                                                  [ Ty.path "u64" ],
                                                                                M.get_associated_function (|
                                                                                  Ty.apply
                                                                                    (Ty.path "*mut")
                                                                                    []
                                                                                    [ Ty.path "u64"
                                                                                    ],
                                                                                  "add",
                                                                                  [],
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.read (| dst |);
                                                                                  M.read (| i |)
                                                                                ]
                                                                              |);
                                                                              M.call_closure (|
                                                                                Ty.path "u64",
                                                                                M.get_associated_function (|
                                                                                  Ty.path "u64",
                                                                                  "from_be_bytes",
                                                                                  [],
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.call_closure (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "array")
                                                                                      [
                                                                                        Value.Integer
                                                                                          IntegerKind.Usize
                                                                                          8
                                                                                      ]
                                                                                      [ Ty.path "u8"
                                                                                      ],
                                                                                    M.get_associated_function (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "core::result::Result")
                                                                                        []
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "array")
                                                                                            [
                                                                                              Value.Integer
                                                                                                IntegerKind.Usize
                                                                                                8
                                                                                            ]
                                                                                            [
                                                                                              Ty.path
                                                                                                "u8"
                                                                                            ];
                                                                                          Ty.path
                                                                                            "core::array::TryFromSliceError"
                                                                                        ],
                                                                                      "unwrap",
                                                                                      [],
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.call_closure (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "core::result::Result")
                                                                                          []
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "array")
                                                                                              [
                                                                                                Value.Integer
                                                                                                  IntegerKind.Usize
                                                                                                  8
                                                                                              ]
                                                                                              [
                                                                                                Ty.path
                                                                                                  "u8"
                                                                                              ];
                                                                                            Ty.path
                                                                                              "core::array::TryFromSliceError"
                                                                                          ],
                                                                                        M.get_trait_method (|
                                                                                          "core::convert::TryInto",
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "&")
                                                                                            []
                                                                                            [
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "slice")
                                                                                                []
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "u8"
                                                                                                ]
                                                                                            ],
                                                                                          [],
                                                                                          [
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "array")
                                                                                              [
                                                                                                Value.Integer
                                                                                                  IntegerKind.Usize
                                                                                                  8
                                                                                              ]
                                                                                              [
                                                                                                Ty.path
                                                                                                  "u8"
                                                                                              ]
                                                                                          ],
                                                                                          "try_into",
                                                                                          [],
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                l
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |) in
                                                                      let~ _ :
                                                                          Ty.apply
                                                                            (Ty.path "*")
                                                                            []
                                                                            [ Ty.tuple [] ] :=
                                                                        M.alloc (|
                                                                          let β := i in
                                                                          M.write (|
                                                                            β,
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              BinOp.Wrap.add,
                                                                              [
                                                                                M.read (| β |);
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |) in
                                                                      M.alloc (| Value.Tuple [] |)))
                                                                ]
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)))
                                                        |)))
                                                  ]
                                                |))))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| partial_last_word |) |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::result::Result::Ok"
                                        []
                                        [
                                          Ty.tuple [];
                                          Ty.path
                                            "revm_interpreter::instruction_result::InstructionResult"
                                        ]
                                        [ Value.Tuple [] ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ limbs :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ Ty.path "u8" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::RChunksExact") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                            "rchunks_exact",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| partial_last_word |) |)
                            |);
                            Value.Integer IntegerKind.Usize 8
                          ]
                        |)
                      |) in
                    let~ partial_last_limb :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::slice::iter::RChunksExact")
                              []
                              [ Ty.path "u8" ],
                            "remainder",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, limbs |) ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.use
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::slice::iter::RChunksExact")
                                []
                                [ Ty.path "u8" ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::slice::iter::RChunksExact")
                                  []
                                  [ Ty.path "u8" ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [ M.read (| limbs |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::RChunksExact")
                                                []
                                                [ Ty.path "u8" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let l := M.copy (| γ0_0 |) in
                                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "*mut")
                                                        []
                                                        [ Ty.path "u64" ],
                                                      "write",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [ Ty.path "u64" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [ Ty.path "u64" ],
                                                          "add",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.read (| dst |); M.read (| i |) ]
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "u64",
                                                        M.get_associated_function (|
                                                          Ty.path "u64",
                                                          "from_be_bytes",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 8 ]
                                                              [ Ty.path "u8" ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        8
                                                                    ]
                                                                    [ Ty.path "u8" ];
                                                                  Ty.path
                                                                    "core::array::TryFromSliceError"
                                                                ],
                                                              "unwrap",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "array")
                                                                      [
                                                                        Value.Integer
                                                                          IntegerKind.Usize
                                                                          8
                                                                      ]
                                                                      [ Ty.path "u8" ];
                                                                    Ty.path
                                                                      "core::array::TryFromSliceError"
                                                                  ],
                                                                M.get_trait_method (|
                                                                  "core::convert::TryInto",
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Ty.path "u8" ]
                                                                    ],
                                                                  [],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "array")
                                                                      [
                                                                        Value.Integer
                                                                          IntegerKind.Usize
                                                                          8
                                                                      ]
                                                                      [ Ty.path "u8" ]
                                                                  ],
                                                                  "try_into",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| l |) |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.alloc (|
                                                  let β := i in
                                                  M.write (|
                                                    β,
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.add,
                                                      [
                                                        M.read (| β |);
                                                        Value.Integer IntegerKind.Usize 1
                                                      ]
                                                    |)
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "is_empty",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| partial_last_limb |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              let~ tmp :
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 8 ]
                                        [ Ty.path "u8" ]
                                    ] :=
                                M.alloc (|
                                  repeat (|
                                    Value.Integer IntegerKind.U8 0,
                                    Value.Integer IntegerKind.Usize 8
                                  |)
                                |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "copy_from_slice",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                            M.get_trait_method (|
                                              "core::ops::index::IndexMut",
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 8 ]
                                                [ Ty.path "u8" ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeFrom")
                                                  []
                                                  [ Ty.path "usize" ]
                                              ],
                                              "index_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (| Pointer.Kind.MutRef, tmp |);
                                              Value.StructRecord
                                                "core::ops::range::RangeFrom"
                                                []
                                                [ Ty.path "usize" ]
                                                [
                                                  ("start",
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.sub,
                                                      [
                                                        Value.Integer IntegerKind.Usize 8;
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            "len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.read (| partial_last_limb |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |))
                                                ]
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| partial_last_limb |) |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                                      "write",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                                          "add",
                                          [],
                                          []
                                        |),
                                        [ M.read (| dst |); M.read (| i |) ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.path "u64",
                                          "from_be_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| tmp |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  let β := i in
                                  M.write (|
                                    β,
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.add,
                                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Value.Bool true |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (|
                                    Value.Tuple
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.div,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.add,
                                                  [
                                                    M.read (| i |);
                                                    Value.Integer IntegerKind.Usize 3
                                                  ]
                                                |);
                                                Value.Integer IntegerKind.Usize 4
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (| Pointer.Kind.Ref, n_words |)
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val := M.copy (| γ0_0 |) in
                                        let right_val := M.copy (| γ0_1 |) in
                                        M.match_operator (|
                                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (|
                                                              M.deref (| M.read (| left_val |) |)
                                                            |);
                                                            M.read (|
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      let~ kind :
                                                          Ty.apply
                                                            (Ty.path "*")
                                                            []
                                                            [ Ty.path "core::panicking::AssertKind"
                                                            ] :=
                                                        M.alloc (|
                                                          Value.StructTuple
                                                            "core::panicking::AssertKind::Eq"
                                                            []
                                                            []
                                                            []
                                                        |) in
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "never",
                                                          M.get_function (|
                                                            "core::panicking::assert_failed",
                                                            [],
                                                            [ Ty.path "usize"; Ty.path "usize" ]
                                                          |),
                                                          [
                                                            M.read (| kind |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| left_val |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| right_val |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              []
                                                              [ Ty.path "core::fmt::Arguments" ]
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "core::fmt::Arguments",
                                                                  M.get_associated_function (|
                                                                    Ty.path "core::fmt::Arguments",
                                                                    "new_const",
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Value.Array
                                                                              [
                                                                                mk_str (|
                                                                                  "wrote too much"
                                                                                |)
                                                                              ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ m : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.rem,
                          [ M.read (| i |); Value.Integer IntegerKind.Usize 4 ]
                        |)
                      |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ne,
                                    [ M.read (| m |); Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.tuple [],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                                    "write_bytes",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u64" ],
                                        "add",
                                        [],
                                        []
                                      |),
                                      [ M.read (| dst |); M.read (| i |) ]
                                    |);
                                    Value.Integer IntegerKind.U8 0;
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.sub,
                                      [ Value.Integer IntegerKind.Usize 4; M.read (| m |) ]
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      []
                      [
                        Ty.tuple [];
                        Ty.path "revm_interpreter::instruction_result::InstructionResult"
                      ]
                      [ Value.Tuple [] ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push_slice :
        M.IsAssociatedFunction.C Self "push_slice" push_slice.
      Admitted.
      Global Typeclasses Opaque push_slice.
      
      (*
          pub fn set(&mut self, no_from_top: usize, val: U256) -> Result<(), InstructionResult> {
              if self.data.len() > no_from_top {
                  let len = self.data.len();
                  self.data[len - no_from_top - 1] = val;
                  Ok(())
              } else {
                  Err(InstructionResult::StackUnderflow)
              }
          }
      *)
      Definition set (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; no_from_top; val ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let no_from_top := M.alloc (| no_from_top |) in
            let val := M.alloc (| val |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.tuple [];
                        Ty.path "revm_interpreter::instruction_result::InstructionResult"
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "ruint::Uint")
                                          [
                                            Value.Integer IntegerKind.Usize 256;
                                            Value.Integer IntegerKind.Usize 4
                                          ]
                                          [];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "revm_interpreter::interpreter::stack::Stack",
                                        "data"
                                      |)
                                    |)
                                  ]
                                |);
                                M.read (| no_from_top |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 256;
                                      Value.Integer IntegerKind.Usize 4
                                    ]
                                    [];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "len",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "revm_interpreter::interpreter::stack::Stack",
                                  "data"
                                |)
                              |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.alloc (|
                          M.write (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      []
                                  ],
                                M.get_trait_method (|
                                  "core::ops::index::IndexMut",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "ruint::Uint")
                                        [
                                          Value.Integer IntegerKind.Usize 256;
                                          Value.Integer IntegerKind.Usize 4
                                        ]
                                        [];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [ Ty.path "usize" ],
                                  "index_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "revm_interpreter::interpreter::stack::Stack",
                                      "data"
                                    |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.sub,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.sub,
                                        [ M.read (| len |); M.read (| no_from_top |) ]
                                      |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            M.read (| val |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.tuple [];
                            Ty.path "revm_interpreter::instruction_result::InstructionResult"
                          ]
                          [ Value.Tuple [] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.tuple [];
                            Ty.path "revm_interpreter::instruction_result::InstructionResult"
                          ]
                          [
                            Value.StructTuple
                              "revm_interpreter::instruction_result::InstructionResult::StackUnderflow"
                              []
                              []
                              []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_set : M.IsAssociatedFunction.C Self "set" set.
      Admitted.
      Global Typeclasses Opaque set.
    End Impl_revm_interpreter_interpreter_stack_Stack.
  End stack.
End interpreter.
