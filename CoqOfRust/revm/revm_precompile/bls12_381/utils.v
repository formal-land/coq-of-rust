(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bls12_381.
  Module utils.
    Definition value_NBITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 256 |))).
    
    Global Instance Instance_IsConstant_value_NBITS :
      M.IsFunction.C "revm_precompile::bls12_381::utils::NBITS" value_NBITS.
    Admitted.
    Global Typeclasses Opaque value_NBITS.
    
    Definition value_FP_LENGTH (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 48 |))).
    
    Global Instance Instance_IsConstant_value_FP_LENGTH :
      M.IsFunction.C "revm_precompile::bls12_381::utils::FP_LENGTH" value_FP_LENGTH.
    Admitted.
    Global Typeclasses Opaque value_FP_LENGTH.
    
    Definition value_PADDED_FP_LENGTH (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 64 |))).
    
    Global Instance Instance_IsConstant_value_PADDED_FP_LENGTH :
      M.IsFunction.C "revm_precompile::bls12_381::utils::PADDED_FP_LENGTH" value_PADDED_FP_LENGTH.
    Admitted.
    Global Typeclasses Opaque value_PADDED_FP_LENGTH.
    
    Definition value_PADDED_FP2_LENGTH (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 128 |))).
    
    Global Instance Instance_IsConstant_value_PADDED_FP2_LENGTH :
      M.IsFunction.C "revm_precompile::bls12_381::utils::PADDED_FP2_LENGTH" value_PADDED_FP2_LENGTH.
    Admitted.
    Global Typeclasses Opaque value_PADDED_FP2_LENGTH.
    
    Definition value_PADDING_LENGTH (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 16 |))).
    
    Global Instance Instance_IsConstant_value_PADDING_LENGTH :
      M.IsFunction.C "revm_precompile::bls12_381::utils::PADDING_LENGTH" value_PADDING_LENGTH.
    Admitted.
    Global Typeclasses Opaque value_PADDING_LENGTH.
    
    Definition value_SCALAR_LENGTH (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 32 |))).
    
    Global Instance Instance_IsConstant_value_SCALAR_LENGTH :
      M.IsFunction.C "revm_precompile::bls12_381::utils::SCALAR_LENGTH" value_SCALAR_LENGTH.
    Admitted.
    Global Typeclasses Opaque value_SCALAR_LENGTH.
    
    Definition value_MODULUS_REPR (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 48 ] [ Ty.path "u8" ],
          Value.Array
            [
              Value.Integer IntegerKind.U8 26;
              Value.Integer IntegerKind.U8 1;
              Value.Integer IntegerKind.U8 17;
              Value.Integer IntegerKind.U8 234;
              Value.Integer IntegerKind.U8 57;
              Value.Integer IntegerKind.U8 127;
              Value.Integer IntegerKind.U8 230;
              Value.Integer IntegerKind.U8 154;
              Value.Integer IntegerKind.U8 75;
              Value.Integer IntegerKind.U8 27;
              Value.Integer IntegerKind.U8 167;
              Value.Integer IntegerKind.U8 182;
              Value.Integer IntegerKind.U8 67;
              Value.Integer IntegerKind.U8 75;
              Value.Integer IntegerKind.U8 172;
              Value.Integer IntegerKind.U8 215;
              Value.Integer IntegerKind.U8 100;
              Value.Integer IntegerKind.U8 119;
              Value.Integer IntegerKind.U8 75;
              Value.Integer IntegerKind.U8 132;
              Value.Integer IntegerKind.U8 243;
              Value.Integer IntegerKind.U8 133;
              Value.Integer IntegerKind.U8 18;
              Value.Integer IntegerKind.U8 191;
              Value.Integer IntegerKind.U8 103;
              Value.Integer IntegerKind.U8 48;
              Value.Integer IntegerKind.U8 210;
              Value.Integer IntegerKind.U8 160;
              Value.Integer IntegerKind.U8 246;
              Value.Integer IntegerKind.U8 176;
              Value.Integer IntegerKind.U8 246;
              Value.Integer IntegerKind.U8 36;
              Value.Integer IntegerKind.U8 30;
              Value.Integer IntegerKind.U8 171;
              Value.Integer IntegerKind.U8 255;
              Value.Integer IntegerKind.U8 254;
              Value.Integer IntegerKind.U8 177;
              Value.Integer IntegerKind.U8 83;
              Value.Integer IntegerKind.U8 255;
              Value.Integer IntegerKind.U8 255;
              Value.Integer IntegerKind.U8 185;
              Value.Integer IntegerKind.U8 254;
              Value.Integer IntegerKind.U8 255;
              Value.Integer IntegerKind.U8 255;
              Value.Integer IntegerKind.U8 255;
              Value.Integer IntegerKind.U8 255;
              Value.Integer IntegerKind.U8 170;
              Value.Integer IntegerKind.U8 171
            ]
        |))).
    
    Global Instance Instance_IsConstant_value_MODULUS_REPR :
      M.IsFunction.C "revm_precompile::bls12_381::utils::MODULUS_REPR" value_MODULUS_REPR.
    Admitted.
    Global Typeclasses Opaque value_MODULUS_REPR.
    
    (*
    pub(super) fn fp_to_bytes(out: &mut [u8], input: *const blst_fp) {
        if out.len() != PADDED_FP_LENGTH {
            return;
        }
        let (padding, rest) = out.split_at_mut(PADDING_LENGTH);
        padding.fill(0);
        // SAFETY: Out length is checked previously, `input` is a blst value.
        unsafe { blst_bendian_from_fp(rest.as_mut_ptr(), input) };
    }
    *)
    Definition fp_to_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ out; input ] =>
        ltac:(M.monadic
          (let out :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              out
            |) in
          let input :=
            M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.path "blst::blst_fp" ], input |) in
          M.catch_return (Ty.tuple []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ne,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| out |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "revm_precompile::bls12_381::utils::PADDED_FP_LENGTH",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ],
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "split_at_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| out |) |) |);
                          M.read (|
                            get_constant (|
                              "revm_precompile::bls12_381::utils::PADDING_LENGTH",
                              Ty.path "usize"
                            |)
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let padding :=
                            M.copy (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              γ0_0
                            |) in
                          let rest :=
                            M.copy (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              γ0_1
                            |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "fill",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| padding |) |)
                                  |);
                                  Value.Integer IntegerKind.U8 0
                                ]
                              |) in
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_function (| "blst::blst_bendian_from_fp", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "as_mut_ptr",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| rest |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| input |)
                                ]
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)))
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_fp_to_bytes :
      M.IsFunction.C "revm_precompile::bls12_381::utils::fp_to_bytes" fp_to_bytes.
    Admitted.
    Global Typeclasses Opaque fp_to_bytes.
    
    (*
    pub(super) fn remove_padding(input: &[u8]) -> Result<&[u8; FP_LENGTH], PrecompileError> {
        if input.len() != PADDED_FP_LENGTH {
            return Err(PrecompileError::Other(format!(
                "Padded input should be {PADDED_FP_LENGTH} bytes, was {}",
                input.len()
            )));
        }
        let (padding, unpadded) = input.split_at(PADDING_LENGTH);
        if !padding.iter().all(|&x| x == 0) {
            return Err(PrecompileError::Other(format!(
                "{PADDING_LENGTH} top bytes of input are not zero",
            )));
        }
        Ok(unpadded.try_into().unwrap())
    }
    *)
    Definition remove_padding (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ input ] =>
        ltac:(M.monadic
          (let input :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              input
            |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [
                        M.unevaluated_const
                          (mk_str (|
                            "revm_precompile_bls12_381_utils_remove_padding_discriminant"
                          |))
                      ]
                      [ Ty.path "u8" ]
                  ];
                Ty.path "revm_precompile::interface::PrecompileError"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ne,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| input |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "revm_precompile::bls12_381::utils::PADDED_FP_LENGTH",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 48 ]
                                          [ Ty.path "u8" ]
                                      ];
                                    Ty.path "revm_precompile::interface::PrecompileError"
                                  ]
                                  [
                                    Value.StructTuple
                                      "revm_precompile::interface::PrecompileError::Other"
                                      []
                                      []
                                      [
                                        M.call_closure (|
                                          Ty.path "alloc::string::String",
                                          M.get_function (|
                                            "core::hint::must_use",
                                            [],
                                            [ Ty.path "alloc::string::String" ]
                                          |),
                                          [
                                            M.read (|
                                              let~ res : Ty.path "alloc::string::String" :=
                                                M.call_closure (|
                                                  Ty.path "alloc::string::String",
                                                  M.get_function (| "alloc::fmt::format", [], [] |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::Arguments",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1",
                                                        [
                                                          Value.Integer IntegerKind.Usize 2;
                                                          Value.Integer IntegerKind.Usize 2
                                                        ],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      2
                                                                  ]
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [ Ty.path "str" ]
                                                                  ],
                                                                Value.Array
                                                                  [
                                                                    mk_str (|
                                                                      "Padded input should be "
                                                                    |);
                                                                    mk_str (| " bytes, was " |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      2
                                                                  ]
                                                                  [
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument"
                                                                  ],
                                                                M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        2
                                                                    ]
                                                                    [
                                                                      Ty.path
                                                                        "core::fmt::rt::Argument"
                                                                    ],
                                                                  M.alloc (|
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "usize" ];
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "usize" ]
                                                                      ],
                                                                    Value.Tuple
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "usize",
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u8" ],
                                                                                "len",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      input
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |);
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          get_constant (|
                                                                            "revm_precompile::bls12_381::utils::PADDED_FP_LENGTH",
                                                                            Ty.path "usize"
                                                                          |)
                                                                        |)
                                                                      ]
                                                                  |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let args :=
                                                                          M.copy (|
                                                                            Ty.tuple
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ Ty.path "usize"
                                                                                  ];
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ Ty.path "usize"
                                                                                  ]
                                                                              ],
                                                                            γ
                                                                          |) in
                                                                        Value.Array
                                                                          [
                                                                            M.call_closure (|
                                                                              Ty.path
                                                                                "core::fmt::rt::Argument",
                                                                              M.get_associated_function (|
                                                                                Ty.path
                                                                                  "core::fmt::rt::Argument",
                                                                                "new_display",
                                                                                [],
                                                                                [ Ty.path "usize" ]
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      M.SubPointer.get_tuple_field (|
                                                                                        args,
                                                                                        1
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |);
                                                                            M.call_closure (|
                                                                              Ty.path
                                                                                "core::fmt::rt::Argument",
                                                                              M.get_associated_function (|
                                                                                Ty.path
                                                                                  "core::fmt::rt::Argument",
                                                                                "new_display",
                                                                                [],
                                                                                [ Ty.path "usize" ]
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      M.SubPointer.get_tuple_field (|
                                                                                        args,
                                                                                        0
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          ]))
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |) in
                                              res
                                            |)
                                          ]
                                        |)
                                      ]
                                  ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 48 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "revm_precompile::interface::PrecompileError"
                    ],
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 48 ]
                              [ Ty.path "u8" ]
                          ];
                        Ty.path "revm_precompile::interface::PrecompileError"
                      ],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ],
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "split_at",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input |) |) |);
                          M.read (|
                            get_constant (|
                              "revm_precompile::bls12_381::utils::PADDING_LENGTH",
                              Ty.path "usize"
                            |)
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let padding :=
                            M.copy (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              γ0_0
                            |) in
                          let unpadded :=
                            M.copy (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              γ0_1
                            |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            Ty.path "bool",
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u8" ],
                                                  [],
                                                  [],
                                                  "all",
                                                  [],
                                                  [
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [ Ty.path "u8" ]
                                                          ]
                                                      ]
                                                      (Ty.path "bool")
                                                  ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.alloc (|
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        []
                                                        [ Ty.path "u8" ],
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            []
                                                            [ Ty.path "u8" ],
                                                          "iter",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| padding |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |);
                                                  M.closure
                                                    (fun γ =>
                                                      ltac:(M.monadic
                                                        match γ with
                                                        | [ α0 ] =>
                                                          ltac:(M.monadic
                                                            (M.match_operator (|
                                                              Ty.function
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ Ty.path "u8" ]
                                                                    ]
                                                                ]
                                                                (Ty.path "bool"),
                                                              M.alloc (|
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                α0
                                                              |),
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let γ := M.read (| γ |) in
                                                                    let x :=
                                                                      M.copy (|
                                                                        Ty.path "u8",
                                                                        γ
                                                                      |) in
                                                                    M.call_closure (|
                                                                      Ty.path "bool",
                                                                      BinOp.eq,
                                                                      [
                                                                        M.read (| x |);
                                                                        Value.Integer
                                                                          IntegerKind.U8
                                                                          0
                                                                      ]
                                                                    |)))
                                                              ]
                                                            |)))
                                                        | _ =>
                                                          M.impossible "wrong number of arguments"
                                                        end))
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::result::Result::Err"
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "array")
                                                      [ Value.Integer IntegerKind.Usize 48 ]
                                                      [ Ty.path "u8" ]
                                                  ];
                                                Ty.path
                                                  "revm_precompile::interface::PrecompileError"
                                              ]
                                              [
                                                Value.StructTuple
                                                  "revm_precompile::interface::PrecompileError::Other"
                                                  []
                                                  []
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "alloc::string::String",
                                                      M.get_function (|
                                                        "core::hint::must_use",
                                                        [],
                                                        [ Ty.path "alloc::string::String" ]
                                                      |),
                                                      [
                                                        M.read (|
                                                          let~ res :
                                                              Ty.path "alloc::string::String" :=
                                                            M.call_closure (|
                                                              Ty.path "alloc::string::String",
                                                              M.get_function (|
                                                                "alloc::fmt::format",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "core::fmt::Arguments",
                                                                  M.get_associated_function (|
                                                                    Ty.path "core::fmt::Arguments",
                                                                    "new_v1",
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        2;
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.apply
                                                                              (Ty.path "array")
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  2
                                                                              ]
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ Ty.path "str" ]
                                                                              ],
                                                                            Value.Array
                                                                              [
                                                                                mk_str (| "" |);
                                                                                mk_str (|
                                                                                  " top bytes of input are not zero"
                                                                                |)
                                                                              ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.apply
                                                                              (Ty.path "array")
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ]
                                                                              [
                                                                                Ty.path
                                                                                  "core::fmt::rt::Argument"
                                                                              ],
                                                                            Value.Array
                                                                              [
                                                                                M.call_closure (|
                                                                                  Ty.path
                                                                                    "core::fmt::rt::Argument",
                                                                                  M.get_associated_function (|
                                                                                    Ty.path
                                                                                      "core::fmt::rt::Argument",
                                                                                    "new_display",
                                                                                    [],
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.deref (|
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          get_constant (|
                                                                                            "revm_precompile::bls12_381::utils::PADDING_LENGTH",
                                                                                            Ty.path
                                                                                              "usize"
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |) in
                                                          res
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                              ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (Value.Tuple []))
                                ]
                              |) in
                            M.alloc (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 48 ]
                                        [ Ty.path "u8" ]
                                    ];
                                  Ty.path "revm_precompile::interface::PrecompileError"
                                ],
                              Value.StructTuple
                                "core::result::Result::Ok"
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 48 ]
                                        [ Ty.path "u8" ]
                                    ];
                                  Ty.path "revm_precompile::interface::PrecompileError"
                                ]
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 48 ]
                                          [ Ty.path "u8" ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 48 ]
                                                [ Ty.path "u8" ]
                                            ];
                                          Ty.path "core::array::TryFromSliceError"
                                        ],
                                      "unwrap",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 48 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.path "core::array::TryFromSliceError"
                                          ],
                                        M.get_trait_method (|
                                          "core::convert::TryInto",
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 48 ]
                                                  [ Ty.path "u8" ]
                                              ]
                                          ],
                                          "try_into",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| unpadded |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)))
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_remove_padding :
      M.IsFunction.C "revm_precompile::bls12_381::utils::remove_padding" remove_padding.
    Admitted.
    Global Typeclasses Opaque remove_padding.
    
    (*
    pub(super) fn extract_scalar_input(input: &[u8]) -> Result<blst_scalar, PrecompileError> {
        if input.len() != SCALAR_LENGTH {
            return Err(PrecompileError::Other(format!(
                "Input should be {SCALAR_LENGTH} bytes, was {}",
                input.len()
            )));
        }
    
        let mut out = blst_scalar::default();
        // SAFETY: `input` length is checked previously, out is a blst value.
        unsafe {
            // Note: We do not use `blst_scalar_fr_check` here because, from EIP-2537:
            //
            // * The corresponding integer is not required to be less than or equal than main subgroup
            // order `q`.
            blst_scalar_from_bendian(&mut out, input.as_ptr())
        };
    
        Ok(out)
    }
    *)
    Definition extract_scalar_input (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ input ] =>
        ltac:(M.monadic
          (let input :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              input
            |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "blst::blst_scalar"; Ty.path "revm_precompile::interface::PrecompileError"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ne,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| input |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "revm_precompile::bls12_381::utils::SCALAR_LENGTH",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  []
                                  [
                                    Ty.path "blst::blst_scalar";
                                    Ty.path "revm_precompile::interface::PrecompileError"
                                  ]
                                  [
                                    Value.StructTuple
                                      "revm_precompile::interface::PrecompileError::Other"
                                      []
                                      []
                                      [
                                        M.call_closure (|
                                          Ty.path "alloc::string::String",
                                          M.get_function (|
                                            "core::hint::must_use",
                                            [],
                                            [ Ty.path "alloc::string::String" ]
                                          |),
                                          [
                                            M.read (|
                                              let~ res : Ty.path "alloc::string::String" :=
                                                M.call_closure (|
                                                  Ty.path "alloc::string::String",
                                                  M.get_function (| "alloc::fmt::format", [], [] |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::Arguments",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1",
                                                        [
                                                          Value.Integer IntegerKind.Usize 2;
                                                          Value.Integer IntegerKind.Usize 2
                                                        ],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      2
                                                                  ]
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [ Ty.path "str" ]
                                                                  ],
                                                                Value.Array
                                                                  [
                                                                    mk_str (| "Input should be " |);
                                                                    mk_str (| " bytes, was " |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      2
                                                                  ]
                                                                  [
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument"
                                                                  ],
                                                                M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        2
                                                                    ]
                                                                    [
                                                                      Ty.path
                                                                        "core::fmt::rt::Argument"
                                                                    ],
                                                                  M.alloc (|
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "usize" ];
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "usize" ]
                                                                      ],
                                                                    Value.Tuple
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "usize",
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u8" ],
                                                                                "len",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      input
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |);
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          get_constant (|
                                                                            "revm_precompile::bls12_381::utils::SCALAR_LENGTH",
                                                                            Ty.path "usize"
                                                                          |)
                                                                        |)
                                                                      ]
                                                                  |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let args :=
                                                                          M.copy (|
                                                                            Ty.tuple
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ Ty.path "usize"
                                                                                  ];
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ Ty.path "usize"
                                                                                  ]
                                                                              ],
                                                                            γ
                                                                          |) in
                                                                        Value.Array
                                                                          [
                                                                            M.call_closure (|
                                                                              Ty.path
                                                                                "core::fmt::rt::Argument",
                                                                              M.get_associated_function (|
                                                                                Ty.path
                                                                                  "core::fmt::rt::Argument",
                                                                                "new_display",
                                                                                [],
                                                                                [ Ty.path "usize" ]
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      M.SubPointer.get_tuple_field (|
                                                                                        args,
                                                                                        1
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |);
                                                                            M.call_closure (|
                                                                              Ty.path
                                                                                "core::fmt::rt::Argument",
                                                                              M.get_associated_function (|
                                                                                Ty.path
                                                                                  "core::fmt::rt::Argument",
                                                                                "new_display",
                                                                                [],
                                                                                [ Ty.path "usize" ]
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      M.SubPointer.get_tuple_field (|
                                                                                        args,
                                                                                        0
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          ]))
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |) in
                                              res
                                            |)
                                          ]
                                        |)
                                      ]
                                  ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ out : Ty.path "blst::blst_scalar" :=
                  M.call_closure (|
                    Ty.path "blst::blst_scalar",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "blst::blst_scalar",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "blst::blst_scalar_from_bendian", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutPointer,
                        M.deref (| M.borrow (| Pointer.Kind.MutRef, out |) |)
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input |) |) |) ]
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "blst::blst_scalar";
                      Ty.path "revm_precompile::interface::PrecompileError"
                    ],
                  Value.StructTuple
                    "core::result::Result::Ok"
                    []
                    [
                      Ty.path "blst::blst_scalar";
                      Ty.path "revm_precompile::interface::PrecompileError"
                    ]
                    [ M.read (| out |) ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_extract_scalar_input :
      M.IsFunction.C "revm_precompile::bls12_381::utils::extract_scalar_input" extract_scalar_input.
    Admitted.
    Global Typeclasses Opaque extract_scalar_input.
    
    (*
    fn is_valid_be(input: &[u8; 48]) -> bool {
        for (i, modulo) in input.iter().zip(MODULUS_REPR.iter()) {
            match i.cmp(modulo) {
                Ordering::Greater => return false,
                Ordering::Less => return true,
                Ordering::Equal => continue,
            }
        }
        // Return false if matching the modulus
        false
    }
    *)
    Definition is_valid_be (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ input ] =>
        ltac:(M.monadic
          (let input :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 48 ] [ Ty.path "u8" ]
                ],
              input
            |) in
          M.catch_return (Ty.path "bool") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.use
                      (M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ];
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                              ],
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ];
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u8" ];
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                                  ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [ Ty.path "u8" ];
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [ Ty.path "u8" ]
                                    ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u8" ],
                                    [],
                                    [],
                                    "zip",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [ Ty.path "u8" ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [ Ty.path "u8" ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "iter",
                                        [],
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| input |) |)
                                          |))
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [ Ty.path "u8" ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "iter",
                                        [],
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.borrow (|
                                            Pointer.Kind.Ref,
                                            get_constant (|
                                              "revm_precompile::bls12_381::utils::MODULUS_REPR",
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 48 ]
                                                [ Ty.path "u8" ]
                                            |)
                                          |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [ Ty.path "u8" ];
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [ Ty.path "u8" ]
                                      ],
                                    γ
                                  |) in
                                M.read (|
                                  M.loop (|
                                    Ty.tuple [],
                                    ltac:(M.monadic
                                      (let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u8" ];
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                                  ]
                                              ],
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u8" ];
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                                    ]
                                                ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::zip::Zip")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [ Ty.path "u8" ];
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [ Ty.path "u8" ]
                                                  ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.MutRef, iter |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.never_to_any (| M.read (| M.break (||) |) |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let γ1_0 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                                let γ1_1 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                                let i :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                                    γ1_0
                                                  |) in
                                                let modulo :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                                    γ1_1
                                                  |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (|
                                                    Ty.path "core::cmp::Ordering",
                                                    M.call_closure (|
                                                      Ty.path "core::cmp::Ordering",
                                                      M.get_trait_method (|
                                                        "core::cmp::Ord",
                                                        Ty.path "u8",
                                                        [],
                                                        [],
                                                        "cmp",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| i |) |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| modulo |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let _ :=
                                                          M.is_struct_tuple (|
                                                            γ,
                                                            "core::cmp::Ordering::Greater"
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (| Value.Bool false |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let _ :=
                                                          M.is_struct_tuple (|
                                                            γ,
                                                            "core::cmp::Ordering::Less"
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (| Value.Bool true |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let _ :=
                                                          M.is_struct_tuple (|
                                                            γ,
                                                            "core::cmp::Ordering::Equal"
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (| M.continue (||) |)
                                                        |)))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                  |)
                                |)))
                          ]
                        |)
                      |))
                  |) in
                M.alloc (| Ty.path "bool", Value.Bool false |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_is_valid_be :
      M.IsFunction.C "revm_precompile::bls12_381::utils::is_valid_be" is_valid_be.
    Admitted.
    Global Typeclasses Opaque is_valid_be.
    
    (*
    pub(super) fn fp_from_bendian(input: &[u8; 48]) -> Result<blst_fp, PrecompileError> {
        if !is_valid_be(input) {
            return Err(PrecompileError::Other("non-canonical fp value".to_string()));
        }
        let mut fp = blst_fp::default();
        // SAFETY: `input` has fixed length, and `fp` is a blst value.
        unsafe {
            // This performs the check for canonical field elements
            blst_fp_from_bendian(&mut fp, input.as_ptr());
        }
    
        Ok(fp)
    }
    *)
    Definition fp_from_bendian (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ input ] =>
        ltac:(M.monadic
          (let input :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 48 ] [ Ty.path "u8" ]
                ],
              input
            |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "blst::blst_fp"; Ty.path "revm_precompile::interface::PrecompileError" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "revm_precompile::bls12_381::utils::is_valid_be",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| input |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  []
                                  [
                                    Ty.path "blst::blst_fp";
                                    Ty.path "revm_precompile::interface::PrecompileError"
                                  ]
                                  [
                                    Value.StructTuple
                                      "revm_precompile::interface::PrecompileError::Other"
                                      []
                                      []
                                      [
                                        M.call_closure (|
                                          Ty.path "alloc::string::String",
                                          M.get_trait_method (|
                                            "alloc::string::ToString",
                                            Ty.path "str",
                                            [],
                                            [],
                                            "to_string",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| mk_str (| "non-canonical fp value" |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ fp : Ty.path "blst::blst_fp" :=
                  M.call_closure (|
                    Ty.path "blst::blst_fp",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "blst::blst_fp",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "blst::blst_fp_from_bendian", [], [] |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutPointer,
                            M.deref (| M.borrow (| Pointer.Kind.MutRef, fp |) |)
                          |);
                          M.call_closure (|
                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input |) |) |))
                            ]
                          |)
                        ]
                      |) in
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "blst::blst_fp"; Ty.path "revm_precompile::interface::PrecompileError"
                    ],
                  Value.StructTuple
                    "core::result::Result::Ok"
                    []
                    [ Ty.path "blst::blst_fp"; Ty.path "revm_precompile::interface::PrecompileError"
                    ]
                    [ M.read (| fp |) ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_fp_from_bendian :
      M.IsFunction.C "revm_precompile::bls12_381::utils::fp_from_bendian" fp_from_bendian.
    Admitted.
    Global Typeclasses Opaque fp_from_bendian.
  End utils.
End bls12_381.
