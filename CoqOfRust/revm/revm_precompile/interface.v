(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module interface.
  Axiom PrecompileResult :
    (Ty.path "revm_precompile::interface::PrecompileResult") =
      (Ty.apply
        (Ty.path "core::result::Result")
        []
        [
          Ty.path "revm_precompile::interface::PrecompileOutput";
          Ty.path "revm_precompile::interface::PrecompileErrors"
        ]).
  
  (* StructRecord
    {
      name := "PrecompileOutput";
      const_params := [];
      ty_params := [];
      fields :=
        [ ("gas_used", Ty.path "u64"); ("bytes", Ty.path "alloy_primitives::bytes_::Bytes") ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_precompile_interface_PrecompileOutput.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileOutput".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "revm_precompile::interface::PrecompileOutput"
            [
              ("gas_used",
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "u64",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_precompile::interface::PrecompileOutput",
                            "gas_used"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("bytes",
                M.call_closure (|
                  Ty.path "alloy_primitives::bytes_::Bytes",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloy_primitives::bytes_::Bytes",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_precompile::interface::PrecompileOutput",
                            "bytes"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_precompile_interface_PrecompileOutput.
  
  Module Impl_core_fmt_Debug_for_revm_precompile_interface_PrecompileOutput.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileOutput".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "PrecompileOutput" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "gas_used" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_precompile::interface::PrecompileOutput",
                      "gas_used"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "bytes" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_precompile::interface::PrecompileOutput",
                          "bytes"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_precompile_interface_PrecompileOutput.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_precompile_interface_PrecompileOutput.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileOutput".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_precompile_interface_PrecompileOutput.
  
  Module Impl_core_cmp_PartialEq_revm_precompile_interface_PrecompileOutput_for_revm_precompile_interface_PrecompileOutput.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileOutput".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            BinOp.eq (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_precompile::interface::PrecompileOutput",
                  "gas_used"
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| other |) |),
                  "revm_precompile::interface::PrecompileOutput",
                  "gas_used"
                |)
              |)
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "alloy_primitives::bytes_::Bytes",
                  [],
                  [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_precompile::interface::PrecompileOutput",
                      "bytes"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_precompile::interface::PrecompileOutput",
                      "bytes"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_precompile::interface::PrecompileOutput" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_precompile_interface_PrecompileOutput_for_revm_precompile_interface_PrecompileOutput.
  
  Module Impl_core_cmp_Eq_for_revm_precompile_interface_PrecompileOutput.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileOutput".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_precompile_interface_PrecompileOutput.
  
  Module Impl_core_hash_Hash_for_revm_precompile_interface_PrecompileOutput.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileOutput".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u64",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_precompile::interface::PrecompileOutput",
                            "gas_used"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "alloy_primitives::bytes_::Bytes",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_precompile::interface::PrecompileOutput",
                          "bytes"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_precompile_interface_PrecompileOutput.
  
  Module Impl_revm_precompile_interface_PrecompileOutput.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileOutput".
    
    (*
        pub fn new(gas_used: u64, bytes: Bytes) -> Self {
            Self { gas_used, bytes }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ gas_used; bytes ] =>
        ltac:(M.monadic
          (let gas_used := M.alloc (| gas_used |) in
          let bytes := M.alloc (| bytes |) in
          Value.StructRecord
            "revm_precompile::interface::PrecompileOutput"
            [ ("gas_used", M.read (| gas_used |)); ("bytes", M.read (| bytes |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_revm_precompile_interface_PrecompileOutput.
  
  Axiom PrecompileFn :
    (Ty.path "revm_precompile::interface::PrecompileFn") =
      (Ty.function
        [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ]; Ty.path "u64" ]
        (Ty.apply
          (Ty.path "core::result::Result")
          []
          [
            Ty.path "revm_precompile::interface::PrecompileOutput";
            Ty.path "revm_precompile::interface::PrecompileErrors"
          ])).
  
  (*
  Enum PrecompileErrors
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Error";
          item := StructTuple [ Ty.path "revm_precompile::interface::PrecompileError" ];
        };
        {
          name := "Fatal";
          item := StructRecord [ ("msg", Ty.path "alloc::string::String") ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_PrecompileErrors_Error :
    M.IsDiscriminant "revm_precompile::interface::PrecompileErrors::Error" 0.
  Axiom IsDiscriminant_PrecompileErrors_Fatal :
    M.IsDiscriminant "revm_precompile::interface::PrecompileErrors::Fatal" 1.
  
  Module Impl_core_clone_Clone_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "revm_precompile::interface::PrecompileErrors"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Error",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileErrors::Error"
                        [
                          M.call_closure (|
                            Ty.path "revm_precompile::interface::PrecompileError",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "revm_precompile::interface::PrecompileError",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Fatal",
                        "msg"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_precompile::interface::PrecompileErrors::Fatal"
                        [
                          ("msg",
                            M.call_closure (|
                              Ty.path "alloc::string::String",
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "alloc::string::String",
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |)
                              ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_fmt_Debug_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Error",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Error" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Fatal",
                        "msg"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Fatal" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "msg" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_cmp_PartialEq_revm_precompile_interface_PrecompileErrors_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_precompile::interface::PrecompileErrors" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_precompile::interface::PrecompileErrors" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_precompile::interface::PrecompileErrors::Error",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_precompile::interface::PrecompileErrors::Error",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "revm_precompile::interface::PrecompileError" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "revm_precompile::interface::PrecompileError" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_precompile::interface::PrecompileErrors::Fatal",
                                "msg"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_precompile::interface::PrecompileErrors::Fatal",
                                "msg"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::intrinsics::unreachable", [], [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_precompile::interface::PrecompileErrors" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_precompile_interface_PrecompileErrors_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_cmp_Eq_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_hash_Hash_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_precompile::interface::PrecompileErrors" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Error",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_precompile::interface::PrecompileError",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Fatal",
                        "msg"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloc::string::String",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_convert_From_revm_precompile_interface_PrecompileErrors_for_revm_context_interface_result_EVMError_DB_TXERROR.
    Definition Self (DB TXERROR : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::EVMError") [] [ DB; TXERROR ].
    
    (*
        fn from(value: PrecompileErrors) -> Self {
            Self::Precompile(value.to_string())
        }
    *)
    Definition from (DB TXERROR : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DB TXERROR in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Precompile"
            [
              M.call_closure (|
                Ty.path "alloc::string::String",
                M.get_trait_method (|
                  "alloc::string::ToString",
                  Ty.path "revm_precompile::interface::PrecompileErrors",
                  [],
                  [],
                  "to_string",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, value |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DB TXERROR : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_precompile::interface::PrecompileErrors" ]
        (Self DB TXERROR)
        (* Instance *) [ ("from", InstanceField.Method (from DB TXERROR)) ].
  End Impl_core_convert_From_revm_precompile_interface_PrecompileErrors_for_revm_context_interface_result_EVMError_DB_TXERROR.
  
  Module Impl_core_error_Error_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_fmt_Display_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Error(e) => e.fmt(f),
                Self::Fatal { msg } => f.write_str(msg),
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Error",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_trait_method (|
                          "core::fmt::Display",
                          Ty.path "revm_precompile::interface::PrecompileError",
                          [],
                          [],
                          "fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| e |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_precompile::interface::PrecompileErrors::Fatal",
                        "msg"
                      |) in
                    let msg := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "alloc::string::String",
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| msg |) |) |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_precompile_interface_PrecompileErrors.
  
  (*
  Enum PrecompileError
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "OutOfGas";
          item := StructTuple [];
        };
        {
          name := "Blake2WrongLength";
          item := StructTuple [];
        };
        {
          name := "Blake2WrongFinalIndicatorFlag";
          item := StructTuple [];
        };
        {
          name := "ModexpExpOverflow";
          item := StructTuple [];
        };
        {
          name := "ModexpBaseOverflow";
          item := StructTuple [];
        };
        {
          name := "ModexpModOverflow";
          item := StructTuple [];
        };
        {
          name := "Bn128FieldPointNotAMember";
          item := StructTuple [];
        };
        {
          name := "Bn128AffineGFailedToCreate";
          item := StructTuple [];
        };
        {
          name := "Bn128PairLength";
          item := StructTuple [];
        };
        {
          name := "BlobInvalidInputLength";
          item := StructTuple [];
        };
        {
          name := "BlobMismatchedVersion";
          item := StructTuple [];
        };
        {
          name := "BlobVerifyKzgProofFailed";
          item := StructTuple [];
        };
        {
          name := "Other";
          item := StructTuple [ Ty.path "alloc::string::String" ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_PrecompileError_OutOfGas :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::OutOfGas" 0.
  Axiom IsDiscriminant_PrecompileError_Blake2WrongLength :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::Blake2WrongLength" 1.
  Axiom IsDiscriminant_PrecompileError_Blake2WrongFinalIndicatorFlag :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::Blake2WrongFinalIndicatorFlag" 2.
  Axiom IsDiscriminant_PrecompileError_ModexpExpOverflow :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::ModexpExpOverflow" 3.
  Axiom IsDiscriminant_PrecompileError_ModexpBaseOverflow :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::ModexpBaseOverflow" 4.
  Axiom IsDiscriminant_PrecompileError_ModexpModOverflow :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::ModexpModOverflow" 5.
  Axiom IsDiscriminant_PrecompileError_Bn128FieldPointNotAMember :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::Bn128FieldPointNotAMember" 6.
  Axiom IsDiscriminant_PrecompileError_Bn128AffineGFailedToCreate :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::Bn128AffineGFailedToCreate" 7.
  Axiom IsDiscriminant_PrecompileError_Bn128PairLength :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::Bn128PairLength" 8.
  Axiom IsDiscriminant_PrecompileError_BlobInvalidInputLength :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::BlobInvalidInputLength" 9.
  Axiom IsDiscriminant_PrecompileError_BlobMismatchedVersion :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::BlobMismatchedVersion" 10.
  Axiom IsDiscriminant_PrecompileError_BlobVerifyKzgProofFailed :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::BlobVerifyKzgProofFailed" 11.
  Axiom IsDiscriminant_PrecompileError_Other :
    M.IsDiscriminant "revm_precompile::interface::PrecompileError::Other" 12.
  
  Module Impl_core_clone_Clone_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "revm_precompile::interface::PrecompileError"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::OutOfGas"
                      |) in
                    M.alloc (|
                      Value.StructTuple "revm_precompile::interface::PrecompileError::OutOfGas" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Blake2WrongLength"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::Blake2WrongLength"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Blake2WrongFinalIndicatorFlag"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::Blake2WrongFinalIndicatorFlag"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::ModexpExpOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::ModexpExpOverflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::ModexpBaseOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::ModexpBaseOverflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::ModexpModOverflow"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::ModexpModOverflow"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Bn128FieldPointNotAMember"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::Bn128FieldPointNotAMember"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Bn128AffineGFailedToCreate"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::Bn128AffineGFailedToCreate"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Bn128PairLength"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::Bn128PairLength"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::BlobInvalidInputLength"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::BlobInvalidInputLength"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::BlobMismatchedVersion"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::BlobMismatchedVersion"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::BlobVerifyKzgProofFailed"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::BlobVerifyKzgProofFailed"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Other",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_precompile::interface::PrecompileError::Other"
                        [
                          M.call_closure (|
                            Ty.path "alloc::string::String",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloc::string::String",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_precompile_interface_PrecompileError.
  
  Module Impl_core_fmt_Debug_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::OutOfGas"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "OutOfGas" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Blake2WrongLength"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Blake2WrongLength" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Blake2WrongFinalIndicatorFlag"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Blake2WrongFinalIndicatorFlag" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::ModexpExpOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "ModexpExpOverflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::ModexpBaseOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "ModexpBaseOverflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::ModexpModOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "ModexpModOverflow" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Bn128FieldPointNotAMember"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Bn128FieldPointNotAMember" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Bn128AffineGFailedToCreate"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Bn128AffineGFailedToCreate" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Bn128PairLength"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "Bn128PairLength" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::BlobInvalidInputLength"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "BlobInvalidInputLength" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::BlobMismatchedVersion"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "BlobMismatchedVersion" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::BlobVerifyKzgProofFailed"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "BlobVerifyKzgProofFailed" |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Other",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Other" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_precompile_interface_PrecompileError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_precompile_interface_PrecompileError.
  
  Module Impl_core_cmp_PartialEq_revm_precompile_interface_PrecompileError_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_precompile::interface::PrecompileError" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_precompile::interface::PrecompileError" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some (Ty.path "bool"),
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_precompile::interface::PrecompileError::Other",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_precompile::interface::PrecompileError::Other",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_precompile::interface::PrecompileError" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_revm_precompile_interface_PrecompileError_for_revm_precompile_interface_PrecompileError.
  
  Module Impl_core_cmp_Eq_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_precompile_interface_PrecompileError.
  
  Module Impl_core_hash_Hash_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "revm_precompile::interface::PrecompileError" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_precompile::interface::PrecompileError::Other",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloc::string::String",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_precompile_interface_PrecompileError.
  
  Module Impl_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    (*
        pub fn other(err: impl Into<String>) -> Self {
            Self::Other(err.into())
        }
    *)
    Definition other (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ impl_Into_String_ ], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          Value.StructTuple
            "revm_precompile::interface::PrecompileError::Other"
            [
              M.call_closure (|
                Ty.path "alloc::string::String",
                M.get_trait_method (|
                  "core::convert::Into",
                  impl_Into_String_,
                  [],
                  [ Ty.path "alloc::string::String" ],
                  "into",
                  [],
                  []
                |),
                [ M.read (| err |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_other : M.IsAssociatedFunction.C Self "other" other.
    Admitted.
    Global Typeclasses Opaque other.
    
    (*
        pub fn is_oog(&self) -> bool {
            matches!(self, Self::OutOfGas)
        }
    *)
    Definition is_oog (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "bool"),
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_precompile::interface::PrecompileError::OutOfGas"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_oog : M.IsAssociatedFunction.C Self "is_oog" is_oog.
    Admitted.
    Global Typeclasses Opaque is_oog.
  End Impl_revm_precompile_interface_PrecompileError.
  
  Module Impl_core_convert_From_revm_precompile_interface_PrecompileError_for_revm_precompile_interface_PrecompileErrors.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileErrors".
    
    (*
        fn from(err: PrecompileError) -> Self {
            PrecompileErrors::Error(err)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          Value.StructTuple
            "revm_precompile::interface::PrecompileErrors::Error"
            [ M.read (| err |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "revm_precompile::interface::PrecompileError" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_precompile_interface_PrecompileError_for_revm_precompile_interface_PrecompileErrors.
  
  Module Impl_core_error_Error_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_precompile_interface_PrecompileError.
  
  Module Impl_core_fmt_Display_for_revm_precompile_interface_PrecompileError.
    Definition Self : Ty.t := Ty.path "revm_precompile::interface::PrecompileError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let s = match self {
                Self::OutOfGas => "out of gas",
                Self::Blake2WrongLength => "wrong input length for blake2",
                Self::Blake2WrongFinalIndicatorFlag => "wrong final indicator flag for blake2",
                Self::ModexpExpOverflow => "modexp exp overflow",
                Self::ModexpBaseOverflow => "modexp base overflow",
                Self::ModexpModOverflow => "modexp mod overflow",
                Self::Bn128FieldPointNotAMember => "field point not a member of bn128 curve",
                Self::Bn128AffineGFailedToCreate => "failed to create affine g point for bn128 curve",
                Self::Bn128PairLength => "bn128 invalid pair length",
                Self::BlobInvalidInputLength => "invalid blob input length",
                Self::BlobMismatchedVersion => "mismatched blob version",
                Self::BlobVerifyKzgProofFailed => "verifying blob kzg proof failed",
                Self::Other(s) => s,
            };
            f.write_str(s)
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ s : Ty.apply (Ty.path "&") [] [ Ty.path "str" ] :=
              M.copy (|
                M.match_operator (|
                  Some (Ty.apply (Ty.path "&") [] [ Ty.path "str" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::OutOfGas"
                          |) in
                        M.alloc (| mk_str (| "out of gas" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::Blake2WrongLength"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "wrong input length for blake2" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::Blake2WrongFinalIndicatorFlag"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "wrong final indicator flag for blake2" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::ModexpExpOverflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "modexp exp overflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::ModexpBaseOverflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "modexp base overflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::ModexpModOverflow"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "modexp mod overflow" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::Bn128FieldPointNotAMember"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "field point not a member of bn128 curve" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::Bn128AffineGFailedToCreate"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              mk_str (| "failed to create affine g point for bn128 curve" |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::Bn128PairLength"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "bn128 invalid pair length" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::BlobInvalidInputLength"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "invalid blob input length" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::BlobMismatchedVersion"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "mismatched blob version" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_precompile::interface::PrecompileError::BlobVerifyKzgProofFailed"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "verifying blob kzg proof failed" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "revm_precompile::interface::PrecompileError::Other",
                            0
                          |) in
                        let s := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "alloc::string::String",
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_precompile_interface_PrecompileError.
End interface.
