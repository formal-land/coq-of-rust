(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module kzg_point_evaluation.
  Definition value_POINT_EVALUATION (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.StructTuple
          "revm_precompile::PrecompileWithAddress"
          [
            M.read (|
              get_constant (|
                "revm_precompile::kzg_point_evaluation::ADDRESS",
                Ty.path "alloy_primitives::bits::address::Address"
              |)
            |);
            (* ReifyFnPointer *)
            M.pointer_coercion
              (M.get_function (| "revm_precompile::kzg_point_evaluation::run", [], [] |))
          ]
      |))).
  
  Global Instance Instance_IsConstant_value_POINT_EVALUATION :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::POINT_EVALUATION" value_POINT_EVALUATION.
  Admitted.
  Global Typeclasses Opaque value_POINT_EVALUATION.
  
  Definition value_ADDRESS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "alloy_primitives::bits::address::Address",
          M.get_function (| "revm_precompile::u64_to_address", [], [] |),
          [ Value.Integer IntegerKind.U64 10 ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_ADDRESS :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::ADDRESS" value_ADDRESS.
  Admitted.
  Global Typeclasses Opaque value_ADDRESS.
  
  Definition value_GAS_COST (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U64 50000 |))).
  
  Global Instance Instance_IsConstant_value_GAS_COST :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::GAS_COST" value_GAS_COST.
  Admitted.
  Global Typeclasses Opaque value_GAS_COST.
  
  Definition value_VERSIONED_HASH_VERSION_KZG
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 1 |))).
  
  Global Instance Instance_IsConstant_value_VERSIONED_HASH_VERSION_KZG :
    M.IsFunction.C
      "revm_precompile::kzg_point_evaluation::VERSIONED_HASH_VERSION_KZG"
      value_VERSIONED_HASH_VERSION_KZG.
  Admitted.
  Global Typeclasses Opaque value_VERSIONED_HASH_VERSION_KZG.
  
  Definition value_RETURN_VALUE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              get_constant (|
                "revm_precompile::kzg_point_evaluation::RETURN_VALUE::RES",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 64 ] [ Ty.path "u8" ]
              |)
            |)
          |)
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_RETURN_VALUE :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::RETURN_VALUE" value_RETURN_VALUE.
  Admitted.
  Global Typeclasses Opaque value_RETURN_VALUE.
  
  (*
  pub fn run(input: &Bytes, gas_limit: u64) -> PrecompileResult {
      if gas_limit < GAS_COST {
          return Err(PrecompileError::OutOfGas.into());
      }
  
      // Verify input length.
      if input.len() != 192 {
          return Err(PrecompileError::BlobInvalidInputLength.into());
      }
  
      // Verify commitment matches versioned_hash
      let versioned_hash = &input[..32];
      let commitment = &input[96..144];
      if kzg_to_versioned_hash(commitment) != versioned_hash {
          return Err(PrecompileError::BlobMismatchedVersion.into());
      }
  
      // Verify KZG proof with z and y in big endian format
      let commitment = as_bytes48(commitment);
      let z = as_bytes32(&input[32..64]);
      let y = as_bytes32(&input[64..96]);
      let proof = as_bytes48(&input[144..192]);
      if !verify_kzg_proof(commitment, z, y, proof) {
          return Err(PrecompileError::BlobVerifyKzgProofFailed.into());
      }
  
      // Return FIELD_ELEMENTS_PER_BLOB and BLS_MODULUS as padded 32 byte big endian values
      Ok(PrecompileOutput::new(GAS_COST, RETURN_VALUE.into()))
  }
  *)
  Definition run (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ input; gas_limit ] =>
      ltac:(M.monadic
        (let input := M.alloc (| input |) in
        let gas_limit := M.alloc (| gas_limit |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.lt (|
                                M.read (| gas_limit |),
                                M.read (|
                                  get_constant (|
                                    "revm_precompile::kzg_point_evaluation::GAS_COST",
                                    Ty.path "u64"
                                  |)
                                |)
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      Ty.path "revm_precompile::interface::PrecompileErrors",
                                      M.get_trait_method (|
                                        "core::convert::Into",
                                        Ty.path "revm_precompile::interface::PrecompileError",
                                        [],
                                        [ Ty.path "revm_precompile::interface::PrecompileErrors" ],
                                        "into",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "revm_precompile::interface::PrecompileError::OutOfGas"
                                          []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.ne (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.path "bytes::bytes::Bytes",
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "bytes::bytes::Bytes" ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.path "alloy_primitives::bytes_::Bytes",
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| input |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |),
                                Value.Integer IntegerKind.Usize 192
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      Ty.path "revm_precompile::interface::PrecompileErrors",
                                      M.get_trait_method (|
                                        "core::convert::Into",
                                        Ty.path "revm_precompile::interface::PrecompileError",
                                        [],
                                        [ Ty.path "revm_precompile::interface::PrecompileErrors" ],
                                        "into",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "revm_precompile::interface::PrecompileError::BlobInvalidInputLength"
                                          []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ versioned_hash :
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ],
                          "index",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "bytes::bytes::Bytes",
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "alloy_primitives::bytes_::Bytes",
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| input |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          Value.StructRecord
                            "core::ops::range::RangeTo"
                            [ ("end_", Value.Integer IntegerKind.Usize 32) ]
                        ]
                      |)
                    |)
                  |)
                |) in
              let~ commitment :
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                          "index",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "bytes::bytes::Bytes",
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "alloy_primitives::bytes_::Bytes",
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| input |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          Value.StructRecord
                            "core::ops::range::Range"
                            [
                              ("start", Value.Integer IntegerKind.Usize 96);
                              ("end_", Value.Integer IntegerKind.Usize 144)
                            ]
                        ]
                      |)
                    |)
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 32 ]
                                    [ Ty.path "u8" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                  "ne",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 32 ]
                                          [ Ty.path "u8" ],
                                        M.get_function (|
                                          "revm_precompile::kzg_point_evaluation::kzg_to_versioned_hash",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| commitment |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.borrow (| Pointer.Kind.Ref, versioned_hash |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      Ty.path "revm_precompile::interface::PrecompileErrors",
                                      M.get_trait_method (|
                                        "core::convert::Into",
                                        Ty.path "revm_precompile::interface::PrecompileError",
                                        [],
                                        [ Ty.path "revm_precompile::interface::PrecompileErrors" ],
                                        "into",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "revm_precompile::interface::PrecompileError::BlobMismatchedVersion"
                                          []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ commitment : Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes48" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes48" ],
                    M.get_function (|
                      "revm_precompile::kzg_point_evaluation::as_bytes48",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| commitment |) |) |) ]
                  |)
                |) in
              let~ z : Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes32" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes32" ],
                    M.get_function (|
                      "revm_precompile::kzg_point_evaluation::as_bytes32",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "bytes::bytes::Bytes",
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.path "bytes::bytes::Bytes" ],
                                                M.get_trait_method (|
                                                  "core::ops::deref::Deref",
                                                  Ty.path "alloy_primitives::bytes_::Bytes",
                                                  [],
                                                  [],
                                                  "deref",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| input |) |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start", Value.Integer IntegerKind.Usize 32);
                                      ("end_", Value.Integer IntegerKind.Usize 64)
                                    ]
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ y : Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes32" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes32" ],
                    M.get_function (|
                      "revm_precompile::kzg_point_evaluation::as_bytes32",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "bytes::bytes::Bytes",
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.path "bytes::bytes::Bytes" ],
                                                M.get_trait_method (|
                                                  "core::ops::deref::Deref",
                                                  Ty.path "alloy_primitives::bytes_::Bytes",
                                                  [],
                                                  [],
                                                  "deref",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| input |) |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start", Value.Integer IntegerKind.Usize 64);
                                      ("end_", Value.Integer IntegerKind.Usize 96)
                                    ]
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ proof : Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes48" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::Bytes48" ],
                    M.get_function (|
                      "revm_precompile::kzg_point_evaluation::as_bytes48",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "bytes::bytes::Bytes",
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.path "bytes::bytes::Bytes" ],
                                                M.get_trait_method (|
                                                  "core::ops::deref::Deref",
                                                  Ty.path "alloy_primitives::bytes_::Bytes",
                                                  [],
                                                  [],
                                                  "deref",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| input |) |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start", Value.Integer IntegerKind.Usize 144);
                                      ("end_", Value.Integer IntegerKind.Usize 192)
                                    ]
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (|
                                    "revm_precompile::kzg_point_evaluation::verify_kzg_proof",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| commitment |) |)
                                    |);
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| z |) |) |);
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| y |) |) |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| proof |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      Ty.path "revm_precompile::interface::PrecompileErrors",
                                      M.get_trait_method (|
                                        "core::convert::Into",
                                        Ty.path "revm_precompile::interface::PrecompileError",
                                        [],
                                        [ Ty.path "revm_precompile::interface::PrecompileErrors" ],
                                        "into",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "revm_precompile::interface::PrecompileError::BlobVerifyKzgProofFailed"
                                          []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.path "revm_precompile::interface::PrecompileOutput",
                      M.get_associated_function (|
                        Ty.path "revm_precompile::interface::PrecompileOutput",
                        "new",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          get_constant (|
                            "revm_precompile::kzg_point_evaluation::GAS_COST",
                            Ty.path "u64"
                          |)
                        |);
                        M.call_closure (|
                          Ty.path "alloy_primitives::bytes_::Bytes",
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 64 ]
                                  [ Ty.path "u8" ]
                              ],
                            [],
                            [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  get_constant (|
                                    "revm_precompile::kzg_point_evaluation::RETURN_VALUE",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 64 ]
                                          [ Ty.path "u8" ]
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_run :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::run" run.
  Admitted.
  Global Typeclasses Opaque run.
  
  (*
  pub fn kzg_to_versioned_hash(commitment: &[u8]) -> [u8; 32] {
      let mut hash: [u8; 32] = Sha256::digest(commitment).into();
      hash[0] = VERSIONED_HASH_VERSION_KZG;
      hash
  }
  *)
  Definition kzg_to_versioned_hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ commitment ] =>
      ltac:(M.monadic
        (let commitment := M.alloc (| commitment |) in
        M.read (|
          let~ hash :
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.apply
                    (Ty.path "generic_array::GenericArray")
                    []
                    [
                      Ty.path "u8";
                      Ty.apply
                        (Ty.path "typenum::uint::UInt")
                        []
                        [
                          Ty.apply
                            (Ty.path "typenum::uint::UInt")
                            []
                            [
                              Ty.apply
                                (Ty.path "typenum::uint::UInt")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "typenum::uint::UInt")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "typenum::uint::UInt")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "typenum::uint::UInt")
                                            []
                                            [
                                              Ty.path "typenum::uint::UTerm";
                                              Ty.path "typenum::bit::B1"
                                            ];
                                          Ty.path "typenum::bit::B0"
                                        ];
                                      Ty.path "typenum::bit::B0"
                                    ];
                                  Ty.path "typenum::bit::B0"
                                ];
                              Ty.path "typenum::bit::B0"
                            ];
                          Ty.path "typenum::bit::B0"
                        ]
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ],
                  "into",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "generic_array::GenericArray")
                      []
                      [
                        Ty.path "u8";
                        Ty.apply
                          (Ty.path "typenum::uint::UInt")
                          []
                          [
                            Ty.apply
                              (Ty.path "typenum::uint::UInt")
                              []
                              [
                                Ty.apply
                                  (Ty.path "typenum::uint::UInt")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "typenum::uint::UInt")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "typenum::uint::UInt")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "typenum::uint::UInt")
                                              []
                                              [
                                                Ty.path "typenum::uint::UTerm";
                                                Ty.path "typenum::bit::B1"
                                              ];
                                            Ty.path "typenum::bit::B0"
                                          ];
                                        Ty.path "typenum::bit::B0"
                                      ];
                                    Ty.path "typenum::bit::B0"
                                  ];
                                Ty.path "typenum::bit::B0"
                              ];
                            Ty.path "typenum::bit::B0"
                          ]
                      ],
                    M.get_trait_method (|
                      "digest::digest::Digest",
                      Ty.apply
                        (Ty.path "digest::core_api::wrapper::CoreWrapper")
                        []
                        [
                          Ty.apply
                            (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                            []
                            [
                              Ty.path "sha2::core_api::Sha256VarCore";
                              Ty.apply
                                (Ty.path "typenum::uint::UInt")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "typenum::uint::UInt")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "typenum::uint::UInt")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "typenum::uint::UInt")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "typenum::uint::UInt")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "typenum::uint::UInt")
                                                    []
                                                    [
                                                      Ty.path "typenum::uint::UTerm";
                                                      Ty.path "typenum::bit::B1"
                                                    ];
                                                  Ty.path "typenum::bit::B0"
                                                ];
                                              Ty.path "typenum::bit::B0"
                                            ];
                                          Ty.path "typenum::bit::B0"
                                        ];
                                      Ty.path "typenum::bit::B0"
                                    ];
                                  Ty.path "typenum::bit::B0"
                                ];
                              Ty.path "sha2::OidSha256"
                            ]
                        ],
                      [],
                      [],
                      "digest",
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ]
                    |),
                    [ M.read (| commitment |) ]
                  |)
                ]
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| hash, Value.Integer IntegerKind.Usize 0 |),
                M.read (|
                  get_constant (|
                    "revm_precompile::kzg_point_evaluation::VERSIONED_HASH_VERSION_KZG",
                    Ty.path "u8"
                  |)
                |)
              |)
            |) in
          hash
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_kzg_to_versioned_hash :
    M.IsFunction.C
      "revm_precompile::kzg_point_evaluation::kzg_to_versioned_hash"
      kzg_to_versioned_hash.
  Admitted.
  Global Typeclasses Opaque kzg_to_versioned_hash.
  
  (*
  pub fn verify_kzg_proof(commitment: &Bytes48, z: &Bytes32, y: &Bytes32, proof: &Bytes48) -> bool {
      cfg_if::cfg_if! {
          if #[cfg(feature = "c-kzg")] {
              let kzg_settings = c_kzg::ethereum_kzg_settings();
          } else if #[cfg(feature = "kzg-rs")] {
              let env = kzg_rs::EnvKzgSettings::default();
              let kzg_settings = env.get();
          }
      }
      KzgProof::verify_kzg_proof(commitment, z, y, proof, kzg_settings).unwrap_or(false)
  }
  *)
  Definition verify_kzg_proof (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ commitment; z; y; proof ] =>
      ltac:(M.monadic
        (let commitment := M.alloc (| commitment |) in
        let z := M.alloc (| z |) in
        let y := M.alloc (| y |) in
        let proof := M.alloc (| proof |) in
        M.read (|
          let~ kzg_settings :
              Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::KZGSettings" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "c_kzg::bindings::KZGSettings" ],
                M.get_function (| "c_kzg::ethereum_kzg_settings::ethereum_kzg_settings", [], [] |),
                []
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "bool"; Ty.path "c_kzg::bindings::Error" ],
                "unwrap_or",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "bool"; Ty.path "c_kzg::bindings::Error" ],
                  M.get_associated_function (|
                    Ty.path "c_kzg::bindings::KZGProof",
                    "verify_kzg_proof",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| commitment |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| z |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| y |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| proof |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| kzg_settings |) |) |)
                  ]
                |);
                Value.Bool false
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_verify_kzg_proof :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::verify_kzg_proof" verify_kzg_proof.
  Admitted.
  Global Typeclasses Opaque verify_kzg_proof.
  
  (*
  pub fn as_array<const N: usize>(bytes: &[u8]) -> &[u8; N] {
      bytes.try_into().expect("slice with incorrect length")
  }
  *)
  Definition as_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ bytes ] =>
      ltac:(M.monadic
        (let bytes := M.alloc (| bytes |) in
        M.call_closure (|
          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                Ty.path "core::array::TryFromSliceError"
              ],
            "expect",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_trait_method (|
                "core::convert::TryInto",
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] ],
                "try_into",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (| mk_str (| "slice with incorrect length" |) |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_as_array :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::as_array" as_array.
  Admitted.
  Global Typeclasses Opaque as_array.
  
  (*
  pub fn as_bytes32(bytes: &[u8]) -> &Bytes32 {
      // SAFETY: `#[repr(C)] Bytes32([u8; 32])`
      unsafe { &*as_array::<32>(bytes).as_ptr().cast() }
  }
  *)
  Definition as_bytes32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ bytes ] =>
      ltac:(M.monadic
        (let bytes := M.alloc (| bytes |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "c_kzg::bindings::Bytes32" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [ Ty.path "c_kzg::bindings::Bytes32" ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 32 ]
                                    [ Ty.path "u8" ]
                                ],
                              M.get_function (|
                                "revm_precompile::kzg_point_evaluation::as_array",
                                [ Value.Integer IntegerKind.Usize 32 ],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_as_bytes32 :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::as_bytes32" as_bytes32.
  Admitted.
  Global Typeclasses Opaque as_bytes32.
  
  (*
  pub fn as_bytes48(bytes: &[u8]) -> &Bytes48 {
      // SAFETY: `#[repr(C)] Bytes48([u8; 48])`
      unsafe { &*as_array::<48>(bytes).as_ptr().cast() }
  }
  *)
  Definition as_bytes48 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ bytes ] =>
      ltac:(M.monadic
        (let bytes := M.alloc (| bytes |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "c_kzg::bindings::Bytes48" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [ Ty.path "c_kzg::bindings::Bytes48" ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 48 ]
                                    [ Ty.path "u8" ]
                                ],
                              M.get_function (|
                                "revm_precompile::kzg_point_evaluation::as_array",
                                [ Value.Integer IntegerKind.Usize 48 ],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_as_bytes48 :
    M.IsFunction.C "revm_precompile::kzg_point_evaluation::as_bytes48" as_bytes48.
  Admitted.
  Global Typeclasses Opaque as_bytes48.
End kzg_point_evaluation.
