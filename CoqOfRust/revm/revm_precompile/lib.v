(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
pub fn calc_linear_cost_u32(len: usize, base: u64, word: u64) -> u64 {
    (len as u64).div_ceil(32) * word + base
}
*)
Definition calc_linear_cost_u32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ len; base; word ] =>
    ltac:(M.monadic
      (let len := M.alloc (| len |) in
      let base := M.alloc (| base |) in
      let word := M.alloc (| word |) in
      BinOp.Wrap.add (|
        BinOp.Wrap.mul (|
          M.call_closure (|
            Ty.path "u64",
            M.get_associated_function (| Ty.path "u64", "div_ceil", [], [] |),
            [ M.cast (Ty.path "u64") (M.read (| len |)); Value.Integer IntegerKind.U64 32 ]
          |),
          M.read (| word |)
        |),
        M.read (| base |)
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Axiom Function_calc_linear_cost_u32 :
  M.IsFunction "revm_precompile::calc_linear_cost_u32" calc_linear_cost_u32.
Smpl Add apply Function_calc_linear_cost_u32 : is_function.

(* StructRecord
  {
    name := "Precompiles";
    const_params := [];
    ty_params := [];
    fields :=
      [
        ("inner",
          Ty.apply
            (Ty.path "std::collections::hash::map::HashMap")
            []
            [
              Ty.path "alloy_primitives::bits::address::Address";
              Ty.function
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                  Ty.path "u64"
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.path "revm_precompile::interface::PrecompileOutput";
                    Ty.path "revm_precompile::interface::PrecompileErrors"
                  ]);
              Ty.path "std::hash::random::RandomState"
            ]);
        ("addresses",
          Ty.apply
            (Ty.path "std::collections::hash::set::HashSet")
            []
            [
              Ty.path "alloy_primitives::bits::address::Address";
              Ty.path "std::hash::random::RandomState"
            ])
      ];
  } *)

Module Impl_core_clone_Clone_for_revm_precompile_Precompiles.
  Definition Self : Ty.t := Ty.path "revm_precompile::Precompiles".
  
  (* Clone *)
  Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        Value.StructRecord
          "revm_precompile::Precompiles"
          [
            ("inner",
              M.call_closure (|
                Ty.apply
                  (Ty.path "std::collections::hash::map::HashMap")
                  []
                  [
                    Ty.path "alloy_primitives::bits::address::Address";
                    Ty.function
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                        Ty.path "u64"
                      ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "revm_precompile::interface::PrecompileOutput";
                          Ty.path "revm_precompile::interface::PrecompileErrors"
                        ]);
                    Ty.path "std::hash::random::RandomState"
                  ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "std::collections::hash::map::HashMap")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.function
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                          Ty.path "u64"
                        ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "revm_precompile::interface::PrecompileOutput";
                            Ty.path "revm_precompile::interface::PrecompileErrors"
                          ]);
                      Ty.path "std::hash::random::RandomState"
                    ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_precompile::Precompiles",
                          "inner"
                        |)
                      |)
                    |)
                  |)
                ]
              |));
            ("addresses",
              M.call_closure (|
                Ty.apply
                  (Ty.path "std::collections::hash::set::HashSet")
                  []
                  [
                    Ty.path "alloy_primitives::bits::address::Address";
                    Ty.path "std::hash::random::RandomState"
                  ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "std::collections::hash::set::HashSet")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.path "std::hash::random::RandomState"
                    ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_precompile::Precompiles",
                          "addresses"
                        |)
                      |)
                    |)
                  |)
                ]
              |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_revm_precompile_Precompiles.

Module Impl_core_default_Default_for_revm_precompile_Precompiles.
  Definition Self : Ty.t := Ty.path "revm_precompile::Precompiles".
  
  (* Default *)
  Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (Value.StructRecord
          "revm_precompile::Precompiles"
          [
            ("inner",
              M.call_closure (|
                Ty.apply
                  (Ty.path "std::collections::hash::map::HashMap")
                  []
                  [
                    Ty.path "alloy_primitives::bits::address::Address";
                    Ty.function
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                        Ty.path "u64"
                      ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "revm_precompile::interface::PrecompileOutput";
                          Ty.path "revm_precompile::interface::PrecompileErrors"
                        ]);
                    Ty.path "std::hash::random::RandomState"
                  ],
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.apply
                    (Ty.path "std::collections::hash::map::HashMap")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.function
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                          Ty.path "u64"
                        ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "revm_precompile::interface::PrecompileOutput";
                            Ty.path "revm_precompile::interface::PrecompileErrors"
                          ]);
                      Ty.path "std::hash::random::RandomState"
                    ],
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |));
            ("addresses",
              M.call_closure (|
                Ty.apply
                  (Ty.path "std::collections::hash::set::HashSet")
                  []
                  [
                    Ty.path "alloy_primitives::bits::address::Address";
                    Ty.path "std::hash::random::RandomState"
                  ],
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.apply
                    (Ty.path "std::collections::hash::set::HashSet")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.path "std::hash::random::RandomState"
                    ],
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_revm_precompile_Precompiles.

Module Impl_core_fmt_Debug_for_revm_precompile_Precompiles.
  Definition Self : Ty.t := Ty.path "revm_precompile::Precompiles".
  
  (* Debug *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_associated_function (|
            Ty.path "core::fmt::Formatter",
            "debug_struct_field2_finish",
            [],
            []
          |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "Precompiles" |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "inner" |) |) |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_precompile::Precompiles",
                    "inner"
                  |)
                |)
              |)
            |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "addresses" |) |) |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_precompile::Precompiles",
                        "addresses"
                      |)
                    |)
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_revm_precompile_Precompiles.

Module Impl_revm_precompile_Precompiles.
  Definition Self : Ty.t := Ty.path "revm_precompile::Precompiles".
  
  (*
      pub fn new(spec: PrecompileSpecId) -> &'static Self {
          match spec {
              PrecompileSpecId::HOMESTEAD => Self::homestead(),
              PrecompileSpecId::BYZANTIUM => Self::byzantium(),
              PrecompileSpecId::ISTANBUL => Self::istanbul(),
              PrecompileSpecId::BERLIN => Self::berlin(),
              PrecompileSpecId::CANCUN => Self::cancun(),
              PrecompileSpecId::PRAGUE => Self::prague(),
              PrecompileSpecId::LATEST => Self::latest(),
          }
      }
  *)
  Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ spec ] =>
      ltac:(M.monadic
        (let spec := M.alloc (| spec |) in
        M.read (|
          M.match_operator (|
            spec,
            [
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::HOMESTEAD" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
                      M.get_associated_function (|
                        Ty.path "revm_precompile::Precompiles",
                        "homestead",
                        [],
                        []
                      |),
                      []
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::BYZANTIUM" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
                      M.get_associated_function (|
                        Ty.path "revm_precompile::Precompiles",
                        "byzantium",
                        [],
                        []
                      |),
                      []
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::ISTANBUL" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
                      M.get_associated_function (|
                        Ty.path "revm_precompile::Precompiles",
                        "istanbul",
                        [],
                        []
                      |),
                      []
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::BERLIN" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
                      M.get_associated_function (|
                        Ty.path "revm_precompile::Precompiles",
                        "berlin",
                        [],
                        []
                      |),
                      []
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::CANCUN" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
                      M.get_associated_function (|
                        Ty.path "revm_precompile::Precompiles",
                        "cancun",
                        [],
                        []
                      |),
                      []
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::PRAGUE" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
                      M.get_associated_function (|
                        Ty.path "revm_precompile::Precompiles",
                        "prague",
                        [],
                        []
                      |),
                      []
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::LATEST" |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
                      M.get_associated_function (|
                        Ty.path "revm_precompile::Precompiles",
                        "latest",
                        [],
                        []
                      |),
                      []
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
  Smpl Add apply AssociatedFunction_new : is_associated.
  
  (*
      pub fn homestead() -> &'static Self {
          static INSTANCE: OnceBox<Precompiles> = OnceBox::new();
          INSTANCE.get_or_init(|| {
              let mut precompiles = Precompiles::default();
              precompiles.extend([
                  secp256k1::ECRECOVER,
                  hash::SHA256,
                  hash::RIPEMD160,
                  identity::FUN,
              ]);
              Box::new(precompiles)
          })
      }
  *)
  Definition homestead (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "once_cell::race::once_box::OnceBox")
                  []
                  [ Ty.path "revm_precompile::Precompiles" ],
                "get_or_init",
                [],
                [
                  Ty.function
                    [ Ty.tuple [] ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "revm_precompile::Precompiles"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.get_constant "revm_precompile::homestead::INSTANCE" |) |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "revm_precompile::Precompiles",
                                          M.get_trait_method (|
                                            "core::default::Default",
                                            Ty.path "revm_precompile::Precompiles",
                                            [],
                                            [],
                                            "default",
                                            [],
                                            []
                                          |),
                                          []
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.path "revm_precompile::Precompiles",
                                            "extend",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 4 ]
                                                [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                                            ]
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.MutRef, precompiles |);
                                            Value.Array
                                              [
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::secp256k1::ECRECOVER"
                                                |);
                                                M.read (|
                                                  M.get_constant "revm_precompile::hash::SHA256"
                                                |);
                                                M.read (|
                                                  M.get_constant "revm_precompile::hash::RIPEMD160"
                                                |);
                                                M.read (|
                                                  M.get_constant "revm_precompile::identity::FUN"
                                                |)
                                              ]
                                          ]
                                        |)
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path "revm_precompile::Precompiles";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path "revm_precompile::Precompiles";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.read (| precompiles |) ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_homestead : M.IsAssociatedFunction Self "homestead" homestead.
  Smpl Add apply AssociatedFunction_homestead : is_associated.
  
  (*
      pub fn inner(&self) -> &HashMap<Address, PrecompileFn> {
          &self.inner
      }
  *)
  Definition inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::Precompiles",
                "inner"
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_inner : M.IsAssociatedFunction Self "inner" inner.
  Smpl Add apply AssociatedFunction_inner : is_associated.
  
  (*
      pub fn byzantium() -> &'static Self {
          static INSTANCE: OnceBox<Precompiles> = OnceBox::new();
          INSTANCE.get_or_init(|| {
              let mut precompiles = Self::homestead().clone();
              precompiles.extend([
                  // EIP-196: Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128.
                  // EIP-197: Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128.
                  bn128::add::BYZANTIUM,
                  bn128::mul::BYZANTIUM,
                  bn128::pair::BYZANTIUM,
                  // EIP-198: Big integer modular exponentiation.
                  modexp::BYZANTIUM,
              ]);
              Box::new(precompiles)
          })
      }
  *)
  Definition byzantium (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "once_cell::race::once_box::OnceBox")
                  []
                  [ Ty.path "revm_precompile::Precompiles" ],
                "get_or_init",
                [],
                [
                  Ty.function
                    [ Ty.tuple [] ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "revm_precompile::Precompiles"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.get_constant "revm_precompile::byzantium::INSTANCE" |) |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "revm_precompile::Precompiles",
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Ty.path "revm_precompile::Precompiles",
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "revm_precompile::Precompiles" ],
                                                  M.get_associated_function (|
                                                    Ty.path "revm_precompile::Precompiles",
                                                    "homestead",
                                                    [],
                                                    []
                                                  |),
                                                  []
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.path "revm_precompile::Precompiles",
                                            "extend",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 4 ]
                                                [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                                            ]
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.MutRef, precompiles |);
                                            Value.Array
                                              [
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::bn128::add::BYZANTIUM"
                                                |);
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::bn128::mul::BYZANTIUM"
                                                |);
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::bn128::pair::BYZANTIUM"
                                                |);
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::modexp::BYZANTIUM"
                                                |)
                                              ]
                                          ]
                                        |)
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path "revm_precompile::Precompiles";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path "revm_precompile::Precompiles";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.read (| precompiles |) ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_byzantium : M.IsAssociatedFunction Self "byzantium" byzantium.
  Smpl Add apply AssociatedFunction_byzantium : is_associated.
  
  (*
      pub fn istanbul() -> &'static Self {
          static INSTANCE: OnceBox<Precompiles> = OnceBox::new();
          INSTANCE.get_or_init(|| {
              let mut precompiles = Self::byzantium().clone();
              precompiles.extend([
                  // EIP-1108: Reduce alt_bn128 precompile gas costs.
                  bn128::add::ISTANBUL,
                  bn128::mul::ISTANBUL,
                  bn128::pair::ISTANBUL,
                  // EIP-152: Add BLAKE2 compression function `F` precompile.
                  blake2::FUN,
              ]);
              Box::new(precompiles)
          })
      }
  *)
  Definition istanbul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "once_cell::race::once_box::OnceBox")
                  []
                  [ Ty.path "revm_precompile::Precompiles" ],
                "get_or_init",
                [],
                [
                  Ty.function
                    [ Ty.tuple [] ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "revm_precompile::Precompiles"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.get_constant "revm_precompile::istanbul::INSTANCE" |) |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "revm_precompile::Precompiles",
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Ty.path "revm_precompile::Precompiles",
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "revm_precompile::Precompiles" ],
                                                  M.get_associated_function (|
                                                    Ty.path "revm_precompile::Precompiles",
                                                    "byzantium",
                                                    [],
                                                    []
                                                  |),
                                                  []
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.path "revm_precompile::Precompiles",
                                            "extend",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 4 ]
                                                [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                                            ]
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.MutRef, precompiles |);
                                            Value.Array
                                              [
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::bn128::add::ISTANBUL"
                                                |);
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::bn128::mul::ISTANBUL"
                                                |);
                                                M.read (|
                                                  M.get_constant
                                                    "revm_precompile::bn128::pair::ISTANBUL"
                                                |);
                                                M.read (|
                                                  M.get_constant "revm_precompile::blake2::FUN"
                                                |)
                                              ]
                                          ]
                                        |)
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path "revm_precompile::Precompiles";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path "revm_precompile::Precompiles";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.read (| precompiles |) ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_istanbul : M.IsAssociatedFunction Self "istanbul" istanbul.
  Smpl Add apply AssociatedFunction_istanbul : is_associated.
  
  (*
      pub fn berlin() -> &'static Self {
          static INSTANCE: OnceBox<Precompiles> = OnceBox::new();
          INSTANCE.get_or_init(|| {
              let mut precompiles = Self::istanbul().clone();
              precompiles.extend([
                  // EIP-2565: ModExp Gas Cost.
                  modexp::BERLIN,
              ]);
              Box::new(precompiles)
          })
      }
  *)
  Definition berlin (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "once_cell::race::once_box::OnceBox")
                  []
                  [ Ty.path "revm_precompile::Precompiles" ],
                "get_or_init",
                [],
                [
                  Ty.function
                    [ Ty.tuple [] ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "revm_precompile::Precompiles"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.get_constant "revm_precompile::berlin::INSTANCE" |) |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "revm_precompile::Precompiles",
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Ty.path "revm_precompile::Precompiles",
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "revm_precompile::Precompiles" ],
                                                  M.get_associated_function (|
                                                    Ty.path "revm_precompile::Precompiles",
                                                    "istanbul",
                                                    [],
                                                    []
                                                  |),
                                                  []
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.path "revm_precompile::Precompiles",
                                            "extend",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                                            ]
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.MutRef, precompiles |);
                                            Value.Array
                                              [
                                                M.read (|
                                                  M.get_constant "revm_precompile::modexp::BERLIN"
                                                |)
                                              ]
                                          ]
                                        |)
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path "revm_precompile::Precompiles";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path "revm_precompile::Precompiles";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.read (| precompiles |) ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_berlin : M.IsAssociatedFunction Self "berlin" berlin.
  Smpl Add apply AssociatedFunction_berlin : is_associated.
  
  (*
      pub fn cancun() -> &'static Self {
          static INSTANCE: OnceBox<Precompiles> = OnceBox::new();
          INSTANCE.get_or_init(|| {
              let mut precompiles = Self::berlin().clone();
  
              // EIP-4844: Shard Blob Transactions
              cfg_if! {
                  if #[cfg(any(feature = "c-kzg", feature = "kzg-rs"))] {
                      let precompile = kzg_point_evaluation::POINT_EVALUATION.clone();
                  } else {
                      let precompile = PrecompileWithAddress(u64_to_address(0x0A), |_,_| Err(PrecompileErrors::Fatal { msg: "c-kzg feature is not enabled".into()}));
                  }
              }
  
  
              precompiles.extend([
                  precompile,
              ]);
  
              Box::new(precompiles)
          })
      }
  *)
  Definition cancun (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "once_cell::race::once_box::OnceBox")
                  []
                  [ Ty.path "revm_precompile::Precompiles" ],
                "get_or_init",
                [],
                [
                  Ty.function
                    [ Ty.tuple [] ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "revm_precompile::Precompiles"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.get_constant "revm_precompile::cancun::INSTANCE" |) |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "revm_precompile::Precompiles",
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Ty.path "revm_precompile::Precompiles",
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "revm_precompile::Precompiles" ],
                                                  M.get_associated_function (|
                                                    Ty.path "revm_precompile::Precompiles",
                                                    "berlin",
                                                    [],
                                                    []
                                                  |),
                                                  []
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ precompile :
                                        Ty.path "revm_precompile::PrecompileWithAddress" :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "revm_precompile::PrecompileWithAddress",
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Ty.path "revm_precompile::PrecompileWithAddress",
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.get_constant
                                                "revm_precompile::kzg_point_evaluation::POINT_EVALUATION"
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.path "revm_precompile::Precompiles",
                                            "extend",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                                            ]
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.MutRef, precompiles |);
                                            Value.Array [ M.read (| precompile |) ]
                                          ]
                                        |)
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path "revm_precompile::Precompiles";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path "revm_precompile::Precompiles";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.read (| precompiles |) ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_cancun : M.IsAssociatedFunction Self "cancun" cancun.
  Smpl Add apply AssociatedFunction_cancun : is_associated.
  
  (*
      pub fn prague() -> &'static Self {
          static INSTANCE: OnceBox<Precompiles> = OnceBox::new();
          INSTANCE.get_or_init(|| {
              let precompiles = Self::cancun().clone();
  
              // Don't include BLS12-381 precompiles in no_std builds.
              #[cfg(feature = "blst")]
              let precompiles = {
                  let mut precompiles = precompiles;
                  precompiles.extend(bls12_381::precompiles());
                  precompiles
              };
  
              Box::new(precompiles)
          })
      }
  *)
  Definition prague (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "once_cell::race::once_box::OnceBox")
                  []
                  [ Ty.path "revm_precompile::Precompiles" ],
                "get_or_init",
                [],
                [
                  Ty.function
                    [ Ty.tuple [] ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "revm_precompile::Precompiles"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.get_constant "revm_precompile::prague::INSTANCE" |) |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.read (|
                                    let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "revm_precompile::Precompiles",
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            Ty.path "revm_precompile::Precompiles",
                                            [],
                                            [],
                                            "clone",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "revm_precompile::Precompiles" ],
                                                  M.get_associated_function (|
                                                    Ty.path "revm_precompile::Precompiles",
                                                    "cancun",
                                                    [],
                                                    []
                                                  |),
                                                  []
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                      M.copy (|
                                        let~ precompiles : Ty.path "revm_precompile::Precompiles" :=
                                          M.copy (| precompiles |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.tuple [],
                                              M.get_associated_function (|
                                                Ty.path "revm_precompile::Precompiles",
                                                "extend",
                                                [],
                                                [ Ty.associated_unknown ]
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.MutRef, precompiles |);
                                                M.call_closure (|
                                                  Ty.associated_unknown,
                                                  M.get_function (|
                                                    "revm_precompile::bls12_381::precompiles",
                                                    [],
                                                    []
                                                  |),
                                                  []
                                                |)
                                              ]
                                            |)
                                          |) in
                                        precompiles
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path "revm_precompile::Precompiles";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path "revm_precompile::Precompiles";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.read (| precompiles |) ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_prague : M.IsAssociatedFunction Self "prague" prague.
  Smpl Add apply AssociatedFunction_prague : is_associated.
  
  (*
      pub fn latest() -> &'static Self {
          Self::prague()
      }
  *)
  Definition latest (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.apply (Ty.path "&") [] [ Ty.path "revm_precompile::Precompiles" ],
          M.get_associated_function (| Ty.path "revm_precompile::Precompiles", "prague", [], [] |),
          []
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_latest : M.IsAssociatedFunction Self "latest" latest.
  Smpl Add apply AssociatedFunction_latest : is_associated.
  
  (*
      pub fn addresses(&self) -> impl ExactSizeIterator<Item = &Address> {
          self.inner.keys()
      }
  *)
  Definition addresses (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "std::collections::hash::map::Keys")
            []
            [
              Ty.path "alloy_primitives::bits::address::Address";
              Ty.function
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                  Ty.path "u64"
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.path "revm_precompile::interface::PrecompileOutput";
                    Ty.path "revm_precompile::interface::PrecompileErrors"
                  ])
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.function
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                    Ty.path "u64"
                  ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "revm_precompile::interface::PrecompileOutput";
                      Ty.path "revm_precompile::interface::PrecompileErrors"
                    ]);
                Ty.path "std::hash::random::RandomState"
              ],
            "keys",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::Precompiles",
                "inner"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_addresses : M.IsAssociatedFunction Self "addresses" addresses.
  Smpl Add apply AssociatedFunction_addresses : is_associated.
  
  (*
      pub fn into_addresses(self) -> impl ExactSizeIterator<Item = Address> {
          self.inner.into_keys()
      }
  *)
  Definition into_addresses (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "std::collections::hash::map::IntoKeys")
            []
            [
              Ty.path "alloy_primitives::bits::address::Address";
              Ty.function
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                  Ty.path "u64"
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.path "revm_precompile::interface::PrecompileOutput";
                    Ty.path "revm_precompile::interface::PrecompileErrors"
                  ])
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.function
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                    Ty.path "u64"
                  ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "revm_precompile::interface::PrecompileOutput";
                      Ty.path "revm_precompile::interface::PrecompileErrors"
                    ]);
                Ty.path "std::hash::random::RandomState"
              ],
            "into_keys",
            [],
            []
          |),
          [
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "revm_precompile::Precompiles",
                "inner"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_into_addresses :
    M.IsAssociatedFunction Self "into_addresses" into_addresses.
  Smpl Add apply AssociatedFunction_into_addresses : is_associated.
  
  (*
      pub fn contains(&self, address: &Address) -> bool {
          self.inner.contains_key(address)
      }
  *)
  Definition contains (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; address ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let address := M.alloc (| address |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.function
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                    Ty.path "u64"
                  ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "revm_precompile::interface::PrecompileOutput";
                      Ty.path "revm_precompile::interface::PrecompileErrors"
                    ]);
                Ty.path "std::hash::random::RandomState"
              ],
            "contains_key",
            [],
            [ Ty.path "alloy_primitives::bits::address::Address" ]
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::Precompiles",
                "inner"
              |)
            |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_contains : M.IsAssociatedFunction Self "contains" contains.
  Smpl Add apply AssociatedFunction_contains : is_associated.
  
  (*
      pub fn get(&self, address: &Address) -> Option<&PrecompileFn> {
          self.inner.get(address)
      }
  *)
  Definition get (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; address ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let address := M.alloc (| address |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::option::Option")
            []
            [
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.function
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                      Ty.path "u64"
                    ]
                    (Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "revm_precompile::interface::PrecompileOutput";
                        Ty.path "revm_precompile::interface::PrecompileErrors"
                      ])
                ]
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.function
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                    Ty.path "u64"
                  ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "revm_precompile::interface::PrecompileOutput";
                      Ty.path "revm_precompile::interface::PrecompileErrors"
                    ]);
                Ty.path "std::hash::random::RandomState"
              ],
            "get",
            [],
            [ Ty.path "alloy_primitives::bits::address::Address" ]
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::Precompiles",
                "inner"
              |)
            |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
  Smpl Add apply AssociatedFunction_get : is_associated.
  
  (*
      pub fn get_mut(&mut self, address: &Address) -> Option<&mut PrecompileFn> {
          self.inner.get_mut(address)
      }
  *)
  Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; address ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let address := M.alloc (| address |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::option::Option")
            []
            [
              Ty.apply
                (Ty.path "&mut")
                []
                [
                  Ty.function
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                      Ty.path "u64"
                    ]
                    (Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "revm_precompile::interface::PrecompileOutput";
                        Ty.path "revm_precompile::interface::PrecompileErrors"
                      ])
                ]
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.function
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                    Ty.path "u64"
                  ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "revm_precompile::interface::PrecompileOutput";
                      Ty.path "revm_precompile::interface::PrecompileErrors"
                    ]);
                Ty.path "std::hash::random::RandomState"
              ],
            "get_mut",
            [],
            [ Ty.path "alloy_primitives::bits::address::Address" ]
          |),
          [
            M.borrow (|
              Pointer.Kind.MutRef,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::Precompiles",
                "inner"
              |)
            |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_get_mut : M.IsAssociatedFunction Self "get_mut" get_mut.
  Smpl Add apply AssociatedFunction_get_mut : is_associated.
  
  (*
      pub fn is_empty(&self) -> bool {
          self.inner.len() == 0
      }
  *)
  Definition is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        BinOp.eq (|
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "std::collections::hash::map::HashMap")
                []
                [
                  Ty.path "alloy_primitives::bits::address::Address";
                  Ty.function
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                      Ty.path "u64"
                    ]
                    (Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "revm_precompile::interface::PrecompileOutput";
                        Ty.path "revm_precompile::interface::PrecompileErrors"
                      ]);
                  Ty.path "std::hash::random::RandomState"
                ],
              "len",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_precompile::Precompiles",
                  "inner"
                |)
              |)
            ]
          |),
          Value.Integer IntegerKind.Usize 0
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_is_empty : M.IsAssociatedFunction Self "is_empty" is_empty.
  Smpl Add apply AssociatedFunction_is_empty : is_associated.
  
  (*
      pub fn len(&self) -> usize {
          self.inner.len()
      }
  *)
  Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::collections::hash::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.function
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                    Ty.path "u64"
                  ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "revm_precompile::interface::PrecompileOutput";
                      Ty.path "revm_precompile::interface::PrecompileErrors"
                    ]);
                Ty.path "std::hash::random::RandomState"
              ],
            "len",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::Precompiles",
                "inner"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_len : M.IsAssociatedFunction Self "len" len.
  Smpl Add apply AssociatedFunction_len : is_associated.
  
  (*
      pub fn addresses_set(&self) -> &HashSet<Address> {
          &self.addresses
      }
  *)
  Definition addresses_set (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::Precompiles",
                "addresses"
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_addresses_set :
    M.IsAssociatedFunction Self "addresses_set" addresses_set.
  Smpl Add apply AssociatedFunction_addresses_set : is_associated.
  
  (*
      pub fn extend(&mut self, other: impl IntoIterator<Item = PrecompileWithAddress>) {
          let items: Vec<PrecompileWithAddress> = other.into_iter().collect::<Vec<_>>();
          self.addresses.extend(items.iter().map(|p| *p.address()));
          self.inner.extend(items.into_iter().map(|p| (p.0, p.1)));
      }
  *)
  Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ impl_IntoIterator_Item___PrecompileWithAddress_ ], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        M.read (|
          let~ items :
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "revm_precompile::PrecompileWithAddress"; Ty.path "alloc::alloc::Global"
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "revm_precompile::PrecompileWithAddress"; Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.associated_in_trait
                    "core::iter::traits::collect::IntoIterator"
                    []
                    []
                    impl_IntoIterator_Item___PrecompileWithAddress_
                    "IntoIter",
                  [],
                  [],
                  "collect",
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "revm_precompile::PrecompileWithAddress";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      impl_IntoIterator_Item___PrecompileWithAddress_
                      "IntoIter",
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      impl_IntoIterator_Item___PrecompileWithAddress_,
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| other |) ]
                  |)
                ]
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::iter::traits::collect::Extend",
                  Ty.apply
                    (Ty.path "std::collections::hash::set::HashSet")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.path "std::hash::random::RandomState"
                    ],
                  [],
                  [ Ty.path "alloy_primitives::bits::address::Address" ],
                  "extend",
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          []
                          [ Ty.path "revm_precompile::PrecompileWithAddress" ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                              ]
                          ]
                          (Ty.path "alloy_primitives::bits::address::Address")
                      ]
                  ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_precompile::Precompiles",
                      "addresses"
                    |)
                  |);
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          []
                          [ Ty.path "revm_precompile::PrecompileWithAddress" ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                              ]
                          ]
                          (Ty.path "alloy_primitives::bits::address::Address")
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.path "revm_precompile::PrecompileWithAddress" ],
                      [],
                      [],
                      "map",
                      [],
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                              ]
                          ]
                          (Ty.path "alloy_primitives::bits::address::Address")
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          []
                          [ Ty.path "revm_precompile::PrecompileWithAddress" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.path "revm_precompile::PrecompileWithAddress" ],
                          "iter",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.path "revm_precompile::PrecompileWithAddress" ]
                                  ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path "revm_precompile::PrecompileWithAddress";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, items |) ]
                              |)
                            |)
                          |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let p := M.copy (| γ |) in
                                        M.read (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "alloy_primitives::bits::address::Address"
                                                ],
                                              M.get_associated_function (|
                                                Ty.path "revm_precompile::PrecompileWithAddress",
                                                "address",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| p |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::iter::traits::collect::Extend",
                  Ty.apply
                    (Ty.path "std::collections::hash::map::HashMap")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.function
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                          Ty.path "u64"
                        ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "revm_precompile::interface::PrecompileOutput";
                            Ty.path "revm_precompile::interface::PrecompileErrors"
                          ]);
                      Ty.path "std::hash::random::RandomState"
                    ],
                  [],
                  [
                    Ty.tuple
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.function
                          [
                            Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                            Ty.path "u64"
                          ]
                          (Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.path "revm_precompile::interface::PrecompileOutput";
                              Ty.path "revm_precompile::interface::PrecompileErrors"
                            ])
                      ]
                  ],
                  "extend",
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          []
                          [
                            Ty.path "revm_precompile::PrecompileWithAddress";
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.function
                          [ Ty.tuple [ Ty.path "revm_precompile::PrecompileWithAddress" ] ]
                          (Ty.tuple
                            [
                              Ty.path "alloy_primitives::bits::address::Address";
                              Ty.function
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                                  Ty.path "u64"
                                ]
                                (Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "revm_precompile::interface::PrecompileOutput";
                                    Ty.path "revm_precompile::interface::PrecompileErrors"
                                  ])
                            ])
                      ]
                  ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_precompile::Precompiles",
                      "inner"
                    |)
                  |);
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          []
                          [
                            Ty.path "revm_precompile::PrecompileWithAddress";
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.function
                          [ Ty.tuple [ Ty.path "revm_precompile::PrecompileWithAddress" ] ]
                          (Ty.tuple
                            [
                              Ty.path "alloy_primitives::bits::address::Address";
                              Ty.function
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                                  Ty.path "u64"
                                ]
                                (Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "revm_precompile::interface::PrecompileOutput";
                                    Ty.path "revm_precompile::interface::PrecompileErrors"
                                  ])
                            ])
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        []
                        [
                          Ty.path "revm_precompile::PrecompileWithAddress";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [],
                      "map",
                      [],
                      [
                        Ty.tuple
                          [
                            Ty.path "alloy_primitives::bits::address::Address";
                            Ty.function
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                                Ty.path "u64"
                              ]
                              (Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "revm_precompile::interface::PrecompileOutput";
                                  Ty.path "revm_precompile::interface::PrecompileErrors"
                                ])
                          ];
                        Ty.function
                          [ Ty.tuple [ Ty.path "revm_precompile::PrecompileWithAddress" ] ]
                          (Ty.tuple
                            [
                              Ty.path "alloy_primitives::bits::address::Address";
                              Ty.function
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                                  Ty.path "u64"
                                ]
                                (Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "revm_precompile::interface::PrecompileOutput";
                                    Ty.path "revm_precompile::interface::PrecompileErrors"
                                  ])
                            ])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          []
                          [
                            Ty.path "revm_precompile::PrecompileWithAddress";
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "revm_precompile::PrecompileWithAddress";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [ M.read (| items |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let p := M.copy (| γ |) in
                                        Value.Tuple
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_tuple_field (|
                                                p,
                                                "revm_precompile::PrecompileWithAddress",
                                                0
                                              |)
                                            |);
                                            M.read (|
                                              M.SubPointer.get_struct_tuple_field (|
                                                p,
                                                "revm_precompile::PrecompileWithAddress",
                                                1
                                              |)
                                            |)
                                          ]))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_extend : M.IsAssociatedFunction Self "extend" extend.
  Smpl Add apply AssociatedFunction_extend : is_associated.
End Impl_revm_precompile_Precompiles.

(* StructTuple
  {
    name := "PrecompileWithAddress";
    const_params := [];
    ty_params := [];
    fields :=
      [
        Ty.path "alloy_primitives::bits::address::Address";
        Ty.function
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ]; Ty.path "u64" ]
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.path "revm_precompile::interface::PrecompileOutput";
              Ty.path "revm_precompile::interface::PrecompileErrors"
            ])
      ];
  } *)

Module Impl_core_clone_Clone_for_revm_precompile_PrecompileWithAddress.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileWithAddress".
  
  (* Clone *)
  Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        Value.StructTuple
          "revm_precompile::PrecompileWithAddress"
          [
            M.call_closure (|
              Ty.path "alloy_primitives::bits::address::Address",
              M.get_trait_method (|
                "core::clone::Clone",
                Ty.path "alloy_primitives::bits::address::Address",
                [],
                [],
                "clone",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_precompile::PrecompileWithAddress",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |);
            M.call_closure (|
              Ty.function
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                  Ty.path "u64"
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.path "revm_precompile::interface::PrecompileOutput";
                    Ty.path "revm_precompile::interface::PrecompileErrors"
                  ]),
              M.get_trait_method (|
                "core::clone::Clone",
                Ty.function
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                    Ty.path "u64"
                  ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "revm_precompile::interface::PrecompileOutput";
                      Ty.path "revm_precompile::interface::PrecompileErrors"
                    ]),
                [],
                [],
                "clone",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_precompile::PrecompileWithAddress",
                        1
                      |)
                    |)
                  |)
                |)
              ]
            |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_revm_precompile_PrecompileWithAddress.

Module Impl_core_fmt_Debug_for_revm_precompile_PrecompileWithAddress.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileWithAddress".
  
  (* Debug *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_associated_function (|
            Ty.path "core::fmt::Formatter",
            "debug_tuple_field2_finish",
            [],
            []
          |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (| M.read (| Value.String "PrecompileWithAddress" |) |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_precompile::PrecompileWithAddress",
                    0
                  |)
                |)
              |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_precompile::PrecompileWithAddress",
                        1
                      |)
                    |)
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_revm_precompile_PrecompileWithAddress.

Module Impl_core_convert_From_Tuple_alloy_primitives_bits_address_Address_ref__alloy_primitives_bytes__Bytesu64Tocore_result_Result_revm_precompile_interface_PrecompileOutput_revm_precompile_interface_PrecompileErrors__for_revm_precompile_PrecompileWithAddress.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileWithAddress".
  
  (*
      fn from(value: (Address, PrecompileFn)) -> Self {
          PrecompileWithAddress(value.0, value.1)
      }
  *)
  Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ value ] =>
      ltac:(M.monadic
        (let value := M.alloc (| value |) in
        Value.StructTuple
          "revm_precompile::PrecompileWithAddress"
          [
            M.read (| M.SubPointer.get_tuple_field (| value, 0 |) |);
            M.read (| M.SubPointer.get_tuple_field (| value, 1 |) |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *)
      [
        Ty.tuple
          [
            Ty.path "alloy_primitives::bits::address::Address";
            Ty.function
              [
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                Ty.path "u64"
              ]
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "revm_precompile::interface::PrecompileOutput";
                  Ty.path "revm_precompile::interface::PrecompileErrors"
                ])
          ]
      ]
      Self
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_Tuple_alloy_primitives_bits_address_Address_ref__alloy_primitives_bytes__Bytesu64Tocore_result_Result_revm_precompile_interface_PrecompileOutput_revm_precompile_interface_PrecompileErrors__for_revm_precompile_PrecompileWithAddress.

Module Impl_core_convert_From_revm_precompile_PrecompileWithAddress_for_Tuple_alloy_primitives_bits_address_Address_ref__alloy_primitives_bytes__Bytesu64Tocore_result_Result_revm_precompile_interface_PrecompileOutput_revm_precompile_interface_PrecompileErrors_.
  Definition Self : Ty.t :=
    Ty.tuple
      [
        Ty.path "alloy_primitives::bits::address::Address";
        Ty.function
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bytes_::Bytes" ]; Ty.path "u64" ]
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.path "revm_precompile::interface::PrecompileOutput";
              Ty.path "revm_precompile::interface::PrecompileErrors"
            ])
      ].
  
  (*
      fn from(value: PrecompileWithAddress) -> Self {
          (value.0, value.1)
      }
  *)
  Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ value ] =>
      ltac:(M.monadic
        (let value := M.alloc (| value |) in
        Value.Tuple
          [
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                value,
                "revm_precompile::PrecompileWithAddress",
                0
              |)
            |);
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                value,
                "revm_precompile::PrecompileWithAddress",
                1
              |)
            |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "revm_precompile::PrecompileWithAddress" ]
      Self
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_revm_precompile_PrecompileWithAddress_for_Tuple_alloy_primitives_bits_address_Address_ref__alloy_primitives_bytes__Bytesu64Tocore_result_Result_revm_precompile_interface_PrecompileOutput_revm_precompile_interface_PrecompileErrors_.

Module Impl_revm_precompile_PrecompileWithAddress.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileWithAddress".
  
  (*
      pub fn address(&self) -> &Address {
          &self.0
      }
  *)
  Definition address (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::PrecompileWithAddress",
                0
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_address : M.IsAssociatedFunction Self "address" address.
  Smpl Add apply AssociatedFunction_address : is_associated.
  
  (*
      pub fn precompile(&self) -> &PrecompileFn {
          &self.1
      }
  *)
  Definition precompile (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "revm_precompile::PrecompileWithAddress",
                1
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_precompile : M.IsAssociatedFunction Self "precompile" precompile.
  Smpl Add apply AssociatedFunction_precompile : is_associated.
End Impl_revm_precompile_PrecompileWithAddress.

(*
Enum PrecompileSpecId
{
  const_params := [];
  ty_params := [];
  variants :=
    [
      {
        name := "HOMESTEAD";
        item := StructTuple [];
      };
      {
        name := "BYZANTIUM";
        item := StructTuple [];
      };
      {
        name := "ISTANBUL";
        item := StructTuple [];
      };
      {
        name := "BERLIN";
        item := StructTuple [];
      };
      {
        name := "CANCUN";
        item := StructTuple [];
      };
      {
        name := "PRAGUE";
        item := StructTuple [];
      };
      {
        name := "LATEST";
        item := StructTuple [];
      }
    ];
}
*)

Axiom IsDiscriminant_PrecompileSpecId_HOMESTEAD :
  M.IsDiscriminant "revm_precompile::PrecompileSpecId::HOMESTEAD" 0.
Axiom IsDiscriminant_PrecompileSpecId_BYZANTIUM :
  M.IsDiscriminant "revm_precompile::PrecompileSpecId::BYZANTIUM" 1.
Axiom IsDiscriminant_PrecompileSpecId_ISTANBUL :
  M.IsDiscriminant "revm_precompile::PrecompileSpecId::ISTANBUL" 2.
Axiom IsDiscriminant_PrecompileSpecId_BERLIN :
  M.IsDiscriminant "revm_precompile::PrecompileSpecId::BERLIN" 3.
Axiom IsDiscriminant_PrecompileSpecId_CANCUN :
  M.IsDiscriminant "revm_precompile::PrecompileSpecId::CANCUN" 4.
Axiom IsDiscriminant_PrecompileSpecId_PRAGUE :
  M.IsDiscriminant "revm_precompile::PrecompileSpecId::PRAGUE" 5.
Axiom IsDiscriminant_PrecompileSpecId_LATEST :
  M.IsDiscriminant "revm_precompile::PrecompileSpecId::LATEST" 6.

Module Impl_core_marker_Copy_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::Copy"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_core_marker_Copy_for_revm_precompile_PrecompileSpecId.

Module Impl_core_clone_Clone_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (* Clone *)
  Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (| M.deref (| M.read (| self |) |) |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_revm_precompile_PrecompileSpecId.

Module Impl_core_fmt_Debug_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (* Debug *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
            M.read (|
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::HOMESTEAD" |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "HOMESTEAD" |) |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::BYZANTIUM" |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "BYZANTIUM" |) |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::ISTANBUL" |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "ISTANBUL" |) |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::BERLIN" |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "BERLIN" |) |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::CANCUN" |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "CANCUN" |) |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::PRAGUE" |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "PRAGUE" |) |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (| γ, "revm_precompile::PrecompileSpecId::LATEST" |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "LATEST" |) |)
                        |)
                      |)))
                ]
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_revm_precompile_PrecompileSpecId.

Module Impl_core_marker_StructuralPartialEq_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_revm_precompile_PrecompileSpecId.

Module Impl_core_cmp_PartialEq_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (* PartialEq *)
  Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_precompile::PrecompileSpecId" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |) in
          let~ __arg1_discr : Ty.path "isize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_precompile::PrecompileSpecId" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |)
            |) in
          M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_for_revm_precompile_PrecompileSpecId.

Module Impl_core_cmp_Eq_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (* Eq *)
  Definition assert_receiver_is_total_eq
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *)
      [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_revm_precompile_PrecompileSpecId.

Module Impl_core_hash_Hash_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (* Hash *)
  Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ __H ], [ self; state ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let state := M.alloc (| state |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_precompile::PrecompileSpecId" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.path "isize",
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::hash::Hash"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("hash", InstanceField.Method hash) ].
End Impl_core_hash_Hash_for_revm_precompile_PrecompileSpecId.

Module Impl_core_cmp_Ord_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (* Ord *)
  Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_precompile::PrecompileSpecId" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |) in
          let~ __arg1_discr : Ty.path "isize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_precompile::PrecompileSpecId" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], [], "cmp", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Ord"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
End Impl_core_cmp_Ord_for_revm_precompile_PrecompileSpecId.

Module Impl_core_cmp_PartialOrd_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (* PartialOrd *)
  Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        M.read (|
          let~ __self_discr : Ty.path "isize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_precompile::PrecompileSpecId" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |) in
          let~ __arg1_discr : Ty.path "isize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "revm_precompile::PrecompileSpecId" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.path "isize",
                [],
                [ Ty.path "isize" ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialOrd"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
End Impl_core_cmp_PartialOrd_for_revm_precompile_PrecompileSpecId.

Module Impl_core_convert_From_revm_specification_hardfork_SpecId_for_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (*
      fn from(spec_id: SpecId) -> Self {
          Self::from_spec_id(spec_id)
      }
  *)
  Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ spec_id ] =>
      ltac:(M.monadic
        (let spec_id := M.alloc (| spec_id |) in
        M.call_closure (|
          Ty.path "revm_precompile::PrecompileSpecId",
          M.get_associated_function (|
            Ty.path "revm_precompile::PrecompileSpecId",
            "from_spec_id",
            [],
            []
          |),
          [ M.read (| spec_id |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::convert::From"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "revm_specification::hardfork::SpecId" ]
      Self
      (* Instance *) [ ("from", InstanceField.Method from) ].
End Impl_core_convert_From_revm_specification_hardfork_SpecId_for_revm_precompile_PrecompileSpecId.

Module Impl_revm_precompile_PrecompileSpecId.
  Definition Self : Ty.t := Ty.path "revm_precompile::PrecompileSpecId".
  
  (*
      pub const fn from_spec_id(spec_id: specification::hardfork::SpecId) -> Self {
          use specification::hardfork::SpecId::*;
          match spec_id {
              FRONTIER | FRONTIER_THAWING | HOMESTEAD | DAO_FORK | TANGERINE | SPURIOUS_DRAGON => {
                  Self::HOMESTEAD
              }
              BYZANTIUM | CONSTANTINOPLE | PETERSBURG => Self::BYZANTIUM,
              ISTANBUL | MUIR_GLACIER => Self::ISTANBUL,
              BERLIN | LONDON | ARROW_GLACIER | GRAY_GLACIER | MERGE | SHANGHAI => Self::BERLIN,
              CANCUN => Self::CANCUN,
              PRAGUE | OSAKA => Self::PRAGUE,
              LATEST => Self::LATEST,
          }
      }
  *)
  Definition from_spec_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ spec_id ] =>
      ltac:(M.monadic
        (let spec_id := M.alloc (| spec_id |) in
        M.read (|
          M.match_operator (|
            spec_id,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::FRONTIER"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::FRONTIER_THAWING"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::HOMESTEAD"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::DAO_FORK"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::TANGERINE"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::SPURIOUS_DRAGON"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "revm_precompile::PrecompileSpecId::HOMESTEAD" []
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::BYZANTIUM"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::CONSTANTINOPLE"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::PETERSBURG"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "revm_precompile::PrecompileSpecId::BYZANTIUM" []
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::ISTANBUL"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::MUIR_GLACIER"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "revm_precompile::PrecompileSpecId::ISTANBUL" []
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::BERLIN"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::LONDON"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::ARROW_GLACIER"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::GRAY_GLACIER"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::MERGE"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::SHANGHAI"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "revm_precompile::PrecompileSpecId::BERLIN" []
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_specification::hardfork::SpecId::CANCUN" |) in
                  M.alloc (| Value.StructTuple "revm_precompile::PrecompileSpecId::CANCUN" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::PRAGUE"
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "revm_specification::hardfork::SpecId::OSAKA"
                            |) in
                          Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "revm_precompile::PrecompileSpecId::PRAGUE" []
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let _ :=
                    M.is_struct_tuple (| γ, "revm_specification::hardfork::SpecId::LATEST" |) in
                  M.alloc (| Value.StructTuple "revm_precompile::PrecompileSpecId::LATEST" [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom AssociatedFunction_from_spec_id : M.IsAssociatedFunction Self "from_spec_id" from_spec_id.
  Smpl Add apply AssociatedFunction_from_spec_id : is_associated.
End Impl_revm_precompile_PrecompileSpecId.

(*
pub const fn u64_to_address(x: u64) -> Address {
    let x = x.to_be_bytes();
    Address::new([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],
    ])
}
*)
Definition u64_to_address (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ x ] =>
    ltac:(M.monadic
      (let x := M.alloc (| x |) in
      M.read (|
        let~ x :
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ] :=
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
              M.get_associated_function (| Ty.path "u64", "to_be_bytes", [], [] |),
              [ M.read (| x |) ]
            |)
          |) in
        M.alloc (|
          M.call_closure (|
            Ty.path "alloy_primitives::bits::address::Address",
            M.get_associated_function (|
              Ty.path "alloy_primitives::bits::address::Address",
              "new",
              [],
              []
            |),
            [
              Value.Array
                [
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  Value.Integer IntegerKind.U8 0;
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 1 |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 2 |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 3 |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 4 |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 5 |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 6 |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (| x, Value.Integer IntegerKind.Usize 7 |)
                  |)
                ]
            ]
          |)
        |)
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Axiom Function_u64_to_address : M.IsFunction "revm_precompile::u64_to_address" u64_to_address.
Smpl Add apply Function_u64_to_address : is_function.
