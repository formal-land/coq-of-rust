(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module cfg.
  (* StructRecord
    {
      name := "CfgEnv";
      const_params := [];
      ty_params := [ "SPEC" ];
      fields :=
        [
          ("chain_id", Ty.path "u64");
          ("spec", SPEC);
          ("limit_contract_code_size",
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]);
          ("disable_nonce_check", Ty.path "bool")
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
    Definition Self (SPEC : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::cfg::CfgEnv") [] [ SPEC ].
    
    (* Clone *)
    Definition clone (SPEC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "revm_context::cfg::CfgEnv"
            [
              ("chain_id",
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", Ty.path "u64", [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::cfg::CfgEnv",
                      "chain_id"
                    |)
                  ]
                |));
              ("spec",
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", SPEC, [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::cfg::CfgEnv",
                      "spec"
                    |)
                  ]
                |));
              ("limit_contract_code_size",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::cfg::CfgEnv",
                      "limit_contract_code_size"
                    |)
                  ]
                |));
              ("disable_nonce_check",
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", Ty.path "bool", [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::cfg::CfgEnv",
                      "disable_nonce_check"
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SPEC : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self SPEC)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone SPEC)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
    Definition Self (SPEC : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::cfg::CfgEnv") [] [ SPEC ].
    
    (* Debug *)
    Definition fmt (SPEC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field4_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "CfgEnv" |);
              M.read (| Value.String "chain_id" |);
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context::cfg::CfgEnv",
                "chain_id"
              |);
              M.read (| Value.String "spec" |);
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context::cfg::CfgEnv",
                "spec"
              |);
              M.read (| Value.String "limit_contract_code_size" |);
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context::cfg::CfgEnv",
                "limit_contract_code_size"
              |);
              M.read (| Value.String "disable_nonce_check" |);
              M.alloc (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_context::cfg::CfgEnv",
                  "disable_nonce_check"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SPEC : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self SPEC)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt SPEC)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
    Definition Self (SPEC : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::cfg::CfgEnv") [] [ SPEC ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SPEC : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self SPEC)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq SPEC))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
  
  Module Impl_core_marker_StructuralPartialEq_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
    Definition Self (SPEC : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::cfg::CfgEnv") [] [ SPEC ].
    
    Axiom Implements :
      forall (SPEC : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self SPEC)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
    Definition Self (SPEC : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::cfg::CfgEnv") [] [ SPEC ].
    
    (* PartialEq *)
    Definition eq (SPEC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::cfg::CfgEnv",
                      "chain_id"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "revm_context::cfg::CfgEnv",
                      "chain_id"
                    |)
                  |)
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (| "core::cmp::PartialEq", SPEC, [ SPEC ], "eq", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm_context::cfg::CfgEnv",
                        "spec"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "revm_context::cfg::CfgEnv",
                        "spec"
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                    [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] ],
                    "eq",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::cfg::CfgEnv",
                      "limit_contract_code_size"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "revm_context::cfg::CfgEnv",
                      "limit_contract_code_size"
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_context::cfg::CfgEnv",
                    "disable_nonce_check"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "revm_context::cfg::CfgEnv",
                    "disable_nonce_check"
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SPEC : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self SPEC)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq SPEC)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_SPEC_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_for_revm_context_cfg_CfgEnv_SPEC.
  
  Module Impl_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::cfg::CfgEnv")
        []
        [ Ty.path "revm_specification::hardfork::SpecId" ].
    
    (*
        pub fn with_chain_id(mut self, chain_id: u64) -> Self {
            self.chain_id = chain_id;
            self
        }
    *)
    Definition with_chain_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; chain_id ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let chain_id := M.alloc (| chain_id |) in
          M.read (|
            let~ _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "revm_context::cfg::CfgEnv",
                  "chain_id"
                |),
                M.read (| chain_id |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_with_chain_id :
      M.IsAssociatedFunction Self "with_chain_id" with_chain_id.
  End Impl_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId.
  
  Module Impl_revm_context_interface_cfg_Cfg_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_where_core_marker_Copy_SPEC_for_revm_context_cfg_CfgEnv_SPEC.
    Definition Self (SPEC : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::cfg::CfgEnv") [] [ SPEC ].
    
    (*     type Spec = SPEC; *)
    Definition _Spec (SPEC : Ty.t) : Ty.t := SPEC.
    
    (*
        fn chain_id(&self) -> u64 {
            self.chain_id
        }
    *)
    Definition chain_id (SPEC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_context::cfg::CfgEnv",
              "chain_id"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn spec(&self) -> Self::Spec {
            self.spec
        }
    *)
    Definition spec (SPEC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_context::cfg::CfgEnv",
              "spec"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn max_code_size(&self) -> usize {
            self.limit_contract_code_size.unwrap_or(MAX_CODE_SIZE)
        }
    *)
    Definition max_code_size
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
              "unwrap_or",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_context::cfg::CfgEnv",
                  "limit_contract_code_size"
                |)
              |);
              M.read (| M.get_constant (| "revm_specification::constants::MAX_CODE_SIZE" |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_eip3607_disabled(&self) -> bool {
            cfg_if::cfg_if! {
                if #[cfg(feature = "optional_eip3607")] {
                    self.disable_eip3607
                } else {
                    false
                }
            }
        }
    *)
    Definition is_eip3607_disabled
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_balance_check_disabled(&self) -> bool {
            cfg_if::cfg_if! {
                if #[cfg(feature = "optional_balance_check")] {
                    self.disable_balance_check
                } else {
                    false
                }
            }
        }
    *)
    Definition is_balance_check_disabled
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_gas_refund_disabled(&self) -> bool {
            cfg_if::cfg_if! {
                if #[cfg(feature = "optional_gas_refund")] {
                    self.disable_gas_refund
                } else {
                    false
                }
            }
        }
    *)
    Definition is_gas_refund_disabled
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_block_gas_limit_disabled(&self) -> bool {
            cfg_if::cfg_if! {
                if #[cfg(feature = "optional_block_gas_limit")] {
                    self.disable_block_gas_limit
                } else {
                    false
                }
            }
        }
    *)
    Definition is_block_gas_limit_disabled
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_nonce_check_disabled(&self) -> bool {
            self.disable_nonce_check
        }
    *)
    Definition is_nonce_check_disabled
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "revm_context::cfg::CfgEnv",
              "disable_nonce_check"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_base_fee_check_disabled(&self) -> bool {
            cfg_if::cfg_if! {
                if #[cfg(feature = "optional_no_base_fee")] {
                    self.disable_base_fee
                } else {
                    false
                }
            }
        }
    *)
    Definition is_base_fee_check_disabled
        (SPEC : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SPEC in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SPEC : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::cfg::Cfg"
        (Self SPEC)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Spec", InstanceField.Ty (_Spec SPEC));
          ("chain_id", InstanceField.Method (chain_id SPEC));
          ("spec", InstanceField.Method (spec SPEC));
          ("max_code_size", InstanceField.Method (max_code_size SPEC));
          ("is_eip3607_disabled", InstanceField.Method (is_eip3607_disabled SPEC));
          ("is_balance_check_disabled", InstanceField.Method (is_balance_check_disabled SPEC));
          ("is_gas_refund_disabled", InstanceField.Method (is_gas_refund_disabled SPEC));
          ("is_block_gas_limit_disabled", InstanceField.Method (is_block_gas_limit_disabled SPEC));
          ("is_nonce_check_disabled", InstanceField.Method (is_nonce_check_disabled SPEC));
          ("is_base_fee_check_disabled", InstanceField.Method (is_base_fee_check_disabled SPEC))
        ].
  End Impl_revm_context_interface_cfg_Cfg_where_core_convert_Into_SPEC_revm_specification_hardfork_SpecId_where_core_marker_Copy_SPEC_for_revm_context_cfg_CfgEnv_SPEC.
  
  Module Impl_core_default_Default_for_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::cfg::CfgEnv")
        []
        [ Ty.path "revm_specification::hardfork::SpecId" ].
    
    (*
        fn default() -> Self {
            Self {
                chain_id: 1,
                limit_contract_code_size: None,
                spec: SpecId::PRAGUE,
                disable_nonce_check: false,
                #[cfg(feature = "memory_limit")]
                memory_limit: (1 << 32) - 1,
                #[cfg(feature = "optional_balance_check")]
                disable_balance_check: false,
                #[cfg(feature = "optional_block_gas_limit")]
                disable_block_gas_limit: false,
                #[cfg(feature = "optional_eip3607")]
                disable_eip3607: false,
                #[cfg(feature = "optional_gas_refund")]
                disable_gas_refund: false,
                #[cfg(feature = "optional_no_base_fee")]
                disable_base_fee: false,
            }
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "revm_context::cfg::CfgEnv"
            [
              ("chain_id", Value.Integer IntegerKind.U64 1);
              ("limit_contract_code_size", Value.StructTuple "core::option::Option::None" []);
              ("spec", Value.StructTuple "revm_specification::hardfork::SpecId::PRAGUE" []);
              ("disable_nonce_check", Value.Bool false)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId.
End cfg.
