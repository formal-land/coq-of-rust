(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module context.
  (* StructRecord
    {
      name := "Context";
      const_params := [];
      ty_params := [ "BLOCK"; "TX"; "CFG"; "DB"; "JOURNAL"; "CHAIN" ];
      fields :=
        [
          ("block", BLOCK);
          ("tx", TX);
          ("cfg", CFG);
          ("journaled_state", JOURNAL);
          ("chain", CHAIN);
          ("error", Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.associated ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_where_core_clone_Clone_BLOCK_where_core_clone_Clone_CFG_where_core_clone_Clone_CHAIN_where_core_clone_Clone_TX_where_core_clone_Clone_DB_where_core_clone_Clone_JOURNAL_where_core_clone_Clone_associated_type_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::context::Context") [] [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ].
    
    (* #[derive_where(Clone, Debug; BLOCK, CFG, CHAIN, TX, DB, JOURNAL, <DB as Database>::Error)] *)
    Definition clone
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "block"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "tx"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "cfg"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "journaled_state"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "chain"
                      |) in
                    let γ1_5 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "error"
                      |) in
                    let __field_block := M.alloc (| γ1_0 |) in
                    let __field_tx := M.alloc (| γ1_1 |) in
                    let __field_cfg := M.alloc (| γ1_2 |) in
                    let __field_journaled_state := M.alloc (| γ1_3 |) in
                    let __field_chain := M.alloc (| γ1_4 |) in
                    let __field_error := M.alloc (| γ1_5 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context::context::Context"
                        [
                          ("block",
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", BLOCK, [], "clone", [] |),
                              [ M.read (| __field_block |) ]
                            |));
                          ("tx",
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", TX, [], "clone", [] |),
                              [ M.read (| __field_tx |) ]
                            |));
                          ("cfg",
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", CFG, [], "clone", [] |),
                              [ M.read (| __field_cfg |) ]
                            |));
                          ("journaled_state",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                JOURNAL,
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __field_journaled_state |) ]
                            |));
                          ("chain",
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", CHAIN, [], "clone", [] |),
                              [ M.read (| __field_chain |) ]
                            |));
                          ("error",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.tuple []; Ty.associated ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __field_error |) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone BLOCK TX CFG DB JOURNAL CHAIN)) ].
  End Impl_core_clone_Clone_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_where_core_clone_Clone_BLOCK_where_core_clone_Clone_CFG_where_core_clone_Clone_CHAIN_where_core_clone_Clone_TX_where_core_clone_Clone_DB_where_core_clone_Clone_JOURNAL_where_core_clone_Clone_associated_type_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
  
  Module Impl_core_fmt_Debug_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_where_core_fmt_Debug_BLOCK_where_core_fmt_Debug_CFG_where_core_fmt_Debug_CHAIN_where_core_fmt_Debug_TX_where_core_fmt_Debug_DB_where_core_fmt_Debug_JOURNAL_where_core_fmt_Debug_associated_type_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::context::Context") [] [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ].
    
    (* #[derive_where(Clone, Debug; BLOCK, CFG, CHAIN, TX, DB, JOURNAL, <DB as Database>::Error)] *)
    Definition fmt
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; __f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let __f := M.alloc (| __f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "block"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "tx"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "cfg"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "journaled_state"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "chain"
                      |) in
                    let γ1_5 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context::context::Context",
                        "error"
                      |) in
                    let __field_block := M.alloc (| γ1_0 |) in
                    let __field_tx := M.alloc (| γ1_1 |) in
                    let __field_cfg := M.alloc (| γ1_2 |) in
                    let __field_journaled_state := M.alloc (| γ1_3 |) in
                    let __field_chain := M.alloc (| γ1_4 |) in
                    let __field_error := M.alloc (| γ1_5 |) in
                    let~ __builder :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_struct",
                            []
                          |),
                          [ M.read (| __f |); M.read (| Value.String "Context" |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            []
                          |),
                          [ __builder; M.read (| Value.String "block" |); M.read (| __field_block |)
                          ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            []
                          |),
                          [ __builder; M.read (| Value.String "tx" |); M.read (| __field_tx |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            []
                          |),
                          [ __builder; M.read (| Value.String "cfg" |); M.read (| __field_cfg |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            []
                          |),
                          [
                            __builder;
                            M.read (| Value.String "journaled_state" |);
                            M.read (| __field_journaled_state |)
                          ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            []
                          |),
                          [ __builder; M.read (| Value.String "chain" |); M.read (| __field_chain |)
                          ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            []
                          |),
                          [ __builder; M.read (| Value.String "error" |); M.read (| __field_error |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "finish",
                          []
                        |),
                        [ __builder ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt BLOCK TX CFG DB JOURNAL CHAIN)) ].
  End Impl_core_fmt_Debug_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_where_core_fmt_Debug_BLOCK_where_core_fmt_Debug_CFG_where_core_fmt_Debug_CHAIN_where_core_fmt_Debug_TX_where_core_fmt_Debug_DB_where_core_fmt_Debug_JOURNAL_where_core_fmt_Debug_associated_type_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
  
  Module Impl_core_default_Default_for_revm_context_context_Context_revm_context_block_BlockEnv_revm_context_tx_TxEnv_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_revm_context_journaled_state_JournaledState_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_Tuple_.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [
          Ty.path "revm_context::block::BlockEnv";
          Ty.path "revm_context::tx::TxEnv";
          Ty.apply
            (Ty.path "revm_context::cfg::CfgEnv")
            []
            [ Ty.path "revm_specification::hardfork::SpecId" ];
          Ty.apply
            (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
            []
            [ Ty.path "core::convert::Infallible" ];
          Ty.apply
            (Ty.path "revm_context::journaled_state::JournaledState")
            []
            [
              Ty.apply
                (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                []
                [ Ty.path "core::convert::Infallible" ]
            ];
          Ty.tuple []
        ].
    
    (*
        fn default() -> Self {
            Self::new(EmptyDB::new(), SpecId::LATEST)
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "revm_context::context::Context")
                []
                [
                  Ty.path "revm_context::block::BlockEnv";
                  Ty.path "revm_context::tx::TxEnv";
                  Ty.apply
                    (Ty.path "revm_context::cfg::CfgEnv")
                    []
                    [ Ty.path "revm_specification::hardfork::SpecId" ];
                  Ty.apply
                    (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                    []
                    [ Ty.path "core::convert::Infallible" ];
                  Ty.apply
                    (Ty.path "revm_context::journaled_state::JournaledState")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                        []
                        [ Ty.path "core::convert::Infallible" ]
                    ];
                  Ty.tuple []
                ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                    []
                    [ Ty.path "core::convert::Infallible" ],
                  "new",
                  []
                |),
                []
              |);
              Value.StructTuple "revm_specification::hardfork::SpecId::LATEST" []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_context_context_Context_revm_context_block_BlockEnv_revm_context_tx_TxEnv_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_revm_context_journaled_state_JournaledState_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_Tuple_.
  
  Module Impl_revm_context_context_Context_revm_context_block_BlockEnv_revm_context_tx_TxEnv_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_revm_context_journaled_state_JournaledState_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_Tuple_.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [
          Ty.path "revm_context::block::BlockEnv";
          Ty.path "revm_context::tx::TxEnv";
          Ty.apply
            (Ty.path "revm_context::cfg::CfgEnv")
            []
            [ Ty.path "revm_specification::hardfork::SpecId" ];
          Ty.apply
            (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
            []
            [ Ty.path "core::convert::Infallible" ];
          Ty.apply
            (Ty.path "revm_context::journaled_state::JournaledState")
            []
            [
              Ty.apply
                (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                []
                [ Ty.path "core::convert::Infallible" ]
            ];
          Ty.tuple []
        ].
    
    (*
        pub fn builder() -> Self {
            Self::new(EmptyDB::new(), SpecId::LATEST)
        }
    *)
    Definition builder (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "revm_context::context::Context")
                []
                [
                  Ty.path "revm_context::block::BlockEnv";
                  Ty.path "revm_context::tx::TxEnv";
                  Ty.apply
                    (Ty.path "revm_context::cfg::CfgEnv")
                    []
                    [ Ty.path "revm_specification::hardfork::SpecId" ];
                  Ty.apply
                    (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                    []
                    [ Ty.path "core::convert::Infallible" ];
                  Ty.apply
                    (Ty.path "revm_context::journaled_state::JournaledState")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                        []
                        [ Ty.path "core::convert::Infallible" ]
                    ];
                  Ty.tuple []
                ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "revm_database_interface::empty_db::EmptyDBTyped")
                    []
                    [ Ty.path "core::convert::Infallible" ],
                  "new",
                  []
                |),
                []
              |);
              Value.StructTuple "revm_specification::hardfork::SpecId::LATEST" []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_builder : M.IsAssociatedFunction Self "builder" builder.
  End Impl_revm_context_context_Context_revm_context_block_BlockEnv_revm_context_tx_TxEnv_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_revm_context_journaled_state_JournaledState_revm_database_interface_empty_db_EmptyDBTyped_core_convert_Infallible_Tuple_.
  
  Module Impl_revm_context_context_Context_BLOCK_TX_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [
          BLOCK;
          TX;
          Ty.apply
            (Ty.path "revm_context::cfg::CfgEnv")
            []
            [ Ty.path "revm_specification::hardfork::SpecId" ];
          DB;
          JOURNAL;
          CHAIN
        ].
    
    (*
        pub fn new(db: DB, spec: SpecId) -> Self {
            let mut journaled_state = JOURNAL::new(db);
            journaled_state.set_spec_id(spec);
            Self {
                tx: TX::default(),
                block: BLOCK::default(),
                cfg: CfgEnv {
                    spec,
                    ..Default::default()
                },
                journaled_state,
                chain: Default::default(),
                error: Ok(()),
            }
        }
    *)
    Definition new
        (BLOCK TX DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ db; spec ] =>
        ltac:(M.monadic
          (let db := M.alloc (| db |) in
          let spec := M.alloc (| spec |) in
          M.read (|
            let~ journaled_state :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_context_interface::journaled_state::Journal",
                    JOURNAL,
                    [],
                    "new",
                    []
                  |),
                  [ M.read (| db |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_context_interface::journaled_state::Journal",
                    JOURNAL,
                    [],
                    "set_spec_id",
                    []
                  |),
                  [ journaled_state; M.read (| spec |) ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "revm_context::context::Context"
                [
                  ("tx",
                    M.call_closure (|
                      M.get_trait_method (| "core::default::Default", TX, [], "default", [] |),
                      []
                    |));
                  ("block",
                    M.call_closure (|
                      M.get_trait_method (| "core::default::Default", BLOCK, [], "default", [] |),
                      []
                    |));
                  ("cfg",
                    M.struct_record_update
                      (M.call_closure (|
                        M.get_trait_method (|
                          "core::default::Default",
                          Ty.apply
                            (Ty.path "revm_context::cfg::CfgEnv")
                            []
                            [ Ty.path "revm_specification::hardfork::SpecId" ],
                          [],
                          "default",
                          []
                        |),
                        []
                      |))
                      [ ("spec", M.read (| spec |)) ]);
                  ("journaled_state", M.read (| journaled_state |));
                  ("chain",
                    M.call_closure (|
                      M.get_trait_method (| "core::default::Default", CHAIN, [], "default", [] |),
                      []
                    |));
                  ("error", Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ])
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new :
      forall (BLOCK TX DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction (Self BLOCK TX DB JOURNAL CHAIN) "new" (new BLOCK TX DB JOURNAL CHAIN).
  End Impl_revm_context_context_Context_BLOCK_TX_revm_context_cfg_CfgEnv_revm_specification_hardfork_SpecId_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::context::Context") [] [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ].
    
    (*
        pub fn code(
            &mut self,
            address: Address,
        ) -> Result<Eip7702CodeLoad<Bytes>, <DB as Database>::Error> {
            let a = self.journaled_state.load_account_code(address)?;
            // SAFETY: Safe to unwrap as load_code will insert code if it is empty.
            let code = a.info.code.as_ref().unwrap();
            if code.is_eof() {
                return Ok(Eip7702CodeLoad::new_not_delegated(
                    EOF_MAGIC_BYTES.clone(),
                    a.is_cold,
                ));
            }
    
            if let Bytecode::Eip7702(code) = code {
                let address = code.address();
                let is_cold = a.is_cold;
    
                let delegated_account = self.journaled_state.load_account_code(address)?;
    
                // SAFETY: Safe to unwrap as load_code will insert code if it is empty.
                let delegated_code = delegated_account.info.code.as_ref().unwrap();
    
                let bytes = if delegated_code.is_eof() {
                    EOF_MAGIC_BYTES.clone()
                } else {
                    delegated_code.original_bytes()
                };
    
                return Ok(Eip7702CodeLoad::new(
                    StateLoad::new(bytes, is_cold),
                    delegated_account.is_cold,
                ));
            }
    
            Ok(Eip7702CodeLoad::new_not_delegated(
                code.original_bytes(),
                a.is_cold,
            ))
        }
    *)
    Definition code
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ a :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "revm_context_interface::journaled_state::StateLoad")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "revm_state::Account" ]
                                  ];
                                Ty.associated
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "revm_context_interface::journaled_state::Journal",
                                JOURNAL,
                                [],
                                "load_account_code",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "revm_context::context::Context",
                                  "journaled_state"
                                |);
                                M.read (| address |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                              []
                                              [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                                            Ty.associated
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let~ code :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "revm_bytecode::bytecode::Bytecode" ]
                          ],
                        "unwrap",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "revm_bytecode::bytecode::Bytecode" ],
                            "as_ref",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path
                                          "revm_context_interface::journaled_state::StateLoad")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.path "revm_state::Account" ]
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ a ]
                                  |)
                                |),
                                "revm_state::Account",
                                "info"
                              |),
                              "revm_state::account_info::AccountInfo",
                              "code"
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "revm_bytecode::bytecode::Bytecode",
                                    "is_eof",
                                    []
                                  |),
                                  [ M.read (| code |) ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path
                                              "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                            []
                                            [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                          "new_not_delegated",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              Ty.path "alloy_primitives::bytes_::Bytes",
                                              [],
                                              "clone",
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.get_constant (|
                                                  "revm_bytecode::eof::EOF_MAGIC_BYTES"
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              a,
                                              "revm_context_interface::journaled_state::StateLoad",
                                              "is_cold"
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := code in
                          let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "revm_bytecode::bytecode::Bytecode::Eip7702",
                              0
                            |) in
                          let code := M.alloc (| γ1_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ address :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "revm_bytecode::eip7702::Eip7702Bytecode",
                                        "address",
                                        []
                                      |),
                                      [ M.read (| code |) ]
                                    |)
                                  |) in
                                let~ is_cold :=
                                  M.copy (|
                                    M.SubPointer.get_struct_record_field (|
                                      a,
                                      "revm_context_interface::journaled_state::StateLoad",
                                      "is_cold"
                                    |)
                                  |) in
                                let~ delegated_account :=
                                  M.copy (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "revm_context_interface::journaled_state::StateLoad")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.path "revm_state::Account" ]
                                                  ];
                                                Ty.associated
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "revm_context_interface::journaled_state::Journal",
                                                JOURNAL,
                                                [],
                                                "load_account_code",
                                                []
                                              |),
                                              [
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "revm_context::context::Context",
                                                  "journaled_state"
                                                |);
                                                M.read (| address |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "alloy_primitives::bytes_::Bytes"
                                                              ];
                                                            Ty.associated
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.associated
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |) in
                                let~ delegated_code :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.path "revm_bytecode::bytecode::Bytecode" ]
                                          ],
                                        "unwrap",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "revm_bytecode::bytecode::Bytecode" ],
                                            "as_ref",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path
                                                          "revm_context_interface::journaled_state::StateLoad")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&mut")
                                                            []
                                                            [ Ty.path "revm_state::Account" ]
                                                        ],
                                                      [],
                                                      "deref",
                                                      []
                                                    |),
                                                    [ delegated_account ]
                                                  |)
                                                |),
                                                "revm_state::Account",
                                                "info"
                                              |),
                                              "revm_state::account_info::AccountInfo",
                                              "code"
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |) in
                                let~ bytes :=
                                  M.copy (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "revm_bytecode::bytecode::Bytecode",
                                                      "is_eof",
                                                      []
                                                    |),
                                                    [ M.read (| delegated_code |) ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  Ty.path "alloy_primitives::bytes_::Bytes",
                                                  [],
                                                  "clone",
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.get_constant (|
                                                      "revm_bytecode::eof::EOF_MAGIC_BYTES"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "revm_bytecode::bytecode::Bytecode",
                                                  "original_bytes",
                                                  []
                                                |),
                                                [ M.read (| delegated_code |) ]
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |) in
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path
                                              "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                            []
                                            [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                          "new",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "revm_context_interface::journaled_state::StateLoad")
                                                []
                                                [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                              "new",
                                              []
                                            |),
                                            [ M.read (| bytes |); M.read (| is_cold |) ]
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              delegated_account,
                                              "revm_context_interface::journaled_state::StateLoad",
                                              "is_cold"
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                            []
                            [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                          "new_not_delegated",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_bytecode::bytecode::Bytecode",
                              "original_bytes",
                              []
                            |),
                            [ M.read (| code |) ]
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              a,
                              "revm_context_interface::journaled_state::StateLoad",
                              "is_cold"
                            |)
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_code :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "code"
        (code BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn with_new_journal<OJOURNAL: Journal<Database = DB>>(
            self,
            mut journal: OJOURNAL,
        ) -> Context<BLOCK, TX, CFG, DB, OJOURNAL, CHAIN> {
            journal.set_spec_id(self.cfg.spec().into());
            Context {
                tx: self.tx,
                block: self.block,
                cfg: self.cfg,
                journaled_state: journal,
                chain: self.chain,
                error: Ok(()),
            }
        }
    *)
    Definition with_new_journal
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ OJOURNAL ], [ self; journal ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let journal := M.alloc (| journal |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_context_interface::journaled_state::Journal",
                    OJOURNAL,
                    [],
                    "set_spec_id",
                    []
                  |),
                  [
                    journal;
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.associated,
                        [ Ty.path "revm_specification::hardfork::SpecId" ],
                        "into",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_context_interface::cfg::Cfg",
                            CFG,
                            [],
                            "spec",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "revm_context::context::Context",
                              "cfg"
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "revm_context::context::Context"
                [
                  ("tx",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "tx"
                      |)
                    |));
                  ("block",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "block"
                      |)
                    |));
                  ("cfg",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "cfg"
                      |)
                    |));
                  ("journaled_state", M.read (| journal |));
                  ("chain",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "chain"
                      |)
                    |));
                  ("error", Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ])
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_with_new_journal :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "with_new_journal"
        (with_new_journal BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn with_db<ODB: Database>(
            self,
            db: ODB,
        ) -> Context<BLOCK, TX, CFG, ODB, JournaledState<ODB>, CHAIN> {
            let spec = self.cfg.spec().into();
            let mut journaled_state = JournaledState::new(spec, db);
            journaled_state.set_spec_id(spec);
            Context {
                tx: self.tx,
                block: self.block,
                cfg: self.cfg,
                journaled_state,
                chain: self.chain,
                error: Ok(()),
            }
        }
    *)
    Definition with_db
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ ODB ], [ self; db ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let db := M.alloc (| db |) in
          M.read (|
            let~ spec :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.associated,
                    [ Ty.path "revm_specification::hardfork::SpecId" ],
                    "into",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "revm_context_interface::cfg::Cfg",
                        CFG,
                        [],
                        "spec",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "revm_context::context::Context",
                          "cfg"
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ journaled_state :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "revm_context::journaled_state::JournaledState") [] [ ODB ],
                    "new",
                    []
                  |),
                  [ M.read (| spec |); M.read (| db |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "revm_context::journaled_state::JournaledState") [] [ ODB ],
                    "set_spec_id",
                    []
                  |),
                  [ journaled_state; M.read (| spec |) ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "revm_context::context::Context"
                [
                  ("tx",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "tx"
                      |)
                    |));
                  ("block",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "block"
                      |)
                    |));
                  ("cfg",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "cfg"
                      |)
                    |));
                  ("journaled_state", M.read (| journaled_state |));
                  ("chain",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "chain"
                      |)
                    |));
                  ("error", Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ])
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_with_db :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "with_db"
        (with_db BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn with_block<OB: Block>(self, block: OB) -> Context<OB, TX, CFG, DB, JOURNAL, CHAIN> {
            Context {
                tx: self.tx,
                block,
                cfg: self.cfg,
                journaled_state: self.journaled_state,
                chain: self.chain,
                error: Ok(()),
            }
        }
    *)
    Definition with_block
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ OB ], [ self; block ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let block := M.alloc (| block |) in
          Value.StructRecord
            "revm_context::context::Context"
            [
              ("tx",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "tx"
                  |)
                |));
              ("block", M.read (| block |));
              ("cfg",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "cfg"
                  |)
                |));
              ("journaled_state",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "journaled_state"
                  |)
                |));
              ("chain",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "chain"
                  |)
                |));
              ("error", Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_with_block :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "with_block"
        (with_block BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn with_tx<OTX: Transaction>(
            self,
            tx: OTX,
        ) -> Context<BLOCK, OTX, CFG, DB, JOURNAL, CHAIN> {
            Context {
                tx,
                block: self.block,
                cfg: self.cfg,
                journaled_state: self.journaled_state,
                chain: self.chain,
                error: Ok(()),
            }
        }
    *)
    Definition with_tx
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ OTX ], [ self; tx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let tx := M.alloc (| tx |) in
          Value.StructRecord
            "revm_context::context::Context"
            [
              ("tx", M.read (| tx |));
              ("block",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "block"
                  |)
                |));
              ("cfg",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "cfg"
                  |)
                |));
              ("journaled_state",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "journaled_state"
                  |)
                |));
              ("chain",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "chain"
                  |)
                |));
              ("error", Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_with_tx :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "with_tx"
        (with_tx BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn with_chain<OC>(self, chain: OC) -> Context<BLOCK, TX, CFG, DB, JOURNAL, OC> {
            Context {
                tx: self.tx,
                block: self.block,
                cfg: self.cfg,
                journaled_state: self.journaled_state,
                chain,
                error: Ok(()),
            }
        }
    *)
    Definition with_chain
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ OC ], [ self; chain ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let chain := M.alloc (| chain |) in
          Value.StructRecord
            "revm_context::context::Context"
            [
              ("tx",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "tx"
                  |)
                |));
              ("block",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "block"
                  |)
                |));
              ("cfg",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "cfg"
                  |)
                |));
              ("journaled_state",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "revm_context::context::Context",
                    "journaled_state"
                  |)
                |));
              ("chain", M.read (| chain |));
              ("error", Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_with_chain :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "with_chain"
        (with_chain BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn with_cfg<OCFG: Cfg>(
            mut self,
            cfg: OCFG,
        ) -> Context<BLOCK, TX, OCFG, DB, JOURNAL, CHAIN> {
            self.journaled_state.set_spec_id(cfg.spec().into());
            Context {
                tx: self.tx,
                block: self.block,
                cfg,
                journaled_state: self.journaled_state,
                chain: self.chain,
                error: Ok(()),
            }
        }
    *)
    Definition with_cfg
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ OCFG ], [ self; cfg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cfg := M.alloc (| cfg |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_context_interface::journaled_state::Journal",
                    JOURNAL,
                    [],
                    "set_spec_id",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "revm_context::context::Context",
                      "journaled_state"
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.associated,
                        [ Ty.path "revm_specification::hardfork::SpecId" ],
                        "into",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_context_interface::cfg::Cfg",
                            OCFG,
                            [],
                            "spec",
                            []
                          |),
                          [ cfg ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "revm_context::context::Context"
                [
                  ("tx",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "tx"
                      |)
                    |));
                  ("block",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "block"
                      |)
                    |));
                  ("cfg", M.read (| cfg |));
                  ("journaled_state",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "journaled_state"
                      |)
                    |));
                  ("chain",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "revm_context::context::Context",
                        "chain"
                      |)
                    |));
                  ("error", Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ])
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_with_cfg :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "with_cfg"
        (with_cfg BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_cfg_chained<F>(mut self, f: F) -> Self
        where
            F: FnOnce(&mut CFG),
        {
            f(&mut self.cfg);
            self.journaled_state.set_spec_id(self.cfg.spec().into());
            self
        }
    *)
    Definition modify_cfg_chained
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ CFG ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "revm_context::context::Context",
                          "cfg"
                        |)
                      ]
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_context_interface::journaled_state::Journal",
                    JOURNAL,
                    [],
                    "set_spec_id",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "revm_context::context::Context",
                      "journaled_state"
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.associated,
                        [ Ty.path "revm_specification::hardfork::SpecId" ],
                        "into",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_context_interface::cfg::Cfg",
                            CFG,
                            [],
                            "spec",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "revm_context::context::Context",
                              "cfg"
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_cfg_chained :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_cfg_chained"
        (modify_cfg_chained BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_block_chained<F>(mut self, f: F) -> Self
        where
            F: FnOnce(&mut BLOCK),
        {
            self.modify_block(f);
            self
        }
    *)
    Definition modify_block_chained
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "revm_context::context::Context")
                      []
                      [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ],
                    "modify_block",
                    [ F ]
                  |),
                  [ self; M.read (| f |) ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_block_chained :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_block_chained"
        (modify_block_chained BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_tx_chained<F>(mut self, f: F) -> Self
        where
            F: FnOnce(&mut TX),
        {
            self.modify_tx(f);
            self
        }
    *)
    Definition modify_tx_chained
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "revm_context::context::Context")
                      []
                      [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ],
                    "modify_tx",
                    [ F ]
                  |),
                  [ self; M.read (| f |) ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_tx_chained :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_tx_chained"
        (modify_tx_chained BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_chain_chained<F>(mut self, f: F) -> Self
        where
            F: FnOnce(&mut CHAIN),
        {
            self.modify_chain(f);
            self
        }
    *)
    Definition modify_chain_chained
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "revm_context::context::Context")
                      []
                      [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ],
                    "modify_chain",
                    [ F ]
                  |),
                  [ self; M.read (| f |) ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_chain_chained :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_chain_chained"
        (modify_chain_chained BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_db_chained<F>(mut self, f: F) -> Self
        where
            F: FnOnce(&mut DB),
        {
            self.modify_db(f);
            self
        }
    *)
    Definition modify_db_chained
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "revm_context::context::Context")
                      []
                      [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ],
                    "modify_db",
                    [ F ]
                  |),
                  [ self; M.read (| f |) ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_db_chained :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_db_chained"
        (modify_db_chained BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_journal_chained<F>(mut self, f: F) -> Self
        where
            F: FnOnce(&mut JOURNAL),
        {
            self.modify_journal(f);
            self
        }
    *)
    Definition modify_journal_chained
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "revm_context::context::Context")
                      []
                      [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ],
                    "modify_journal",
                    [ F ]
                  |),
                  [ self; M.read (| f |) ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_journal_chained :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_journal_chained"
        (modify_journal_chained BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_block<F>(&mut self, f: F)
        where
            F: FnOnce(&mut BLOCK),
        {
            f(&mut self.block);
        }
    *)
    Definition modify_block
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ BLOCK ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm_context::context::Context",
                          "block"
                        |)
                      ]
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_block :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_block"
        (modify_block BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_tx<F>(&mut self, f: F)
        where
            F: FnOnce(&mut TX),
        {
            f(&mut self.tx);
        }
    *)
    Definition modify_tx
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ TX ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm_context::context::Context",
                          "tx"
                        |)
                      ]
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_tx :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_tx"
        (modify_tx BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_cfg<F>(&mut self, f: F)
        where
            F: FnOnce(&mut CFG),
        {
            f(&mut self.cfg);
            self.journaled_state.set_spec_id(self.cfg.spec().into());
        }
    *)
    Definition modify_cfg
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ CFG ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm_context::context::Context",
                          "cfg"
                        |)
                      ]
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_context_interface::journaled_state::Journal",
                    JOURNAL,
                    [],
                    "set_spec_id",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::context::Context",
                      "journaled_state"
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.associated,
                        [ Ty.path "revm_specification::hardfork::SpecId" ],
                        "into",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_context_interface::cfg::Cfg",
                            CFG,
                            [],
                            "spec",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm_context::context::Context",
                              "cfg"
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_cfg :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_cfg"
        (modify_cfg BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_chain<F>(&mut self, f: F)
        where
            F: FnOnce(&mut CHAIN),
        {
            f(&mut self.chain);
        }
    *)
    Definition modify_chain
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ CHAIN ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm_context::context::Context",
                          "chain"
                        |)
                      ]
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_chain :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_chain"
        (modify_chain BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_db<F>(&mut self, f: F)
        where
            F: FnOnce(&mut DB),
        {
            f(self.journaled_state.db());
        }
    *)
    Definition modify_db
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ DB ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_context_interface::journaled_state::Journal",
                            JOURNAL,
                            [],
                            "db",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "revm_context::context::Context",
                              "journaled_state"
                            |)
                          ]
                        |)
                      ]
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_db :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_db"
        (modify_db BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn modify_journal<F>(&mut self, f: F)
        where
            F: FnOnce(&mut JOURNAL),
        {
            f(&mut self.journaled_state);
        }
    *)
    Definition modify_journal
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ JOURNAL ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "revm_context::context::Context",
                          "journaled_state"
                        |)
                      ]
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modify_journal :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "modify_journal"
        (modify_journal BLOCK TX CFG DB JOURNAL CHAIN).
    
    (*
        pub fn code_hash(
            &mut self,
            address: Address,
        ) -> Result<Eip7702CodeLoad<B256>, <DB as Database>::Error> {
            let acc = self.journaled_state.load_account_code(address)?;
            if acc.is_empty() {
                return Ok(Eip7702CodeLoad::new_not_delegated(B256::ZERO, acc.is_cold));
            }
            // SAFETY: Safe to unwrap as load_code will insert code if it is empty.
            let code = acc.info.code.as_ref().unwrap();
    
            // If bytecode is EIP-7702 then we need to load the delegated account.
            if let Bytecode::Eip7702(code) = code {
                let address = code.address();
                let is_cold = acc.is_cold;
    
                let delegated_account = self.journaled_state.load_account_code(address)?;
    
                let hash = if delegated_account.is_empty() {
                    B256::ZERO
                } else if delegated_account.info.code.as_ref().unwrap().is_eof() {
                    EOF_MAGIC_HASH
                } else {
                    delegated_account.info.code_hash
                };
    
                return Ok(Eip7702CodeLoad::new(
                    StateLoad::new(hash, is_cold),
                    delegated_account.is_cold,
                ));
            }
    
            let hash = if code.is_eof() {
                EOF_MAGIC_HASH
            } else {
                acc.info.code_hash
            };
    
            Ok(Eip7702CodeLoad::new_not_delegated(hash, acc.is_cold))
        }
    *)
    Definition code_hash
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ acc :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "revm_context_interface::journaled_state::StateLoad")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ Ty.path "revm_state::Account" ]
                                  ];
                                Ty.associated
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "revm_context_interface::journaled_state::Journal",
                                JOURNAL,
                                [],
                                "load_account_code",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "revm_context::context::Context",
                                  "journaled_state"
                                |);
                                M.read (| address |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloy_primitives::bits::fixed::FixedBytes")
                                                  [ Value.Integer IntegerKind.Usize 32 ]
                                                  []
                                              ];
                                            Ty.associated
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "revm_state::Account",
                                    "is_empty",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path
                                              "revm_context_interface::journaled_state::StateLoad")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [ Ty.path "revm_state::Account" ]
                                            ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [ acc ]
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path
                                              "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "alloy_primitives::bits::fixed::FixedBytes")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                []
                                            ],
                                          "new_not_delegated",
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.get_constant (|
                                              "alloy_primitives::bits::fixed::ZERO"
                                            |)
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              acc,
                                              "revm_context_interface::journaled_state::StateLoad",
                                              "is_cold"
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ code :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "revm_bytecode::bytecode::Bytecode" ]
                          ],
                        "unwrap",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "revm_bytecode::bytecode::Bytecode" ],
                            "as_ref",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path
                                          "revm_context_interface::journaled_state::StateLoad")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.path "revm_state::Account" ]
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ acc ]
                                  |)
                                |),
                                "revm_state::Account",
                                "info"
                              |),
                              "revm_state::account_info::AccountInfo",
                              "code"
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := code in
                          let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "revm_bytecode::bytecode::Bytecode::Eip7702",
                              0
                            |) in
                          let code := M.alloc (| γ1_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ address :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "revm_bytecode::eip7702::Eip7702Bytecode",
                                        "address",
                                        []
                                      |),
                                      [ M.read (| code |) ]
                                    |)
                                  |) in
                                let~ is_cold :=
                                  M.copy (|
                                    M.SubPointer.get_struct_record_field (|
                                      acc,
                                      "revm_context_interface::journaled_state::StateLoad",
                                      "is_cold"
                                    |)
                                  |) in
                                let~ delegated_account :=
                                  M.copy (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "revm_context_interface::journaled_state::StateLoad")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.path "revm_state::Account" ]
                                                  ];
                                                Ty.associated
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "revm_context_interface::journaled_state::Journal",
                                                JOURNAL,
                                                [],
                                                "load_account_code",
                                                []
                                              |),
                                              [
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "revm_context::context::Context",
                                                  "journaled_state"
                                                |);
                                                M.read (| address |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloy_primitives::bits::fixed::FixedBytes")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      32
                                                                  ]
                                                                  []
                                                              ];
                                                            Ty.associated
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.associated
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |) in
                                let~ hash :=
                                  M.copy (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "revm_state::Account",
                                                      "is_empty",
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::deref::Deref",
                                                            Ty.apply
                                                              (Ty.path
                                                                "revm_context_interface::journaled_state::StateLoad")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&mut")
                                                                  []
                                                                  [ Ty.path "revm_state::Account" ]
                                                              ],
                                                            [],
                                                            "deref",
                                                            []
                                                          |),
                                                          [ delegated_account ]
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.get_constant (|
                                              "alloy_primitives::bits::fixed::ZERO"
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path
                                                                "revm_bytecode::bytecode::Bytecode",
                                                              "is_eof",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "revm_bytecode::bytecode::Bytecode"
                                                                        ]
                                                                    ],
                                                                  "unwrap",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "revm_bytecode::bytecode::Bytecode"
                                                                        ],
                                                                      "as_ref",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.read (|
                                                                            M.call_closure (|
                                                                              M.get_trait_method (|
                                                                                "core::ops::deref::Deref",
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "revm_context_interface::journaled_state::StateLoad")
                                                                                  []
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "&mut")
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "revm_state::Account"
                                                                                      ]
                                                                                  ],
                                                                                [],
                                                                                "deref",
                                                                                []
                                                                              |),
                                                                              [ delegated_account ]
                                                                            |)
                                                                          |),
                                                                          "revm_state::Account",
                                                                          "info"
                                                                        |),
                                                                        "revm_state::account_info::AccountInfo",
                                                                        "code"
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.get_constant (|
                                                      "revm_bytecode::eof::EOF_MAGIC_HASH"
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.SubPointer.get_struct_record_field (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "revm_context_interface::journaled_state::StateLoad")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&mut")
                                                                    []
                                                                    [ Ty.path "revm_state::Account"
                                                                    ]
                                                                ],
                                                              [],
                                                              "deref",
                                                              []
                                                            |),
                                                            [ delegated_account ]
                                                          |)
                                                        |),
                                                        "revm_state::Account",
                                                        "info"
                                                      |),
                                                      "revm_state::account_info::AccountInfo",
                                                      "code_hash"
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)
                                  |) in
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path
                                              "revm_context_interface::journaled_state::Eip7702CodeLoad")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "alloy_primitives::bits::fixed::FixedBytes")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                []
                                            ],
                                          "new",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "revm_context_interface::journaled_state::StateLoad")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloy_primitives::bits::fixed::FixedBytes")
                                                    [ Value.Integer IntegerKind.Usize 32 ]
                                                    []
                                                ],
                                              "new",
                                              []
                                            |),
                                            [ M.read (| hash |); M.read (| is_cold |) ]
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              delegated_account,
                                              "revm_context_interface::journaled_state::StateLoad",
                                              "is_cold"
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ hash :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "revm_bytecode::bytecode::Bytecode",
                                      "is_eof",
                                      []
                                    |),
                                    [ M.read (| code |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.get_constant (| "revm_bytecode::eof::EOF_MAGIC_HASH" |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path
                                          "revm_context_interface::journaled_state::StateLoad")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.path "revm_state::Account" ]
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ acc ]
                                  |)
                                |),
                                "revm_state::Account",
                                "info"
                              |),
                              "revm_state::account_info::AccountInfo",
                              "code_hash"
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                []
                            ],
                          "new_not_delegated",
                          []
                        |),
                        [
                          M.read (| hash |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              acc,
                              "revm_context_interface::journaled_state::StateLoad",
                              "is_cold"
                            |)
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_code_hash :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsAssociatedFunction
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        "code_hash"
        (code_hash BLOCK TX CFG DB JOURNAL CHAIN).
  End Impl_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_host_Host_where_revm_context_interface_block_Block_BLOCK_where_revm_context_interface_transaction_Transaction_TX_where_revm_context_interface_cfg_Cfg_CFG_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::context::Context") [] [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ].
    
    (*
        fn block_hash(&mut self, requested_number: u64) -> Option<B256> {
            let block_number = self.block().number();
    
            let Some(diff) = block_number.checked_sub(requested_number) else {
                return Some(B256::ZERO);
            };
    
            // blockhash should push zero if number is same as current block number.
            if diff == 0 {
                return Some(B256::ZERO);
            }
    
            if diff <= BLOCK_HASH_HISTORY {
                return self
                    .journaled_state
                    .db()
                    .block_hash(requested_number)
                    .map_err(|e| self.error = Err(e))
                    .ok();
            }
    
            Some(B256::ZERO)
        }
    *)
    Definition block_hash
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; requested_number ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let requested_number := M.alloc (| requested_number |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ block_number :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "revm_context_interface::block::Block",
                        BLOCK,
                        [],
                        "number",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "revm_context_interface::block::BlockGetter",
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "revm_context::context::Context")
                                  []
                                  [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ]
                              ],
                            [],
                            "block",
                            []
                          |),
                          [ self ]
                        |)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "u64", "checked_sub", [] |),
                      [ M.read (| block_number |); M.read (| requested_number |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let diff := M.copy (| γ0_0 |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.eq (|
                                          M.read (| diff |),
                                          Value.Integer IntegerKind.U64 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::option::Option::Some"
                                            [
                                              M.read (|
                                                M.get_constant (|
                                                  "alloy_primitives::bits::fixed::ZERO"
                                                |)
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.le (|
                                          M.read (| diff |),
                                          M.read (|
                                            M.get_constant (|
                                              "revm_primitives::constants::BLOCK_HASH_HISTORY"
                                            |)
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloy_primitives::bits::fixed::FixedBytes")
                                                    [ Value.Integer IntegerKind.Usize 32 ]
                                                    [];
                                                  Ty.tuple []
                                                ],
                                              "ok",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloy_primitives::bits::fixed::FixedBytes")
                                                        [ Value.Integer IntegerKind.Usize 32 ]
                                                        [];
                                                      Ty.associated
                                                    ],
                                                  "map_err",
                                                  [
                                                    Ty.tuple [];
                                                    Ty.function
                                                      [ Ty.tuple [ Ty.associated ] ]
                                                      (Ty.tuple [])
                                                  ]
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "revm_database_interface::Database",
                                                      DB,
                                                      [],
                                                      "block_hash",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "revm_context_interface::journaled_state::Journal",
                                                          JOURNAL,
                                                          [],
                                                          "db",
                                                          []
                                                        |),
                                                        [
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| self |),
                                                            "revm_context::context::Context",
                                                            "journaled_state"
                                                          |)
                                                        ]
                                                      |);
                                                      M.read (| requested_number |)
                                                    ]
                                                  |);
                                                  M.closure
                                                    (fun γ =>
                                                      ltac:(M.monadic
                                                        match γ with
                                                        | [ α0 ] =>
                                                          ltac:(M.monadic
                                                            (M.match_operator (|
                                                              M.alloc (| α0 |),
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let e := M.copy (| γ |) in
                                                                    M.read (|
                                                                      M.write (|
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.read (| self |),
                                                                          "revm_context::context::Context",
                                                                          "error"
                                                                        |),
                                                                        Value.StructTuple
                                                                          "core::result::Result::Err"
                                                                          [ M.read (| e |) ]
                                                                      |)
                                                                    |)))
                                                              ]
                                                            |)))
                                                        | _ =>
                                                          M.impossible "wrong number of arguments"
                                                        end))
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.read (|
                                M.get_constant (| "alloy_primitives::bits::fixed::ZERO" |)
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn load_account_delegated(&mut self, address: Address) -> Option<AccountLoad> {
            self.journaled_state
                .load_account_delegated(address)
                .map_err(|e| self.error = Err(e))
                .ok()
        }
    *)
    Definition load_account_delegated
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.path "revm_context_interface::journaled_state::AccountLoad"; Ty.tuple [] ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "revm_context_interface::journaled_state::AccountLoad"; Ty.associated
                    ],
                  "map_err",
                  [ Ty.tuple []; Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.tuple []) ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "revm_context_interface::journaled_state::Journal",
                      JOURNAL,
                      [],
                      "load_account_delegated",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm_context::context::Context",
                        "journaled_state"
                      |);
                      M.read (| address |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let e := M.copy (| γ |) in
                                    M.read (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "revm_context::context::Context",
                                          "error"
                                        |),
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| e |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn balance(&mut self, address: Address) -> Option<StateLoad<U256>> {
            self.journaled_state
                .load_account(address)
                .map_err(|e| self.error = Err(e))
                .map(|acc| acc.map(|a| a.info.balance))
                .ok()
        }
    *)
    Definition balance
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ];
                  Ty.tuple []
                ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::journaled_state::StateLoad")
                        []
                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "revm_state::Account" ] ];
                      Ty.tuple []
                    ],
                  "map",
                  [
                    Ty.apply
                      (Ty.path "revm_context_interface::journaled_state::StateLoad")
                      []
                      [
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          []
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "revm_context_interface::journaled_state::StateLoad")
                              []
                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "revm_state::Account" ] ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "revm_context_interface::journaled_state::StateLoad")
                        []
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            []
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "revm_context_interface::journaled_state::StateLoad")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ Ty.path "revm_state::Account" ] ];
                          Ty.associated
                        ],
                      "map_err",
                      [ Ty.tuple []; Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.tuple []) ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "revm_context_interface::journaled_state::Journal",
                          JOURNAL,
                          [],
                          "load_account",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "revm_context::context::Context",
                            "journaled_state"
                          |);
                          M.read (| address |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let e := M.copy (| γ |) in
                                        M.read (|
                                          M.write (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "revm_context::context::Context",
                                              "error"
                                            |),
                                            Value.StructTuple
                                              "core::result::Result::Err"
                                              [ M.read (| e |) ]
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let acc := M.copy (| γ |) in
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path
                                            "revm_context_interface::journaled_state::StateLoad")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.path "revm_state::Account" ]
                                          ],
                                        "map",
                                        [
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [
                                              Value.Integer IntegerKind.Usize 256;
                                              Value.Integer IntegerKind.Usize 4
                                            ]
                                            [];
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [ Ty.path "revm_state::Account" ]
                                                ]
                                            ]
                                            (Ty.apply
                                              (Ty.path "ruint::Uint")
                                              [
                                                Value.Integer IntegerKind.Usize 256;
                                                Value.Integer IntegerKind.Usize 4
                                              ]
                                              [])
                                        ]
                                      |),
                                      [
                                        M.read (| acc |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    M.alloc (| α0 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let a := M.copy (| γ |) in
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.read (| a |),
                                                                "revm_state::Account",
                                                                "info"
                                                              |),
                                                              "revm_state::account_info::AccountInfo",
                                                              "balance"
                                                            |)
                                                          |)))
                                                    ]
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end))
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn code(&mut self, address: Address) -> Option<Eip7702CodeLoad<Bytes>> {
            self.code(address).map_err(|e| self.error = Err(e)).ok()
        }
    *)
    Definition code
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                    []
                    [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                  Ty.tuple []
                ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                        []
                        [ Ty.path "alloy_primitives::bytes_::Bytes" ];
                      Ty.associated
                    ],
                  "map_err",
                  [ Ty.tuple []; Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.tuple []) ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "revm_context::context::Context")
                        []
                        [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ],
                      "code",
                      []
                    |),
                    [ M.read (| self |); M.read (| address |) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let e := M.copy (| γ |) in
                                    M.read (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "revm_context::context::Context",
                                          "error"
                                        |),
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| e |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn code_hash(&mut self, address: Address) -> Option<Eip7702CodeLoad<B256>> {
            self.code_hash(address)
                .map_err(|e| self.error = Err(e))
                .ok()
        }
    *)
    Definition code_hash
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ];
                  Ty.tuple []
                ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::journaled_state::Eip7702CodeLoad")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            []
                        ];
                      Ty.associated
                    ],
                  "map_err",
                  [ Ty.tuple []; Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.tuple []) ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "revm_context::context::Context")
                        []
                        [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ],
                      "code_hash",
                      []
                    |),
                    [ M.read (| self |); M.read (| address |) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let e := M.copy (| γ |) in
                                    M.read (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "revm_context::context::Context",
                                          "error"
                                        |),
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| e |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn sload(&mut self, address: Address, index: U256) -> Option<StateLoad<U256>> {
            self.journaled_state
                .sload(address, index)
                .map_err(|e| self.error = Err(e))
                .ok()
        }
    *)
    Definition sload
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        []
                    ];
                  Ty.tuple []
                ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::journaled_state::StateLoad")
                        []
                        [
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4
                            ]
                            []
                        ];
                      Ty.associated
                    ],
                  "map_err",
                  [ Ty.tuple []; Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.tuple []) ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "revm_context_interface::journaled_state::Journal",
                      JOURNAL,
                      [],
                      "sload",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm_context::context::Context",
                        "journaled_state"
                      |);
                      M.read (| address |);
                      M.read (| index |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let e := M.copy (| γ |) in
                                    M.read (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "revm_context::context::Context",
                                          "error"
                                        |),
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| e |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn sstore(
            &mut self,
            address: Address,
            index: U256,
            value: U256,
        ) -> Option<StateLoad<SStoreResult>> {
            self.journaled_state
                .sstore(address, index, value)
                .map_err(|e| self.error = Err(e))
                .ok()
        }
    *)
    Definition sstore
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address; index; value ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let index := M.alloc (| index |) in
          let value := M.alloc (| value |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [ Ty.path "revm_context_interface::host::SStoreResult" ];
                  Ty.tuple []
                ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::journaled_state::StateLoad")
                        []
                        [ Ty.path "revm_context_interface::host::SStoreResult" ];
                      Ty.associated
                    ],
                  "map_err",
                  [ Ty.tuple []; Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.tuple []) ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "revm_context_interface::journaled_state::Journal",
                      JOURNAL,
                      [],
                      "sstore",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm_context::context::Context",
                        "journaled_state"
                      |);
                      M.read (| address |);
                      M.read (| index |);
                      M.read (| value |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let e := M.copy (| γ |) in
                                    M.read (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "revm_context::context::Context",
                                          "error"
                                        |),
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| e |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn tload(&mut self, address: Address, index: U256) -> U256 {
            self.journaled_state.tload(address, index)
        }
    *)
    Definition tload
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_context_interface::journaled_state::Journal",
              JOURNAL,
              [],
              "tload",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context::context::Context",
                "journaled_state"
              |);
              M.read (| address |);
              M.read (| index |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn tstore(&mut self, address: Address, index: U256, value: U256) {
            self.journaled_state.tstore(address, index, value)
        }
    *)
    Definition tstore
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address; index; value ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let index := M.alloc (| index |) in
          let value := M.alloc (| value |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_context_interface::journaled_state::Journal",
              JOURNAL,
              [],
              "tstore",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context::context::Context",
                "journaled_state"
              |);
              M.read (| address |);
              M.read (| index |);
              M.read (| value |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn log(&mut self, log: Log) {
            self.journaled_state.log(log);
        }
    *)
    Definition log
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; log ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let log := M.alloc (| log |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "revm_context_interface::journaled_state::Journal",
                    JOURNAL,
                    [],
                    "log",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context::context::Context",
                      "journaled_state"
                    |);
                    M.read (| log |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn selfdestruct(
            &mut self,
            address: Address,
            target: Address,
        ) -> Option<StateLoad<SelfDestructResult>> {
            self.journaled_state
                .selfdestruct(address, target)
                .map_err(|e| self.error = Err(e))
                .ok()
        }
    *)
    Definition selfdestruct
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; address; target ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let target := M.alloc (| target |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::journaled_state::StateLoad")
                    []
                    [ Ty.path "revm_context_interface::host::SelfDestructResult" ];
                  Ty.tuple []
                ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::journaled_state::StateLoad")
                        []
                        [ Ty.path "revm_context_interface::host::SelfDestructResult" ];
                      Ty.associated
                    ],
                  "map_err",
                  [ Ty.tuple []; Ty.function [ Ty.tuple [ Ty.associated ] ] (Ty.tuple []) ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "revm_context_interface::journaled_state::Journal",
                      JOURNAL,
                      [],
                      "selfdestruct",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "revm_context::context::Context",
                        "journaled_state"
                      |);
                      M.read (| address |);
                      M.read (| target |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let e := M.copy (| γ |) in
                                    M.read (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "revm_context::context::Context",
                                          "error"
                                        |),
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| e |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::host::Host"
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("block_hash", InstanceField.Method (block_hash BLOCK TX CFG DB JOURNAL CHAIN));
          ("load_account_delegated",
            InstanceField.Method (load_account_delegated BLOCK TX CFG DB JOURNAL CHAIN));
          ("balance", InstanceField.Method (balance BLOCK TX CFG DB JOURNAL CHAIN));
          ("code", InstanceField.Method (code BLOCK TX CFG DB JOURNAL CHAIN));
          ("code_hash", InstanceField.Method (code_hash BLOCK TX CFG DB JOURNAL CHAIN));
          ("sload", InstanceField.Method (sload BLOCK TX CFG DB JOURNAL CHAIN));
          ("sstore", InstanceField.Method (sstore BLOCK TX CFG DB JOURNAL CHAIN));
          ("tload", InstanceField.Method (tload BLOCK TX CFG DB JOURNAL CHAIN));
          ("tstore", InstanceField.Method (tstore BLOCK TX CFG DB JOURNAL CHAIN));
          ("log", InstanceField.Method (log BLOCK TX CFG DB JOURNAL CHAIN));
          ("selfdestruct", InstanceField.Method (selfdestruct BLOCK TX CFG DB JOURNAL CHAIN))
        ].
  End Impl_revm_context_interface_host_Host_where_revm_context_interface_block_Block_BLOCK_where_revm_context_interface_transaction_Transaction_TX_where_revm_context_interface_cfg_Cfg_CFG_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_Cfg_CFG_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context::context::Context") [] [ BLOCK; TX; CFG; DB; JOURNAL; CHAIN ].
    
    (*     type Cfg = CFG; *)
    Definition _Cfg (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t) : Ty.t := CFG.
    
    (*
        fn cfg(&self) -> &Self::Cfg {
            &self.cfg
        }
    *)
    Definition cfg
        (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX CFG DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "revm_context::context::Context",
            "cfg"
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX CFG DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::cfg::CfgGetter"
        (Self BLOCK TX CFG DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Cfg", InstanceField.Ty (_Cfg BLOCK TX CFG DB JOURNAL CHAIN));
          ("cfg", InstanceField.Method (cfg BLOCK TX CFG DB JOURNAL CHAIN))
        ].
  End Impl_revm_context_interface_cfg_CfgGetter_where_revm_context_interface_cfg_Cfg_CFG_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_CFG_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_journaled_state_JournalGetter_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [ BLOCK; TX; SPEC; DB; JOURNAL; CHAIN ].
    
    (*     type Journal = JOURNAL; *)
    Definition _Journal (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t := JOURNAL.
    
    (*
        fn journal(&mut self) -> &mut Self::Journal {
            &mut self.journaled_state
        }
    *)
    Definition journal
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "revm_context::context::Context",
            "journaled_state"
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn journal_ref(&self) -> &Self::Journal {
            &self.journaled_state
        }
    *)
    Definition journal_ref
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "revm_context::context::Context",
            "journaled_state"
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::journaled_state::JournalGetter"
        (Self BLOCK TX SPEC DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Journal", InstanceField.Ty (_Journal BLOCK TX SPEC DB JOURNAL CHAIN));
          ("journal", InstanceField.Method (journal BLOCK TX SPEC DB JOURNAL CHAIN));
          ("journal_ref", InstanceField.Method (journal_ref BLOCK TX SPEC DB JOURNAL CHAIN))
        ].
  End Impl_revm_context_interface_journaled_state_JournalGetter_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_database_interface_DatabaseGetter_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [ BLOCK; TX; SPEC; DB; JOURNAL; CHAIN ].
    
    (*     type Database = DB; *)
    Definition _Database (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t := DB.
    
    (*
        fn db(&mut self) -> &mut Self::Database {
            self.journaled_state.db()
        }
    *)
    Definition db
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_context_interface::journaled_state::Journal",
              JOURNAL,
              [],
              "db",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context::context::Context",
                "journaled_state"
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn db_ref(&self) -> &Self::Database {
            self.journaled_state.db_ref()
        }
    *)
    Definition db_ref
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_context_interface::journaled_state::Journal",
              JOURNAL,
              [],
              "db_ref",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context::context::Context",
                "journaled_state"
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_database_interface::DatabaseGetter"
        (Self BLOCK TX SPEC DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Database", InstanceField.Ty (_Database BLOCK TX SPEC DB JOURNAL CHAIN));
          ("db", InstanceField.Method (db BLOCK TX SPEC DB JOURNAL CHAIN));
          ("db_ref", InstanceField.Method (db_ref BLOCK TX SPEC DB JOURNAL CHAIN))
        ].
  End Impl_revm_database_interface_DatabaseGetter_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_errors_ErrorGetter_where_revm_context_interface_transaction_Transaction_TX_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [ BLOCK; TX; SPEC; DB; JOURNAL; CHAIN ].
    
    (*     type Error = EVMError<DB::Error, TX::TransactionError>; *)
    Definition _Error (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ Ty.associated; Ty.associated ].
    
    (*
        fn take_error(&mut self) -> Result<(), Self::Error> {
            core::mem::replace(&mut self.error, Ok(())).map_err(EVMError::Database)
        }
    *)
    Definition take_error
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.associated ],
              "map_err",
              [
                Ty.apply
                  (Ty.path "revm_context_interface::result::EVMError")
                  []
                  [ Ty.associated; Ty.associated ];
                Ty.function
                  [ Ty.associated ]
                  (Ty.apply
                    (Ty.path "revm_context_interface::result::EVMError")
                    []
                    [ Ty.associated; Ty.associated ])
              ]
            |),
            [
              M.call_closure (|
                M.get_function (|
                  "core::mem::replace",
                  [ Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.associated ] ]
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_context::context::Context",
                    "error"
                  |);
                  Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]
                ]
              |);
              M.constructor_as_closure "revm_context_interface::result::EVMError::Database"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::errors::ErrorGetter"
        (Self BLOCK TX SPEC DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BLOCK TX SPEC DB JOURNAL CHAIN));
          ("take_error", InstanceField.Method (take_error BLOCK TX SPEC DB JOURNAL CHAIN))
        ].
  End Impl_revm_context_interface_errors_ErrorGetter_where_revm_context_interface_transaction_Transaction_TX_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_transaction_TransactionGetter_where_revm_context_interface_transaction_Transaction_TX_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [ BLOCK; TX; SPEC; DB; JOURNAL; CHAIN ].
    
    (*     type Transaction = TX; *)
    Definition _Transaction (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t := TX.
    
    (*
        fn tx(&self) -> &Self::Transaction {
            &self.tx
        }
    *)
    Definition tx
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "revm_context::context::Context",
            "tx"
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::transaction::TransactionGetter"
        (Self BLOCK TX SPEC DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Transaction", InstanceField.Ty (_Transaction BLOCK TX SPEC DB JOURNAL CHAIN));
          ("tx", InstanceField.Method (tx BLOCK TX SPEC DB JOURNAL CHAIN))
        ].
  End Impl_revm_context_interface_transaction_TransactionGetter_where_revm_context_interface_transaction_Transaction_TX_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_transaction_TransactionSetter_where_revm_context_interface_transaction_Transaction_TX_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [ BLOCK; TX; SPEC; DB; JOURNAL; CHAIN ].
    
    (*
        fn set_tx(&mut self, tx: <Self as TransactionGetter>::Transaction) {
            self.tx = tx;
        }
    *)
    Definition set_tx
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; tx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let tx := M.alloc (| tx |) in
          M.read (|
            let~ _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_context::context::Context",
                  "tx"
                |),
                M.read (| tx |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::transaction::TransactionSetter"
        (Self BLOCK TX SPEC DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("set_tx", InstanceField.Method (set_tx BLOCK TX SPEC DB JOURNAL CHAIN)) ].
  End Impl_revm_context_interface_transaction_TransactionSetter_where_revm_context_interface_transaction_Transaction_TX_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_Block_BLOCK_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [ BLOCK; TX; SPEC; DB; JOURNAL; CHAIN ].
    
    (*     type Block = BLOCK; *)
    Definition _Block (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t := BLOCK.
    
    (*
        fn block(&self) -> &Self::Block {
            &self.block
        }
    *)
    Definition block
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "revm_context::context::Context",
            "block"
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::block::BlockGetter"
        (Self BLOCK TX SPEC DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Block", InstanceField.Ty (_Block BLOCK TX SPEC DB JOURNAL CHAIN));
          ("block", InstanceField.Method (block BLOCK TX SPEC DB JOURNAL CHAIN))
        ].
  End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_Block_BLOCK_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
  
  Module Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_Block_BLOCK_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
    Definition Self (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context::context::Context")
        []
        [ BLOCK; TX; SPEC; DB; JOURNAL; CHAIN ].
    
    (*
        fn set_block(&mut self, block: <Self as BlockGetter>::Block) {
            self.block = block;
        }
    *)
    Definition set_block
        (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BLOCK TX SPEC DB JOURNAL CHAIN in
      match ε, τ, α with
      | [], [], [ self; block ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let block := M.alloc (| block |) in
          M.read (|
            let~ _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_context::context::Context",
                  "block"
                |),
                M.read (| block |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BLOCK TX SPEC DB JOURNAL CHAIN : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::block::BlockSetter"
        (Self BLOCK TX SPEC DB JOURNAL CHAIN)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("set_block", InstanceField.Method (set_block BLOCK TX SPEC DB JOURNAL CHAIN)) ].
  End Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_Block_BLOCK_where_revm_database_interface_Database_DB_where_revm_context_interface_journaled_state_Journal_JOURNAL_for_revm_context_context_Context_BLOCK_TX_SPEC_DB_JOURNAL_CHAIN.
End context.
