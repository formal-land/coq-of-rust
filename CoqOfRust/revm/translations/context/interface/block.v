(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module block.
  (* Trait *)
  Module Block.
    Definition blob_gasprice
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              "map",
              [
                Ty.path "u128";
                Ty.function
                  [
                    Ty.tuple
                      [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ]
                  ]
                  (Ty.path "u128")
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "revm_context_interface::block::Block",
                  Self,
                  [],
                  "blob_excess_gas_and_price",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let a := M.copy (| γ |) in
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    a,
                                    "revm_context_interface::block::blob::BlobExcessGasAndPrice",
                                    "blob_gasprice"
                                  |)
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_blob_gasprice :
      M.IsProvidedMethod "revm_context_interface::block::Block" "blob_gasprice" blob_gasprice.
    Definition blob_excess_gas
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ],
              "map",
              [
                Ty.path "u64";
                Ty.function
                  [
                    Ty.tuple
                      [ Ty.path "revm_context_interface::block::blob::BlobExcessGasAndPrice" ]
                  ]
                  (Ty.path "u64")
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "revm_context_interface::block::Block",
                  Self,
                  [],
                  "blob_excess_gas_and_price",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let a := M.copy (| γ |) in
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    a,
                                    "revm_context_interface::block::blob::BlobExcessGasAndPrice",
                                    "excess_blob_gas"
                                  |)
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_blob_excess_gas :
      M.IsProvidedMethod "revm_context_interface::block::Block" "blob_excess_gas" blob_excess_gas.
  End Block.
  
  Module underscore.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "number", [] |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "beneficiary",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "timestamp",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "gas_limit",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "basefee", [] |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "difficulty",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "prevrandao",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas_and_price",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_gasprice",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref__T.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "number", [] |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "beneficiary",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "timestamp",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "gas_limit",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "basefee", [] |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "difficulty",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "prevrandao",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas_and_price",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_gasprice",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "number", [] |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "beneficiary",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "timestamp",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "gas_limit",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "basefee", [] |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "difficulty",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "prevrandao",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas_and_price",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_gasprice",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition number (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "number", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition beneficiary (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "beneficiary",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition timestamp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "timestamp",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition gas_limit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "gas_limit",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition basefee (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (| "revm_context_interface::block::Block", T, [], "basefee", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition difficulty (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "difficulty",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition prevrandao (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "prevrandao",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas_and_price
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas_and_price",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_gasprice
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_gasprice",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition blob_excess_gas
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::Block",
                T,
                [],
                "blob_excess_gas",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::Block"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("number", InstanceField.Method (number T));
            ("beneficiary", InstanceField.Method (beneficiary T));
            ("timestamp", InstanceField.Method (timestamp T));
            ("gas_limit", InstanceField.Method (gas_limit T));
            ("basefee", InstanceField.Method (basefee T));
            ("difficulty", InstanceField.Method (difficulty T));
            ("prevrandao", InstanceField.Method (prevrandao T));
            ("blob_excess_gas_and_price", InstanceField.Method (blob_excess_gas_and_price T));
            ("blob_gasprice", InstanceField.Method (blob_gasprice T));
            ("blob_excess_gas", InstanceField.Method (blob_excess_gas T))
          ].
    End Impl_revm_context_interface_block_Block_where_revm_context_interface_block_Block_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::BlockGetter",
                T,
                [],
                "block",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref__T.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::BlockGetter",
                T,
                [],
                "block",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::BlockGetter",
                T,
                [],
                "block",
                []
              |),
              [ M.read (| M.read (| self |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition _Block (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Arc)] *)
      Definition block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_context_interface::block::BlockGetter",
                T,
                [],
                "block",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_context_interface::block::BlockGetter"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Block", InstanceField.Ty (_Block T)); ("block", InstanceField.Method (block T)) ].
    End Impl_revm_context_interface_block_BlockGetter_where_revm_context_interface_block_BlockGetter_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  End underscore.
  
  
  
  
  (* Trait *)
  (* Empty module 'BlockGetter' *)
  
  
  
  
  
  (* Trait *)
  (* Empty module 'BlockSetter' *)
  
  Module Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_ref_mut_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
    
    (*
        fn set_block(&mut self, block: <Self as BlockGetter>::Block) {
            ( **self).set_block(block)
        }
    *)
    Definition set_block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; block ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let block := M.alloc (| block |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_context_interface::block::BlockSetter",
              T,
              [],
              "set_block",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| block |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::block::BlockSetter"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("set_block", InstanceField.Method (set_block T)) ].
  End Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_ref_mut_T.
  
  Module Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn set_block(&mut self, block: <Self as BlockGetter>::Block) {
            ( **self).set_block(block)
        }
    *)
    Definition set_block (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; block ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let block := M.alloc (| block |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_context_interface::block::BlockSetter",
              T,
              [],
              "set_block",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| block |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::block::BlockSetter"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("set_block", InstanceField.Method (set_block T)) ].
  End Impl_revm_context_interface_block_BlockSetter_where_revm_context_interface_block_BlockSetter_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
End block.
