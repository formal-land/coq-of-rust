(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module result.
  (* Trait *)
  (* Empty module 'HaltReasonTrait' *)
  
  Module Impl_revm_context_interface_result_HaltReasonTrait_where_core_clone_Clone_HaltReasonT_where_core_fmt_Debug_HaltReasonT_where_core_cmp_PartialEq_HaltReasonT_where_core_cmp_Eq_HaltReasonT_where_core_convert_From_HaltReasonT_revm_context_interface_result_HaltReason_for_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t := HaltReasonT.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::result::HaltReasonTrait"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_revm_context_interface_result_HaltReasonTrait_where_core_clone_Clone_HaltReasonT_where_core_fmt_Debug_HaltReasonT_where_core_cmp_PartialEq_HaltReasonT_where_core_cmp_Eq_HaltReasonT_where_core_convert_From_HaltReasonT_revm_context_interface_result_HaltReason_for_HaltReasonT.
  
  (* StructRecord
    {
      name := "ResultAndState";
      const_params := [];
      ty_params := [ "HaltReasonT" ];
      fields :=
        [
          ("result",
            Ty.apply
              (Ty.path "revm_context_interface::result::ExecutionResult")
              []
              [ HaltReasonT ]);
          ("state",
            Ty.apply
              (Ty.path "hashbrown::map::HashMap")
              []
              [
                Ty.path "alloy_primitives::bits::address::Address";
                Ty.path "revm_state::Account";
                Ty.path "foldhash::seed::fast::RandomState";
                Ty.path "hashbrown::raw::alloc::inner::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* Debug *)
    Definition fmt (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "ResultAndState" |);
              M.read (| Value.String "result" |);
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "revm_context_interface::result::ResultAndState",
                "result"
              |);
              M.read (| Value.String "state" |);
              M.alloc (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_context_interface::result::ResultAndState",
                  "state"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt HaltReasonT)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* Clone *)
    Definition clone
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "revm_context_interface::result::ResultAndState"
            [
              ("result",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "revm_context_interface::result::ExecutionResult")
                      []
                      [ HaltReasonT ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context_interface::result::ResultAndState",
                      "result"
                    |)
                  ]
                |));
              ("state",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "hashbrown::map::HashMap")
                      []
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.path "revm_state::Account";
                        Ty.path "foldhash::seed::fast::RandomState";
                        Ty.path "hashbrown::raw::alloc::inner::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "revm_context_interface::result::ResultAndState",
                      "state"
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone HaltReasonT)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* PartialEq *)
    Definition eq (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "revm_context_interface::result::ExecutionResult")
                  []
                  [ HaltReasonT ],
                [
                  Ty.apply
                    (Ty.path "revm_context_interface::result::ExecutionResult")
                    []
                    [ HaltReasonT ]
                ],
                "eq",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_context_interface::result::ResultAndState",
                  "result"
                |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| other |),
                  "revm_context_interface::result::ResultAndState",
                  "result"
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "hashbrown::map::HashMap")
                    []
                    [
                      Ty.path "alloy_primitives::bits::address::Address";
                      Ty.path "revm_state::Account";
                      Ty.path "foldhash::seed::fast::RandomState";
                      Ty.path "hashbrown::raw::alloc::inner::Global"
                    ],
                  [
                    Ty.apply
                      (Ty.path "hashbrown::map::HashMap")
                      []
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.path "revm_state::Account";
                        Ty.path "foldhash::seed::fast::RandomState";
                        Ty.path "hashbrown::raw::alloc::inner::Global"
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "revm_context_interface::result::ResultAndState",
                    "state"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "revm_context_interface::result::ResultAndState",
                    "state"
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq HaltReasonT)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ResultAndState") [] [ HaltReasonT ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq HaltReasonT))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ResultAndState_HaltReasonT.
  
  (*
  Enum ExecutionResult
  {
    const_params := [];
    ty_params := [ "HaltReasonT" ];
    variants :=
      [
        {
          name := "Success";
          item :=
            StructRecord
              [
                ("reason", Ty.path "revm_context_interface::result::SuccessReason");
                ("gas_used", Ty.path "u64");
                ("gas_refunded", Ty.path "u64");
                ("logs",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::log::Log")
                        []
                        [ Ty.path "alloy_primitives::log::LogData" ];
                      Ty.path "alloc::alloc::Global"
                    ]);
                ("output", Ty.path "revm_context_interface::result::Output")
              ];
          discriminant := None;
        };
        {
          name := "Revert";
          item :=
            StructRecord
              [ ("gas_used", Ty.path "u64"); ("output", Ty.path "alloy_primitives::bytes_::Bytes")
              ];
          discriminant := None;
        };
        {
          name := "Halt";
          item := StructRecord [ ("reason", HaltReasonT); ("gas_used", Ty.path "u64") ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Clone *)
    Definition clone
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::ExecutionResult::Success"
                        [
                          ("reason",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_context_interface::result::SuccessReason",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("gas_used",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |));
                          ("gas_refunded",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_2 |) ]
                            |));
                          ("logs",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::log::Log")
                                      []
                                      [ Ty.path "alloy_primitives::log::LogData" ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_3 |) ]
                            |));
                          ("output",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "revm_context_interface::result::Output",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_4 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::ExecutionResult::Revert"
                        [
                          ("gas_used",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("output",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "alloy_primitives::bytes_::Bytes",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::ExecutionResult::Halt"
                        [
                          ("reason",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                HaltReasonT,
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("gas_used",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone HaltReasonT)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Debug *)
    Definition fmt (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field5_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Success" |);
                          M.read (| Value.String "reason" |);
                          M.read (| __self_0 |);
                          M.read (| Value.String "gas_used" |);
                          M.read (| __self_1 |);
                          M.read (| Value.String "gas_refunded" |);
                          M.read (| __self_2 |);
                          M.read (| Value.String "logs" |);
                          M.read (| __self_3 |);
                          M.read (| Value.String "output" |);
                          __self_4
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Revert" |);
                          M.read (| Value.String "gas_used" |);
                          M.read (| __self_0 |);
                          M.read (| Value.String "output" |);
                          __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Halt" |);
                          M.read (| Value.String "reason" |);
                          M.read (| __self_0 |);
                          M.read (| Value.String "gas_used" |);
                          __self_1
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt HaltReasonT)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* PartialEq *)
    Definition eq (HaltReasonT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::ExecutionResult")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::ExecutionResult")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let γ2_2 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_refunded"
                              |) in
                            let γ2_3 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "logs"
                              |) in
                            let γ2_4 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "output"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let __self_2 := M.alloc (| γ2_2 |) in
                            let __self_3 := M.alloc (| γ2_3 |) in
                            let __self_4 := M.alloc (| γ2_4 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let γ2_2 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_refunded"
                              |) in
                            let γ2_3 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "logs"
                              |) in
                            let γ2_4 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "output"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            let __arg1_2 := M.alloc (| γ2_2 |) in
                            let __arg1_3 := M.alloc (| γ2_3 |) in
                            let __arg1_4 := M.alloc (| γ2_4 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    LogicalOp.and (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "revm_context_interface::result::SuccessReason"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "revm_context_interface::result::SuccessReason"
                                              ]
                                          ],
                                          "eq",
                                          []
                                        |),
                                        [ __self_0; __arg1_0 ]
                                      |),
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                            "eq",
                                            []
                                          |),
                                          [ __self_1; __arg1_1 ]
                                        |)))
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                          "eq",
                                          []
                                        |),
                                        [ __self_2; __arg1_2 ]
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::log::Log")
                                                  []
                                                  [ Ty.path "alloy_primitives::log::LogData" ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloy_primitives::log::Log")
                                                    []
                                                    [ Ty.path "alloy_primitives::log::LogData" ];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                        ],
                                        "eq",
                                        []
                                      |),
                                      [ __self_3; __arg1_3 ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "revm_context_interface::result::Output" ],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "revm_context_interface::result::Output" ]
                                      ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_4; __arg1_4 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "output"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "output"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                                      ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_1; __arg1_1 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "reason"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ HaltReasonT ],
                                    [ Ty.apply (Ty.path "&") [] [ HaltReasonT ] ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_1; __arg1_1 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq HaltReasonT)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq HaltReasonT))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (* Hash *)
    Definition hash
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::ExecutionResult")
                        []
                        [ HaltReasonT ]
                    ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_discr; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_used"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "gas_refunded"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let γ1_4 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let __self_4 := M.alloc (| γ1_4 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "revm_context_interface::result::SuccessReason",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_1 |); M.read (| state |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_2 |); M.read (| state |) ]
                        |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::log::Log")
                                  []
                                  [ Ty.path "alloy_primitives::log::LogData" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_3 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_context_interface::result::Output",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_4 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "gas_used"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloy_primitives::bytes_::Bytes",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "reason"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt",
                        "gas_used"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            HaltReasonT,
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (HaltReasonT : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self HaltReasonT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash HaltReasonT)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_HaltReasonT_where_revm_context_interface_result_HaltReasonTrait_HaltReasonT_for_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  Module Impl_revm_context_interface_result_ExecutionResult_HaltReasonT.
    Definition Self (HaltReasonT : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::ExecutionResult") [] [ HaltReasonT ].
    
    (*
        pub fn is_success(&self) -> bool {
            matches!(self, Self::Success { .. })
        }
    *)
    Definition is_success
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_success :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "is_success" (is_success HaltReasonT).
    
    (*
        pub fn created_address(&self) -> Option<Address> {
            match self {
                Self::Success { output, .. } => output.address().cloned(),
                _ => None,
            }
        }
    *)
    Definition created_address
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "alloy_primitives::bits::address::Address" ]
                            ],
                          "cloned",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_context_interface::result::Output",
                              "address",
                              []
                            |),
                            [ M.read (| output |) ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_created_address :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "created_address" (created_address HaltReasonT).
    
    (*
        pub fn is_halt(&self) -> bool {
            matches!(self, Self::Halt { .. })
        }
    *)
    Definition is_halt
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Halt"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_halt :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "is_halt" (is_halt HaltReasonT).
    
    (*
        pub fn output(&self) -> Option<&Bytes> {
            match self {
                Self::Success { output, .. } => Some(output.data()),
                Self::Revert { output, .. } => Some(output),
                _ => None,
            }
        }
    *)
    Definition output
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_context_interface::result::Output",
                              "data",
                              []
                            |),
                            [ M.read (| output |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let output := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| output |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_output :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "output" (output HaltReasonT).
    
    (*
        pub fn into_output(self) -> Option<Bytes> {
            match self {
                Self::Success { output, .. } => Some(output.into_data()),
                Self::Revert { output, .. } => Some(output),
                _ => None,
            }
        }
    *)
    Definition into_output
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "output"
                      |) in
                    let output := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "revm_context_interface::result::Output",
                              "into_data",
                              []
                            |),
                            [ M.read (| output |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Revert",
                        "output"
                      |) in
                    let output := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| output |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_output :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "into_output" (into_output HaltReasonT).
    
    (*
        pub fn logs(&self) -> &[Log] {
            match self {
                Self::Success { logs, .. } => logs.as_slice(),
                _ => &[],
            }
        }
    *)
    Definition logs
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let logs := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::log::Log")
                                []
                                [ Ty.path "alloy_primitives::log::LogData" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "as_slice",
                          []
                        |),
                        [ M.read (| logs |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| M.alloc (| Value.Array [] |) |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_logs :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "logs" (logs HaltReasonT).
    
    (*
        pub fn into_logs(self) -> Vec<Log> {
            match self {
                Self::Success { logs, .. } => logs,
                _ => Vec::new(),
            }
        }
    *)
    Definition into_logs
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::ExecutionResult::Success",
                        "logs"
                      |) in
                    let logs := M.copy (| γ0_0 |) in
                    logs));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::log::Log")
                                []
                                [ Ty.path "alloy_primitives::log::LogData" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          []
                        |),
                        []
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_logs :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "into_logs" (into_logs HaltReasonT).
    
    (*
        pub fn gas_used(&self) -> u64 {
            match *self {
                Self::Success { gas_used, .. }
                | Self::Revert { gas_used, .. }
                | Self::Halt { gas_used, .. } => gas_used,
            }
        }
    *)
    Definition gas_used
        (HaltReasonT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self HaltReasonT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.read (| self |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_context_interface::result::ExecutionResult::Success",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_context_interface::result::ExecutionResult::Revert",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "revm_context_interface::result::ExecutionResult::Halt",
                                "gas_used"
                              |) in
                            let gas_used := M.copy (| γ0_0 |) in
                            Value.Tuple [ gas_used ]))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ gas_used ] => ltac:(M.monadic gas_used)
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_gas_used :
      forall (HaltReasonT : Ty.t),
      M.IsAssociatedFunction (Self HaltReasonT) "gas_used" (gas_used HaltReasonT).
  End Impl_revm_context_interface_result_ExecutionResult_HaltReasonT.
  
  (*
  Enum Output
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Call";
          item := StructTuple [ Ty.path "alloy_primitives::bytes_::Bytes" ];
          discriminant := None;
        };
        {
          name := "Create";
          item :=
            StructTuple
              [
                Ty.path "alloy_primitives::bytes_::Bytes";
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "alloy_primitives::bits::address::Address" ]
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Call" |); __self_0 ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Create" |);
                          M.read (| __self_0 |);
                          __self_1
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_Output.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::Output::Call"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::Output::Create"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloy_primitives::bytes_::Bytes",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "alloy_primitives::bits::address::Address" ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_1 |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_Output.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_Output.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::Output" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::Output" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::Output::Call",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::Output::Call",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::Output::Create",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::Output::Create",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::Output::Create",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::Output::Create",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloy_primitives::bytes_::Bytes" ],
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "alloy_primitives::bytes_::Bytes" ]
                                    ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "alloy_primitives::bits::address::Address" ]
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "alloy_primitives::bits::address::Address" ]
                                          ]
                                      ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_1; __arg1_1 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_result_Output.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_Output.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::Output" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_discr; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "alloy_primitives::bytes_::Bytes",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "alloy_primitives::bytes_::Bytes",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_Output.
  
  Module Impl_revm_context_interface_result_Output.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::Output".
    
    (*
        pub fn into_data(self) -> Bytes {
            match self {
                Output::Call(data) => data,
                Output::Create(data, _) => data,
            }
        }
    *)
    Definition into_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    data));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ0_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    data))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_data : M.IsAssociatedFunction Self "into_data" into_data.
    
    (*
        pub fn data(&self) -> &Bytes {
            match self {
                Output::Call(data) => data,
                Output::Create(data, _) => data,
            }
        }
    *)
    Definition data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (| M.read (| data |) |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (| M.read (| data |) |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_data : M.IsAssociatedFunction Self "data" data.
    
    (*
        pub fn address(&self) -> Option<&Address> {
            match self {
                Output::Call(_) => None,
                Output::Create(_, address) => address.as_ref(),
            }
        }
    *)
    Definition address (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Call",
                        0
                      |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::Output::Create",
                        1
                      |) in
                    let address := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                          "as_ref",
                          []
                        |),
                        [ M.read (| address |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_address : M.IsAssociatedFunction Self "address" address.
  End Impl_revm_context_interface_result_Output.
  
  (*
  Enum EVMError
  {
    const_params := [];
    ty_params := [ "DBError"; "TransactionError" ];
    variants :=
      [
        {
          name := "Transaction";
          item := StructTuple [ TransactionError ];
          discriminant := None;
        };
        {
          name := "Header";
          item := StructTuple [ Ty.path "revm_context_interface::result::InvalidHeader" ];
          discriminant := None;
        };
        {
          name := "Database";
          item := StructTuple [ DBError ];
          discriminant := None;
        };
        {
          name := "Custom";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "Precompile";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_DBError_where_core_fmt_Debug_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* Debug *)
    Definition fmt
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Transaction" |); __self_0 ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Header" |); __self_0 ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Database" |); __self_0 ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Custom",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Custom" |); __self_0 ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Precompile",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Precompile" |); __self_0 ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self DBError TransactionError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt DBError TransactionError)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_DBError_where_core_fmt_Debug_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_DBError_where_core_clone_Clone_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* Clone *)
    Definition clone
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Transaction"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              TransactionError,
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Header"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "revm_context_interface::result::InvalidHeader",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Database"
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", DBError, [], "clone", [] |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Custom",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Custom"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloc::string::String",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Precompile",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Precompile"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "alloc::string::String",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self DBError TransactionError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone DBError TransactionError)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_DBError_where_core_clone_Clone_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self DBError TransactionError)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_DBError_where_core_cmp_PartialEq_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* PartialEq *)
    Definition eq
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::EVMError")
                        []
                        [ DBError; TransactionError ]
                    ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [
                      Ty.apply
                        (Ty.path "revm_context_interface::result::EVMError")
                        []
                        [ DBError; TransactionError ]
                    ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Transaction",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Transaction",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ TransactionError ],
                                  [ Ty.apply (Ty.path "&") [] [ TransactionError ] ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Header",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Header",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "revm_context_interface::result::InvalidHeader" ],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Database",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Database",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ DBError ],
                                  [ Ty.apply (Ty.path "&") [] [ DBError ] ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self DBError TransactionError)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq DBError TransactionError)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_DBError_where_core_cmp_PartialEq_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_DBError_where_core_cmp_Eq_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
    Definition Self (DBError TransactionError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionError ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (DBError TransactionError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionError in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionError : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self DBError TransactionError)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq DBError TransactionError))
        ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_DBError_where_core_cmp_Eq_TransactionError_for_revm_context_interface_result_EVMError_DBError_TransactionError.
  
  Module Impl_core_convert_From_where_revm_database_interface_DBErrorMarker_DBError_DBError_for_revm_context_interface_result_EVMError_DBError_TX.
    Definition Self (DBError TX : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::EVMError") [] [ DBError; TX ].
    
    (*
        fn from(value: DBError) -> Self {
            Self::Database(value)
        }
    *)
    Definition from (DBError TX : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DBError TX in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Database"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TX : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self DBError TX)
        (* Trait polymorphic types *) [ (* T *) DBError ]
        (* Instance *) [ ("from", InstanceField.Method (from DBError TX)) ].
  End Impl_core_convert_From_where_revm_database_interface_DBErrorMarker_DBError_DBError_for_revm_context_interface_result_EVMError_DBError_TX.
  
  (* Trait *)
  (* Empty module 'FromStringError' *)
  
  Module Impl_revm_context_interface_result_FromStringError_for_revm_context_interface_result_EVMError_DB_TX.
    Definition Self (DB TX : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_context_interface::result::EVMError") [] [ DB; TX ].
    
    (*
        fn from_string(value: String) -> Self {
            Self::Custom(value)
        }
    *)
    Definition from_string
        (DB TX : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DB TX in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Custom"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DB TX : Ty.t),
      M.IsTraitInstance
        "revm_context_interface::result::FromStringError"
        (Self DB TX)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("from_string", InstanceField.Method (from_string DB TX)) ].
  End Impl_revm_context_interface_result_FromStringError_for_revm_context_interface_result_EVMError_DB_TX.
  
  Module Impl_core_convert_From_revm_context_interface_result_InvalidTransaction_for_revm_context_interface_result_EVMError_DB_revm_context_interface_result_InvalidTransaction.
    Definition Self (DB : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DB; Ty.path "revm_context_interface::result::InvalidTransaction" ].
    
    (*
        fn from(value: InvalidTransaction) -> Self {
            Self::Transaction(value)
        }
    *)
    Definition from (DB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self DB in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Transaction"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DB : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self DB)
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "revm_context_interface::result::InvalidTransaction" ]
        (* Instance *) [ ("from", InstanceField.Method (from DB)) ].
  End Impl_core_convert_From_revm_context_interface_result_InvalidTransaction_for_revm_context_interface_result_EVMError_DB_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        pub fn map_db_err<F, E>(self, op: F) -> EVMError<E, TransactionValidationErrorT>
        where
            F: FnOnce(DBError) -> E,
        {
            match self {
                Self::Transaction(e) => EVMError::Transaction(e),
                Self::Header(e) => EVMError::Header(e),
                Self::Database(e) => EVMError::Database(op(e)),
                Self::Precompile(e) => EVMError::Precompile(e),
                Self::Custom(e) => EVMError::Custom(e),
            }
        }
    *)
    Definition map_db_err
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [ F; E ], [ self; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let op := M.alloc (| op |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Transaction"
                        [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Header"
                        [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Database"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [ Ty.tuple [ DBError ] ],
                              "call_once",
                              []
                            |),
                            [ M.read (| op |); Value.Tuple [ M.read (| e |) ] ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Precompile",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Precompile"
                        [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Custom",
                        0
                      |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::EVMError::Custom"
                        [ M.read (| e |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_map_db_err :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsAssociatedFunction
        (Self DBError TransactionValidationErrorT)
        "map_db_err"
        (map_db_err DBError TransactionValidationErrorT).
  End Impl_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  Module Impl_core_error_Error_where_core_error_Error_DBError_where_core_error_Error_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {
            match self {
                Self::Transaction(e) => Some(e),
                Self::Header(e) => Some(e),
                Self::Database(e) => Some(e),
                Self::Precompile(_) | Self::Custom(_) => None,
            }
        }
    *)
    Definition source
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| e |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              ltac:(M.monadic
                                (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (Self DBError TransactionValidationErrorT)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("source", InstanceField.Method (source DBError TransactionValidationErrorT)) ].
  End Impl_core_error_Error_where_core_error_Error_DBError_where_core_error_Error_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_DBError_where_core_fmt_Display_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Transaction(e) => write!(f, "transaction validation error: {e}"),
                Self::Header(e) => write!(f, "header validation error: {e}"),
                Self::Database(e) => write!(f, "database error: {e}"),
                Self::Precompile(e) | Self::Custom(e) => f.write_str(e),
            }
        }
    *)
    Definition fmt
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Transaction",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "transaction validation error: " |) ]
                              |);
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ TransactionValidationErrorT ]
                                        ]
                                      |),
                                      [ e ]
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Header",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "header validation error: " |) ]
                              |);
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "revm_context_interface::result::InvalidHeader"
                                            ]
                                        ]
                                      |),
                                      [ e ]
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::EVMError::Database",
                        0
                      |) in
                    let e := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "database error: " |) ]
                              |);
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ DBError ] ]
                                      |),
                                      [ e ]
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Precompile",
                                0
                              |) in
                            let e := M.alloc (| γ1_0 |) in
                            Value.Tuple [ e ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_context_interface::result::EVMError::Custom",
                                0
                              |) in
                            let e := M.alloc (| γ1_0 |) in
                            Value.Tuple [ e ]))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ e ] =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Formatter",
                                      "write_str",
                                      []
                                    |),
                                    [
                                      M.read (| f |);
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "alloc::string::String",
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [ M.read (| e |) ]
                                      |)
                                    ]
                                  |)
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self DBError TransactionValidationErrorT)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt DBError TransactionValidationErrorT)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_DBError_where_core_fmt_Display_TransactionValidationErrorT_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  Module Impl_core_convert_From_revm_context_interface_result_InvalidHeader_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
    Definition Self (DBError TransactionValidationErrorT : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "revm_context_interface::result::EVMError")
        []
        [ DBError; TransactionValidationErrorT ].
    
    (*
        fn from(value: InvalidHeader) -> Self {
            Self::Header(value)
        }
    *)
    Definition from
        (DBError TransactionValidationErrorT : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self DBError TransactionValidationErrorT in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::EVMError::Header"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (DBError TransactionValidationErrorT : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self DBError TransactionValidationErrorT)
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "revm_context_interface::result::InvalidHeader" ]
        (* Instance *)
        [ ("from", InstanceField.Method (from DBError TransactionValidationErrorT)) ].
  End Impl_core_convert_From_revm_context_interface_result_InvalidHeader_for_revm_context_interface_result_EVMError_DBError_TransactionValidationErrorT.
  
  (*
  Enum InvalidTransaction
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "PriorityFeeGreaterThanMaxFee";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "GasPriceLessThanBasefee";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallerGasLimitMoreThanBlock";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallGasCostMoreThanGasLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "RejectCallerWithCode";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "LackOfFundForMaxFee";
          item :=
            StructRecord
              [
                ("fee",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        [];
                      Ty.path "alloc::alloc::Global"
                    ]);
                ("balance",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                        [];
                      Ty.path "alloc::alloc::Global"
                    ])
              ];
          discriminant := None;
        };
        {
          name := "OverflowPaymentInTransaction";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NonceOverflowInTransaction";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NonceTooHigh";
          item := StructRecord [ ("tx", Ty.path "u64"); ("state", Ty.path "u64") ];
          discriminant := None;
        };
        {
          name := "NonceTooLow";
          item := StructRecord [ ("tx", Ty.path "u64"); ("state", Ty.path "u64") ];
          discriminant := None;
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidChainId";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "AccessListNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "MaxFeePerBlobGasNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BlobVersionedHashesNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BlobGasPriceGreaterThanMax";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EmptyBlobs";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BlobCreateTransaction";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "TooManyBlobs";
          item := StructRecord [ ("max", Ty.path "usize"); ("have", Ty.path "usize") ];
          discriminant := None;
        };
        {
          name := "BlobVersionNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofCrateShouldHaveToAddress";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "AuthorizationListNotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "AuthorizationListInvalidFields";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EmptyAuthorizationList";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidAuthorizationList";
          item :=
            StructTuple
              [ Ty.path "revm_specification::eip7702::authorization_list::InvalidAuthorization" ];
          discriminant := None;
        };
        {
          name := "Eip2930NotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Eip1559NotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Eip4844NotSupported";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Eip7702NotSupported";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "PriorityFeeGreaterThanMaxFee" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "GasPriceLessThanBasefee" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallerGasLimitMoreThanBlock" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallGasCostMoreThanGasLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "RejectCallerWithCode" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "LackOfFundForMaxFee" |);
                          M.read (| Value.String "fee" |);
                          M.read (| __self_0 |);
                          M.read (| Value.String "balance" |);
                          __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OverflowPaymentInTransaction" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "NonceOverflowInTransaction" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "NonceTooHigh" |);
                          M.read (| Value.String "tx" |);
                          M.read (| __self_0 |);
                          M.read (| Value.String "state" |);
                          __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "NonceTooLow" |);
                          M.read (| Value.String "tx" |);
                          M.read (| __self_0 |);
                          M.read (| Value.String "state" |);
                          __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateInitCodeSizeLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "InvalidChainId" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "AccessListNotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "MaxFeePerBlobGasNotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "BlobVersionedHashesNotSupported" |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "BlobGasPriceGreaterThanMax" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EmptyBlobs" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "BlobCreateTransaction" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "TooManyBlobs" |);
                          M.read (| Value.String "max" |);
                          M.read (| __self_0 |);
                          M.read (| Value.String "have" |);
                          __self_1
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "BlobVersionNotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EofCrateShouldHaveToAddress" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "AuthorizationListNotSupported" |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "AuthorizationListInvalidFields" |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EmptyAuthorizationList" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "InvalidAuthorizationList" |);
                          __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Eip2930NotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Eip1559NotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Eip4844NotSupported" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Eip7702NotSupported" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee"
                        [
                          ("fee",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      [];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("balance",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "ruint::Uint")
                                      [
                                        Value.Integer IntegerKind.Usize 256;
                                        Value.Integer IntegerKind.Usize 4
                                      ]
                                      [];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh"
                        [
                          ("tx",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("state",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow"
                        [
                          ("tx",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("state",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u64",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs"
                        [
                          ("max",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "usize",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("have",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "usize",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "revm_specification::eip7702::authorization_list::InvalidAuthorization",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "fee"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "balance"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "fee"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                                "balance"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::Uint")
                                              [
                                                Value.Integer IntegerKind.Usize 256;
                                                Value.Integer IntegerKind.Usize 4
                                              ]
                                              [];
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ],
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "ruint::Uint")
                                                [
                                                  Value.Integer IntegerKind.Usize 256;
                                                  Value.Integer IntegerKind.Usize 4
                                                ]
                                                [];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ]
                                    ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "ruint::Uint")
                                                [
                                                  Value.Integer IntegerKind.Usize 256;
                                                  Value.Integer IntegerKind.Usize 4
                                                ]
                                                [];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "ruint::Uint")
                                                  [
                                                    Value.Integer IntegerKind.Usize 256;
                                                    Value.Integer IntegerKind.Usize 4
                                                  ]
                                                  [];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                      ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_1; __arg1_1 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "state"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                                "state"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_1; __arg1_1 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "state"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "tx"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                                "state"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_1; __arg1_1 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "max"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "have"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "max"
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                                "have"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                    "eq",
                                    []
                                  |),
                                  [ __self_0; __arg1_0 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                      "eq",
                                      []
                                    |),
                                    [ __self_1; __arg1_1 ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "revm_specification::eip7702::authorization_list::InvalidAuthorization"
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "revm_specification::eip7702::authorization_list::InvalidAuthorization"
                                      ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::InvalidTransaction" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_discr; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply
                                  (Ty.path "ruint::Uint")
                                  [
                                    Value.Integer IntegerKind.Usize 256;
                                    Value.Integer IntegerKind.Usize 4
                                  ]
                                  [];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "ruint::Uint")
                                [
                                  Value.Integer IntegerKind.Usize 256;
                                  Value.Integer IntegerKind.Usize 4
                                ]
                                [];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "usize",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "usize",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path
                            "revm_specification::eip7702::authorization_list::InvalidAuthorization",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_revm_context_interface_transaction_TransactionError_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "revm_context_interface::transaction::TransactionError"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_revm_context_interface_transaction_TransactionError_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_convert_From_revm_specification_eip7702_authorization_list_InvalidAuthorization_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (*
        fn from(value: InvalidAuthorization) -> Self {
            Self::InvalidAuthorizationList(value)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple
            "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList"
            [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "revm_specification::eip7702::authorization_list::InvalidAuthorization" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_revm_specification_eip7702_authorization_list_InvalidAuthorization_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_error_Error_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_context_interface_result_InvalidTransaction.
  
  Module Impl_core_fmt_Display_for_revm_context_interface_result_InvalidTransaction.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidTransaction".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::PriorityFeeGreaterThanMaxFee => {
                    write!(f, "priority fee is greater than max fee")
                }
                Self::GasPriceLessThanBasefee => {
                    write!(f, "gas price is less than basefee")
                }
                Self::CallerGasLimitMoreThanBlock => {
                    write!(f, "caller gas limit exceeds the block gas limit")
                }
                Self::CallGasCostMoreThanGasLimit => {
                    write!(f, "call gas cost exceeds the gas limit")
                }
                Self::RejectCallerWithCode => {
                    write!(f, "reject transactions from senders with deployed code")
                }
                Self::LackOfFundForMaxFee { fee, balance } => {
                    write!(f, "lack of funds ({balance}) for max fee ({fee})")
                }
                Self::OverflowPaymentInTransaction => {
                    write!(f, "overflow payment in transaction")
                }
                Self::NonceOverflowInTransaction => {
                    write!(f, "nonce overflow in transaction")
                }
                Self::NonceTooHigh { tx, state } => {
                    write!(f, "nonce {tx} too high, expected {state}")
                }
                Self::NonceTooLow { tx, state } => {
                    write!(f, "nonce {tx} too low, expected {state}")
                }
                Self::CreateInitCodeSizeLimit => {
                    write!(f, "create initcode size limit")
                }
                Self::InvalidChainId => write!(f, "invalid chain ID"),
                Self::AccessListNotSupported => write!(f, "access list not supported"),
                Self::MaxFeePerBlobGasNotSupported => {
                    write!(f, "max fee per blob gas not supported")
                }
                Self::BlobVersionedHashesNotSupported => {
                    write!(f, "blob versioned hashes not supported")
                }
                Self::BlobGasPriceGreaterThanMax => {
                    write!(f, "blob gas price is greater than max fee per blob gas")
                }
                Self::EmptyBlobs => write!(f, "empty blobs"),
                Self::BlobCreateTransaction => write!(f, "blob create transaction"),
                Self::TooManyBlobs { max, have } => {
                    write!(f, "too many blobs, have {have}, max {max}")
                }
                Self::BlobVersionNotSupported => write!(f, "blob version not supported"),
                Self::EofCrateShouldHaveToAddress => write!(f, "EOF crate should have `to` address"),
                Self::AuthorizationListNotSupported => write!(f, "authorization list not supported"),
                Self::AuthorizationListInvalidFields => {
                    write!(f, "authorization list tx has invalid fields")
                }
                Self::EmptyAuthorizationList => write!(f, "empty authorization list"),
                Self::Eip2930NotSupported => write!(f, "Eip2930 is not supported"),
                Self::Eip1559NotSupported => write!(f, "Eip1559 is not supported"),
                Self::Eip4844NotSupported => write!(f, "Eip4844 is not supported"),
                Self::Eip7702NotSupported => write!(f, "Eip7702 is not supported"),
                Self::InvalidAuthorizationList(i) => fmt::Display::fmt(i, f),
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::PriorityFeeGreaterThanMaxFee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "priority fee is greater than max fee" |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::GasPriceLessThanBasefee"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "gas price is less than basefee" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallerGasLimitMoreThanBlock"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (|
                                      Value.String "caller gas limit exceeds the block gas limit"
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CallGasCostMoreThanGasLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "call gas cost exceeds the gas limit" |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::RejectCallerWithCode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (|
                                      Value.String
                                        "reject transactions from senders with deployed code"
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "fee"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::LackOfFundForMaxFee",
                        "balance"
                      |) in
                    let fee := M.alloc (| γ1_0 |) in
                    let balance := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (| Value.String "lack of funds (" |);
                                    M.read (| Value.String ") for max fee (" |);
                                    M.read (| Value.String ")" |)
                                  ]
                              |);
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [
                                                      Value.Integer IntegerKind.Usize 256;
                                                      Value.Integer IntegerKind.Usize 4
                                                    ]
                                                    [];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                        ]
                                      |),
                                      [ balance ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [
                                                      Value.Integer IntegerKind.Usize 256;
                                                      Value.Integer IntegerKind.Usize 4
                                                    ]
                                                    [];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                        ]
                                      |),
                                      [ fee ]
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::OverflowPaymentInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "overflow payment in transaction" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceOverflowInTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "nonce overflow in transaction" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooHigh",
                        "state"
                      |) in
                    let tx := M.alloc (| γ1_0 |) in
                    let state := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (| Value.String "nonce " |);
                                    M.read (| Value.String " too high, expected " |)
                                  ]
                              |);
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                      |),
                                      [ tx ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                      |),
                                      [ state ]
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "tx"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::NonceTooLow",
                        "state"
                      |) in
                    let tx := M.alloc (| γ1_0 |) in
                    let state := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (| Value.String "nonce " |);
                                    M.read (| Value.String " too low, expected " |)
                                  ]
                              |);
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                      |),
                                      [ tx ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                      |),
                                      [ state ]
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "create initcode size limit" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidChainId"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "invalid chain ID" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AccessListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "access list not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::MaxFeePerBlobGasNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "max fee per blob gas not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionedHashesNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "blob versioned hashes not supported" |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobGasPriceGreaterThanMax"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (|
                                      Value.String
                                        "blob gas price is greater than max fee per blob gas"
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyBlobs"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [ M.alloc (| Value.Array [ M.read (| Value.String "empty blobs" |) ] |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobCreateTransaction"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "blob create transaction" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "max"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::TooManyBlobs",
                        "have"
                      |) in
                    let max := M.alloc (| γ1_0 |) in
                    let have := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (| Value.String "too many blobs, have " |);
                                    M.read (| Value.String ", max " |)
                                  ]
                              |);
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                      |),
                                      [ have ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                      |),
                                      [ max ]
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::BlobVersionNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "blob version not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EofCrateShouldHaveToAddress"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "EOF crate should have `to` address" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListNotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "authorization list not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::AuthorizationListInvalidFields"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [
                                    M.read (|
                                      Value.String "authorization list tx has invalid fields"
                                    |)
                                  ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::EmptyAuthorizationList"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "empty authorization list" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip2930NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "Eip2930 is not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip1559NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "Eip1559 is not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip4844NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "Eip4844 is not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::Eip7702NotSupported"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "Eip7702 is not supported" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::InvalidTransaction::InvalidAuthorizationList",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::fmt::Display",
                          Ty.path
                            "revm_specification::eip7702::authorization_list::InvalidAuthorization",
                          [],
                          "fmt",
                          []
                        |),
                        [ M.read (| i |); M.read (| f |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_context_interface_result_InvalidTransaction.
  
  (*
  Enum InvalidHeader
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "PrevrandaoNotSet";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "ExcessBlobGasNotSet";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::InvalidHeader::PrevrandaoNotSet"
                          |) in
                        M.alloc (| M.read (| Value.String "PrevrandaoNotSet" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::InvalidHeader::ExcessBlobGasNotSet"
                          |) in
                        M.alloc (| M.read (| Value.String "ExcessBlobGasNotSet" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::InvalidHeader" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_discr; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_error_Error_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_revm_context_interface_result_InvalidHeader.
  
  Module Impl_core_fmt_Display_for_revm_context_interface_result_InvalidHeader.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::InvalidHeader".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::PrevrandaoNotSet => write!(f, "`prevrandao` not set"),
                Self::ExcessBlobGasNotSet => write!(f, "`excess_blob_gas` not set"),
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidHeader::PrevrandaoNotSet"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array [ M.read (| Value.String "`prevrandao` not set" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::InvalidHeader::ExcessBlobGasNotSet"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              M.alloc (|
                                Value.Array
                                  [ M.read (| Value.String "`excess_blob_gas` not set" |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_context_interface_result_InvalidHeader.
  
  (*
  Enum SuccessReason
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Stop";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Return";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "SelfDestruct";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofReturnContract";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::Stop"
                          |) in
                        M.alloc (| M.read (| Value.String "Stop" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::Return"
                          |) in
                        M.alloc (| M.read (| Value.String "Return" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::SelfDestruct"
                          |) in
                        M.alloc (| M.read (| Value.String "SelfDestruct" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::SuccessReason::EofReturnContract"
                          |) in
                        M.alloc (| M.read (| Value.String "EofReturnContract" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_SuccessReason.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_SuccessReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::SuccessReason".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::SuccessReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_discr; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_SuccessReason.
  
  (*
  Enum HaltReason
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "OutOfGas";
          item := StructTuple [ Ty.path "revm_context_interface::result::OutOfGasError" ];
          discriminant := None;
        };
        {
          name := "OpcodeNotFound";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidFEOpcode";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidJump";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NotActivated";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "StackUnderflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "StackOverflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OutOfOffset";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateCollision";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "PrecompileError";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "NonceOverflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateContractSizeLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateContractStartingWithEF";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CreateInitCodeSizeLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OverflowPayment";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "StateChangeDuringStaticCall";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallNotAllowedInsideStatic";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OutOfFunds";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "CallTooDeep";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofAuxDataOverflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EofAuxDataTooSmall";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "SubRoutineStackOverflow";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidEXTCALLTarget";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfGas",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OutOfGas" |); __self_0 ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OpcodeNotFound"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OpcodeNotFound" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidFEOpcode"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "InvalidFEOpcode" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidJump"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "InvalidJump" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::NotActivated"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "NotActivated" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StackUnderflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "StackUnderflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StackOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "StackOverflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfOffset"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OutOfOffset" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateCollision"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateCollision" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::PrecompileError"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "PrecompileError" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::NonceOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "NonceOverflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateContractSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateContractSizeLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateContractStartingWithEF"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateContractStartingWithEF" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CreateInitCodeSizeLimit"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CreateInitCodeSizeLimit" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OverflowPayment"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OverflowPayment" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::StateChangeDuringStaticCall"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "StateChangeDuringStaticCall" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CallNotAllowedInsideStatic"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallNotAllowedInsideStatic" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfFunds"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "OutOfFunds" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::CallTooDeep"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "CallTooDeep" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::EofAuxDataOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EofAuxDataOverflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::EofAuxDataTooSmall"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "EofAuxDataTooSmall" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::SubRoutineStackOverflow"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "SubRoutineStackOverflow" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "revm_context_interface::result::HaltReason::InvalidEXTCALLTarget"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "InvalidEXTCALLTarget" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::HaltReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::HaltReason" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "revm_context_interface::result::HaltReason::OutOfGas",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "revm_context_interface::result::HaltReason::OutOfGas",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "revm_context_interface::result::OutOfGasError" ],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ __self_0; __arg1_0 ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_HaltReason.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_HaltReason.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::HaltReason".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::HaltReason" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_discr; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_context_interface::result::HaltReason::OutOfGas",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "revm_context_interface::result::OutOfGasError",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_HaltReason.
  
  (*
  Enum OutOfGasError
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Basic";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "MemoryLimit";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Memory";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Precompile";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvalidOperand";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "ReentrancySentry";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::Basic"
                          |) in
                        M.alloc (| M.read (| Value.String "Basic" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::MemoryLimit"
                          |) in
                        M.alloc (| M.read (| Value.String "MemoryLimit" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::Memory"
                          |) in
                        M.alloc (| M.read (| Value.String "Memory" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::Precompile"
                          |) in
                        M.alloc (| M.read (| Value.String "Precompile" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::InvalidOperand"
                          |) in
                        M.alloc (| M.read (| Value.String "InvalidOperand" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "revm_context_interface::result::OutOfGasError::ReentrancySentry"
                          |) in
                        M.alloc (| M.read (| Value.String "ReentrancySentry" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_marker_Copy_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_clone_Clone_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_cmp_PartialEq_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_cmp_Eq_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_context_interface_result_OutOfGasError.
  
  Module Impl_core_hash_Hash_for_revm_context_interface_result_OutOfGasError.
    Definition Self : Ty.t := Ty.path "revm_context_interface::result::OutOfGasError".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "revm_context_interface::result::OutOfGasError" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_discr; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_context_interface_result_OutOfGasError.
End result.
