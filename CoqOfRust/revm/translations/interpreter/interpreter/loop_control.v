(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module interpreter.
  Module loop_control.
    (* StructRecord
      {
        name := "LoopControl";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("instruction_result",
              Ty.path "revm_interpreter::instruction_result::InstructionResult");
            ("next_action", Ty.path "revm_interpreter::interpreter_action::InterpreterAction");
            ("gas", Ty.path "revm_interpreter::gas::Gas")
          ];
      } *)
    
    Module Impl_revm_interpreter_interpreter_loop_control_LoopControl.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::loop_control::LoopControl".
      
      (*
          pub fn new(gas_limit: u64) -> Self {
              Self {
                  instruction_result: InstructionResult::Continue,
                  next_action: InterpreterAction::None,
                  gas: Gas::new(gas_limit),
              }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ gas_limit ] =>
          ltac:(M.monadic
            (let gas_limit := M.alloc (| gas_limit |) in
            Value.StructRecord
              "revm_interpreter::interpreter::loop_control::LoopControl"
              [
                ("instruction_result",
                  Value.StructTuple
                    "revm_interpreter::instruction_result::InstructionResult::Continue"
                    []);
                ("next_action",
                  Value.StructTuple
                    "revm_interpreter::interpreter_action::InterpreterAction::None"
                    []);
                ("gas",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "revm_interpreter::gas::Gas",
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| gas_limit |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    End Impl_revm_interpreter_interpreter_loop_control_LoopControl.
    
    Module Impl_revm_interpreter_interpreter_types_LoopControl_for_revm_interpreter_interpreter_loop_control_LoopControl.
      Definition Self : Ty.t := Ty.path "revm_interpreter::interpreter::loop_control::LoopControl".
      
      (*
          fn set_instruction_result(&mut self, result: InstructionResult) {
              self.instruction_result = result;
          }
      *)
      Definition set_instruction_result (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; result ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let result := M.alloc (| result |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::interpreter::loop_control::LoopControl",
                    "instruction_result"
                  |),
                  M.read (| result |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn set_next_action(&mut self, action: InterpreterAction, result: InstructionResult) {
              self.next_action = action;
              self.instruction_result = result;
          }
      *)
      Definition set_next_action (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; action; result ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let action := M.alloc (| action |) in
            let result := M.alloc (| result |) in
            M.read (|
              let~ _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::interpreter::loop_control::LoopControl",
                    "next_action"
                  |),
                  M.read (| action |)
                |) in
              let~ _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_interpreter::interpreter::loop_control::LoopControl",
                    "instruction_result"
                  |),
                  M.read (| result |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn gas(&mut self) -> &mut Gas {
              &mut self.gas
          }
      *)
      Definition gas (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::interpreter::loop_control::LoopControl",
                        "gas"
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn instruction_result(&self) -> InstructionResult {
              self.instruction_result
          }
      *)
      Definition instruction_result (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "revm_interpreter::interpreter::loop_control::LoopControl",
                "instruction_result"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn take_next_action(&mut self) -> InterpreterAction {
              core::mem::take(&mut self.next_action)
          }
      *)
      Definition take_next_action (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_function (|
                "core::mem::take",
                [],
                [ Ty.path "revm_interpreter::interpreter_action::InterpreterAction" ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_interpreter::interpreter::loop_control::LoopControl",
                        "next_action"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "revm_interpreter::interpreter_types::LoopControl"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("set_instruction_result", InstanceField.Method set_instruction_result);
            ("set_next_action", InstanceField.Method set_next_action);
            ("gas", InstanceField.Method gas);
            ("instruction_result", InstanceField.Method instruction_result);
            ("take_next_action", InstanceField.Method take_next_action)
          ].
    End Impl_revm_interpreter_interpreter_types_LoopControl_for_revm_interpreter_interpreter_loop_control_LoopControl.
  End loop_control.
End interpreter.
