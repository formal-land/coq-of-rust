(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module table.
  Axiom Instruction :
    forall (W H : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::table::Instruction") [] [ W; H ]) =
      (Ty.function
        [
          Ty.apply
            (Ty.path "&mut")
            []
            [ Ty.apply (Ty.path "revm_interpreter::interpreter::Interpreter") [] [ W ] ];
          Ty.apply (Ty.path "&mut") [] [ H ]
        ]
        (Ty.tuple [])).
  
  Axiom InstructionTable :
    forall (W H : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::table::InstructionTable") [] [ W; H ]) =
      (Ty.apply
        (Ty.path "array")
        [ Value.Integer IntegerKind.Usize 256 ]
        [
          Ty.function
            [
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "revm_interpreter::interpreter::Interpreter") [] [ W ] ];
              Ty.apply (Ty.path "&mut") [] [ H ]
            ]
            (Ty.tuple [])
        ]).
  
  Axiom DynInstruction :
    forall (W H : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::table::DynInstruction") [] [ W; H ]) =
      (Ty.dyn
        [ ("existential predicate with variables", []); ("existential predicate with variables", [])
        ]).
  
  Axiom CustomInstructionTable :
    forall (IT : Ty.t),
    (Ty.apply (Ty.path "revm_interpreter::table::CustomInstructionTable") [] [ IT ]) =
      (Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ IT ]).
  
  (* Trait *)
  (* Empty module 'CustomInstruction' *)
  
  (*
  Enum InstructionTables
  {
    const_params := [];
    ty_params := [ "W"; "H"; "CI" ];
    variants :=
      [
        {
          name := "Plain";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [
                        Ty.function
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "revm_interpreter::interpreter::Interpreter")
                                  []
                                  [ W ]
                              ];
                            Ty.apply (Ty.path "&mut") [] [ H ]
                          ]
                          (Ty.tuple [])
                      ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        };
        {
          name := "Custom";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ CI ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_revm_interpreter_table_InstructionTables_WIRE_H_CI.
    Definition Self (WIRE H CI : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_interpreter::table::InstructionTables") [] [ WIRE; H; CI ].
    
    (*
        pub fn insert(&mut self, opcode: u8, instruction: Instruction<WIRE, H>) {
            match self {
                Self::Plain(table) => table[opcode as usize] = instruction,
                Self::Custom(table) => table[opcode as usize] = CI::from_base(instruction),
            }
        }
    *)
    Definition insert
        (WIRE H CI : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIRE H CI in
      match ε, τ, α with
      | [], [], [ self; opcode; instruction ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let opcode := M.alloc (| opcode |) in
          let instruction := M.alloc (| instruction |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::table::InstructionTables::Plain",
                        0
                      |) in
                    let table := M.alloc (| γ1_0 |) in
                    M.write (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| M.deref (| M.read (| table |) |) |) |),
                        M.alloc (| M.cast (Ty.path "usize") (M.read (| opcode |)) |)
                      |),
                      M.read (| instruction |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "revm_interpreter::table::InstructionTables::Custom",
                        0
                      |) in
                    let table := M.alloc (| γ1_0 |) in
                    M.write (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| M.deref (| M.read (| table |) |) |) |),
                        M.alloc (| M.cast (Ty.path "usize") (M.read (| opcode |)) |)
                      |),
                      M.call_closure (|
                        M.get_trait_method (|
                          "revm_interpreter::table::CustomInstruction",
                          CI,
                          [],
                          [],
                          "from_base",
                          [],
                          []
                        |),
                        [ M.read (| instruction |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_insert :
      forall (WIRE H CI : Ty.t),
      M.IsAssociatedFunction (Self WIRE H CI) "insert" (insert WIRE H CI).
    
    (*
        pub fn to_custom(&mut self) -> &mut CustomInstructionTable<CI> {
            self.to_custom_with(|i| CI::from_base(i))
        }
    *)
    Definition to_custom
        (WIRE H CI : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIRE H CI in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "revm_interpreter::table::InstructionTables")
                        []
                        [ WIRE; H; CI ],
                      "to_custom_with",
                      [],
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "revm_interpreter::interpreter::Interpreter")
                                          []
                                          [ WIRE ]
                                      ];
                                    Ty.apply (Ty.path "&mut") [] [ H ]
                                  ]
                                  (Ty.tuple [])
                              ]
                          ]
                          CI
                      ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let i := M.copy (| γ |) in
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "revm_interpreter::table::CustomInstruction",
                                            CI,
                                            [],
                                            [],
                                            "from_base",
                                            [],
                                            []
                                          |),
                                          [ M.read (| i |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_to_custom :
      forall (WIRE H CI : Ty.t),
      M.IsAssociatedFunction (Self WIRE H CI) "to_custom" (to_custom WIRE H CI).
    
    (*
        pub fn to_custom_with<F>(&mut self, f: F) -> &mut CustomInstructionTable<CI>
        where
            F: FnMut(Instruction<WIRE, H>) -> CI,
        {
            match self {
                Self::Plain(_) => self.to_custom_with_slow(f),
                Self::Custom(boxed) => boxed,
            }
        }
    *)
    Definition to_custom_with
        (WIRE H CI : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIRE H CI in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.read (|
                    M.match_operator (|
                      self,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_interpreter::table::InstructionTables::Plain",
                                0
                              |) in
                            M.alloc (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "revm_interpreter::table::InstructionTables")
                                        []
                                        [ WIRE; H; CI ],
                                      "to_custom_with_slow",
                                      [],
                                      [ F ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      M.read (| f |)
                                    ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_interpreter::table::InstructionTables::Custom",
                                0
                              |) in
                            let boxed := M.alloc (| γ1_0 |) in
                            M.alloc (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (| M.read (| M.deref (| M.read (| boxed |) |) |) |)
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_to_custom_with :
      forall (WIRE H CI : Ty.t),
      M.IsAssociatedFunction (Self WIRE H CI) "to_custom_with" (to_custom_with WIRE H CI).
    
    (*
        fn to_custom_with_slow<F>(&mut self, f: F) -> &mut CustomInstructionTable<CI>
        where
            F: FnMut(Instruction<WIRE, H>) -> CI,
        {
            let Self::Plain(table) = self else {
                unreachable!()
            };
            *self = Self::Custom(Box::new(make_custom_instruction_table(table, f)));
            let Self::Custom(boxed) = self else {
                unreachable!()
            };
            boxed
        }
    *)
    Definition to_custom_with_slow
        (WIRE H CI : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIRE H CI in
      match ε, τ, α with
      | [], [ F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "revm_interpreter::table::InstructionTables::Plain",
                            0
                          |) in
                        let table := M.alloc (| γ1_0 |) in
                        let~ _ :=
                          M.write (|
                            M.deref (| M.read (| self |) |),
                            Value.StructTuple
                              "revm_interpreter::table::InstructionTables::Custom"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 256 ]
                                          [ CI ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "new",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_function (|
                                        "revm_interpreter::table::make_custom_instruction_table",
                                        [],
                                        [ WIRE; H; F; CI ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (| M.deref (| M.read (| table |) |) |)
                                          |)
                                        |);
                                        M.read (| f |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                          |) in
                        M.match_operator (|
                          self,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "revm_interpreter::table::InstructionTables::Custom",
                                    0
                                  |) in
                                let boxed := M.alloc (| γ1_0 |) in
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| M.deref (| M.read (| boxed |) |) |) |)
                                  |)
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_to_custom_with_slow :
      forall (WIRE H CI : Ty.t),
      M.IsAssociatedFunction (Self WIRE H CI) "to_custom_with_slow" (to_custom_with_slow WIRE H CI).
    
    (*
        pub fn get_custom(&mut self, opcode: u8) -> &mut CI {
            &mut self.to_custom()[opcode as usize]
        }
    *)
    Definition get_custom
        (WIRE H CI : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIRE H CI in
      match ε, τ, α with
      | [], [], [ self; opcode ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let opcode := M.alloc (| opcode |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_array_field (|
                      M.deref (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "revm_interpreter::table::InstructionTables")
                              []
                              [ WIRE; H; CI ],
                            "to_custom",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |),
                      M.alloc (| M.cast (Ty.path "usize") (M.read (| opcode |)) |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_get_custom :
      forall (WIRE H CI : Ty.t),
      M.IsAssociatedFunction (Self WIRE H CI) "get_custom" (get_custom WIRE H CI).
    
    (*
        pub fn insert_custom(&mut self, opcode: u8, instruction: CI) {
            *self.get_custom(opcode) = instruction;
        }
    *)
    Definition insert_custom
        (WIRE H CI : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIRE H CI in
      match ε, τ, α with
      | [], [], [ self; opcode; instruction ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let opcode := M.alloc (| opcode |) in
          let instruction := M.alloc (| instruction |) in
          M.read (|
            let~ _ :=
              M.write (|
                M.deref (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "revm_interpreter::table::InstructionTables")
                        []
                        [ WIRE; H; CI ],
                      "get_custom",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| opcode |)
                    ]
                  |)
                |),
                M.read (| instruction |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_insert_custom :
      forall (WIRE H CI : Ty.t),
      M.IsAssociatedFunction (Self WIRE H CI) "insert_custom" (insert_custom WIRE H CI).
    
    (*
        pub fn replace_boxed(&mut self, opcode: u8, instruction: CI) -> CI {
            core::mem::replace(self.get_custom(opcode), instruction)
        }
    *)
    Definition replace_boxed
        (WIRE H CI : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self WIRE H CI in
      match ε, τ, α with
      | [], [], [ self; opcode; instruction ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let opcode := M.alloc (| opcode |) in
          let instruction := M.alloc (| instruction |) in
          M.call_closure (|
            M.get_function (| "core::mem::replace", [], [ CI ] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "revm_interpreter::table::InstructionTables")
                        []
                        [ WIRE; H; CI ],
                      "get_custom",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| opcode |)
                    ]
                  |)
                |)
              |);
              M.read (| instruction |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_replace_boxed :
      forall (WIRE H CI : Ty.t),
      M.IsAssociatedFunction (Self WIRE H CI) "replace_boxed" (replace_boxed WIRE H CI).
  End Impl_revm_interpreter_table_InstructionTables_WIRE_H_CI.
  
  (*
  pub const fn make_instruction_table<WIRE: InterpreterTypes, H: Host + ?Sized>(
  ) -> InstructionTable<WIRE, H> {
      const {
          let mut tables: InstructionTable<WIRE, H> = [control::unknown; 256];
          let mut i = 0;
          while i < 256 {
              tables[i] = instruction::<WIRE, H>(i as u8);
              i += 1;
          }
          tables
      }
  }
  *)
  Definition make_instruction_table (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ WIRE; H ], [] =>
      ltac:(M.monadic
        (M.read (|
          M.get_constant (| "revm_interpreter::table::make_instruction_table_discriminant" |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_make_instruction_table :
    M.IsFunction "revm_interpreter::table::make_instruction_table" make_instruction_table.
  
  (*
  pub fn make_custom_instruction_table<W, H, FN, CI: CustomInstruction<Wire = W, Host = H>>(
      table: &InstructionTable<W, H>,
      mut f: FN,
  ) -> CustomInstructionTable<CI>
  where
      W: InterpreterTypes,
      H: Host + ?Sized,
      FN: FnMut(Instruction<W, H>) -> CI,
  {
      core::array::from_fn(|i| f(table[i]))
  }
  *)
  Definition make_custom_instruction_table
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ W; H; FN; CI ], [ table; f ] =>
      ltac:(M.monadic
        (let table := M.alloc (| table |) in
        let f := M.alloc (| f |) in
        M.call_closure (|
          M.get_function (|
            "core::array::from_fn",
            [ Value.Integer IntegerKind.Usize 256 ],
            [ CI; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] CI ]
          |),
          [
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let i := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::function::FnMut",
                                  FN,
                                  [],
                                  [
                                    Ty.tuple
                                      [
                                        Ty.function
                                          [
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "revm_interpreter::interpreter::Interpreter")
                                                  []
                                                  [ W ]
                                              ];
                                            Ty.apply (Ty.path "&mut") [] [ H ]
                                          ]
                                          (Ty.tuple [])
                                      ]
                                  ],
                                  "call_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, f |);
                                  Value.Tuple
                                    [
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.deref (| M.read (| table |) |),
                                          i
                                        |)
                                      |)
                                    ]
                                ]
                              |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_make_custom_instruction_table :
    M.IsFunction
      "revm_interpreter::table::make_custom_instruction_table"
      make_custom_instruction_table.
End table.
