(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module db.
  (* Trait *)
  (* Empty module 'Database' *)
  
  Module underscore.
    Module Impl_revm_primitives_db_Database_where_revm_primitives_db_Database_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
      
      (* #[auto_impl(&mut, Box)] *)
      Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "basic", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "code_by_hash", [] |),
              [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "storage", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition block_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "block_hash", [] |),
              [ M.read (| M.read (| self |) |); M.read (| number |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::Database"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error T));
            ("basic", InstanceField.Method (basic T));
            ("code_by_hash", InstanceField.Method (code_by_hash T));
            ("storage", InstanceField.Method (storage T));
            ("block_hash", InstanceField.Method (block_hash T))
          ].
    End Impl_revm_primitives_db_Database_where_revm_primitives_db_Database_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_primitives_db_Database_where_revm_primitives_db_Database_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&mut, Box)] *)
      Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "basic", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "code_by_hash", [] |),
              [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "storage", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&mut, Box)] *)
      Definition block_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::Database", T, [], "block_hash", [] |),
              [ M.read (| M.read (| self |) |); M.read (| number |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::Database"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error T));
            ("basic", InstanceField.Method (basic T));
            ("code_by_hash", InstanceField.Method (code_by_hash T));
            ("storage", InstanceField.Method (storage T));
            ("block_hash", InstanceField.Method (block_hash T))
          ].
    End Impl_revm_primitives_db_Database_where_revm_primitives_db_Database_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_primitives_db_DatabaseCommit_where_revm_primitives_db_DatabaseCommit_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
      
      (* #[auto_impl(&mut, Box)] *)
      Definition commit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; changes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let changes := M.alloc (| changes |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseCommit", T, [], "commit", [] |),
              [ M.read (| M.read (| self |) |); M.read (| changes |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseCommit"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("commit", InstanceField.Method (commit T)) ].
    End Impl_revm_primitives_db_DatabaseCommit_where_revm_primitives_db_DatabaseCommit_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_primitives_db_DatabaseCommit_where_revm_primitives_db_DatabaseCommit_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&mut, Box)] *)
      Definition commit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; changes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let changes := M.alloc (| changes |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseCommit", T, [], "commit", [] |),
              [ M.read (| M.read (| self |) |); M.read (| changes |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseCommit"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("commit", InstanceField.Method (commit T)) ].
    End Impl_revm_primitives_db_DatabaseCommit_where_revm_primitives_db_DatabaseCommit_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition basic_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "basic_ref", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition code_by_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "code_by_hash_ref",
                []
              |),
              [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition storage_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "storage_ref", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition block_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "block_hash_ref",
                []
              |),
              [ M.read (| M.read (| self |) |); M.read (| number |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseRef"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error T));
            ("basic_ref", InstanceField.Method (basic_ref T));
            ("code_by_hash_ref", InstanceField.Method (code_by_hash_ref T));
            ("storage_ref", InstanceField.Method (storage_ref T));
            ("block_hash_ref", InstanceField.Method (block_hash_ref T))
          ].
    End Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_ref__T.
    Module Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition basic_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "basic_ref", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition code_by_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "code_by_hash_ref",
                []
              |),
              [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition storage_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "storage_ref", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition block_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "block_hash_ref",
                []
              |),
              [ M.read (| M.read (| self |) |); M.read (| number |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseRef"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error T));
            ("basic_ref", InstanceField.Method (basic_ref T));
            ("code_by_hash_ref", InstanceField.Method (code_by_hash_ref T));
            ("storage_ref", InstanceField.Method (storage_ref T));
            ("block_hash_ref", InstanceField.Method (block_hash_ref T))
          ].
    End Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_ref_mut_T.
    Module Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition basic_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "basic_ref", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition code_by_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "code_by_hash_ref",
                []
              |),
              [ M.read (| M.read (| self |) |); M.read (| code_hash |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition storage_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "storage_ref", [] |),
              [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| index |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition block_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "block_hash_ref",
                []
              |),
              [ M.read (| M.read (| self |) |); M.read (| number |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseRef"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error T));
            ("basic_ref", InstanceField.Method (basic_ref T));
            ("code_by_hash_ref", InstanceField.Method (code_by_hash_ref T));
            ("storage_ref", InstanceField.Method (storage_ref T));
            ("block_hash_ref", InstanceField.Method (block_hash_ref T))
          ].
    End Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Module Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition basic_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "basic_ref", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| address |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition code_by_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "code_by_hash_ref",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| code_hash |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition storage_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "storage_ref", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| address |);
                M.read (| index |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition block_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "block_hash_ref",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| number |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseRef"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error T));
            ("basic_ref", InstanceField.Method (basic_ref T));
            ("code_by_hash_ref", InstanceField.Method (code_by_hash_ref T));
            ("storage_ref", InstanceField.Method (storage_ref T));
            ("block_hash_ref", InstanceField.Method (block_hash_ref T))
          ].
    End Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Module Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition basic_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "basic_ref", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| address |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition code_by_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; code_hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let code_hash := M.alloc (| code_hash |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "code_by_hash_ref",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| code_hash |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition storage_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; address; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "storage_ref", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| address |);
                M.read (| index |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (* #[auto_impl(&, &mut, Box, Rc, Arc)] *)
      Definition block_hash_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; number ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let number := M.alloc (| number |) in
            M.call_closure (|
              M.get_trait_method (|
                "revm_primitives::db::DatabaseRef",
                T,
                [],
                "block_hash_ref",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    "deref",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| number |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "revm_primitives::db::DatabaseRef"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error T));
            ("basic_ref", InstanceField.Method (basic_ref T));
            ("code_by_hash_ref", InstanceField.Method (code_by_hash_ref T));
            ("storage_ref", InstanceField.Method (storage_ref T));
            ("block_hash_ref", InstanceField.Method (block_hash_ref T))
          ].
    End Impl_revm_primitives_db_DatabaseRef_where_revm_primitives_db_DatabaseRef_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  End underscore.
  
  
  (* Trait *)
  (* Empty module 'DatabaseCommit' *)
  
  
  
  (* Trait *)
  (* Empty module 'DatabaseRef' *)
  
  
  
  
  
  
  (* StructTuple
    {
      name := "WrapDatabaseRef";
      ty_params := [ "T" ];
      fields := [ T ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* Clone *)
    Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "revm_primitives::db::WrapDatabaseRef"
            [
              M.call_closure (|
                M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                [
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "revm_primitives::db::WrapDatabaseRef",
                    0
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "WrapDatabaseRef" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "revm_primitives::db::WrapDatabaseRef",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_default_Default_where_core_default_Default_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* Default *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "revm_primitives::db::WrapDatabaseRef"
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_marker_StructuralPartialEq_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* PartialEq *)
    Definition eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_marker_StructuralEq_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* PartialOrd *)
    Definition partial_cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "partial_cmp", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
  End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* Ord *)
    Definition cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.SubPointer.get_struct_tuple_field (|
                M.read (| other |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
  End Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (* Hash *)
    Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ __H ] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_T_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_core_convert_From_where_revm_primitives_db_DatabaseRef_F_F_for_revm_primitives_db_WrapDatabaseRef_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ F ].
    
    (*
        fn from(f: F) -> Self {
            WrapDatabaseRef(f)
        }
    *)
    Definition from (F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match τ, α with
      | [], [ f ] =>
        ltac:(M.monadic
          (let f := M.alloc (| f |) in
          Value.StructTuple "revm_primitives::db::WrapDatabaseRef" [ M.read (| f |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self F)
        (* Trait polymorphic types *) [ (* T *) F ]
        (* Instance *) [ ("from", InstanceField.Method (from F)) ].
  End Impl_core_convert_From_where_revm_primitives_db_DatabaseRef_F_F_for_revm_primitives_db_WrapDatabaseRef_F.
  
  (* Trait *)
  (* Empty module 'DatabaseWithDebugError' *)
  
  Module Impl_revm_primitives_db_Database_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (*     type Error = T::Error; *)
    Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
            self.0.basic_ref(address)
        }
    *)
    Definition basic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.call_closure (|
            M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "basic_ref", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.read (| address |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
            self.0.code_by_hash_ref(code_hash)
        }
    *)
    Definition code_by_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; code_hash ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let code_hash := M.alloc (| code_hash |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_primitives::db::DatabaseRef",
              T,
              [],
              "code_by_hash_ref",
              []
            |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.read (| code_hash |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
            self.0.storage_ref(address, index)
        }
    *)
    Definition storage (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; address; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (| "revm_primitives::db::DatabaseRef", T, [], "storage_ref", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.read (| address |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn block_hash(&mut self, number: U256) -> Result<B256, Self::Error> {
            self.0.block_hash_ref(number)
        }
    *)
    Definition block_hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; number ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let number := M.alloc (| number |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_primitives::db::DatabaseRef",
              T,
              [],
              "block_hash_ref",
              []
            |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.read (| number |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "revm_primitives::db::Database"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error T));
          ("basic", InstanceField.Method (basic T));
          ("code_by_hash", InstanceField.Method (code_by_hash T));
          ("storage", InstanceField.Method (storage T));
          ("block_hash", InstanceField.Method (block_hash T))
        ].
  End Impl_revm_primitives_db_Database_where_revm_primitives_db_DatabaseRef_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  Module Impl_revm_primitives_db_DatabaseCommit_where_revm_primitives_db_DatabaseRef_T_where_revm_primitives_db_DatabaseCommit_T_for_revm_primitives_db_WrapDatabaseRef_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::WrapDatabaseRef") [ T ].
    
    (*
        fn commit(&mut self, changes: HashMap<Address, Account>) {
            self.0.commit(changes)
        }
    *)
    Definition commit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; changes ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let changes := M.alloc (| changes |) in
          M.call_closure (|
            M.get_trait_method (| "revm_primitives::db::DatabaseCommit", T, [], "commit", [] |),
            [
              M.SubPointer.get_struct_tuple_field (|
                M.read (| self |),
                "revm_primitives::db::WrapDatabaseRef",
                0
              |);
              M.read (| changes |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "revm_primitives::db::DatabaseCommit"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("commit", InstanceField.Method (commit T)) ].
  End Impl_revm_primitives_db_DatabaseCommit_where_revm_primitives_db_DatabaseRef_T_where_revm_primitives_db_DatabaseCommit_T_for_revm_primitives_db_WrapDatabaseRef_T.
  
  (* StructRecord
    {
      name := "RefDBWrapper";
      ty_params := [ "E" ];
      fields :=
        [
          ("db",
            Ty.apply (Ty.path "&") [ Ty.dyn [ ("revm_primitives::db::DatabaseRef::Trait", []) ] ])
        ];
    } *)
  
  Module Impl_revm_primitives_db_RefDBWrapper_E.
    Definition Self (E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::RefDBWrapper") [ E ].
    
    (*
        pub fn new(db: &'a dyn DatabaseRef<Error = E>) -> Self {
            Self { db }
        }
    *)
    Definition new (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match τ, α with
      | [], [ db ] =>
        ltac:(M.monadic
          (let db := M.alloc (| db |) in
          Value.StructRecord
            "revm_primitives::db::RefDBWrapper"
            [ ("db", (* Unsize *) M.pointer_coercion (M.read (| db |))) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (E : Ty.t), M.IsAssociatedFunction (Self E) "new" (new E).
  End Impl_revm_primitives_db_RefDBWrapper_E.
  
  Module Impl_revm_primitives_db_Database_for_revm_primitives_db_RefDBWrapper_E.
    Definition Self (E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "revm_primitives::db::RefDBWrapper") [ E ].
    
    (*     type Error = E; *)
    Definition _Error (E : Ty.t) : Ty.t := E.
    
    (*
        fn basic(&mut self, address: Address) -> Result<Option<AccountInfo>, Self::Error> {
            self.db.basic_ref(address)
        }
    *)
    Definition basic (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match τ, α with
      | [], [ self; address ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_primitives::db::DatabaseRef",
              Ty.dyn [ ("revm_primitives::db::DatabaseRef::Trait", []) ],
              [],
              "basic_ref",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_primitives::db::RefDBWrapper",
                  "db"
                |)
              |);
              M.read (| address |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn code_by_hash(&mut self, code_hash: B256) -> Result<Bytecode, Self::Error> {
            self.db.code_by_hash_ref(code_hash)
        }
    *)
    Definition code_by_hash (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match τ, α with
      | [], [ self; code_hash ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let code_hash := M.alloc (| code_hash |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_primitives::db::DatabaseRef",
              Ty.dyn [ ("revm_primitives::db::DatabaseRef::Trait", []) ],
              [],
              "code_by_hash_ref",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_primitives::db::RefDBWrapper",
                  "db"
                |)
              |);
              M.read (| code_hash |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn storage(&mut self, address: Address, index: U256) -> Result<U256, Self::Error> {
            self.db.storage_ref(address, index)
        }
    *)
    Definition storage (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match τ, α with
      | [], [ self; address; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_primitives::db::DatabaseRef",
              Ty.dyn [ ("revm_primitives::db::DatabaseRef::Trait", []) ],
              [],
              "storage_ref",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_primitives::db::RefDBWrapper",
                  "db"
                |)
              |);
              M.read (| address |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn block_hash(&mut self, number: U256) -> Result<B256, Self::Error> {
            self.db.block_hash_ref(number)
        }
    *)
    Definition block_hash (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match τ, α with
      | [], [ self; number ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let number := M.alloc (| number |) in
          M.call_closure (|
            M.get_trait_method (|
              "revm_primitives::db::DatabaseRef",
              Ty.dyn [ ("revm_primitives::db::DatabaseRef::Trait", []) ],
              [],
              "block_hash_ref",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "revm_primitives::db::RefDBWrapper",
                  "db"
                |)
              |);
              M.read (| number |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (E : Ty.t),
      M.IsTraitInstance
        "revm_primitives::db::Database"
        (Self E)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error E));
          ("basic", InstanceField.Method (basic E));
          ("code_by_hash", InstanceField.Method (code_by_hash E));
          ("storage", InstanceField.Method (storage E));
          ("block_hash", InstanceField.Method (block_hash E))
        ].
  End Impl_revm_primitives_db_Database_for_revm_primitives_db_RefDBWrapper_E.
End db.
