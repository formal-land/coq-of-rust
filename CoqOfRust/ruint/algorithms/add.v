(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module algorithms.
  Module add.
    (*
    pub fn adc_n(lhs: &mut [u64], rhs: &[u64], mut carry: u64) -> u64 {
        for i in 0..lhs.len() {
            (lhs[i], carry) = adc(lhs[i], rhs[i], carry);
        }
        carry
    }
    *)
    Definition adc_n (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; carry ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let carry := M.alloc (| carry |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 0);
                            ("end_",
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                              |))
                          ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let i := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          None,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.tuple [ Ty.path "u64"; Ty.path "u64" ],
                                              M.get_function (|
                                                "ruint::algorithms::ops::adc",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| lhs |) |),
                                                    M.read (| i |)
                                                  |)
                                                |);
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| rhs |) |),
                                                    M.read (| i |)
                                                  |)
                                                |);
                                                M.read (| carry |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let lhs := M.copy (| γ0_0 |) in
                                                let lhs := M.copy (| γ0_1 |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.write (|
                                                      M.SubPointer.get_array_field (|
                                                        M.deref (| M.read (| lhs |) |),
                                                        M.read (| i |)
                                                      |),
                                                      M.read (| lhs |)
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.write (| carry, M.read (| lhs |) |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            carry
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_adc_n :
      M.IsFunction.C "ruint::algorithms::add::adc_n" adc_n.
    Admitted.
    Global Typeclasses Opaque adc_n.
    
    (*
    pub fn sbb_n(lhs: &mut [u64], rhs: &[u64], mut borrow: u64) -> u64 {
        for i in 0..lhs.len() {
            (lhs[i], borrow) = sbb(lhs[i], rhs[i], borrow);
        }
        borrow
    }
    *)
    Definition sbb_n (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; rhs; borrow ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let rhs := M.alloc (| rhs |) in
          let borrow := M.alloc (| borrow |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.Usize 0);
                            ("end_",
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                              |))
                          ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let i := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          None,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.tuple [ Ty.path "u64"; Ty.path "u64" ],
                                              M.get_function (|
                                                "ruint::algorithms::ops::sbb",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| lhs |) |),
                                                    M.read (| i |)
                                                  |)
                                                |);
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| rhs |) |),
                                                    M.read (| i |)
                                                  |)
                                                |);
                                                M.read (| borrow |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let lhs := M.copy (| γ0_0 |) in
                                                let lhs := M.copy (| γ0_1 |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.write (|
                                                      M.SubPointer.get_array_field (|
                                                        M.deref (| M.read (| lhs |) |),
                                                        M.read (| i |)
                                                      |),
                                                      M.read (| lhs |)
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.write (| borrow, M.read (| lhs |) |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            borrow
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_sbb_n :
      M.IsFunction.C "ruint::algorithms::add::sbb_n" sbb_n.
    Admitted.
    Global Typeclasses Opaque sbb_n.
  End add.
End algorithms.
