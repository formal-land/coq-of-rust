(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module algorithms.
  Module mul.
    (*
    pub fn addmul_ref(result: &mut [u64], a: &[u64], b: &[u64]) -> bool {
        let mut overflow = 0;
        for (i, a) in a.iter().copied().enumerate() {
            let mut result = result.iter_mut().skip(i);
            let mut b = b.iter().copied();
            let mut carry = 0_u128;
            loop {
                match (result.next(), b.next()) {
                    // Partial product.
                    (Some(result), Some(b)) => {
                        carry += u128::from( *result) + u128::from(a) * u128::from(b);
                        *result = carry as u64;
                        carry >>= 64;
                    }
                    // Carry propagation.
                    (Some(result), None) => {
                        carry += u128::from( *result);
                        *result = carry as u64;
                        carry >>= 64;
                    }
                    // Excess product.
                    (None, Some(b)) => {
                        carry += u128::from(a) * u128::from(b);
                        overflow |= carry as u64;
                        carry >>= 64;
                    }
                    // Fin.
                    (None, None) => {
                        break;
                    }
                }
            }
            overflow |= carry as u64;
        }
        overflow != 0
    }
    *)
    Definition addmul_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ result; a; b ] =>
        ltac:(M.monadic
          (let result := M.alloc (| result |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ overflow : Ty.path "u64" := Value.Integer IntegerKind.U64 0 in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ],
                              [],
                              [],
                              "enumerate",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  [],
                                  [],
                                  "copied",
                                  [],
                                  [ Ty.path "u64" ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                      "iter",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            ltac:(M.monadic
                              (let~ _ : Ty.tuple [] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.tuple [ Ty.path "usize"; Ty.path "u64" ] ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::copied::Copied")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u64" ]
                                                ]
                                            ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                          let i := M.copy (| γ1_0 |) in
                                          let a := M.copy (| γ1_1 |) in
                                          let~ result :
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::skip::Skip")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::IterMut")
                                                    []
                                                    [ Ty.path "u64" ]
                                                ] :=
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::skip::Skip")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::IterMut")
                                                    []
                                                    [ Ty.path "u64" ]
                                                ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::IterMut")
                                                  []
                                                  [ Ty.path "u64" ],
                                                [],
                                                [],
                                                "skip",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::IterMut")
                                                    []
                                                    [ Ty.path "u64" ],
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                                    "iter_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| result |) |)
                                                    |)
                                                  ]
                                                |);
                                                M.read (| i |)
                                              ]
                                            |) in
                                          let~ b :
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::copied::Copied")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u64" ]
                                                ] :=
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::copied::Copied")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u64" ]
                                                ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  []
                                                  [ Ty.path "u64" ],
                                                [],
                                                [],
                                                "copied",
                                                [],
                                                [ Ty.path "u64" ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u64" ],
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                                    "iter",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| b |) |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |) in
                                          let~ carry : Ty.path "u128" :=
                                            Value.Integer IntegerKind.U128 0 in
                                          let~ _ : Ty.tuple [] :=
                                            M.read (|
                                              M.loop (|
                                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      Value.Tuple
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&mut")
                                                                  []
                                                                  [ Ty.path "u64" ]
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::skip::Skip")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::IterMut")
                                                                    []
                                                                    [ Ty.path "u64" ]
                                                                ],
                                                              [],
                                                              [],
                                                              "next",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                result
                                                              |)
                                                            ]
                                                          |);
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.path "u64" ],
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::iter::adapters::copied::Copied")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::slice::iter::Iter")
                                                                    []
                                                                    [ Ty.path "u64" ]
                                                                ],
                                                              [],
                                                              [],
                                                              "next",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.borrow (| Pointer.Kind.MutRef, b |)
                                                            ]
                                                          |)
                                                        ]
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ0_0,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let result := M.copy (| γ1_0 |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ0_1,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let b := M.copy (| γ1_0 |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            let β := carry in
                                                            M.write (|
                                                              β,
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.read (| β |);
                                                                  M.call_closure (|
                                                                    Ty.path "u128",
                                                                    BinOp.Wrap.add,
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.path "u128",
                                                                        M.get_trait_method (|
                                                                          "core::convert::From",
                                                                          Ty.path "u128",
                                                                          [],
                                                                          [ Ty.path "u64" ],
                                                                          "from",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.read (|
                                                                            M.deref (|
                                                                              M.read (| result |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        Ty.path "u128",
                                                                        BinOp.Wrap.mul,
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path "u128",
                                                                            M.get_trait_method (|
                                                                              "core::convert::From",
                                                                              Ty.path "u128",
                                                                              [],
                                                                              [ Ty.path "u64" ],
                                                                              "from",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [ M.read (| a |) ]
                                                                          |);
                                                                          M.call_closure (|
                                                                            Ty.path "u128",
                                                                            M.get_trait_method (|
                                                                              "core::convert::From",
                                                                              Ty.path "u128",
                                                                              [],
                                                                              [ Ty.path "u64" ],
                                                                              "from",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [ M.read (| b |) ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            M.write (|
                                                              M.deref (| M.read (| result |) |),
                                                              M.cast
                                                                (Ty.path "u64")
                                                                (M.read (| carry |))
                                                            |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            let β := carry in
                                                            M.write (|
                                                              β,
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.shr,
                                                                [
                                                                  M.read (| β |);
                                                                  Value.Integer IntegerKind.I32 64
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ0_0,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let result := M.copy (| γ1_0 |) in
                                                          let _ :=
                                                            M.is_struct_tuple (|
                                                              γ0_1,
                                                              "core::option::Option::None"
                                                            |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            let β := carry in
                                                            M.write (|
                                                              β,
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.read (| β |);
                                                                  M.call_closure (|
                                                                    Ty.path "u128",
                                                                    M.get_trait_method (|
                                                                      "core::convert::From",
                                                                      Ty.path "u128",
                                                                      [],
                                                                      [ Ty.path "u64" ],
                                                                      "from",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (|
                                                                        M.deref (|
                                                                          M.read (| result |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            M.write (|
                                                              M.deref (| M.read (| result |) |),
                                                              M.cast
                                                                (Ty.path "u64")
                                                                (M.read (| carry |))
                                                            |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            let β := carry in
                                                            M.write (|
                                                              β,
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.shr,
                                                                [
                                                                  M.read (| β |);
                                                                  Value.Integer IntegerKind.I32 64
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let _ :=
                                                            M.is_struct_tuple (|
                                                              γ0_0,
                                                              "core::option::Option::None"
                                                            |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ0_1,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let b := M.copy (| γ1_0 |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            let β := carry in
                                                            M.write (|
                                                              β,
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.read (| β |);
                                                                  M.call_closure (|
                                                                    Ty.path "u128",
                                                                    BinOp.Wrap.mul,
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.path "u128",
                                                                        M.get_trait_method (|
                                                                          "core::convert::From",
                                                                          Ty.path "u128",
                                                                          [],
                                                                          [ Ty.path "u64" ],
                                                                          "from",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [ M.read (| a |) ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        Ty.path "u128",
                                                                        M.get_trait_method (|
                                                                          "core::convert::From",
                                                                          Ty.path "u128",
                                                                          [],
                                                                          [ Ty.path "u64" ],
                                                                          "from",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [ M.read (| b |) ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            let β := overflow in
                                                            M.write (|
                                                              β,
                                                              M.call_closure (|
                                                                Ty.path "u64",
                                                                BinOp.Wrap.bit_or,
                                                                [
                                                                  M.read (| β |);
                                                                  M.cast
                                                                    (Ty.path "u64")
                                                                    (M.read (| carry |))
                                                                ]
                                                              |)
                                                            |) in
                                                          let~ _ : Ty.tuple [] :=
                                                            let β := carry in
                                                            M.write (|
                                                              β,
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.shr,
                                                                [
                                                                  M.read (| β |);
                                                                  Value.Integer IntegerKind.I32 64
                                                                ]
                                                              |)
                                                            |) in
                                                          M.alloc (| Value.Tuple [] |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let _ :=
                                                            M.is_struct_tuple (|
                                                              γ0_0,
                                                              "core::option::Option::None"
                                                            |) in
                                                          let _ :=
                                                            M.is_struct_tuple (|
                                                              γ0_1,
                                                              "core::option::Option::None"
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)))
                                                    ]
                                                  |)))
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            let β := overflow in
                                            M.write (|
                                              β,
                                              M.call_closure (|
                                                Ty.path "u64",
                                                BinOp.Wrap.bit_or,
                                                [
                                                  M.read (| β |);
                                                  M.cast (Ty.path "u64") (M.read (| carry |))
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |))
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.ne,
                [ M.read (| overflow |); Value.Integer IntegerKind.U64 0 ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_ref :
      M.IsFunction.C "ruint::algorithms::mul::addmul_ref" addmul_ref.
    Admitted.
    Global Typeclasses Opaque addmul_ref.
    
    (*
    pub fn addmul(mut lhs: &mut [u64], mut a: &[u64], mut b: &[u64]) -> bool {
        // Trim zeros from `a`
        while let [0, rest @ ..] = a {
            a = rest;
            if let [_, rest @ ..] = lhs {
                lhs = rest;
            }
        }
        while let [rest @ .., 0] = a {
            a = rest;
        }
    
        // Trim zeros from `b`
        while let [0, rest @ ..] = b {
            b = rest;
            if let [_, rest @ ..] = lhs {
                lhs = rest;
            }
        }
        while let [rest @ .., 0] = b {
            b = rest;
        }
    
        if a.is_empty() || b.is_empty() {
            return false;
        }
        if lhs.is_empty() {
            return true;
        }
    
        let (a, b) = if b.len() > a.len() { (b, a) } else { (a, b) };
    
        // Iterate over limbs of `b` and add partial products to `lhs`.
        let mut overflow = false;
        for &b in b {
            if lhs.len() >= a.len() {
                let (target, rest) = lhs.split_at_mut(a.len());
                let carry = addmul_nx1(target, a, b);
                let carry = add_nx1(rest, carry);
                overflow |= carry != 0;
            } else {
                overflow = true;
                if lhs.is_empty() {
                    break;
                }
                addmul_nx1(lhs, &a[..lhs.len()], b);
            }
            lhs = &mut lhs[1..];
        }
        overflow
    }
    *)
    Definition addmul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.catch_return (Ty.path "bool") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := a in
                                let γ := M.read (| γ |) in
                                let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ1_0 |),
                                    Value.Integer IntegerKind.U64 0
                                  |) in
                                let rest := M.alloc (| γ1_rest |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    a,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := lhs in
                                        let γ := M.read (| γ |) in
                                        let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                        let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                                        let rest := M.alloc (| γ1_rest |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.write (|
                                            lhs,
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| rest |) |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := a in
                                let γ := M.read (| γ |) in
                                let γ1_rest := M.SubPointer.get_slice_rest (| γ, 0, 1 |) in
                                let γ1_rev0 := M.SubPointer.get_slice_rev_index (| γ, 0 |) in
                                let rest := M.alloc (| γ1_rest |) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ1_rev0 |),
                                    Value.Integer IntegerKind.U64 0
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    a,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := b in
                                let γ := M.read (| γ |) in
                                let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ1_0 |),
                                    Value.Integer IntegerKind.U64 0
                                  |) in
                                let rest := M.alloc (| γ1_rest |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    b,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := lhs in
                                        let γ := M.read (| γ |) in
                                        let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                        let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                                        let rest := M.alloc (| γ1_rest |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.write (|
                                            lhs,
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| rest |) |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := b in
                                let γ := M.read (| γ |) in
                                let γ1_rest := M.SubPointer.get_slice_rest (| γ, 0, 1 |) in
                                let γ1_rev0 := M.SubPointer.get_slice_rev_index (| γ, 0 |) in
                                let rest := M.alloc (| γ1_rest |) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ1_rev0 |),
                                    Value.Integer IntegerKind.U64 0
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    b,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| a |) |)
                                        |)
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                          "is_empty",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| b |) |)
                                          |)
                                        ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| lhs |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Bool true |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ]
                          ]
                      ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| b |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| a |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Tuple [ M.read (| b |); M.read (| a |) ] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (| Value.Tuple [ M.read (| a |); M.read (| b |) ] |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a := M.copy (| γ0_0 |) in
                        let b := M.copy (| γ0_1 |) in
                        let~ overflow : Ty.path "bool" := Value.Bool false in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.use
                              (M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                                      [],
                                      [],
                                      "into_iter",
                                      [],
                                      []
                                    |),
                                    [ M.read (| b |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let iter := M.copy (| γ |) in
                                      M.loop (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        ltac:(M.monadic
                                          (let~ _ : Ty.tuple [] :=
                                            M.read (|
                                              M.match_operator (|
                                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        []
                                                        [ Ty.path "u64" ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.MutRef, iter |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let _ :=
                                                        M.is_struct_tuple (|
                                                          γ,
                                                          "core::option::Option::None"
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (| M.break (||) |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let γ0_0 := M.read (| γ0_0 |) in
                                                      let b := M.copy (| γ0_0 |) in
                                                      let~ _ : Ty.tuple [] :=
                                                        M.read (|
                                                          M.match_operator (|
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ],
                                                            M.alloc (| Value.Tuple [] |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ :=
                                                                    M.use
                                                                      (M.alloc (|
                                                                        M.call_closure (|
                                                                          Ty.path "bool",
                                                                          BinOp.ge,
                                                                          [
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u64" ],
                                                                                "len",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (| lhs |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |);
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u64" ],
                                                                                "len",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (| a |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)) in
                                                                  let _ :=
                                                                    is_constant_or_break_match (|
                                                                      M.read (| γ |),
                                                                      Value.Bool true
                                                                    |) in
                                                                  M.match_operator (|
                                                                    Ty.apply
                                                                      (Ty.path "*")
                                                                      []
                                                                      [ Ty.tuple [] ],
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u64" ]
                                                                              ];
                                                                            Ty.apply
                                                                              (Ty.path "&mut")
                                                                              []
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u64" ]
                                                                              ]
                                                                          ],
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ Ty.path "u64" ],
                                                                          "split_at_mut",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            M.deref (|
                                                                              M.read (| lhs |)
                                                                            |)
                                                                          |);
                                                                          M.call_closure (|
                                                                            Ty.path "usize",
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path "slice")
                                                                                []
                                                                                [ Ty.path "u64" ],
                                                                              "len",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.read (| a |)
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let γ0_0 :=
                                                                            M.SubPointer.get_tuple_field (|
                                                                              γ,
                                                                              0
                                                                            |) in
                                                                          let γ0_1 :=
                                                                            M.SubPointer.get_tuple_field (|
                                                                              γ,
                                                                              1
                                                                            |) in
                                                                          let target :=
                                                                            M.copy (| γ0_0 |) in
                                                                          let rest :=
                                                                            M.copy (| γ0_1 |) in
                                                                          let~ carry :
                                                                              Ty.path "u64" :=
                                                                            M.call_closure (|
                                                                              Ty.path "u64",
                                                                              M.get_function (|
                                                                                "ruint::algorithms::mul::addmul_nx1",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.MutRef,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      target
                                                                                    |)
                                                                                  |)
                                                                                |);
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (| a |)
                                                                                  |)
                                                                                |);
                                                                                M.read (| b |)
                                                                              ]
                                                                            |) in
                                                                          let~ carry :
                                                                              Ty.path "u64" :=
                                                                            M.call_closure (|
                                                                              Ty.path "u64",
                                                                              M.get_function (|
                                                                                "ruint::algorithms::mul::add_nx1",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.MutRef,
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      rest
                                                                                    |)
                                                                                  |)
                                                                                |);
                                                                                M.read (| carry |)
                                                                              ]
                                                                            |) in
                                                                          let~ _ : Ty.tuple [] :=
                                                                            let β := overflow in
                                                                            M.write (|
                                                                              β,
                                                                              M.call_closure (|
                                                                                Ty.path "bool",
                                                                                BinOp.Wrap.bit_or,
                                                                                [
                                                                                  M.read (| β |);
                                                                                  M.call_closure (|
                                                                                    Ty.path "bool",
                                                                                    BinOp.ne,
                                                                                    [
                                                                                      M.read (|
                                                                                        carry
                                                                                      |);
                                                                                      Value.Integer
                                                                                        IntegerKind.U64
                                                                                        0
                                                                                    ]
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            |) in
                                                                          M.alloc (|
                                                                            Value.Tuple []
                                                                          |)))
                                                                    ]
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let~ _ : Ty.tuple [] :=
                                                                    M.write (|
                                                                      overflow,
                                                                      Value.Bool true
                                                                    |) in
                                                                  let~ _ : Ty.tuple [] :=
                                                                    M.read (|
                                                                      M.match_operator (|
                                                                        Ty.apply
                                                                          (Ty.path "*")
                                                                          []
                                                                          [ Ty.tuple [] ],
                                                                        M.alloc (|
                                                                          Value.Tuple []
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ :=
                                                                                M.use
                                                                                  (M.alloc (|
                                                                                    M.call_closure (|
                                                                                      Ty.path
                                                                                        "bool",
                                                                                      M.get_associated_function (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "slice")
                                                                                          []
                                                                                          [
                                                                                            Ty.path
                                                                                              "u64"
                                                                                          ],
                                                                                        "is_empty",
                                                                                        [],
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              lhs
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      ]
                                                                                    |)
                                                                                  |)) in
                                                                              let _ :=
                                                                                is_constant_or_break_match (|
                                                                                  M.read (| γ |),
                                                                                  Value.Bool true
                                                                                |) in
                                                                              M.alloc (|
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    M.break (||)
                                                                                  |)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (M.alloc (|
                                                                                Value.Tuple []
                                                                              |)))
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  let~ _ : Ty.path "u64" :=
                                                                    M.call_closure (|
                                                                      Ty.path "u64",
                                                                      M.get_function (|
                                                                        "ruint::algorithms::mul::addmul_nx1",
                                                                        [],
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.MutRef,
                                                                          M.deref (|
                                                                            M.read (| lhs |)
                                                                          |)
                                                                        |);
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.call_closure (|
                                                                                  Ty.apply
                                                                                    (Ty.path "&")
                                                                                    []
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "slice")
                                                                                        []
                                                                                        [
                                                                                          Ty.path
                                                                                            "u64"
                                                                                        ]
                                                                                    ],
                                                                                  M.get_trait_method (|
                                                                                    "core::ops::index::Index",
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "slice")
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "u64"
                                                                                      ],
                                                                                    [],
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "core::ops::range::RangeTo")
                                                                                        []
                                                                                        [
                                                                                          Ty.path
                                                                                            "usize"
                                                                                        ]
                                                                                    ],
                                                                                    "index",
                                                                                    [],
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.deref (|
                                                                                        M.read (|
                                                                                          a
                                                                                        |)
                                                                                      |)
                                                                                    |);
                                                                                    Value.StructRecord
                                                                                      "core::ops::range::RangeTo"
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ]
                                                                                      [
                                                                                        ("end_",
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "usize",
                                                                                            M.get_associated_function (|
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "slice")
                                                                                                []
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "u64"
                                                                                                ],
                                                                                              "len",
                                                                                              [],
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.read (|
                                                                                                    lhs
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |))
                                                                                      ]
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        |);
                                                                        M.read (| b |)
                                                                      ]
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ : Ty.tuple [] :=
                                                        M.write (|
                                                          lhs,
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.deref (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path "&mut")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "slice")
                                                                          []
                                                                          [ Ty.path "u64" ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::ops::index::IndexMut",
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Ty.path "u64" ],
                                                                      [],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::ops::range::RangeFrom")
                                                                          []
                                                                          [ Ty.path "usize" ]
                                                                      ],
                                                                      "index_mut",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (|
                                                                          M.read (| lhs |)
                                                                        |)
                                                                      |);
                                                                      Value.StructRecord
                                                                        "core::ops::range::RangeFrom"
                                                                        []
                                                                        [ Ty.path "usize" ]
                                                                        [
                                                                          ("start",
                                                                            Value.Integer
                                                                              IntegerKind.Usize
                                                                              1)
                                                                        ]
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                      |)))
                                ]
                              |))
                          |) in
                        overflow))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul :
      M.IsFunction.C "ruint::algorithms::mul::addmul" addmul.
    Admitted.
    Global Typeclasses Opaque addmul.
    
    (*
    pub fn add_nx1(lhs: &mut [u64], mut a: u64) -> u64 {
        if a == 0 {
            return 0;
        }
        for lhs in lhs {
            let sum = u128::add( *lhs, a);
            *lhs = sum.low();
            a = sum.high();
            if a == 0 {
                return 0;
            }
        }
        a
    }
    *)
    Definition add_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          M.catch_return (Ty.path "u64") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| a |); Value.Integer IntegerKind.U64 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.U64 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.use
                      (M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| lhs |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.read (|
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                []
                                                [ Ty.path "u64" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let lhs := M.copy (| γ0_0 |) in
                                              let~ sum : Ty.path "u128" :=
                                                M.call_closure (|
                                                  Ty.path "u128",
                                                  M.get_trait_method (|
                                                    "ruint::algorithms::DoubleWord",
                                                    Ty.path "u128",
                                                    [],
                                                    [ Ty.path "u64" ],
                                                    "add",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| M.deref (| M.read (| lhs |) |) |);
                                                    M.read (| a |)
                                                  ]
                                                |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.write (|
                                                  M.deref (| M.read (| lhs |) |),
                                                  M.call_closure (|
                                                    Ty.path "u64",
                                                    M.get_trait_method (|
                                                      "ruint::algorithms::DoubleWord",
                                                      Ty.path "u128",
                                                      [],
                                                      [ Ty.path "u64" ],
                                                      "low",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| sum |) ]
                                                  |)
                                                |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.write (|
                                                  a,
                                                  M.call_closure (|
                                                    Ty.path "u64",
                                                    M.get_trait_method (|
                                                      "ruint::algorithms::DoubleWord",
                                                      Ty.path "u128",
                                                      [],
                                                      [ Ty.path "u64" ],
                                                      "high",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| sum |) ]
                                                  |)
                                                |) in
                                              M.match_operator (|
                                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              BinOp.eq,
                                                              [
                                                                M.read (| a |);
                                                                Value.Integer IntegerKind.U64 0
                                                              ]
                                                            |)
                                                          |)) in
                                                      let _ :=
                                                        is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              Value.Integer IntegerKind.U64 0
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |)))
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |))
                  |) in
                a
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_add_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::add_nx1" add_nx1.
    Admitted.
    Global Typeclasses Opaque add_nx1.
    
    (*
    pub fn addmul_n(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), a.len());
        assert_eq!(lhs.len(), b.len());
        match lhs.len() {
            0 => {}
            1 => addmul_1(lhs, a, b),
            2 => addmul_2(lhs, a, b),
            3 => addmul_3(lhs, a, b),
            4 => addmul_4(lhs, a, b),
            _ => {
                let _ = addmul(lhs, a, b);
            }
        }
    }
    *)
    Definition addmul_n (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                    "len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 0
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 1
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_1", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 2
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_2", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 3
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_3", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 4
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_4", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_function (| "ruint::algorithms::mul::addmul", [], [] |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                          ]
                        |)
                      |),
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_n :
      M.IsFunction.C "ruint::algorithms::mul::addmul_n" addmul_n.
    Admitted.
    Global Typeclasses Opaque addmul_n.
    
    (*
    fn addmul_1(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 1);
        assert_eq!(a.len(), 1);
        assert_eq!(b.len(), 1);
    
        mac(&mut lhs[0], a[0], b[0], 0);
    }
    *)
    Definition addmul_1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_1 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_1" addmul_1.
    Admitted.
    Global Typeclasses Opaque addmul_1.
    
    (*
    fn addmul_2(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 2);
        assert_eq!(a.len(), 2);
        assert_eq!(b.len(), 2);
    
        let carry = mac(&mut lhs[0], a[0], b[0], 0);
        mac(&mut lhs[1], a[0], b[1], carry);
    
        mac(&mut lhs[1], a[1], b[0], 0);
    }
    *)
    Definition addmul_2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 2 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 2 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 2 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_2 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_2" addmul_2.
    Admitted.
    Global Typeclasses Opaque addmul_2.
    
    (*
    fn addmul_3(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 3);
        assert_eq!(a.len(), 3);
        assert_eq!(b.len(), 3);
    
        let carry = mac(&mut lhs[0], a[0], b[0], 0);
        let carry = mac(&mut lhs[1], a[0], b[1], carry);
        mac(&mut lhs[2], a[0], b[2], carry);
    
        let carry = mac(&mut lhs[1], a[1], b[0], 0);
        mac(&mut lhs[2], a[1], b[1], carry);
    
        mac(&mut lhs[2], a[2], b[0], 0);
    }
    *)
    Definition addmul_3 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 3 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 3 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 3 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_3 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_3" addmul_3.
    Admitted.
    Global Typeclasses Opaque addmul_3.
    
    (*
    fn addmul_4(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 4);
        assert_eq!(a.len(), 4);
        assert_eq!(b.len(), 4);
    
        let carry = mac(&mut lhs[0], a[0], b[0], 0);
        let carry = mac(&mut lhs[1], a[0], b[1], carry);
        let carry = mac(&mut lhs[2], a[0], b[2], carry);
        mac(&mut lhs[3], a[0], b[3], carry);
    
        let carry = mac(&mut lhs[1], a[1], b[0], 0);
        let carry = mac(&mut lhs[2], a[1], b[1], carry);
        mac(&mut lhs[3], a[1], b[2], carry);
    
        let carry = mac(&mut lhs[2], a[2], b[0], 0);
        mac(&mut lhs[3], a[2], b[1], carry);
    
        mac(&mut lhs[3], a[3], b[0], 0);
    }
    *)
    Definition addmul_4 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 4 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 4 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (| Value.Integer IntegerKind.Usize 4 |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val := M.copy (| γ0_0 |) in
                        let right_val := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 3
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 3
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 1
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 3
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 2
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 3
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 2
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  |);
                  M.read (| carry |)
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_array_field (|
                          M.deref (| M.read (| lhs |) |),
                          Value.Integer IntegerKind.Usize 3
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| a |) |),
                      Value.Integer IntegerKind.Usize 3
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| b |) |),
                      Value.Integer IntegerKind.Usize 0
                    |)
                  |);
                  Value.Integer IntegerKind.U64 0
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_4 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_4" addmul_4.
    Admitted.
    Global Typeclasses Opaque addmul_4.
    
    (*
    fn mac(lhs: &mut u64, a: u64, b: u64, c: u64) -> u64 {
        let prod = u128::muladd2(a, b, c, *lhs);
        *lhs = prod.low();
        prod.high()
    }
    *)
    Definition mac (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b; c ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          let c := M.alloc (| c |) in
          M.read (|
            let~ prod : Ty.path "u128" :=
              M.call_closure (|
                Ty.path "u128",
                M.get_trait_method (|
                  "ruint::algorithms::DoubleWord",
                  Ty.path "u128",
                  [],
                  [ Ty.path "u64" ],
                  "muladd2",
                  [],
                  []
                |),
                [
                  M.read (| a |);
                  M.read (| b |);
                  M.read (| c |);
                  M.read (| M.deref (| M.read (| lhs |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| lhs |) |),
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "ruint::algorithms::DoubleWord",
                    Ty.path "u128",
                    [],
                    [ Ty.path "u64" ],
                    "low",
                    [],
                    []
                  |),
                  [ M.read (| prod |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "ruint::algorithms::DoubleWord",
                  Ty.path "u128",
                  [],
                  [ Ty.path "u64" ],
                  "high",
                  [],
                  []
                |),
                [ M.read (| prod |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_mac : M.IsFunction.C "ruint::algorithms::mul::mac" mac.
    Admitted.
    Global Typeclasses Opaque mac.
    
    (*
    pub fn mul_nx1(lhs: &mut [u64], a: u64) -> u64 {
        let mut carry = 0;
        for lhs in &mut *lhs {
            let product = u128::muladd( *lhs, a, carry);
            *lhs = product.low();
            carry = product.high();
        }
        carry
    }
    *)
    Definition mul_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          M.read (|
            let~ carry : Ty.path "u64" := Value.Integer IntegerKind.U64 0 in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            ltac:(M.monadic
                              (let~ _ : Ty.tuple [] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::slice::iter::IterMut")
                                            []
                                            [ Ty.path "u64" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let lhs := M.copy (| γ0_0 |) in
                                          let~ product : Ty.path "u128" :=
                                            M.call_closure (|
                                              Ty.path "u128",
                                              M.get_trait_method (|
                                                "ruint::algorithms::DoubleWord",
                                                Ty.path "u128",
                                                [],
                                                [ Ty.path "u64" ],
                                                "muladd",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (| M.deref (| M.read (| lhs |) |) |);
                                                M.read (| a |);
                                                M.read (| carry |)
                                              ]
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.write (|
                                              M.deref (| M.read (| lhs |) |),
                                              M.call_closure (|
                                                Ty.path "u64",
                                                M.get_trait_method (|
                                                  "ruint::algorithms::DoubleWord",
                                                  Ty.path "u128",
                                                  [],
                                                  [ Ty.path "u64" ],
                                                  "low",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| product |) ]
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.write (|
                                              carry,
                                              M.call_closure (|
                                                Ty.path "u64",
                                                M.get_trait_method (|
                                                  "ruint::algorithms::DoubleWord",
                                                  Ty.path "u128",
                                                  [],
                                                  [ Ty.path "u64" ],
                                                  "high",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| product |) ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |))
              |) in
            carry
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_mul_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::mul_nx1" mul_nx1.
    Admitted.
    Global Typeclasses Opaque mul_nx1.
    
    (*
    pub fn addmul_nx1(lhs: &mut [u64], a: &[u64], b: u64) -> u64 {
        debug_assert_eq!(lhs.len(), a.len());
        let mut carry = 0;
        for (lhs, a) in lhs.iter_mut().zip(a.iter().copied()) {
            let product = u128::muladd2(a, b, carry, *lhs);
            *lhs = product.low();
            carry = product.high();
        }
        carry
    }
    *)
    Definition addmul_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| lhs |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| a |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val := M.copy (| γ0_0 |) in
                                    let right_val := M.copy (| γ0_1 |) in
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.read (|
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let~ kind :
                                                      Ty.path "core::panicking::AssertKind" :=
                                                    Value.StructTuple
                                                      "core::panicking::AssertKind::Eq"
                                                      []
                                                      []
                                                      [] in
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "never",
                                                      M.get_function (|
                                                        "core::panicking::assert_failed",
                                                        [],
                                                        [ Ty.path "usize"; Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.read (| kind |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| left_val |) |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          |)
                                                        |);
                                                        Value.StructTuple
                                                          "core::option::Option::None"
                                                          []
                                                          [ Ty.path "core::fmt::Arguments" ]
                                                          []
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" := Value.Integer IntegerKind.U64 0 in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::IterMut")
                                  []
                                  [ Ty.path "u64" ];
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                              [],
                              [],
                              "zip",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::IterMut")
                                  []
                                  [ Ty.path "u64" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                  "iter_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |)
                                ]
                              |);
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  [],
                                  [],
                                  "copied",
                                  [],
                                  [ Ty.path "u64" ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                      "iter",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            ltac:(M.monadic
                              (let~ _ : Ty.tuple [] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                                                Ty.path "u64"
                                              ]
                                          ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::zip::Zip")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                []
                                                [ Ty.path "u64" ];
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::copied::Copied")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u64" ]
                                                ]
                                            ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                          let lhs := M.copy (| γ1_0 |) in
                                          let a := M.copy (| γ1_1 |) in
                                          let~ product : Ty.path "u128" :=
                                            M.call_closure (|
                                              Ty.path "u128",
                                              M.get_trait_method (|
                                                "ruint::algorithms::DoubleWord",
                                                Ty.path "u128",
                                                [],
                                                [ Ty.path "u64" ],
                                                "muladd2",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (| a |);
                                                M.read (| b |);
                                                M.read (| carry |);
                                                M.read (| M.deref (| M.read (| lhs |) |) |)
                                              ]
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.write (|
                                              M.deref (| M.read (| lhs |) |),
                                              M.call_closure (|
                                                Ty.path "u64",
                                                M.get_trait_method (|
                                                  "ruint::algorithms::DoubleWord",
                                                  Ty.path "u128",
                                                  [],
                                                  [ Ty.path "u64" ],
                                                  "low",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| product |) ]
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.write (|
                                              carry,
                                              M.call_closure (|
                                                Ty.path "u64",
                                                M.get_trait_method (|
                                                  "ruint::algorithms::DoubleWord",
                                                  Ty.path "u128",
                                                  [],
                                                  [ Ty.path "u64" ],
                                                  "high",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| product |) ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |))
              |) in
            carry
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_nx1" addmul_nx1.
    Admitted.
    Global Typeclasses Opaque addmul_nx1.
    
    (*
    pub fn submul_nx1(lhs: &mut [u64], a: &[u64], b: u64) -> u64 {
        debug_assert_eq!(lhs.len(), a.len());
        let mut carry = 0;
        let mut borrow = 0;
        for (lhs, a) in lhs.iter_mut().zip(a.iter().copied()) {
            // Compute product limbs
            let limb = {
                let product = u128::muladd(a, b, carry);
                carry = product.high();
                product.low()
            };
    
            // Subtract
            let (new, b) = sbb( *lhs, limb, borrow);
            *lhs = new;
            borrow = b;
        }
        borrow + carry
    }
    *)
    Definition submul_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| lhs |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| a |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val := M.copy (| γ0_0 |) in
                                    let right_val := M.copy (| γ0_1 |) in
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.read (|
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let~ kind :
                                                      Ty.path "core::panicking::AssertKind" :=
                                                    Value.StructTuple
                                                      "core::panicking::AssertKind::Eq"
                                                      []
                                                      []
                                                      [] in
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "never",
                                                      M.get_function (|
                                                        "core::panicking::assert_failed",
                                                        [],
                                                        [ Ty.path "usize"; Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.read (| kind |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| left_val |) |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          |)
                                                        |);
                                                        Value.StructTuple
                                                          "core::option::Option::None"
                                                          []
                                                          [ Ty.path "core::fmt::Arguments" ]
                                                          []
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" := Value.Integer IntegerKind.U64 0 in
            let~ borrow : Ty.path "u64" := Value.Integer IntegerKind.U64 0 in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.use
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::IterMut")
                                  []
                                  [ Ty.path "u64" ];
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                              [],
                              [],
                              "zip",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::IterMut")
                                  []
                                  [ Ty.path "u64" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                  "iter_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |)
                                ]
                              |);
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::copied::Copied")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  [],
                                  [],
                                  "copied",
                                  [],
                                  [ Ty.path "u64" ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "u64" ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                      "iter",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            ltac:(M.monadic
                              (let~ _ : Ty.tuple [] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                                                Ty.path "u64"
                                              ]
                                          ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::zip::Zip")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                []
                                                [ Ty.path "u64" ];
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::copied::Copied")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u64" ]
                                                ]
                                            ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                          let lhs := M.copy (| γ1_0 |) in
                                          let a := M.copy (| γ1_1 |) in
                                          let~ limb : Ty.path "u64" :=
                                            M.read (|
                                              let~ product : Ty.path "u128" :=
                                                M.call_closure (|
                                                  Ty.path "u128",
                                                  M.get_trait_method (|
                                                    "ruint::algorithms::DoubleWord",
                                                    Ty.path "u128",
                                                    [],
                                                    [ Ty.path "u64" ],
                                                    "muladd",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| a |);
                                                    M.read (| b |);
                                                    M.read (| carry |)
                                                  ]
                                                |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.write (|
                                                  carry,
                                                  M.call_closure (|
                                                    Ty.path "u64",
                                                    M.get_trait_method (|
                                                      "ruint::algorithms::DoubleWord",
                                                      Ty.path "u128",
                                                      [],
                                                      [ Ty.path "u64" ],
                                                      "high",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| product |) ]
                                                  |)
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "u64",
                                                  M.get_trait_method (|
                                                    "ruint::algorithms::DoubleWord",
                                                    Ty.path "u128",
                                                    [],
                                                    [ Ty.path "u64" ],
                                                    "low",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| product |) ]
                                                |)
                                              |)
                                            |) in
                                          M.match_operator (|
                                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.tuple [ Ty.path "u64"; Ty.path "u64" ],
                                                M.get_function (|
                                                  "ruint::algorithms::ops::sbb",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (| M.deref (| M.read (| lhs |) |) |);
                                                  M.read (| limb |);
                                                  M.read (| borrow |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                  let γ0_1 :=
                                                    M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                  let new := M.copy (| γ0_0 |) in
                                                  let b := M.copy (| γ0_1 |) in
                                                  let~ _ : Ty.tuple [] :=
                                                    M.write (|
                                                      M.deref (| M.read (| lhs |) |),
                                                      M.read (| new |)
                                                    |) in
                                                  let~ _ : Ty.tuple [] :=
                                                    M.write (| borrow, M.read (| b |) |) in
                                                  M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |)))
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |))
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.add,
                [ M.read (| borrow |); M.read (| carry |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_submul_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::submul_nx1" submul_nx1.
    Admitted.
    Global Typeclasses Opaque submul_nx1.
  End mul.
End algorithms.
