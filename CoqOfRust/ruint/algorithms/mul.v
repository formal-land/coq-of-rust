(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module algorithms.
  Module mul.
    (*
    pub fn addmul_ref(result: &mut [u64], a: &[u64], b: &[u64]) -> bool {
        let mut overflow = 0;
        for (i, a) in a.iter().copied().enumerate() {
            let mut result = result.iter_mut().skip(i);
            let mut b = b.iter().copied();
            let mut carry = 0_u128;
            loop {
                match (result.next(), b.next()) {
                    // Partial product.
                    (Some(result), Some(b)) => {
                        carry += u128::from( *result) + u128::from(a) * u128::from(b);
                        *result = carry as u64;
                        carry >>= 64;
                    }
                    // Carry propagation.
                    (Some(result), None) => {
                        carry += u128::from( *result);
                        *result = carry as u64;
                        carry >>= 64;
                    }
                    // Excess product.
                    (None, Some(b)) => {
                        carry += u128::from(a) * u128::from(b);
                        overflow |= carry as u64;
                        carry >>= 64;
                    }
                    // Fin.
                    (None, None) => {
                        break;
                    }
                }
            }
            overflow |= carry as u64;
        }
        overflow != 0
    }
    *)
    Definition addmul_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ result; a; b ] =>
        ltac:(M.monadic
          (let result := M.alloc (| result |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ overflow : Ty.path "u64" := M.alloc (| Value.Integer IntegerKind.U64 0 |) in
            let~ _ : Ty.tuple [] :=
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::copied::Copied")
                            []
                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                          ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ],
                            [],
                            [],
                            "enumerate",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                [],
                                [],
                                "copied",
                                [],
                                [ Ty.path "u64" ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.tuple [ Ty.path "usize"; Ty.path "u64" ] ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::copied::Copied")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                []
                                                [ Ty.path "u64" ]
                                            ]
                                        ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let i := M.copy (| γ1_0 |) in
                                      let a := M.copy (| γ1_1 |) in
                                      let~ result :
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::skip::Skip")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                []
                                                [ Ty.path "u64" ]
                                            ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::skip::Skip")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::IterMut")
                                                  []
                                                  [ Ty.path "u64" ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                []
                                                [ Ty.path "u64" ],
                                              [],
                                              [],
                                              "skip",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::IterMut")
                                                  []
                                                  [ Ty.path "u64" ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                                  "iter_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| result |) |)
                                                  |)
                                                ]
                                              |);
                                              M.read (| i |)
                                            ]
                                          |)
                                        |) in
                                      let~ b :
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::copied::Copied")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                []
                                                [ Ty.path "u64" ]
                                            ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::copied::Copied")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  []
                                                  [ Ty.path "u64" ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                []
                                                [ Ty.path "u64" ],
                                              [],
                                              [],
                                              "copied",
                                              [],
                                              [ Ty.path "u64" ]
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  []
                                                  [ Ty.path "u64" ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                                  "iter",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| b |) |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let~ carry : Ty.path "u128" :=
                                        M.alloc (| Value.Integer IntegerKind.U128 0 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.loop (|
                                          Ty.tuple [],
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Some (Ty.tuple []),
                                              M.alloc (|
                                                Value.Tuple
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "&mut")
                                                            []
                                                            [ Ty.path "u64" ]
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::skip::Skip")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::IterMut")
                                                              []
                                                              [ Ty.path "u64" ]
                                                          ],
                                                        [],
                                                        [],
                                                        "next",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.MutRef, result |) ]
                                                    |);
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "u64" ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::copied::Copied")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::slice::iter::Iter")
                                                              []
                                                              [ Ty.path "u64" ]
                                                          ],
                                                        [],
                                                        [],
                                                        "next",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.MutRef, b |) ]
                                                    |)
                                                  ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_0,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let result := M.copy (| γ1_0 |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_1,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let b := M.copy (| γ1_0 |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β := carry in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "u128",
                                                            BinOp.Wrap.add,
                                                            [
                                                              M.read (| β |);
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path "u128",
                                                                    M.get_trait_method (|
                                                                      "core::convert::From",
                                                                      Ty.path "u128",
                                                                      [],
                                                                      [ Ty.path "u64" ],
                                                                      "from",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (|
                                                                        M.deref (|
                                                                          M.read (| result |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  M.call_closure (|
                                                                    Ty.path "u128",
                                                                    BinOp.Wrap.mul,
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.path "u128",
                                                                        M.get_trait_method (|
                                                                          "core::convert::From",
                                                                          Ty.path "u128",
                                                                          [],
                                                                          [ Ty.path "u64" ],
                                                                          "from",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [ M.read (| a |) ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        Ty.path "u128",
                                                                        M.get_trait_method (|
                                                                          "core::convert::From",
                                                                          Ty.path "u128",
                                                                          [],
                                                                          [ Ty.path "u64" ],
                                                                          "from",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [ M.read (| b |) ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.deref (| M.read (| result |) |),
                                                          M.cast
                                                            (Ty.path "u64")
                                                            (M.read (| carry |))
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β := carry in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "u128",
                                                            BinOp.Wrap.shr,
                                                            [
                                                              M.read (| β |);
                                                              Value.Integer IntegerKind.I32 64
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_0,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let result := M.copy (| γ1_0 |) in
                                                    let _ :=
                                                      M.is_struct_tuple (|
                                                        γ0_1,
                                                        "core::option::Option::None"
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β := carry in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "u128",
                                                            BinOp.Wrap.add,
                                                            [
                                                              M.read (| β |);
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                M.get_trait_method (|
                                                                  "core::convert::From",
                                                                  Ty.path "u128",
                                                                  [],
                                                                  [ Ty.path "u64" ],
                                                                  "from",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    M.deref (|
                                                                      M.read (| result |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.deref (| M.read (| result |) |),
                                                          M.cast
                                                            (Ty.path "u64")
                                                            (M.read (| carry |))
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β := carry in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "u128",
                                                            BinOp.Wrap.shr,
                                                            [
                                                              M.read (| β |);
                                                              Value.Integer IntegerKind.I32 64
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let _ :=
                                                      M.is_struct_tuple (|
                                                        γ0_0,
                                                        "core::option::Option::None"
                                                      |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_1,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let b := M.copy (| γ1_0 |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β := carry in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "u128",
                                                            BinOp.Wrap.add,
                                                            [
                                                              M.read (| β |);
                                                              M.call_closure (|
                                                                Ty.path "u128",
                                                                BinOp.Wrap.mul,
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path "u128",
                                                                    M.get_trait_method (|
                                                                      "core::convert::From",
                                                                      Ty.path "u128",
                                                                      [],
                                                                      [ Ty.path "u64" ],
                                                                      "from",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [ M.read (| a |) ]
                                                                  |);
                                                                  M.call_closure (|
                                                                    Ty.path "u128",
                                                                    M.get_trait_method (|
                                                                      "core::convert::From",
                                                                      Ty.path "u128",
                                                                      [],
                                                                      [ Ty.path "u64" ],
                                                                      "from",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [ M.read (| b |) ]
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β := overflow in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "u64",
                                                            BinOp.Wrap.bit_or,
                                                            [
                                                              M.read (| β |);
                                                              M.cast
                                                                (Ty.path "u64")
                                                                (M.read (| carry |))
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β := carry in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "u128",
                                                            BinOp.Wrap.shr,
                                                            [
                                                              M.read (| β |);
                                                              Value.Integer IntegerKind.I32 64
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let _ :=
                                                      M.is_struct_tuple (|
                                                        γ0_0,
                                                        "core::option::Option::None"
                                                      |) in
                                                    let _ :=
                                                      M.is_struct_tuple (|
                                                        γ0_1,
                                                        "core::option::Option::None"
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                                    |)))
                                              ]
                                            |)))
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          let β := overflow in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "u64",
                                              BinOp.Wrap.bit_or,
                                              [
                                                M.read (| β |);
                                                M.cast (Ty.path "u64") (M.read (| carry |))
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.ne,
                [ M.read (| overflow |); Value.Integer IntegerKind.U64 0 ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_ref :
      M.IsFunction.C "ruint::algorithms::mul::addmul_ref" addmul_ref.
    Admitted.
    Global Typeclasses Opaque addmul_ref.
    
    (*
    pub fn addmul(mut lhs: &mut [u64], mut a: &[u64], mut b: &[u64]) -> bool {
        // Trim zeros from `a`
        while let [0, rest @ ..] = a {
            a = rest;
            if let [_, rest @ ..] = lhs {
                lhs = rest;
            }
        }
        while let [rest @ .., 0] = a {
            a = rest;
        }
    
        // Trim zeros from `b`
        while let [0, rest @ ..] = b {
            b = rest;
            if let [_, rest @ ..] = lhs {
                lhs = rest;
            }
        }
        while let [rest @ .., 0] = b {
            b = rest;
        }
    
        if a.is_empty() || b.is_empty() {
            return false;
        }
        if lhs.is_empty() {
            return true;
        }
    
        let (a, b) = if b.len() > a.len() { (b, a) } else { (a, b) };
    
        // Iterate over limbs of `b` and add partial products to `lhs`.
        let mut overflow = false;
        for &b in b {
            if lhs.len() >= a.len() {
                let (target, rest) = lhs.split_at_mut(a.len());
                let carry = addmul_nx1(target, a, b);
                let carry = add_nx1(rest, carry);
                overflow |= carry != 0;
            } else {
                overflow = true;
                if lhs.is_empty() {
                    break;
                }
                addmul_nx1(lhs, &a[..lhs.len()], b);
            }
            lhs = &mut lhs[1..];
        }
        overflow
    }
    *)
    Definition addmul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := a in
                              let γ := M.read (| γ |) in
                              let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                              let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                              let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ1_0 |),
                                  Value.Integer IntegerKind.U64 0
                                |) in
                              let rest := M.alloc (| γ1_rest |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    a,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := lhs in
                                      let γ := M.read (| γ |) in
                                      let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                      let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                                      let rest := M.alloc (| γ1_rest |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            lhs,
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| rest |) |)
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := a in
                              let γ := M.read (| γ |) in
                              let γ1_rest := M.SubPointer.get_slice_rest (| γ, 0, 1 |) in
                              let γ1_rev0 := M.SubPointer.get_slice_rev_index (| γ, 0 |) in
                              let rest := M.alloc (| γ1_rest |) in
                              let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ1_rev0 |),
                                  Value.Integer IntegerKind.U64 0
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    a,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := b in
                              let γ := M.read (| γ |) in
                              let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                              let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                              let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ1_0 |),
                                  Value.Integer IntegerKind.U64 0
                                |) in
                              let rest := M.alloc (| γ1_rest |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    b,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := lhs in
                                      let γ := M.read (| γ |) in
                                      let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                      let γ1_rest := M.SubPointer.get_slice_rest (| γ, 1, 0 |) in
                                      let rest := M.alloc (| γ1_rest |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            lhs,
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| rest |) |)
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := b in
                              let γ := M.read (| γ |) in
                              let γ1_rest := M.SubPointer.get_slice_rest (| γ, 0, 1 |) in
                              let γ1_rev0 := M.SubPointer.get_slice_rev_index (| γ, 0 |) in
                              let rest := M.alloc (| γ1_rest |) in
                              let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ1_rev0 |),
                                  Value.Integer IntegerKind.U64 0
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    b,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                LogicalOp.or (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |)
                                    ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| b |) |)
                                        |)
                                      ]
                                    |)))
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                    "is_empty",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Bool true |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  None,
                  M.match_operator (|
                    Some
                      (Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ]
                        ]),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| b |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| a |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Tuple [ M.read (| b |); M.read (| a |) ] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (| Value.Tuple [ M.read (| a |); M.read (| b |) ] |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a := M.copy (| γ0_0 |) in
                        let b := M.copy (| γ0_1 |) in
                        let~ overflow : Ty.path "bool" := M.alloc (| Value.Bool false |) in
                        let~ _ : Ty.tuple [] :=
                          M.use
                            (M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::collect::IntoIterator",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                                    [],
                                    [],
                                    "into_iter",
                                    [],
                                    []
                                  |),
                                  [ M.read (| b |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let iter := M.copy (| γ |) in
                                    M.loop (|
                                      Ty.tuple [],
                                      ltac:(M.monadic
                                        (let~ _ : Ty.tuple [] :=
                                          M.match_operator (|
                                            Some (Ty.tuple []),
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [ Ty.path "u64" ],
                                                  [],
                                                  [],
                                                  "next",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.MutRef, iter |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let _ :=
                                                    M.is_struct_tuple (|
                                                      γ,
                                                      "core::option::Option::None"
                                                    |) in
                                                  M.alloc (|
                                                    M.never_to_any (| M.read (| M.break (||) |) |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let γ0_0 := M.read (| γ0_0 |) in
                                                  let b := M.copy (| γ0_0 |) in
                                                  let~ _ : Ty.tuple [] :=
                                                    M.match_operator (|
                                                      Some (Ty.tuple []),
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  M.call_closure (|
                                                                    Ty.path "bool",
                                                                    BinOp.ge,
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.path "usize",
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ Ty.path "u64" ],
                                                                          "len",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| lhs |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        Ty.path "usize",
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ Ty.path "u64" ],
                                                                          "len",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| a |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.match_operator (|
                                                              None,
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&mut")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ Ty.path "u64" ]
                                                                        ];
                                                                      Ty.apply
                                                                        (Ty.path "&mut")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [ Ty.path "u64" ]
                                                                        ]
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ Ty.path "u64" ],
                                                                    "split_at_mut",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (| M.read (| lhs |) |)
                                                                    |);
                                                                    M.call_closure (|
                                                                      Ty.path "usize",
                                                                      M.get_associated_function (|
                                                                        Ty.apply
                                                                          (Ty.path "slice")
                                                                          []
                                                                          [ Ty.path "u64" ],
                                                                        "len",
                                                                        [],
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| a |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  ]
                                                                |)
                                                              |),
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let γ0_0 :=
                                                                      M.SubPointer.get_tuple_field (|
                                                                        γ,
                                                                        0
                                                                      |) in
                                                                    let γ0_1 :=
                                                                      M.SubPointer.get_tuple_field (|
                                                                        γ,
                                                                        1
                                                                      |) in
                                                                    let target :=
                                                                      M.copy (| γ0_0 |) in
                                                                    let rest := M.copy (| γ0_1 |) in
                                                                    let~ carry : Ty.path "u64" :=
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          Ty.path "u64",
                                                                          M.get_function (|
                                                                            "ruint::algorithms::mul::addmul_nx1",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.MutRef,
                                                                              M.deref (|
                                                                                M.read (| target |)
                                                                              |)
                                                                            |);
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.read (| a |)
                                                                              |)
                                                                            |);
                                                                            M.read (| b |)
                                                                          ]
                                                                        |)
                                                                      |) in
                                                                    let~ carry : Ty.path "u64" :=
                                                                      M.alloc (|
                                                                        M.call_closure (|
                                                                          Ty.path "u64",
                                                                          M.get_function (|
                                                                            "ruint::algorithms::mul::add_nx1",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.MutRef,
                                                                              M.deref (|
                                                                                M.read (| rest |)
                                                                              |)
                                                                            |);
                                                                            M.read (| carry |)
                                                                          ]
                                                                        |)
                                                                      |) in
                                                                    let~ _ : Ty.tuple [] :=
                                                                      M.alloc (|
                                                                        let β := overflow in
                                                                        M.write (|
                                                                          β,
                                                                          M.call_closure (|
                                                                            Ty.path "bool",
                                                                            BinOp.Wrap.bit_or,
                                                                            [
                                                                              M.read (| β |);
                                                                              M.call_closure (|
                                                                                Ty.path "bool",
                                                                                BinOp.ne,
                                                                                [
                                                                                  M.read (|
                                                                                    carry
                                                                                  |);
                                                                                  Value.Integer
                                                                                    IntegerKind.U64
                                                                                    0
                                                                                ]
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      |) in
                                                                    M.alloc (| Value.Tuple [] |)))
                                                              ]
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let~ _ : Ty.tuple [] :=
                                                              M.alloc (|
                                                                M.write (|
                                                                  overflow,
                                                                  Value.Bool true
                                                                |)
                                                              |) in
                                                            let~ _ : Ty.tuple [] :=
                                                              M.match_operator (|
                                                                Some (Ty.tuple []),
                                                                M.alloc (| Value.Tuple [] |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ :=
                                                                        M.use
                                                                          (M.alloc (|
                                                                            M.call_closure (|
                                                                              Ty.path "bool",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u64" ],
                                                                                "is_empty",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (| lhs |)
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)) in
                                                                      let _ :=
                                                                        is_constant_or_break_match (|
                                                                          M.read (| γ |),
                                                                          Value.Bool true
                                                                        |) in
                                                                      M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (| M.break (||) |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.alloc (|
                                                                        Value.Tuple []
                                                                      |)))
                                                                ]
                                                              |) in
                                                            let~ _ : Ty.path "u64" :=
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path "u64",
                                                                  M.get_function (|
                                                                    "ruint::algorithms::mul::addmul_nx1",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (| M.read (| lhs |) |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.call_closure (|
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "slice")
                                                                                    []
                                                                                    [ Ty.path "u64"
                                                                                    ]
                                                                                ],
                                                                              M.get_trait_method (|
                                                                                "core::ops::index::Index",
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  []
                                                                                  [ Ty.path "u64" ],
                                                                                [],
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "core::ops::range::RangeTo")
                                                                                    []
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ]
                                                                                ],
                                                                                "index",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.deref (|
                                                                                    M.read (| a |)
                                                                                  |)
                                                                                |);
                                                                                Value.StructRecord
                                                                                  "core::ops::range::RangeTo"
                                                                                  [
                                                                                    ("end_",
                                                                                      M.call_closure (|
                                                                                        Ty.path
                                                                                          "usize",
                                                                                        M.get_associated_function (|
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "slice")
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "u64"
                                                                                            ],
                                                                                          "len",
                                                                                          [],
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                lhs
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        ]
                                                                                      |))
                                                                                  ]
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.read (| b |)
                                                                  ]
                                                                |)
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |) in
                                                  let~ _ : Ty.tuple [] :=
                                                    M.alloc (|
                                                      M.write (|
                                                        lhs,
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.deref (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "&mut")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Ty.path "u64" ]
                                                                    ],
                                                                  M.get_trait_method (|
                                                                    "core::ops::index::IndexMut",
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ Ty.path "u64" ],
                                                                    [],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::ops::range::RangeFrom")
                                                                        []
                                                                        [ Ty.path "usize" ]
                                                                    ],
                                                                    "index_mut",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (| M.read (| lhs |) |)
                                                                    |);
                                                                    Value.StructRecord
                                                                      "core::ops::range::RangeFrom"
                                                                      [
                                                                        ("start",
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                    |)))
                              ]
                            |)) in
                        overflow))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul :
      M.IsFunction.C "ruint::algorithms::mul::addmul" addmul.
    Admitted.
    Global Typeclasses Opaque addmul.
    
    (*
    pub fn add_nx1(lhs: &mut [u64], mut a: u64) -> u64 {
        if a == 0 {
            return 0;
        }
        for lhs in lhs {
            let sum = u128::add( *lhs, a);
            *lhs = sum.low();
            a = sum.high();
            if a == 0 {
                return 0;
            }
        }
        a
    }
    *)
    Definition add_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| a |); Value.Integer IntegerKind.U64 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (| M.return_ (| Value.Integer IntegerKind.U64 0 |) |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.use
                    (M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [ M.read (| lhs |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter := M.copy (| γ |) in
                            M.loop (|
                              Ty.tuple [],
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::slice::iter::IterMut")
                                            []
                                            [ Ty.path "u64" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let lhs := M.copy (| γ0_0 |) in
                                          let~ sum : Ty.path "u128" :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "u128",
                                                M.get_trait_method (|
                                                  "ruint::algorithms::DoubleWord",
                                                  Ty.path "u128",
                                                  [],
                                                  [ Ty.path "u64" ],
                                                  "add",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (| M.deref (| M.read (| lhs |) |) |);
                                                  M.read (| a |)
                                                ]
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.deref (| M.read (| lhs |) |),
                                                M.call_closure (|
                                                  Ty.path "u64",
                                                  M.get_trait_method (|
                                                    "ruint::algorithms::DoubleWord",
                                                    Ty.path "u128",
                                                    [],
                                                    [ Ty.path "u64" ],
                                                    "low",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| sum |) ]
                                                |)
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                a,
                                                M.call_closure (|
                                                  Ty.path "u64",
                                                  M.get_trait_method (|
                                                    "ruint::algorithms::DoubleWord",
                                                    Ty.path "u128",
                                                    [],
                                                    [ Ty.path "u64" ],
                                                    "high",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| sum |) ]
                                                |)
                                              |)
                                            |) in
                                          M.match_operator (|
                                            Some (Ty.tuple []),
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (| a |);
                                                            Value.Integer IntegerKind.U64 0
                                                          ]
                                                        |)
                                                      |)) in
                                                  let _ :=
                                                    is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (|
                                                          Value.Integer IntegerKind.U64 0
                                                        |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                            |)))
                      ]
                    |)) in
                a
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_add_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::add_nx1" add_nx1.
    Admitted.
    Global Typeclasses Opaque add_nx1.
    
    (*
    pub fn addmul_n(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), a.len());
        assert_eq!(lhs.len(), b.len());
        match lhs.len() {
            0 => {}
            1 => addmul_1(lhs, a, b),
            2 => addmul_2(lhs, a, b),
            3 => addmul_3(lhs, a, b),
            4 => addmul_4(lhs, a, b),
            _ => {
                let _ = addmul(lhs, a, b);
            }
        }
    }
    *)
    Definition addmul_n (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                    "len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 0
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 1
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_1", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 2
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_2", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 3
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_3", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.Usize 4
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "ruint::algorithms::mul::addmul_4", [], [] |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_function (| "ruint::algorithms::mul::addmul", [], [] |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |)
                          ]
                        |)
                      |),
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_n :
      M.IsFunction.C "ruint::algorithms::mul::addmul_n" addmul_n.
    Admitted.
    Global Typeclasses Opaque addmul_n.
    
    (*
    fn addmul_1(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 1);
        assert_eq!(a.len(), 1);
        assert_eq!(b.len(), 1);
    
        mac(&mut lhs[0], a[0], b[0], 0);
    }
    *)
    Definition addmul_1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 1 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_1 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_1" addmul_1.
    Admitted.
    Global Typeclasses Opaque addmul_1.
    
    (*
    fn addmul_2(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 2);
        assert_eq!(a.len(), 2);
        assert_eq!(b.len(), 2);
    
        let carry = mac(&mut lhs[0], a[0], b[0], 0);
        mac(&mut lhs[1], a[0], b[1], carry);
    
        mac(&mut lhs[1], a[1], b[0], 0);
    }
    *)
    Definition addmul_2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 2 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 2 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 2 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_2 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_2" addmul_2.
    Admitted.
    Global Typeclasses Opaque addmul_2.
    
    (*
    fn addmul_3(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 3);
        assert_eq!(a.len(), 3);
        assert_eq!(b.len(), 3);
    
        let carry = mac(&mut lhs[0], a[0], b[0], 0);
        let carry = mac(&mut lhs[1], a[0], b[1], carry);
        mac(&mut lhs[2], a[0], b[2], carry);
    
        let carry = mac(&mut lhs[1], a[1], b[0], 0);
        mac(&mut lhs[2], a[1], b[1], carry);
    
        mac(&mut lhs[2], a[2], b[0], 0);
    }
    *)
    Definition addmul_3 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 3 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 2
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 2
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 2
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_3 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_3" addmul_3.
    Admitted.
    Global Typeclasses Opaque addmul_3.
    
    (*
    fn addmul_4(lhs: &mut [u64], a: &[u64], b: &[u64]) {
        assert_eq!(lhs.len(), 4);
        assert_eq!(a.len(), 4);
        assert_eq!(b.len(), 4);
    
        let carry = mac(&mut lhs[0], a[0], b[0], 0);
        let carry = mac(&mut lhs[1], a[0], b[1], carry);
        let carry = mac(&mut lhs[2], a[0], b[2], carry);
        mac(&mut lhs[3], a[0], b[3], carry);
    
        let carry = mac(&mut lhs[1], a[1], b[0], 0);
        let carry = mac(&mut lhs[2], a[1], b[1], carry);
        mac(&mut lhs[3], a[1], b[2], carry);
    
        let carry = mac(&mut lhs[2], a[2], b[0], 0);
        mac(&mut lhs[3], a[2], b[1], carry);
    
        mac(&mut lhs[3], a[3], b[0], 0);
    }
    *)
    Definition addmul_4 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| lhs |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 4 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 4 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| b |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Integer IntegerKind.Usize 4 |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Eq" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 2
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 3
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 3
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 2
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 3
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ carry : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 2
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 3
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 2
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 1
                      |)
                    |);
                    M.read (| carry |)
                  ]
                |)
              |) in
            let~ _ : Ty.path "u64" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "ruint::algorithms::mul::mac", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_array_field (|
                            M.deref (| M.read (| lhs |) |),
                            Value.Integer IntegerKind.Usize 3
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| a |) |),
                        Value.Integer IntegerKind.Usize 3
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| b |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |);
                    Value.Integer IntegerKind.U64 0
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_4 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_4" addmul_4.
    Admitted.
    Global Typeclasses Opaque addmul_4.
    
    (*
    fn mac(lhs: &mut u64, a: u64, b: u64, c: u64) -> u64 {
        let prod = u128::muladd2(a, b, c, *lhs);
        *lhs = prod.low();
        prod.high()
    }
    *)
    Definition mac (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b; c ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          let c := M.alloc (| c |) in
          M.read (|
            let~ prod : Ty.path "u128" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "ruint::algorithms::DoubleWord",
                    Ty.path "u128",
                    [],
                    [ Ty.path "u64" ],
                    "muladd2",
                    [],
                    []
                  |),
                  [
                    M.read (| a |);
                    M.read (| b |);
                    M.read (| c |);
                    M.read (| M.deref (| M.read (| lhs |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| lhs |) |),
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_trait_method (|
                      "ruint::algorithms::DoubleWord",
                      Ty.path "u128",
                      [],
                      [ Ty.path "u64" ],
                      "low",
                      [],
                      []
                    |),
                    [ M.read (| prod |) ]
                  |)
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "ruint::algorithms::DoubleWord",
                  Ty.path "u128",
                  [],
                  [ Ty.path "u64" ],
                  "high",
                  [],
                  []
                |),
                [ M.read (| prod |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_mac : M.IsFunction.C "ruint::algorithms::mul::mac" mac.
    Admitted.
    Global Typeclasses Opaque mac.
    
    (*
    pub fn mul_nx1(lhs: &mut [u64], a: u64) -> u64 {
        let mut carry = 0;
        for lhs in &mut *lhs {
            let product = u128::muladd( *lhs, a, carry);
            *lhs = product.low();
            carry = product.high();
        }
        carry
    }
    *)
    Definition mul_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          M.read (|
            let~ carry : Ty.path "u64" := M.alloc (| Value.Integer IntegerKind.U64 0 |) in
            let~ _ : Ty.tuple [] :=
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ] ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        []
                                        [ Ty.path "u64" ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let lhs := M.copy (| γ0_0 |) in
                                      let~ product : Ty.path "u128" :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "u128",
                                            M.get_trait_method (|
                                              "ruint::algorithms::DoubleWord",
                                              Ty.path "u128",
                                              [],
                                              [ Ty.path "u64" ],
                                              "muladd",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (| M.deref (| M.read (| lhs |) |) |);
                                              M.read (| a |);
                                              M.read (| carry |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.deref (| M.read (| lhs |) |),
                                            M.call_closure (|
                                              Ty.path "u64",
                                              M.get_trait_method (|
                                                "ruint::algorithms::DoubleWord",
                                                Ty.path "u128",
                                                [],
                                                [ Ty.path "u64" ],
                                                "low",
                                                [],
                                                []
                                              |),
                                              [ M.read (| product |) ]
                                            |)
                                          |)
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            carry,
                                            M.call_closure (|
                                              Ty.path "u64",
                                              M.get_trait_method (|
                                                "ruint::algorithms::DoubleWord",
                                                Ty.path "u128",
                                                [],
                                                [ Ty.path "u64" ],
                                                "high",
                                                [],
                                                []
                                              |),
                                              [ M.read (| product |) ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            carry
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_mul_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::mul_nx1" mul_nx1.
    Admitted.
    Global Typeclasses Opaque mul_nx1.
    
    (*
    pub fn addmul_nx1(lhs: &mut [u64], a: &[u64], b: u64) -> u64 {
        debug_assert_eq!(lhs.len(), a.len());
        let mut carry = 0;
        for (lhs, a) in lhs.iter_mut().zip(a.iter().copied()) {
            let product = u128::muladd2(a, b, carry, *lhs);
            *lhs = product.low();
            carry = product.high();
        }
        carry
    }
    *)
    Definition addmul_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| lhs |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| a |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.eq,
                                                  [
                                                    M.read (|
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.read (|
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ carry : Ty.path "u64" := M.alloc (| Value.Integer IntegerKind.U64 0 |) in
            let~ _ : Ty.tuple [] :=
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                          Ty.apply
                            (Ty.path "core::iter::adapters::copied::Copied")
                            []
                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                          ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                            [],
                            [],
                            "zip",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "iter_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |) ]
                            |);
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                [],
                                [],
                                "copied",
                                [],
                                [ Ty.path "u64" ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                                            Ty.path "u64"
                                          ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::zip::Zip")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::IterMut")
                                            []
                                            [ Ty.path "u64" ];
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::copied::Copied")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                []
                                                [ Ty.path "u64" ]
                                            ]
                                        ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let lhs := M.copy (| γ1_0 |) in
                                      let a := M.copy (| γ1_1 |) in
                                      let~ product : Ty.path "u128" :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "u128",
                                            M.get_trait_method (|
                                              "ruint::algorithms::DoubleWord",
                                              Ty.path "u128",
                                              [],
                                              [ Ty.path "u64" ],
                                              "muladd2",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (| a |);
                                              M.read (| b |);
                                              M.read (| carry |);
                                              M.read (| M.deref (| M.read (| lhs |) |) |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            M.deref (| M.read (| lhs |) |),
                                            M.call_closure (|
                                              Ty.path "u64",
                                              M.get_trait_method (|
                                                "ruint::algorithms::DoubleWord",
                                                Ty.path "u128",
                                                [],
                                                [ Ty.path "u64" ],
                                                "low",
                                                [],
                                                []
                                              |),
                                              [ M.read (| product |) ]
                                            |)
                                          |)
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.write (|
                                            carry,
                                            M.call_closure (|
                                              Ty.path "u64",
                                              M.get_trait_method (|
                                                "ruint::algorithms::DoubleWord",
                                                Ty.path "u128",
                                                [],
                                                [ Ty.path "u64" ],
                                                "high",
                                                [],
                                                []
                                              |),
                                              [ M.read (| product |) ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            carry
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_addmul_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::addmul_nx1" addmul_nx1.
    Admitted.
    Global Typeclasses Opaque addmul_nx1.
    
    (*
    pub fn submul_nx1(lhs: &mut [u64], a: &[u64], b: u64) -> u64 {
        debug_assert_eq!(lhs.len(), a.len());
        let mut carry = 0;
        let mut borrow = 0;
        for (lhs, a) in lhs.iter_mut().zip(a.iter().copied()) {
            // Compute product limbs
            let limb = {
                let product = u128::muladd(a, b, carry);
                carry = product.high();
                product.low()
            };
    
            // Subtract
            let (new, b) = sbb( *lhs, limb, borrow);
            *lhs = new;
            borrow = b;
        }
        borrow + carry
    }
    *)
    Definition submul_nx1 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ lhs; a; b ] =>
        ltac:(M.monadic
          (let lhs := M.alloc (| lhs |) in
          let a := M.alloc (| a |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| lhs |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| a |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.eq,
                                                  [
                                                    M.read (|
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.read (|
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ carry : Ty.path "u64" := M.alloc (| Value.Integer IntegerKind.U64 0 |) in
            let~ borrow : Ty.path "u64" := M.alloc (| Value.Integer IntegerKind.U64 0 |) in
            let~ _ : Ty.tuple [] :=
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                          Ty.apply
                            (Ty.path "core::iter::adapters::copied::Copied")
                            []
                            [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                            Ty.apply
                              (Ty.path "core::iter::adapters::copied::Copied")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ] ]
                          ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ];
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                            [],
                            [],
                            "zip",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u64" ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "iter_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| lhs |) |) |) ]
                            |);
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::copied::Copied")
                                []
                                [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ]
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                [],
                                [],
                                "copied",
                                [],
                                [ Ty.path "u64" ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| a |) |) |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&mut") [] [ Ty.path "u64" ];
                                            Ty.path "u64"
                                          ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::zip::Zip")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::IterMut")
                                            []
                                            [ Ty.path "u64" ];
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::copied::Copied")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                []
                                                [ Ty.path "u64" ]
                                            ]
                                        ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let lhs := M.copy (| γ1_0 |) in
                                      let a := M.copy (| γ1_1 |) in
                                      let~ limb : Ty.path "u64" :=
                                        M.copy (|
                                          let~ product : Ty.path "u128" :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "u128",
                                                M.get_trait_method (|
                                                  "ruint::algorithms::DoubleWord",
                                                  Ty.path "u128",
                                                  [],
                                                  [ Ty.path "u64" ],
                                                  "muladd",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| a |); M.read (| b |); M.read (| carry |)
                                                ]
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                carry,
                                                M.call_closure (|
                                                  Ty.path "u64",
                                                  M.get_trait_method (|
                                                    "ruint::algorithms::DoubleWord",
                                                    Ty.path "u128",
                                                    [],
                                                    [ Ty.path "u64" ],
                                                    "high",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| product |) ]
                                                |)
                                              |)
                                            |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "u64",
                                              M.get_trait_method (|
                                                "ruint::algorithms::DoubleWord",
                                                Ty.path "u128",
                                                [],
                                                [ Ty.path "u64" ],
                                                "low",
                                                [],
                                                []
                                              |),
                                              [ M.read (| product |) ]
                                            |)
                                          |)
                                        |) in
                                      M.match_operator (|
                                        None,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [ Ty.path "u64"; Ty.path "u64" ],
                                            M.get_function (|
                                              "ruint::algorithms::ops::sbb",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (| M.deref (| M.read (| lhs |) |) |);
                                              M.read (| limb |);
                                              M.read (| borrow |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let new := M.copy (| γ0_0 |) in
                                              let b := M.copy (| γ0_1 |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.alloc (|
                                                  M.write (|
                                                    M.deref (| M.read (| lhs |) |),
                                                    M.read (| new |)
                                                  |)
                                                |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.alloc (|
                                                  M.write (| borrow, M.read (| b |) |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.add,
                [ M.read (| borrow |); M.read (| carry |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_submul_nx1 :
      M.IsFunction.C "ruint::algorithms::mul::submul_nx1" submul_nx1.
    Admitted.
    Global Typeclasses Opaque submul_nx1.
  End mul.
End algorithms.
