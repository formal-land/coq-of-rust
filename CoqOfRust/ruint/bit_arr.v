(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bit_arr.
  (* StructTuple
    {
      name := "Bits";
      const_params := [ "BITS"; "LIMBS" ];
      ty_params := [];
      fields := [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ];
    } *)
  
  Module Impl_core_fmt_Debug_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (* Debug *)
    Definition fmt
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Bits" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt BITS LIMBS)) ].
  End Impl_core_fmt_Debug_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_clone_Clone_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (* Clone *)
    Definition clone
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *) [ ("clone", InstanceField.Method (clone BITS LIMBS)) ].
  End Impl_core_clone_Clone_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_marker_Copy_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *) [].
  End Impl_core_marker_Copy_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_default_Default_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (* Default *)
    Definition default
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "ruint::bit_arr::Bits"
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *) [ ("default", InstanceField.Method (default BITS LIMBS)) ].
  End Impl_core_default_Default_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_cmp_Eq_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("assert_receiver_is_total_eq",
            InstanceField.Method (assert_receiver_is_total_eq BITS LIMBS))
        ].
  End Impl_core_cmp_Eq_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_marker_StructuralPartialEq_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_cmp_PartialEq_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (* PartialEq *)
    Definition eq
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "ruint::bit_arr::Bits",
                  0
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "ruint::bit_arr::Bits",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("eq", InstanceField.Method (eq BITS LIMBS)) ].
  End Impl_core_cmp_PartialEq_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_hash_Hash_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (* Hash *)
    Definition hash
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [],
              "hash",
              [],
              [ __H ]
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *) [ ("hash", InstanceField.Method (hash BITS LIMBS)) ].
  End Impl_core_hash_Hash_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_convert_From_ruint_Uint_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
        fn from(value: Uint<BITS, LIMBS>) -> Self {
            Self(value)
        }
    *)
    Definition from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple "ruint::bit_arr::Bits" [ M.read (| value |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("from", InstanceField.Method (from BITS LIMBS)) ].
  End Impl_core_convert_From_ruint_Uint_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_convert_From_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
        fn from(value: Bits<BITS, LIMBS>) -> Self {
            value.0
        }
    *)
    Definition from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (| M.SubPointer.get_struct_tuple_field (| value, "ruint::bit_arr::Bits", 0 |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("from", InstanceField.Method (from BITS LIMBS)) ].
  End Impl_core_convert_From_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_str_traits_FromStr_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*     type Err = <Uint<BITS, LIMBS> as FromStr>::Err; *)
    Definition _Err (BITS LIMBS : Value.t) : Ty.t :=
      Ty.associated_in_trait
        "core::str::traits::FromStr"
        []
        []
        (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [])
        "Err".
    
    (*
        fn from_str(src: &str) -> Result<Self, Self::Err> {
            src.parse().map(Self)
        }
    *)
    Definition from_str
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.path "ruint::string::ParseError"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                  Ty.path "ruint::string::ParseError"
                ],
              "map",
              [],
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.function
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  (Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                    Ty.path "ruint::string::ParseError"
                  ],
                M.get_associated_function (|
                  Ty.path "str",
                  "parse",
                  [],
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) ]
              |);
              M.constructor_as_closure "ruint::bit_arr::Bits"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::str::traits::FromStr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Err", InstanceField.Ty (_Err BITS LIMBS));
          ("from_str", InstanceField.Method (from_str BITS LIMBS))
        ].
  End Impl_core_str_traits_FromStr_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*     pub const LIMBS: usize = Uint::<BITS, LIMBS>::LIMBS; *)
    (* Ty.path "usize" *)
    Definition value_LIMBS
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      ltac:(M.monadic
        (get_associated_constant (|
          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
          "LIMBS",
          Ty.path "usize"
        |))).
    
    Global Instance AssociatedConstant_value_LIMBS :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "LIMBS" (value_LIMBS BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque value_LIMBS.
    
    (*     pub const BITS: usize = Uint::<BITS, LIMBS>::BITS; *)
    (* Ty.path "usize" *)
    Definition value_BITS
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      ltac:(M.monadic
        (get_associated_constant (|
          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
          "BITS",
          Ty.path "usize"
        |))).
    
    Global Instance AssociatedConstant_value_BITS :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "BITS" (value_BITS BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque value_BITS.
    
    (*     pub const BYTES: usize = Uint::<BITS, LIMBS>::BYTES; *)
    (* Ty.path "usize" *)
    Definition value_BYTES
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      ltac:(M.monadic
        (get_associated_constant (|
          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
          "BYTES",
          Ty.path "usize"
        |))).
    
    Global Instance AssociatedConstant_value_BYTES :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "BYTES" (value_BYTES BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque value_BYTES.
    
    (*     pub const ZERO: Self = Self(Uint::<BITS, LIMBS>::ZERO); *)
    (* Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] *)
    Definition value_ZERO
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "ruint::bit_arr::Bits"
            [
              M.read (|
                get_associated_constant (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "ZERO",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                |)
              |)
            ]
        |))).
    
    Global Instance AssociatedConstant_value_ZERO :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "ZERO" (value_ZERO BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque value_ZERO.
    
    (*
        pub const fn into_inner(self) -> Uint<BITS, LIMBS> {
            self.0
        }
    *)
    Definition into_inner
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_inner :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "into_inner" (into_inner BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque into_inner.
    
    (*
        pub const fn as_uint(&self) -> &Uint<BITS, LIMBS> {
            &self.0
        }
    *)
    Definition as_uint
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "ruint::bit_arr::Bits",
                  0
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_uint :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "as_uint" (as_uint BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque as_uint.
    
    (*
        pub fn as_uint_mut(&mut self) -> &mut Uint<BITS, LIMBS> {
            &mut self.0
        }
    *)
    Definition as_uint_mut
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_uint_mut :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "as_uint_mut" (as_uint_mut BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque as_uint_mut.
    (*
                    pub fn $fnname(self) -> $res {
                        Uint::$fnname(self.0).into()
                    }
    *)
    Definition reverse_bits
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "reverse_bits",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_reverse_bits :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "reverse_bits" (reverse_bits BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque reverse_bits.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition as_le_bytes
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::borrow::Cow")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply
                (Ty.path "alloc::borrow::Cow")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              [],
              [
                Ty.apply
                  (Ty.path "alloc::borrow::Cow")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
              ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::borrow::Cow")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "as_le_bytes",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_le_bytes :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "as_le_bytes" (as_le_bytes BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque as_le_bytes.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition to_be_bytes_vec
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "to_be_bytes_vec",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_be_bytes_vec :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "to_be_bytes_vec" (to_be_bytes_vec BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque to_be_bytes_vec.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition to_le_bytes
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [ BYTES ], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "to_le_bytes",
                  [ BYTES ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_le_bytes :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "to_le_bytes" (to_le_bytes BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque to_le_bytes.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition to_be_bytes
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [ BYTES ], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ BYTES ] [ Ty.path "u8" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "to_be_bytes",
                  [ BYTES ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_be_bytes :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "to_be_bytes" (to_be_bytes BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque to_be_bytes.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition leading_zeros
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.path "usize",
              [],
              [ Ty.path "usize" ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "leading_zeros",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_leading_zeros :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "leading_zeros" (leading_zeros BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque leading_zeros.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition leading_ones
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.path "usize",
              [],
              [ Ty.path "usize" ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "leading_ones",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_leading_ones :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "leading_ones" (leading_ones BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque leading_ones.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition trailing_zeros
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.path "usize",
              [],
              [ Ty.path "usize" ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "trailing_zeros",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_trailing_zeros :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "trailing_zeros" (trailing_zeros BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque trailing_zeros.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res {
                        Uint::$fnname(&self.0).into()
                    }
    *)
    Definition trailing_ones
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.path "usize",
              [],
              [ Ty.path "usize" ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "trailing_ones",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_trailing_ones :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "trailing_ones" (trailing_ones BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque trailing_ones.
    
    (*
                    pub unsafe fn $fnname(&mut self) -> $res {
                        Uint::$fnname(&mut self.0).into()
                    }
    *)
    Definition as_limbs_mut
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ]
                  ],
                  "into",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "as_limbs_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_tuple_field (|
                                  M.deref (| M.read (| self |) |),
                                  "ruint::bit_arr::Bits",
                                  0
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_limbs_mut :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "as_limbs_mut" (as_limbs_mut BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque as_limbs_mut.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> Option<Self> {
                        Uint::$fnname(self.0, $arg).map(Bits::from)
                    }
    *)
    Definition checked_shl
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              "map",
              [],
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.function
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  (Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "checked_shl",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |);
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
                [],
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                "from",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_shl :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_shl" (checked_shl BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque checked_shl.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> Option<Self> {
                        Uint::$fnname(self.0, $arg).map(Bits::from)
                    }
    *)
    Definition checked_shr
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              "map",
              [],
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.function
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  (Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "checked_shr",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |);
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
                [],
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                "from",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_shr :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_shr" (checked_shr BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque checked_shr.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> (Self, bool) {
                        let (value, flag) = Uint::$fnname(self.0, $arg);
                        (value.into(), flag)
                    }
    *)
    Definition overflowing_shl
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "overflowing_shl",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (| rhs |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value := M.copy (| γ0_0 |) in
                    let flag := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              [],
                              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| value |) ]
                          |);
                          M.read (| flag |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_overflowing_shl :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_shl" (overflowing_shl BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque overflowing_shl.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> (Self, bool) {
                        let (value, flag) = Uint::$fnname(self.0, $arg);
                        (value.into(), flag)
                    }
    *)
    Definition overflowing_shr
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "overflowing_shr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (| rhs |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value := M.copy (| γ0_0 |) in
                    let flag := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              [],
                              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| value |) ]
                          |);
                          M.read (| flag |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_overflowing_shr :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_shr" (overflowing_shr BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque overflowing_shr.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> $res {
                        Uint::$fnname(self.0, $arg).into()
                    }
    *)
    Definition wrapping_shl
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "wrapping_shl",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_shl :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_shl" (wrapping_shl BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque wrapping_shl.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> $res {
                        Uint::$fnname(self.0, $arg).into()
                    }
    *)
    Definition wrapping_shr
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "wrapping_shr",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_shr :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_shr" (wrapping_shr BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque wrapping_shr.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> $res {
                        Uint::$fnname(self.0, $arg).into()
                    }
    *)
    Definition rotate_left
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "rotate_left",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_rotate_left :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "rotate_left" (rotate_left BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque rotate_left.
    
    (*
                    pub fn $fnname(self, $arg: $arg_ty) -> $res {
                        Uint::$fnname(self.0, $arg).into()
                    }
    *)
    Definition rotate_right
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "rotate_right",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_rotate_right :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "rotate_right" (rotate_right BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque rotate_right.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?($($arg: $arg_ty),+) -> Option<Self> {
                        Uint::$fnname($($arg),+).map(Bits::from)
                    }
    *)
    Definition try_from_be_slice
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              "map",
              [],
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.function
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  (Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "try_from_be_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
              |);
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
                [],
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                "from",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_from_be_slice :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "try_from_be_slice" (try_from_be_slice BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque try_from_be_slice.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?($($arg: $arg_ty),+) -> Option<Self> {
                        Uint::$fnname($($arg),+).map(Bits::from)
                    }
    *)
    Definition try_from_le_slice
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              "map",
              [],
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.function
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  (Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "try_from_le_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
              |);
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
                [],
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                "from",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_from_le_slice :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "try_from_le_slice" (try_from_le_slice BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque try_from_le_slice.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?($($arg: $arg_ty),+) -> Result<Self, $err_ty> {
                        Uint::$fnname($($arg),+).map(Bits::from)
                    }
    *)
    Definition from_str_radix
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.path "ruint::string::ParseError"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                  Ty.path "ruint::string::ParseError"
                ],
              "map",
              [],
              [
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [];
                Ty.function
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  (Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [])
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                    Ty.path "ruint::string::ParseError"
                  ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "from_str_radix",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |);
                  M.read (| radix |)
                ]
              |);
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
                [],
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                "from",
                [],
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_str_radix :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "from_str_radix" (from_str_radix BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque from_str_radix.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?($($arg: $arg_ty),+) -> $res {
                        Uint::$fnname($($arg),+).into()
                    }
    *)
    Definition from_be_bytes
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [ BYTES ], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "from_be_bytes",
                  [ BYTES ],
                  []
                |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_be_bytes :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "from_be_bytes" (from_be_bytes BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque from_be_bytes.
    
    (*
                    pub fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?($($arg: $arg_ty),+) -> $res {
                        Uint::$fnname($($arg),+).into()
                    }
    *)
    Definition from_le_bytes
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [ BYTES ], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "from_le_bytes",
                  [ BYTES ],
                  []
                |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_le_bytes :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "from_le_bytes" (from_le_bytes BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque from_le_bytes.
    
    (*
                    pub const fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?($($arg: $arg_ty),+) -> Self {
                        Bits(Uint::$fnname($($arg),+))
                    }
    *)
    Definition from_limbs
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ limbs ] =>
        ltac:(M.monadic
          (let limbs := M.alloc (| limbs |) in
          Value.StructTuple
            "ruint::bit_arr::Bits"
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "from_limbs",
                  [],
                  []
                |),
                [ M.read (| limbs |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_limbs :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "from_limbs" (from_limbs BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque from_limbs.
    
    (*
                    pub const fn $fnname$(<$(const $generic_arg: $generic_ty),+>)?(&self) -> $res_ty {
                        Uint::$fnname(&self.0)
                    }
    *)
    Definition as_limbs
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "as_limbs",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_limbs :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "as_limbs" (as_limbs BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque as_limbs.
  End Impl_ruint_bit_arr_Bits_BITS_LIMBS.
  
  
  Module Impl_core_ops_index_Index_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*     type Output = bool; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t := Ty.path "bool".
    
    (*
        fn index(&self, index: usize) -> &Self::Output {
            if self.0.bit(index) {
                &true
            } else {
                &false
            }
        }
    *)
    Definition index
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.read (|
            M.match_operator (|
              Some (Ty.apply (Ty.path "&") [] [ Ty.path "bool" ]),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "bit",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_tuple_field (|
                                  M.deref (| M.read (| self |) |),
                                  "ruint::bit_arr::Bits",
                                  0
                                |)
                              |);
                              M.read (| index |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Bool true |) |) |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Bool false |) |)
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::index::Index"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("index", InstanceField.Method (index BITS LIMBS))
        ].
  End Impl_core_ops_index_Index_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Not_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*     type Output = Self; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
        fn not(self) -> Self {
            self.0.not().into()
        }
    *)
    Definition not
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Not",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [],
                  "not",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Not"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("not", InstanceField.Method (not BITS LIMBS))
        ].
  End Impl_core_ops_bit_Not_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Not_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*     type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
        fn not(self) -> Bits<BITS, LIMBS> {
            self.0.not().into()
        }
    *)
    Definition not
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Not",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [],
                  "not",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Not"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("not", InstanceField.Method (not BITS LIMBS))
        ].
  End Impl_core_ops_bit_Not_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitOrAssign_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Bits<BITS, LIMBS>) {
                    self.0.$fn_assign(&rhs.0);
                }
    *)
    Definition bitor_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOrAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ],
                    "bitor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitOrAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("bitor_assign", InstanceField.Method (bitor_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_BitOrAssign_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitOrAssign_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Bits<BITS, LIMBS>) {
                    self.0.$fn_assign(rhs.0);
                }
    *)
    Definition bitor_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOrAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| rhs |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitOrAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *) [ ("bitor_assign", InstanceField.Method (bitor_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_BitOrAssign_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitOr_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(mut self, rhs: Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.$fn_assign(rhs.0);
                    self
                }
    *)
    Definition bitor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOrAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |)
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitor", InstanceField.Method (bitor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitOr_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitOr_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(mut self, rhs: &Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.$fn_assign(rhs.0);
                    self
                }
    *)
    Definition bitor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOrAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| rhs |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitor", InstanceField.Method (bitor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitOr_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitOr_ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, mut rhs: Bits<BITS, LIMBS>) -> Self::Output {
                    rhs.0.$fn_assign(self.0);
                    rhs
                }
    *)
    Definition bitor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOrAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            rhs
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitor", InstanceField.Method (bitor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitOr_ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitOr_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.clone().$fn(rhs.0).into()
                }
    *)
    Definition bitor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::BitOr",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                  "bitor",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    ]
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| rhs |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitor", InstanceField.Method (bitor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitOr_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitAndAssign_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Bits<BITS, LIMBS>) {
                    self.0.$fn_assign(&rhs.0);
                }
    *)
    Definition bitand_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ],
                    "bitand_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitAndAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("bitand_assign", InstanceField.Method (bitand_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_BitAndAssign_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitAndAssign_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Bits<BITS, LIMBS>) {
                    self.0.$fn_assign(rhs.0);
                }
    *)
    Definition bitand_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitand_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| rhs |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitAndAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *) [ ("bitand_assign", InstanceField.Method (bitand_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_BitAndAssign_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitAnd_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(mut self, rhs: Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.$fn_assign(rhs.0);
                    self
                }
    *)
    Definition bitand
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitand_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |)
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitAnd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitand", InstanceField.Method (bitand BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitAnd_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitAnd_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(mut self, rhs: &Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.$fn_assign(rhs.0);
                    self
                }
    *)
    Definition bitand
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitand_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| rhs |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitAnd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitand", InstanceField.Method (bitand BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitAnd_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitAnd_ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, mut rhs: Bits<BITS, LIMBS>) -> Self::Output {
                    rhs.0.$fn_assign(self.0);
                    rhs
                }
    *)
    Definition bitand
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitand_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            rhs
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitAnd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitand", InstanceField.Method (bitand BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitAnd_ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitAnd_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.clone().$fn(rhs.0).into()
                }
    *)
    Definition bitand
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::BitAnd",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                  "bitand",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    ]
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| rhs |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitAnd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitand", InstanceField.Method (bitand BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitAnd_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitXorAssign_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Bits<BITS, LIMBS>) {
                    self.0.$fn_assign(&rhs.0);
                }
    *)
    Definition bitxor_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXorAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ],
                    "bitxor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitXorAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("bitxor_assign", InstanceField.Method (bitxor_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_BitXorAssign_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitXorAssign_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Bits<BITS, LIMBS>) {
                    self.0.$fn_assign(rhs.0);
                }
    *)
    Definition bitxor_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXorAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitxor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| rhs |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitXorAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *) [ ("bitxor_assign", InstanceField.Method (bitxor_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_BitXorAssign_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitXor_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(mut self, rhs: Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.$fn_assign(rhs.0);
                    self
                }
    *)
    Definition bitxor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXorAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitxor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |)
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitXor"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitxor", InstanceField.Method (bitxor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitXor_ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitXor_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(mut self, rhs: &Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.$fn_assign(rhs.0);
                    self
                }
    *)
    Definition bitxor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXorAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitxor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| rhs |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitXor"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitxor", InstanceField.Method (bitxor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitXor_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitXor_ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, mut rhs: Bits<BITS, LIMBS>) -> Self::Output {
                    rhs.0.$fn_assign(self.0);
                    rhs
                }
    *)
    Definition bitxor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXorAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitxor_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (| rhs, "ruint::bit_arr::Bits", 0 |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |)
                  ]
                |)
              |) in
            rhs
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitXor"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitxor", InstanceField.Method (bitxor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitXor_ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_BitXor_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Bits<BITS, LIMBS>) -> Self::Output {
                    self.0.clone().$fn(rhs.0).into()
                }
    *)
    Definition bitxor
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::BitXor",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                  "bitxor",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "ruint::bit_arr::Bits",
                          0
                        |)
                      |)
                    ]
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| rhs |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::BitXor"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ]
        ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("bitxor", InstanceField.Method (bitxor BITS LIMBS))
        ].
  End Impl_core_ops_bit_BitXor_ref__ruint_bit_arr_Bits_BITS_LIMBS_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_ShlAssign_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: usize) {
                    self.0.$fn_assign(rhs);
                }
    *)
    Definition shl_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::ShlAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.path "usize" ],
                    "shl_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::ShlAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_ShlAssign_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_ShlAssign_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &usize) {
                    self.0.$fn_assign(rhs);
                }
    *)
    Definition shl_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::ShlAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                    "shl_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::ShlAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_ShlAssign_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shl_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Self; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: usize) -> Self {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shl
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shl",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.path "usize" ],
                  "shl",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shl"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shl", InstanceField.Method (shl BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shl_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shl_usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: usize) -> Self::Output {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shl
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shl",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.path "usize" ],
                  "shl",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shl"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shl", InstanceField.Method (shl BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shl_usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shl_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Self; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &usize) -> Self {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shl
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shl",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                  "shl",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shl"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shl", InstanceField.Method (shl BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shl_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shl_ref__usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &usize) -> Self::Output {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shl
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shl",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                  "shl",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shl"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shl", InstanceField.Method (shl BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shl_ref__usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_ShrAssign_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: usize) {
                    self.0.$fn_assign(rhs);
                }
    *)
    Definition shr_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::ShrAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.path "usize" ],
                    "shr_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::ShrAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_ShrAssign_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_ShrAssign_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &usize) {
                    self.0.$fn_assign(rhs);
                }
    *)
    Definition shr_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::ShrAssign",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                    "shr_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "ruint::bit_arr::Bits",
                        0
                      |)
                    |);
                    M.read (| rhs |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::ShrAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
  End Impl_core_ops_bit_ShrAssign_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shr_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Self; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: usize) -> Self {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shr
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shr",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.path "usize" ],
                  "shr",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shr", InstanceField.Method (shr BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shr_usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shr_usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: usize) -> Self::Output {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shr
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shr",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.path "usize" ],
                  "shr",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shr", InstanceField.Method (shr BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shr_usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shr_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*             type Output = Self; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &usize) -> Self {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shr
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shr",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                  "shr",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "ruint::bit_arr::Bits", 0 |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shr", InstanceField.Method (shr BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shr_ref__usize_for_ruint_bit_arr_Bits_BITS_LIMBS.
  
  Module Impl_core_ops_bit_Shr_ref__usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Bits<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &usize) -> Self::Output {
                    self.0.$fn(rhs).into()
                }
    *)
    Definition shr
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.apply (Ty.path "ruint::bit_arr::Bits") [ BITS; LIMBS ] [] ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.get_trait_method (|
                  "core::ops::bit::Shr",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                  "shr",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ruint::bit_arr::Bits",
                      0
                    |)
                  |);
                  M.read (| rhs |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::bit::Shr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("shr", InstanceField.Method (shr BITS LIMBS))
        ].
  End Impl_core_ops_bit_Shr_ref__usize_for_ref__ruint_bit_arr_Bits_BITS_LIMBS.
End bit_arr.
