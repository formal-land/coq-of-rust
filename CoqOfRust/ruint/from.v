(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module from.
  (*
  Enum ToUintError
  {
    const_params := [];
    ty_params := [ "T" ];
    variants :=
      [
        {
          name := "ValueTooLarge";
          item := StructTuple [ Ty.path "usize"; T ];
        };
        {
          name := "ValueNegative";
          item := StructTuple [ Ty.path "usize"; T ];
        };
        {
          name := "NotANumber";
          item := StructTuple [ Ty.path "usize" ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_ToUintError_ValueTooLarge :
    M.IsDiscriminant "ruint::from::ToUintError::ValueTooLarge" 0.
  Axiom IsDiscriminant_ToUintError_ValueNegative :
    M.IsDiscriminant "ruint::from::ToUintError::ValueNegative" 1.
  Axiom IsDiscriminant_ToUintError_NotANumber :
    M.IsDiscriminant "ruint::from::ToUintError::NotANumber" 2.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    (* Clone *)
    Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "ruint::from::ToUintError::ValueTooLarge"
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "usize",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |);
                          M.call_closure (|
                            T,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              T,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "ruint::from::ToUintError::ValueNegative"
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "usize",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |);
                          M.call_closure (|
                            T,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              T,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::NotANumber",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "ruint::from::ToUintError::NotANumber"
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "usize",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_for_ruint_from_ToUintError_T.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_T_for_ruint_from_ToUintError_T.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "ValueTooLarge" |) |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |))
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field2_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "ValueNegative" |) |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |))
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::NotANumber",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NotANumber" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |))
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_ruint_from_ToUintError_T.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_ruint_from_ToUintError_T.
  
  Module Impl_core_marker_StructuralPartialEq_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_ruint_from_ToUintError_T.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_ruint_from_ToUintError_T_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    (* PartialEq *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ] ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ] ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::ToUintError::ValueTooLarge",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::ToUintError::ValueTooLarge",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "ruint::from::ToUintError::ValueTooLarge",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "ruint::from::ToUintError::ValueTooLarge",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ T ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::ToUintError::ValueNegative",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::ToUintError::ValueNegative",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "ruint::from::ToUintError::ValueNegative",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "ruint::from::ToUintError::ValueNegative",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ T ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::ToUintError::NotANumber",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "ruint::from::ToUintError::NotANumber",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::intrinsics::unreachable", [], [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_ruint_from_ToUintError_T_for_ruint_from_ToUintError_T.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    (* Hash *)
    Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ] ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "usize",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ __H ] |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "usize",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ __H ] |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::NotANumber",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "usize",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_T_for_ruint_from_ToUintError_T.
  
  Module Impl_core_error_Error_where_core_fmt_Debug_T_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_error_Error_where_core_fmt_Debug_T_for_ruint_from_ToUintError_T.
  
  Module Impl_core_fmt_Display_for_ruint_from_ToUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::ToUintError") [] [ T ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::ValueTooLarge(bits, _) => write!(f, "Value is too large for Uint<{bits}>"),
                Self::ValueNegative(bits, _) => {
                    write!(f, "Negative values cannot be represented as Uint<{bits}>")
                }
                Self::NotANumber(bits) => {
                    write!(
                        f,
                        "'Not a number' (NaN) cannot be represented as Uint<{bits}>"
                    )
                }
            }
        }
    *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueTooLarge",
                        1
                      |) in
                    let bits := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (| "Value is too large for Uint<" |);
                                          mk_str (| ">" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, bits |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::ValueNegative",
                        1
                      |) in
                    let bits := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (|
                                            "Negative values cannot be represented as Uint<"
                                          |);
                                          mk_str (| ">" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, bits |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::ToUintError::NotANumber",
                        0
                      |) in
                    let bits := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (|
                                            "'Not a number' (NaN) cannot be represented as Uint<"
                                          |);
                                          mk_str (| ">" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, bits |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Display_for_ruint_from_ToUintError_T.
  
  (*
  Enum FromUintError
  {
    const_params := [];
    ty_params := [ "T" ];
    variants :=
      [
        {
          name := "Overflow";
          item := StructTuple [ Ty.path "usize"; T; T ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_FromUintError_Overflow :
    M.IsDiscriminant "ruint::from::FromUintError::Overflow" 0.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    (* Clone *)
    Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        1
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        2
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    M.alloc (|
                      Value.StructTuple
                        "ruint::from::FromUintError::Overflow"
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "usize",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |);
                          M.call_closure (|
                            T,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              T,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |);
                          M.call_closure (|
                            T,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              T,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_for_ruint_from_FromUintError_T.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_T_for_ruint_from_FromUintError_T.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        1
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        2
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field3_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Overflow" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |));
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_2 |) |)
                            |))
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_ruint_from_FromUintError_T.
  
  Module Impl_core_marker_StructuralPartialEq_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_ruint_from_FromUintError_T.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_ruint_from_FromUintError_T_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    (* PartialEq *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "ruint::from::FromUintError::Overflow",
                        0
                      |) in
                    let γ2_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "ruint::from::FromUintError::Overflow",
                        1
                      |) in
                    let γ2_2 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "ruint::from::FromUintError::Overflow",
                        2
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let __self_1 := M.alloc (| γ2_1 |) in
                    let __self_2 := M.alloc (| γ2_2 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "ruint::from::FromUintError::Overflow",
                        0
                      |) in
                    let γ2_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "ruint::from::FromUintError::Overflow",
                        1
                      |) in
                    let γ2_2 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "ruint::from::FromUintError::Overflow",
                        2
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    let __arg1_1 := M.alloc (| γ2_1 |) in
                    let __arg1_2 := M.alloc (| γ2_2 |) in
                    M.alloc (|
                      LogicalOp.and (|
                        LogicalOp.and (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                              [],
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, __self_0 |);
                              M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                            ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply (Ty.path "&") [] [ T ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                              ]
                            |)))
                        |),
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              Ty.apply (Ty.path "&") [] [ T ],
                              [],
                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, __self_2 |);
                              M.borrow (| Pointer.Kind.Ref, __arg1_2 |)
                            ]
                          |)))
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_ruint_from_FromUintError_T_for_ruint_from_FromUintError_T.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_ruint_from_FromUintError_T.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    (* Hash *)
    Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        1
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        2
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "usize",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            T,
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ __H ] |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_T_for_ruint_from_FromUintError_T.
  
  Module Impl_core_error_Error_where_core_fmt_Debug_T_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_error_Error_where_core_fmt_Debug_T_for_ruint_from_FromUintError_T.
  
  Module Impl_core_fmt_Display_for_ruint_from_FromUintError_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Overflow(bits, ..) => write!(
                    f,
                    "Uint<{bits}> value is too large for {}",
                    core::any::type_name::<T>()
                ),
            }
        }
    *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "ruint::from::FromUintError::Overflow",
                        0
                      |) in
                    let bits := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (| "Uint<" |);
                                          mk_str (| "> value is too large for " |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 2 ]
                                            [ Ty.path "core::fmt::rt::Argument" ]
                                        ],
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                                  M.get_function (|
                                                    "core::any::type_name",
                                                    [],
                                                    [ T ]
                                                  |),
                                                  []
                                                |)
                                              |)
                                            |);
                                            M.borrow (| Pointer.Kind.Ref, bits |)
                                          ]
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let args := M.copy (| γ |) in
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_display",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.read (|
                                                            M.SubPointer.get_tuple_field (|
                                                              args,
                                                              1
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_display",
                                                      [],
                                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.read (|
                                                            M.SubPointer.get_tuple_field (|
                                                              args,
                                                              0
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Display_for_ruint_from_FromUintError_T.
  
  (*
  Enum ToFieldError
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "NotInField";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_ToFieldError_NotInField :
    M.IsDiscriminant "ruint::from::ToFieldError::NotInField" 0.
  
  Module Impl_core_fmt_Debug_for_ruint_from_ToFieldError.
    Definition Self : Ty.t := Ty.path "ruint::from::ToFieldError".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NotInField" |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_ruint_from_ToFieldError.
  
  Module Impl_core_clone_Clone_for_ruint_from_ToFieldError.
    Definition Self : Ty.t := Ty.path "ruint::from::ToFieldError".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_ruint_from_ToFieldError.
  
  Module Impl_core_marker_Copy_for_ruint_from_ToFieldError.
    Definition Self : Ty.t := Ty.path "ruint::from::ToFieldError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_ruint_from_ToFieldError.
  
  Module Impl_core_error_Error_for_ruint_from_ToFieldError.
    Definition Self : Ty.t := Ty.path "ruint::from::ToFieldError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_error_Error_for_ruint_from_ToFieldError.
  
  Module Impl_core_fmt_Display_for_ruint_from_ToFieldError.
    Definition Self : Ty.t := Ty.path "ruint::from::ToFieldError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::NotInField => {
                    f.write_str("Number is equal or larger than the target field modulus.")
                }
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ := M.is_struct_tuple (| γ, "ruint::from::ToFieldError::NotInField" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              mk_str (|
                                "Number is equal or larger than the target field modulus."
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_ruint_from_ToFieldError.
  
  Module Impl_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
        pub fn from<T>(value: T) -> Self
        where
            Self: UintTryFrom<T>,
        {
            match Self::uint_try_from(value) {
                Ok(n) => n,
                Err(e) => panic!("Uint conversion error: {e}"),
            }
        }
    *)
    Definition from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [ T ], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ],
                  M.get_trait_method (|
                    "ruint::from::UintTryFrom",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ T ],
                    "uint_try_from",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let n := M.copy (| γ0_0 |) in
                    n));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    let e := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                [
                                  Value.Integer IntegerKind.Usize 1;
                                  Value.Integer IntegerKind.Usize 1
                                ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array [ mk_str (| "Uint conversion error: " |) ]
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.call_closure (|
                                              Ty.path "core::fmt::rt::Argument",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Argument",
                                                "new_display",
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::from::ToUintError")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "ruint::Uint")
                                                        [ BITS; LIMBS ]
                                                        []
                                                    ]
                                                ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.borrow (| Pointer.Kind.Ref, e |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "from" (from BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque from.
    
    (*
        pub fn saturating_from<T>(value: T) -> Self
        where
            Self: UintTryFrom<T>,
        {
            match Self::uint_try_from(value) {
                Ok(n) => n,
                Err(ToUintError::ValueTooLarge(..)) => Self::MAX,
                Err(ToUintError::ValueNegative(..) | ToUintError::NotANumber(_)) => Self::ZERO,
            }
        }
    *)
    Definition saturating_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [ T ], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ],
                  M.get_trait_method (|
                    "ruint::from::UintTryFrom",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ T ],
                    "uint_try_from",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let n := M.copy (| γ0_0 |) in
                    n));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    let _ :=
                      M.is_struct_tuple (| γ0_0, "ruint::from::ToUintError::ValueTooLarge" |) in
                    get_associated_constant (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "MAX",
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.find_or_pattern (Ty.tuple []) (|
                      γ0_0,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "ruint::from::ToUintError::ValueNegative"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "ruint::from::ToUintError::NotANumber",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            ltac:(M.monadic
                              (get_associated_constant (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "ZERO",
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_saturating_from :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_from" (saturating_from BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque saturating_from.
    
    (*
        pub fn wrapping_from<T>(value: T) -> Self
        where
            Self: UintTryFrom<T>,
        {
            match Self::uint_try_from(value) {
                Ok(n) | Err(ToUintError::ValueTooLarge(_, n) | ToUintError::ValueNegative(_, n)) => n,
                Err(ToUintError::NotANumber(_)) => Self::ZERO,
            }
        }
    *)
    Definition wrapping_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [ T ], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ],
                  M.get_trait_method (|
                    "ruint::from::UintTryFrom",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ T ],
                    "uint_try_from",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern
                      (Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::result::Result::Ok",
                                0
                              |) in
                            let n := M.copy (| γ0_0 |) in
                            Value.Tuple [ n ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::result::Result::Err",
                                0
                              |) in
                            M.find_or_pattern
                              (Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                              γ0_0,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "ruint::from::ToUintError::ValueTooLarge",
                                        0
                                      |) in
                                    let γ0_1 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "ruint::from::ToUintError::ValueTooLarge",
                                        1
                                      |) in
                                    let n := M.copy (| γ0_1 |) in
                                    Value.Tuple [ n ]));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "ruint::from::ToUintError::ValueNegative",
                                        0
                                      |) in
                                    let γ0_1 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "ruint::from::ToUintError::ValueNegative",
                                        1
                                      |) in
                                    let n := M.copy (| γ0_1 |) in
                                    Value.Tuple [ n ]))
                              ],
                              fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ n ] => ltac:(M.monadic (Value.Tuple [ n ]))
                                  | _ => M.impossible "wrong number of arguments"
                                  end)
                            |)))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ n ] => ltac:(M.monadic n)
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "ruint::from::ToUintError::NotANumber",
                        0
                      |) in
                    get_associated_constant (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "ZERO",
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_from :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_from" (wrapping_from BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque wrapping_from.
    
    (*
        pub fn to<T>(&self) -> T
        where
            Self: UintTryTo<T>,
            T: Debug,
        {
            self.uint_try_to().expect("Uint conversion error")
        }
    *)
    Definition to
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            T,
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ T; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ] ],
              "expect",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ T; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ] ],
                M.get_trait_method (|
                  "ruint::from::UintTryTo",
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  [],
                  [ T ],
                  "uint_try_to",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Uint conversion error" |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "to" (to BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque to.
    
    (*
        pub fn wrapping_to<T>(&self) -> T
        where
            Self: UintTryTo<T>,
        {
            match self.uint_try_to() {
                Ok(n) | Err(FromUintError::Overflow(_, n, _)) => n,
            }
        }
    *)
    Definition wrapping_to
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ T ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ T; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ] ],
                  M.get_trait_method (|
                    "ruint::from::UintTryTo",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ T ],
                    "uint_try_to",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple [ T ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::result::Result::Ok",
                                0
                              |) in
                            let n := M.copy (| γ0_0 |) in
                            Value.Tuple [ n ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::result::Result::Err",
                                0
                              |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::FromUintError::Overflow",
                                0
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::FromUintError::Overflow",
                                1
                              |) in
                            let γ1_2 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::FromUintError::Overflow",
                                2
                              |) in
                            let n := M.copy (| γ1_1 |) in
                            Value.Tuple [ n ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ n ] => ltac:(M.monadic n)
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_to :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_to" (wrapping_to BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque wrapping_to.
    
    (*
        pub fn saturating_to<T>(&self) -> T
        where
            Self: UintTryTo<T>,
        {
            match self.uint_try_to() {
                Ok(n) | Err(FromUintError::Overflow(_, _, n)) => n,
            }
        }
    *)
    Definition saturating_to
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ T ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ T; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ] ],
                  M.get_trait_method (|
                    "ruint::from::UintTryTo",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ T ],
                    "uint_try_to",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple [ T ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::result::Result::Ok",
                                0
                              |) in
                            let n := M.copy (| γ0_0 |) in
                            Value.Tuple [ n ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::result::Result::Err",
                                0
                              |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::FromUintError::Overflow",
                                0
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::FromUintError::Overflow",
                                1
                              |) in
                            let γ1_2 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "ruint::from::FromUintError::Overflow",
                                2
                              |) in
                            let n := M.copy (| γ1_2 |) in
                            Value.Tuple [ n ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ n ] => ltac:(M.monadic n)
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_saturating_to :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_to" (saturating_to BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque saturating_to.
    
    (*
        pub fn from_uint<const BITS_SRC: usize, const LIMBS_SRC: usize>(
            value: Uint<BITS_SRC, LIMBS_SRC>,
        ) -> Self {
            Self::from_limbs_slice(value.as_limbs())
        }
    *)
    Definition from_uint
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [ BITS_SRC; LIMBS_SRC ], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "from_limbs_slice",
              [],
              []
            |),
            [
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "array") [ LIMBS_SRC ] [ Ty.path "u64" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS_SRC; LIMBS_SRC ] [],
                        "as_limbs",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, value |) ]
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_uint :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "from_uint" (from_uint BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque from_uint.
    
    (*
        pub fn checked_from_uint<const BITS_SRC: usize, const LIMBS_SRC: usize>(
            value: Uint<BITS_SRC, LIMBS_SRC>,
        ) -> Option<Self> {
            Self::checked_from_limbs_slice(value.as_limbs())
        }
    *)
    Definition checked_from_uint
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [ BITS_SRC; LIMBS_SRC ], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "checked_from_limbs_slice",
              [],
              []
            |),
            [
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "array") [ LIMBS_SRC ] [ Ty.path "u64" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS_SRC; LIMBS_SRC ] [],
                        "as_limbs",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, value |) ]
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_from_uint :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_from_uint" (checked_from_uint BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque checked_from_uint.
  End Impl_ruint_Uint_BITS_LIMBS.
  
  (* Trait *)
  (* Empty module 'UintTryFrom' *)
  
  Module Impl_ruint_from_UintTryFrom_where_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_T_T_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
        fn uint_try_from(value: T) -> Result<Self, ToUintError<Self>> {
            Self::try_from(value)
        }
    *)
    Definition uint_try_from
        (BITS LIMBS : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS T in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.apply
                  (Ty.path "ruint::from::ToUintError")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ T ],
              "try_from",
              [],
              []
            |),
            [ M.read (| value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "ruint::from::UintTryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self BITS LIMBS T)
        (* Instance *) [ ("uint_try_from", InstanceField.Method (uint_try_from BITS LIMBS T)) ].
  End Impl_ruint_from_UintTryFrom_where_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_T_T_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_ruint_from_UintTryFrom_ruint_Uint_BITS_SRC_LIMBS_SRC_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS BITS_SRC LIMBS_SRC : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
        fn uint_try_from(value: Uint<BITS_SRC, LIMBS_SRC>) -> Result<Self, ToUintError<Self>> {
            let (n, overflow) = Self::overflowing_from_limbs_slice(value.as_limbs());
            if overflow {
                Err(ToUintError::ValueTooLarge(BITS, n))
            } else {
                Ok(n)
            }
        }
    *)
    Definition uint_try_from
        (BITS LIMBS BITS_SRC LIMBS_SRC : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS BITS_SRC LIMBS_SRC in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "overflowing_from_limbs_slice",
                    [],
                    []
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "array") [ LIMBS_SRC ] [ Ty.path "u64" ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS_SRC; LIMBS_SRC ] [],
                              "as_limbs",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, value |) ]
                          |)
                        |)
                      |))
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let n := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                              Ty.apply
                                (Ty.path "ruint::from::ToUintError")
                                []
                                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                            ]
                        ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use overflow in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  Value.StructTuple
                                    "ruint::from::ToUintError::ValueTooLarge"
                                    [ BITS; M.read (| n |) ]
                                ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Ok" [ M.read (| n |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS BITS_SRC LIMBS_SRC : Value.t),
      M.IsTraitInstance
        "ruint::from::UintTryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS_SRC; LIMBS_SRC ] [] ]
        (Self BITS LIMBS BITS_SRC LIMBS_SRC)
        (* Instance *)
        [ ("uint_try_from", InstanceField.Method (uint_try_from BITS LIMBS BITS_SRC LIMBS_SRC)) ].
  End Impl_ruint_from_UintTryFrom_ruint_Uint_BITS_SRC_LIMBS_SRC_for_ruint_Uint_BITS_LIMBS.
  
  (* Trait *)
  (* Empty module 'UintTryTo' *)
  
  Module Impl_ruint_from_UintTryTo_where_core_convert_TryFrom_T_ref__ruint_Uint_BITS_LIMBS_T_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
        fn uint_try_to(&self) -> Result<T, FromUintError<T>> {
            T::try_from(self)
        }
    *)
    Definition uint_try_to
        (BITS LIMBS : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ T; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ T ] ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              T,
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "ruint::from::UintTryTo"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self BITS LIMBS T)
        (* Instance *) [ ("uint_try_to", InstanceField.Method (uint_try_to BITS LIMBS T)) ].
  End Impl_ruint_from_UintTryTo_where_core_convert_TryFrom_T_ref__ruint_Uint_BITS_LIMBS_T_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_ruint_from_UintTryTo_ruint_Uint_BITS_DST_LIMBS_DST_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS BITS_DST LIMBS_DST : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
        fn uint_try_to(
            &self,
        ) -> Result<Uint<BITS_DST, LIMBS_DST>, FromUintError<Uint<BITS_DST, LIMBS_DST>>> {
            let (n, overflow) = Uint::overflowing_from_limbs_slice(self.as_limbs());
            if overflow {
                Err(FromUintError::Overflow(BITS_DST, n, Uint::MAX))
            } else {
                Ok(n)
            }
        }
    *)
    Definition uint_try_to
        (BITS LIMBS BITS_DST LIMBS_DST : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS BITS_DST LIMBS_DST in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS_DST; LIMBS_DST ] [];
                      Ty.apply
                        (Ty.path "ruint::from::FromUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS_DST; LIMBS_DST ] [] ]
                    ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS_DST; LIMBS_DST ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS_DST; LIMBS_DST ] [],
                    "overflowing_from_limbs_slice",
                    [],
                    []
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "as_limbs",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |))
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let n := M.copy (| γ0_0 |) in
                    let overflow := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply (Ty.path "ruint::Uint") [ BITS_DST; LIMBS_DST ] [];
                              Ty.apply
                                (Ty.path "ruint::from::FromUintError")
                                []
                                [ Ty.apply (Ty.path "ruint::Uint") [ BITS_DST; LIMBS_DST ] [] ]
                            ]
                        ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use overflow in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  Value.StructTuple
                                    "ruint::from::FromUintError::Overflow"
                                    [
                                      BITS_DST;
                                      M.read (| n |);
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [ BITS_DST; LIMBS_DST ]
                                            [],
                                          "MAX",
                                          Ty.apply
                                            (Ty.path "ruint::Uint")
                                            [ BITS_DST; LIMBS_DST ]
                                            []
                                        |)
                                      |)
                                    ]
                                ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Ok" [ M.read (| n |) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS BITS_DST LIMBS_DST : Value.t),
      M.IsTraitInstance
        "ruint::from::UintTryTo"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS_DST; LIMBS_DST ] [] ]
        (Self BITS LIMBS BITS_DST LIMBS_DST)
        (* Instance *)
        [ ("uint_try_to", InstanceField.Method (uint_try_to BITS LIMBS BITS_DST LIMBS_DST)) ].
  End Impl_ruint_from_UintTryTo_ruint_Uint_BITS_DST_LIMBS_DST_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_u64_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*     type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
        fn try_from(value: u64) -> Result<Self, Self::Error> {
            if LIMBS <= 1 {
                if value > Self::MASK {
                    // Construct wrapped value
                    let mut limbs = [0; LIMBS];
                    if LIMBS == 1 {
                        limbs[0] = value & Self::MASK;
                    }
                    return Err(ToUintError::ValueTooLarge(BITS, Self::from_limbs(limbs)));
                }
                if LIMBS == 0 {
                    return Ok(Self::ZERO);
                }
            }
            let mut limbs = [0; LIMBS];
            limbs[0] = value;
            Ok(Self::from_limbs(limbs))
        }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [ Ty.path "u64" ]
                  (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [])
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ LIMBS; Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.gt,
                                            [
                                              M.read (| value |);
                                              M.read (|
                                                get_associated_constant (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "MASK",
                                                  Ty.path "u64"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ limbs :
                                              Ty.apply
                                                (Ty.path "*")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ LIMBS ]
                                                    [ Ty.path "u64" ]
                                                ] :=
                                            M.alloc (|
                                              repeat (| Value.Integer IntegerKind.U64 0, LIMBS |)
                                            |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.match_operator (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "bool",
                                                            BinOp.eq,
                                                            [
                                                              LIMBS;
                                                              Value.Integer IntegerKind.Usize 1
                                                            ]
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.SubPointer.get_array_field (|
                                                            limbs,
                                                            Value.Integer IntegerKind.Usize 0
                                                          |),
                                                          M.call_closure (|
                                                            Ty.path "u64",
                                                            BinOp.Wrap.bit_and,
                                                            [
                                                              M.read (| value |);
                                                              M.read (|
                                                                get_associated_constant (|
                                                                  Ty.apply
                                                                    (Ty.path "ruint::Uint")
                                                                    [ BITS; LIMBS ]
                                                                    [],
                                                                  "MASK",
                                                                  Ty.path "u64"
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::result::Result::Err"
                                              [
                                                Value.StructTuple
                                                  "ruint::from::ToUintError::ValueTooLarge"
                                                  [
                                                    BITS;
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "ruint::Uint")
                                                        [ BITS; LIMBS ]
                                                        [],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [ BITS; LIMBS ]
                                                          [],
                                                        "from_limbs",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| limbs |) ]
                                                    |)
                                                  ]
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [ LIMBS; Value.Integer IntegerKind.Usize 0 ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Ok"
                                            [
                                              M.read (|
                                                get_associated_constant (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "ZERO",
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    []
                                                |)
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ limbs :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ] :=
                  M.alloc (| repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_array_field (| limbs, Value.Integer IntegerKind.Usize 0 |),
                      M.read (| value |)
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "from_limbs",
                          [],
                          []
                        |),
                        [ M.read (| limbs |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u64" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_u64_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_u128_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*     type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
        fn try_from(value: u128) -> Result<Self, Self::Error> {
            if value <= u64::MAX as u128 {
                return Self::try_from(value as u64);
            }
            if Self::LIMBS < 2 {
                return Self::try_from(value as u64)
                    .and_then(|n| Err(ToUintError::ValueTooLarge(BITS, n)));
            }
            let mut limbs = [0; LIMBS];
            limbs[0] = value as u64;
            limbs[1] = (value >> 64) as u64;
            if Self::LIMBS == 2 && limbs[1] > Self::MASK {
                limbs[1] %= Self::MASK;
                Err(ToUintError::ValueTooLarge(BITS, Self::from_limbs(limbs)))
            } else {
                Ok(Self::from_limbs(limbs))
            }
        }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [ Ty.path "u128" ]
                  (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [])
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [
                                    M.read (| value |);
                                    M.cast
                                      (Ty.path "u128")
                                      (M.read (|
                                        get_associated_constant (|
                                          Ty.path "u64",
                                          "MAX",
                                          Ty.path "u64"
                                        |)
                                      |))
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.cast (Ty.path "u64") (M.read (| value |)) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "LIMBS",
                                        Ty.path "usize"
                                      |)
                                    |);
                                    Value.Integer IntegerKind.Usize 2
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                          Ty.apply
                                            (Ty.path "ruint::from::ToUintError")
                                            []
                                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                        ],
                                      "and_then",
                                      [],
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ]
                                          (Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                              Ty.apply
                                                (Ty.path "ruint::from::ToUintError")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    []
                                                ]
                                            ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                            Ty.apply
                                              (Ty.path "ruint::from::ToUintError")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ],
                                        M.get_trait_method (|
                                          "core::convert::TryFrom",
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          [],
                                          [ Ty.path "u64" ],
                                          "try_from",
                                          [],
                                          []
                                        |),
                                        [ M.cast (Ty.path "u64") (M.read (| value |)) ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              ltac:(M.monadic
                                                (M.match_operator (|
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "ruint::Uint")
                                                                [ BITS; LIMBS ]
                                                                []
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [ BITS; LIMBS ]
                                                              [];
                                                            Ty.apply
                                                              (Ty.path "ruint::from::ToUintError")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "ruint::Uint")
                                                                  [ BITS; LIMBS ]
                                                                  []
                                                              ]
                                                          ])
                                                    ],
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let n := M.copy (| γ |) in
                                                        Value.StructTuple
                                                          "core::result::Result::Err"
                                                          [
                                                            Value.StructTuple
                                                              "ruint::from::ToUintError::ValueTooLarge"
                                                              [ BITS; M.read (| n |) ]
                                                          ]))
                                                  ]
                                                |)))
                                            | _ => M.impossible "wrong number of arguments"
                                            end))
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ limbs :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ] :=
                  M.alloc (| repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_array_field (| limbs, Value.Integer IntegerKind.Usize 0 |),
                      M.cast (Ty.path "u64") (M.read (| value |))
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_array_field (| limbs, Value.Integer IntegerKind.Usize 1 |),
                      M.cast
                        (Ty.path "u64")
                        (M.call_closure (|
                          Ty.path "u128",
                          BinOp.Wrap.shr,
                          [ M.read (| value |); Value.Integer IntegerKind.I32 64 ]
                        |))
                    |)
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                          Ty.apply
                            (Ty.path "ruint::from::ToUintError")
                            []
                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                        ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "LIMBS",
                                        Ty.path "usize"
                                      |)
                                    |);
                                    Value.Integer IntegerKind.Usize 2
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          limbs,
                                          Value.Integer IntegerKind.Usize 1
                                        |)
                                      |);
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          "MASK",
                                          Ty.path "u64"
                                        |)
                                      |)
                                    ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            let β :=
                              M.SubPointer.get_array_field (|
                                limbs,
                                Value.Integer IntegerKind.Usize 1
                              |) in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.rem,
                                [
                                  M.read (| β |);
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      "MASK",
                                      Ty.path "u64"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "ruint::from::ToUintError::ValueTooLarge"
                                [
                                  BITS;
                                  M.call_closure (|
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      "from_limbs",
                                      [],
                                      []
                                    |),
                                    [ M.read (| limbs |) ]
                                  |)
                                ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "from_limbs",
                                  [],
                                  []
                                |),
                                [ M.read (| limbs |) ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u128" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_u128_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_bool_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $uint) -> Result<Self, Self::Error> {
                    Self::try_from(value as u64)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.apply
                  (Ty.path "ruint::from::ToUintError")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.path "u64" ],
              "try_from",
              [],
              []
            |),
            [ M.cast (Ty.path "u64") (M.read (| value |)) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bool" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_bool_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_u8_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $uint) -> Result<Self, Self::Error> {
                    Self::try_from(value as u64)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.apply
                  (Ty.path "ruint::from::ToUintError")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.path "u64" ],
              "try_from",
              [],
              []
            |),
            [ M.cast (Ty.path "u64") (M.read (| value |)) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_u8_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_u16_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $uint) -> Result<Self, Self::Error> {
                    Self::try_from(value as u64)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.apply
                  (Ty.path "ruint::from::ToUintError")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.path "u64" ],
              "try_from",
              [],
              []
            |),
            [ M.cast (Ty.path "u64") (M.read (| value |)) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u16" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_u16_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_u32_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $uint) -> Result<Self, Self::Error> {
                    Self::try_from(value as u64)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.apply
                  (Ty.path "ruint::from::ToUintError")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.path "u64" ],
              "try_from",
              [],
              []
            |),
            [ M.cast (Ty.path "u64") (M.read (| value |)) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u32" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_u32_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_usize_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $uint) -> Result<Self, Self::Error> {
                    Self::try_from(value as u64)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.apply
                  (Ty.path "ruint::from::ToUintError")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.path "u64" ],
              "try_from",
              [],
              []
            |),
            [ M.cast (Ty.path "u64") (M.read (| value |)) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "usize" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_usize_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_i8_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $int) -> Result<Self, Self::Error> {
                    if value.is_negative() {
                        Err(match Self::try_from(value as $uint) {
                            Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => {
                                ToUintError::ValueNegative(BITS, n)
                            }
                            _ => unreachable!(),
                        })
                    } else {
                        Self::try_from(value as $uint)
                    }
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (| Ty.path "i8", "is_negative", [], [] |),
                            [ M.read (| value |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.read (|
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "u8" ],
                                    "try_from",
                                    [],
                                    []
                                  |),
                                  [ M.cast (Ty.path "u8") (M.read (| value |)) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.find_or_pattern
                                      (Ty.tuple
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                                      γ,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Ok",
                                                0
                                              |) in
                                            let n := M.copy (| γ0_0 |) in
                                            Value.Tuple [ n ]));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Err",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                0
                                              |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                1
                                              |) in
                                            let n := M.copy (| γ1_1 |) in
                                            Value.Tuple [ n ]))
                                      ],
                                      fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ n ] =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                Value.StructTuple
                                                  "ruint::from::ToUintError::ValueNegative"
                                                  [ BITS; M.read (| n |) ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "internal error: entered unreachable code" |)
                                          ]
                                        |)
                                      |)
                                    |)))
                              ]
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                            Ty.apply
                              (Ty.path "ruint::from::ToUintError")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                          ],
                        M.get_trait_method (|
                          "core::convert::TryFrom",
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          [],
                          [ Ty.path "u8" ],
                          "try_from",
                          [],
                          []
                        |),
                        [ M.cast (Ty.path "u8") (M.read (| value |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "i8" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_i8_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_i16_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $int) -> Result<Self, Self::Error> {
                    if value.is_negative() {
                        Err(match Self::try_from(value as $uint) {
                            Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => {
                                ToUintError::ValueNegative(BITS, n)
                            }
                            _ => unreachable!(),
                        })
                    } else {
                        Self::try_from(value as $uint)
                    }
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (| Ty.path "i16", "is_negative", [], [] |),
                            [ M.read (| value |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.read (|
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "u16" ],
                                    "try_from",
                                    [],
                                    []
                                  |),
                                  [ M.cast (Ty.path "u16") (M.read (| value |)) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.find_or_pattern
                                      (Ty.tuple
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                                      γ,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Ok",
                                                0
                                              |) in
                                            let n := M.copy (| γ0_0 |) in
                                            Value.Tuple [ n ]));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Err",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                0
                                              |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                1
                                              |) in
                                            let n := M.copy (| γ1_1 |) in
                                            Value.Tuple [ n ]))
                                      ],
                                      fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ n ] =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                Value.StructTuple
                                                  "ruint::from::ToUintError::ValueNegative"
                                                  [ BITS; M.read (| n |) ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "internal error: entered unreachable code" |)
                                          ]
                                        |)
                                      |)
                                    |)))
                              ]
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                            Ty.apply
                              (Ty.path "ruint::from::ToUintError")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                          ],
                        M.get_trait_method (|
                          "core::convert::TryFrom",
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          [],
                          [ Ty.path "u16" ],
                          "try_from",
                          [],
                          []
                        |),
                        [ M.cast (Ty.path "u16") (M.read (| value |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "i16" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_i16_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_i32_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $int) -> Result<Self, Self::Error> {
                    if value.is_negative() {
                        Err(match Self::try_from(value as $uint) {
                            Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => {
                                ToUintError::ValueNegative(BITS, n)
                            }
                            _ => unreachable!(),
                        })
                    } else {
                        Self::try_from(value as $uint)
                    }
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (| Ty.path "i32", "is_negative", [], [] |),
                            [ M.read (| value |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.read (|
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "u32" ],
                                    "try_from",
                                    [],
                                    []
                                  |),
                                  [ M.cast (Ty.path "u32") (M.read (| value |)) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.find_or_pattern
                                      (Ty.tuple
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                                      γ,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Ok",
                                                0
                                              |) in
                                            let n := M.copy (| γ0_0 |) in
                                            Value.Tuple [ n ]));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Err",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                0
                                              |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                1
                                              |) in
                                            let n := M.copy (| γ1_1 |) in
                                            Value.Tuple [ n ]))
                                      ],
                                      fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ n ] =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                Value.StructTuple
                                                  "ruint::from::ToUintError::ValueNegative"
                                                  [ BITS; M.read (| n |) ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "internal error: entered unreachable code" |)
                                          ]
                                        |)
                                      |)
                                    |)))
                              ]
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                            Ty.apply
                              (Ty.path "ruint::from::ToUintError")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                          ],
                        M.get_trait_method (|
                          "core::convert::TryFrom",
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          [],
                          [ Ty.path "u32" ],
                          "try_from",
                          [],
                          []
                        |),
                        [ M.cast (Ty.path "u32") (M.read (| value |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "i32" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_i32_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_i64_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $int) -> Result<Self, Self::Error> {
                    if value.is_negative() {
                        Err(match Self::try_from(value as $uint) {
                            Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => {
                                ToUintError::ValueNegative(BITS, n)
                            }
                            _ => unreachable!(),
                        })
                    } else {
                        Self::try_from(value as $uint)
                    }
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (| Ty.path "i64", "is_negative", [], [] |),
                            [ M.read (| value |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.read (|
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "u64" ],
                                    "try_from",
                                    [],
                                    []
                                  |),
                                  [ M.cast (Ty.path "u64") (M.read (| value |)) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.find_or_pattern
                                      (Ty.tuple
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                                      γ,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Ok",
                                                0
                                              |) in
                                            let n := M.copy (| γ0_0 |) in
                                            Value.Tuple [ n ]));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Err",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                0
                                              |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                1
                                              |) in
                                            let n := M.copy (| γ1_1 |) in
                                            Value.Tuple [ n ]))
                                      ],
                                      fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ n ] =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                Value.StructTuple
                                                  "ruint::from::ToUintError::ValueNegative"
                                                  [ BITS; M.read (| n |) ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "internal error: entered unreachable code" |)
                                          ]
                                        |)
                                      |)
                                    |)))
                              ]
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                            Ty.apply
                              (Ty.path "ruint::from::ToUintError")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                          ],
                        M.get_trait_method (|
                          "core::convert::TryFrom",
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          [],
                          [ Ty.path "u64" ],
                          "try_from",
                          [],
                          []
                        |),
                        [ M.cast (Ty.path "u64") (M.read (| value |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "i64" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_i64_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_i128_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $int) -> Result<Self, Self::Error> {
                    if value.is_negative() {
                        Err(match Self::try_from(value as $uint) {
                            Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => {
                                ToUintError::ValueNegative(BITS, n)
                            }
                            _ => unreachable!(),
                        })
                    } else {
                        Self::try_from(value as $uint)
                    }
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (| Ty.path "i128", "is_negative", [], [] |),
                            [ M.read (| value |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.read (|
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "u128" ],
                                    "try_from",
                                    [],
                                    []
                                  |),
                                  [ M.cast (Ty.path "u128") (M.read (| value |)) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.find_or_pattern
                                      (Ty.tuple
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                                      γ,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Ok",
                                                0
                                              |) in
                                            let n := M.copy (| γ0_0 |) in
                                            Value.Tuple [ n ]));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Err",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                0
                                              |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                1
                                              |) in
                                            let n := M.copy (| γ1_1 |) in
                                            Value.Tuple [ n ]))
                                      ],
                                      fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ n ] =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                Value.StructTuple
                                                  "ruint::from::ToUintError::ValueNegative"
                                                  [ BITS; M.read (| n |) ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "internal error: entered unreachable code" |)
                                          ]
                                        |)
                                      |)
                                    |)))
                              ]
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                            Ty.apply
                              (Ty.path "ruint::from::ToUintError")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                          ],
                        M.get_trait_method (|
                          "core::convert::TryFrom",
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          [],
                          [ Ty.path "u128" ],
                          "try_from",
                          [],
                          []
                        |),
                        [ M.cast (Ty.path "u128") (M.read (| value |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "i128" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_i128_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_isize_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
                fn try_from(value: $int) -> Result<Self, Self::Error> {
                    if value.is_negative() {
                        Err(match Self::try_from(value as $uint) {
                            Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => {
                                ToUintError::ValueNegative(BITS, n)
                            }
                            _ => unreachable!(),
                        })
                    } else {
                        Self::try_from(value as $uint)
                    }
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.apply
                        (Ty.path "ruint::from::ToUintError")
                        []
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (| Ty.path "isize", "is_negative", [], [] |),
                            [ M.read (| value |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.read (|
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::convert::TryFrom",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "usize" ],
                                    "try_from",
                                    [],
                                    []
                                  |),
                                  [ M.cast (Ty.path "usize") (M.read (| value |)) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.find_or_pattern
                                      (Ty.tuple
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]) (|
                                      γ,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Ok",
                                                0
                                              |) in
                                            let n := M.copy (| γ0_0 |) in
                                            Value.Tuple [ n ]));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::result::Result::Err",
                                                0
                                              |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                0
                                              |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ0_0,
                                                "ruint::from::ToUintError::ValueTooLarge",
                                                1
                                              |) in
                                            let n := M.copy (| γ1_1 |) in
                                            Value.Tuple [ n ]))
                                      ],
                                      fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ n ] =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                Value.StructTuple
                                                  "ruint::from::ToUintError::ValueNegative"
                                                  [ BITS; M.read (| n |) ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "internal error: entered unreachable code" |)
                                          ]
                                        |)
                                      |)
                                    |)))
                              ]
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                            Ty.apply
                              (Ty.path "ruint::from::ToUintError")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                          ],
                        M.get_trait_method (|
                          "core::convert::TryFrom",
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          [],
                          [ Ty.path "usize" ],
                          "try_from",
                          [],
                          []
                        |),
                        [ M.cast (Ty.path "usize") (M.read (| value |)) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "isize" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_isize_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_f64_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*     type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
        fn try_from(value: f64) -> Result<Self, Self::Error> {
            if value.is_nan() {
                return Err(ToUintError::NotANumber(BITS));
            }
            if value < 0.0 {
                let wrapped = match Self::try_from(value.abs()) {
                    Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => n,
                    _ => Self::ZERO,
                }
                .wrapping_neg();
                return Err(ToUintError::ValueNegative(BITS, wrapped));
            }
            #[allow(clippy::cast_precision_loss)] // BITS is small-ish
            let modulus = (Self::BITS as f64).exp2();
            if value >= modulus {
                let wrapped = match Self::try_from(value % modulus) {
                    Ok(n) | Err(ToUintError::ValueTooLarge(_, n)) => n,
                    _ => Self::ZERO,
                };
                return Err(ToUintError::ValueTooLarge(BITS, wrapped)); // Wrapping
            }
            if value < 0.5 {
                return Ok(Self::ZERO);
            }
            // All non-normal cases should have been handled above
            assert!(value.is_normal());
    
            // Add offset to round to nearest integer.
            let value = value + 0.5;
    
            // Parse IEEE-754 double
            // Sign should be zero, exponent should be >= 0.
            let bits = value.to_bits();
            let sign = bits >> 63;
            assert!(sign == 0);
            let biased_exponent = (bits >> 52) & 0x7ff;
            assert!(biased_exponent >= 1023);
            let exponent = biased_exponent - 1023;
            let fraction = bits & 0x000f_ffff_ffff_ffff;
            let mantissa = 0x0010_0000_0000_0000 | fraction;
    
            // Convert mantissa * 2^(exponent - 52) to Uint
            #[allow(clippy::cast_possible_truncation)] // exponent is small-ish
            if exponent as usize > Self::BITS + 52 {
                // Wrapped value is zero because the value is extended with zero bits.
                return Err(ToUintError::ValueTooLarge(BITS, Self::ZERO));
            }
            if exponent <= 52 {
                // Truncate mantissa
                Self::try_from(mantissa >> (52 - exponent))
            } else {
                #[allow(clippy::cast_possible_truncation)] // exponent is small-ish
                let exponent = exponent as usize - 52;
                let n = Self::try_from(mantissa)?;
                let (n, overflow) = n.overflowing_shl(exponent);
                if overflow {
                    Err(ToUintError::ValueTooLarge(BITS, n))
                } else {
                    Ok(n)
                }
            }
        }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [ Ty.path "f64" ]
                  (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [])
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (| Ty.path "f64", "is_nan", [], [] |),
                                  [ M.read (| value |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::ToUintError::NotANumber"
                                        [ BITS ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| value |); M.read (| UnsupportedLiteral |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ wrapped :
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "wrapping_neg",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ],
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [ BITS; LIMBS ]
                                                      [];
                                                    Ty.apply
                                                      (Ty.path "ruint::from::ToUintError")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [ BITS; LIMBS ]
                                                          []
                                                      ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::convert::TryFrom",
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  [],
                                                  [ Ty.path "f64" ],
                                                  "try_from",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.path "f64",
                                                    M.get_associated_function (|
                                                      Ty.path "f64",
                                                      "abs",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| value |) ]
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.find_or_pattern
                                                    (Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [ BITS; LIMBS ]
                                                          []
                                                      ]) (|
                                                    γ,
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::result::Result::Ok",
                                                              0
                                                            |) in
                                                          let n := M.copy (| γ0_0 |) in
                                                          Value.Tuple [ n ]));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::result::Result::Err",
                                                              0
                                                            |) in
                                                          let γ1_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ0_0,
                                                              "ruint::from::ToUintError::ValueTooLarge",
                                                              0
                                                            |) in
                                                          let γ1_1 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ0_0,
                                                              "ruint::from::ToUintError::ValueTooLarge",
                                                              1
                                                            |) in
                                                          let n := M.copy (| γ1_1 |) in
                                                          Value.Tuple [ n ]))
                                                    ],
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        match γ with
                                                        | [ n ] => ltac:(M.monadic n)
                                                        | _ =>
                                                          M.impossible "wrong number of arguments"
                                                        end)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (get_associated_constant (|
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [ BITS; LIMBS ]
                                                      [],
                                                    "ZERO",
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [ BITS; LIMBS ]
                                                      []
                                                  |)))
                                            ]
                                          |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::ToUintError::ValueNegative"
                                        [ BITS; M.read (| wrapped |) ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ modulus : Ty.apply (Ty.path "*") [] [ Ty.path "f64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "f64",
                      M.get_associated_function (| Ty.path "f64", "exp2", [], [] |),
                      [
                        M.cast
                          (Ty.path "f64")
                          (M.read (|
                            get_associated_constant (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "BITS",
                              Ty.path "usize"
                            |)
                          |))
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ge,
                                  [ M.read (| value |); M.read (| modulus |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ wrapped :
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] :=
                                  M.copy (|
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                              Ty.apply
                                                (Ty.path "ruint::from::ToUintError")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    []
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::convert::TryFrom",
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            [],
                                            [ Ty.path "f64" ],
                                            "try_from",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.path "f64",
                                              BinOp.Wrap.rem,
                                              [ M.read (| value |); M.read (| modulus |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.find_or_pattern
                                              (Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    []
                                                ]) (|
                                              γ,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::result::Result::Ok",
                                                        0
                                                      |) in
                                                    let n := M.copy (| γ0_0 |) in
                                                    Value.Tuple [ n ]));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::result::Result::Err",
                                                        0
                                                      |) in
                                                    let γ1_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_0,
                                                        "ruint::from::ToUintError::ValueTooLarge",
                                                        0
                                                      |) in
                                                    let γ1_1 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ0_0,
                                                        "ruint::from::ToUintError::ValueTooLarge",
                                                        1
                                                      |) in
                                                    let n := M.copy (| γ1_1 |) in
                                                    Value.Tuple [ n ]))
                                              ],
                                              fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ n ] => ltac:(M.monadic n)
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (get_associated_constant (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              "ZERO",
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                            |)))
                                      ]
                                    |)
                                  |) in
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::ToUintError::ValueTooLarge"
                                        [ BITS; M.read (| wrapped |) ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| value |); M.read (| UnsupportedLiteral |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          "ZERO",
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                        |)
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "f64",
                                      "is_normal",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic", [], [] |),
                                [ mk_str (| "assertion failed: value.is_normal()" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ value : Ty.apply (Ty.path "*") [] [ Ty.path "f64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "f64",
                      BinOp.Wrap.add,
                      [ M.read (| value |); M.read (| UnsupportedLiteral |) ]
                    |)
                  |) in
                let~ bits : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                      [ M.read (| value |) ]
                    |)
                  |) in
                let~ sign : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.shr,
                      [ M.read (| bits |); Value.Integer IntegerKind.I32 63 ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| sign |); Value.Integer IntegerKind.U64 0 ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic", [], [] |),
                                [ mk_str (| "assertion failed: sign == 0" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ biased_exponent : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.shr,
                          [ M.read (| bits |); Value.Integer IntegerKind.I32 52 ]
                        |);
                        Value.Integer IntegerKind.U64 2047
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [
                                      M.read (| biased_exponent |);
                                      Value.Integer IntegerKind.U64 1023
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic", [], [] |),
                                [ mk_str (| "assertion failed: biased_exponent >= 1023" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ exponent : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.sub,
                      [ M.read (| biased_exponent |); Value.Integer IntegerKind.U64 1023 ]
                    |)
                  |) in
                let~ fraction : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [ M.read (| bits |); Value.Integer IntegerKind.U64 4503599627370495 ]
                    |)
                  |) in
                let~ mantissa : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_or,
                      [ Value.Integer IntegerKind.U64 4503599627370496; M.read (| fraction |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.cast (Ty.path "usize") (M.read (| exponent |));
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.add,
                                      [
                                        M.read (|
                                          get_associated_constant (|
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            "BITS",
                                            Ty.path "usize"
                                          |)
                                        |);
                                        Value.Integer IntegerKind.Usize 52
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::ToUintError::ValueTooLarge"
                                        [
                                          BITS;
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              "ZERO",
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                          Ty.apply
                            (Ty.path "ruint::from::ToUintError")
                            []
                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                        ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.le,
                                [ M.read (| exponent |); Value.Integer IntegerKind.U64 52 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                Ty.apply
                                  (Ty.path "ruint::from::ToUintError")
                                  []
                                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                              ],
                            M.get_trait_method (|
                              "core::convert::TryFrom",
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              [],
                              [ Ty.path "u64" ],
                              "try_from",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shr,
                                [
                                  M.read (| mantissa |);
                                  M.call_closure (|
                                    Ty.path "u64",
                                    BinOp.Wrap.sub,
                                    [ Value.Integer IntegerKind.U64 52; M.read (| exponent |) ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ exponent : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.sub,
                              [
                                M.cast (Ty.path "usize") (M.read (| exponent |));
                                Value.Integer IntegerKind.Usize 52
                              ]
                            |)
                          |) in
                        let~ n :
                            Ty.apply
                              (Ty.path "*")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] :=
                          M.copy (|
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::control_flow::ControlFlow")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.apply
                                            (Ty.path "ruint::from::ToUintError")
                                            []
                                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                        ];
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    [],
                                    [],
                                    "branch",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                          Ty.apply
                                            (Ty.path "ruint::from::ToUintError")
                                            []
                                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        [],
                                        [ Ty.path "u64" ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| mantissa |) ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [];
                                                  Ty.apply
                                                    (Ty.path "ruint::from::ToUintError")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "ruint::Uint")
                                                        [ BITS; LIMBS ]
                                                        []
                                                    ]
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [ BITS; LIMBS ]
                                                      [];
                                                    Ty.apply
                                                      (Ty.path "ruint::from::ToUintError")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [ BITS; LIMBS ]
                                                          []
                                                      ]
                                                  ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.apply
                                                        (Ty.path "ruint::from::ToUintError")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "ruint::Uint")
                                                            [ BITS; LIMBS ]
                                                            []
                                                        ]
                                                    ]
                                                ],
                                                "from_residual",
                                                [],
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |)
                          |) in
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ]
                            ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.path "bool"
                                ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "overflowing_shl",
                                [],
                                []
                              |),
                              [ M.read (| n |); M.read (| exponent |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let n := M.copy (| γ0_0 |) in
                                let overflow := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                          Ty.apply
                                            (Ty.path "ruint::from::ToUintError")
                                            []
                                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                        ]
                                    ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.use overflow in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [
                                              Value.StructTuple
                                                "ruint::from::ToUintError::ValueTooLarge"
                                                [ BITS; M.read (| n |) ]
                                            ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          Value.StructTuple
                                            "core::result::Result::Ok"
                                            [ M.read (| n |) ]
                                        |)))
                                  ]
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "f64" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_f64_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_f32_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*     type Error = ToUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply
        (Ty.path "ruint::from::ToUintError")
        []
        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*
        fn try_from(value: f32) -> Result<Self, Self::Error> {
            #[allow(clippy::cast_lossless)]
            Self::try_from(value as f64)
        }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                Ty.apply
                  (Ty.path "ruint::from::ToUintError")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              [],
              [ Ty.path "f64" ],
              "try_from",
              [],
              []
            |),
            [ M.cast (Ty.path "f64") (M.read (| value |)) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "f32" ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_f32_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_bool.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "bool".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "bool" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "bool";
                Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "bool" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "bool",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_bool.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_bool.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "bool".
    
    (*     type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "bool" ].
    
    (*
        fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
            if BITS == 0 {
                return Ok(false);
            }
            if value.bit_len() > 1 {
                return Err(Self::Error::Overflow(BITS, value.bit(0), true));
            }
            Ok(value.as_limbs()[0] != 0)
        }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "bool";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "bool")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::result::Result::Ok" [ Value.Bool false ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              "bit",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| value |) |)
                                              |);
                                              Value.Integer IntegerKind.Usize 0
                                            ]
                                          |);
                                          Value.Bool true
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.ne,
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    "as_limbs",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| value |) |)
                                    |)
                                  ]
                                |)
                              |),
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |);
                          Value.Integer IntegerKind.U64 0
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_bool.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i8.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i8".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i8" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "i8"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i8" ] ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "i8",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i8.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i8.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i8".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i8" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "i8";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "i8")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.I8 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "i8")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "i8",
                                              "MAX",
                                              Ty.path "i8"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "i8")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i8.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u8.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u8".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u8" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "u8"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u8" ] ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "u8",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u8.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u8.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u8".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u8" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "u8";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "u8")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.U8 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "u8")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "u8",
                                              "MAX",
                                              Ty.path "u8"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "u8")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u8.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i16.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i16".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i16" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "i16"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i16" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "i16",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i16.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i16.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i16".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i16" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "i16";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "i16")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.I16 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "i16")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "i16",
                                              "MAX",
                                              Ty.path "i16"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "i16")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i16.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u16.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u16".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u16" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "u16"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u16" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "u16",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u16.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u16.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u16".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u16" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "u16";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "u16")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.U16 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "u16")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "u16",
                                              "MAX",
                                              Ty.path "u16"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "u16")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u16.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i32.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i32".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i32" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "i32"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i32" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "i32",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i32.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i32.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i32".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i32" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "i32";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "i32")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.I32 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "i32")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "i32",
                                              "MAX",
                                              Ty.path "i32"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "i32")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i32.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u32.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u32".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u32" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "u32"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u32" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "u32",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u32.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u32.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u32".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u32" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "u32";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "u32")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.U32 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "u32")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "u32",
                                              "MAX",
                                              Ty.path "u32"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "u32")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u32.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i64.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i64".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i64" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "i64"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i64" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "i64",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i64.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i64.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i64".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i64" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "i64";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "i64")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.I64 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "i64")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "i64",
                                              "MAX",
                                              Ty.path "i64"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "i64")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i64.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u64.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u64".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u64" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "u64"; Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u64" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "u64",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u64.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u64.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u64".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u64" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "u64";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "u64")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.U64 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.read (|
                                            M.use
                                              (M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |))
                                          |);
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "u64",
                                              "MAX",
                                              Ty.path "u64"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.read (|
                        M.use
                          (M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |))
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u64.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_isize.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "isize".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "isize" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "isize";
                Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "isize" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "isize",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_isize.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_isize.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "isize".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "isize" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "isize";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "isize")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.Isize 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "isize")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "isize",
                                              "MAX",
                                              Ty.path "isize"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "isize")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_isize.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_usize.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "usize".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "usize" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "usize";
                Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "usize" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "usize",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_usize.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_usize.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "usize".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "usize" ].
    
    (*
                fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    const SIGNED: bool = <$int>::MIN != 0;
                    const CAPACITY: usize = if SIGNED { <$int>::BITS - 1 } else { <$int>::BITS } as usize;
                    if BITS == 0 {
                        return Ok(0);
                    }
                    if value.bit_len() > CAPACITY {
                        return Err(Self::Error::Overflow(
                            BITS,
                            value.limbs[0] as Self,
                            Self::MAX,
                        ));
                    }
                    Ok(value.as_limbs()[0] as Self)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "usize";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "usize")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "ruint::from::try_from::CAPACITY",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.cast
                                            (Ty.path "usize")
                                            (M.read (|
                                              M.SubPointer.get_array_field (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| value |) |),
                                                  "ruint::Uint",
                                                  "limbs"
                                                |),
                                                Value.Integer IntegerKind.Usize 0
                                              |)
                                            |));
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "usize",
                                              "MAX",
                                              Ty.path "usize"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.cast
                        (Ty.path "usize")
                        (M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                                ]
                              |)
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_usize.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i128.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i128".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i128" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "i128";
                Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i128" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "i128",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_i128.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i128.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i128".
    
    (*     type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "i128" ].
    
    (*
        fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
            if BITS == 0 {
                return Ok(0);
            }
            let mut result = value.limbs[0] as i128;
            if BITS <= 64 {
                return Ok(result);
            }
            result |= (value.limbs[1] as i128) << 64;
            if value.bit_len() > 127 {
                return Err(Self::Error::Overflow(BITS, result, i128::MAX));
            }
            Ok(result)
        }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "i128";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "i128")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.I128 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ result : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "i128")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| value |) |),
                            "ruint::Uint",
                            "limbs"
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ BITS; Value.Integer IntegerKind.Usize 64 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ M.read (| result |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    let β := result in
                    M.write (|
                      β,
                      M.call_closure (|
                        Ty.path "i128",
                        BinOp.Wrap.bit_or,
                        [
                          M.read (| β |);
                          M.call_closure (|
                            Ty.path "i128",
                            BinOp.Wrap.shl,
                            [
                              M.cast
                                (Ty.path "i128")
                                (M.read (|
                                  M.SubPointer.get_array_field (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| value |) |),
                                      "ruint::Uint",
                                      "limbs"
                                    |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                |));
                              Value.Integer IntegerKind.I32 64
                            ]
                          |)
                        ]
                      |)
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 127
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.read (| result |);
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "i128",
                                              "MAX",
                                              Ty.path "i128"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_i128.
  
  Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u128.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u128".
    
    (*             type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u128" ].
    
    (*
                fn try_from(value: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
                    Self::try_from(&value)
                }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "u128";
                Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u128" ]
              ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "u128",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "try_from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_u128.
  
  Module Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u128.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u128".
    
    (*     type Error = FromUintError<Self>; *)
    Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u128" ].
    
    (*
        fn try_from(value: &Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
            if BITS == 0 {
                return Ok(0);
            }
            let mut result = value.limbs[0] as u128;
            if BITS <= 64 {
                return Ok(result);
            }
            result |= (value.limbs[1] as u128) << 64;
            if value.bit_len() > 128 {
                return Err(Self::Error::Overflow(BITS, result, u128::MAX));
            }
            Ok(result)
        }
    *)
    Definition try_from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "u128";
                Ty.associated_in_trait
                  "core::convert::TryFrom"
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                  ]
                  (Ty.path "u128")
                  "Error"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ Value.Integer IntegerKind.U128 0 ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ result : Ty.apply (Ty.path "*") [] [ Ty.path "u128" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "u128")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| value |) |),
                            "ruint::Uint",
                            "limbs"
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ BITS; Value.Integer IntegerKind.Usize 64 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [ M.read (| result |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    let β := result in
                    M.write (|
                      β,
                      M.call_closure (|
                        Ty.path "u128",
                        BinOp.Wrap.bit_or,
                        [
                          M.read (| β |);
                          M.call_closure (|
                            Ty.path "u128",
                            BinOp.Wrap.shl,
                            [
                              M.cast
                                (Ty.path "u128")
                                (M.read (|
                                  M.SubPointer.get_array_field (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| value |) |),
                                      "ruint::Uint",
                                      "limbs"
                                    |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                |));
                              Value.Integer IntegerKind.I32 64
                            ]
                          |)
                        ]
                      |)
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "bit_len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| value |) |)
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 128
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      Value.StructTuple
                                        "ruint::from::FromUintError::Overflow"
                                        [
                                          BITS;
                                          M.read (| result |);
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "u128",
                                              "MAX",
                                              Ty.path "u128"
                                            |)
                                          |)
                                        ]
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| result |) ] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error BITS LIMBS));
          ("try_from", InstanceField.Method (try_from BITS LIMBS))
        ].
  End Impl_core_convert_TryFrom_ref__ruint_Uint_BITS_LIMBS_for_u128.
  
  Module Impl_core_convert_From_ruint_Uint_BITS_LIMBS_for_f32.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "f32".
    
    (*
        fn from(value: Uint<BITS, LIMBS>) -> Self {
            Self::from(&value)
        }
    *)
    Definition from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.path "f32",
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "f32",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("from", InstanceField.Method (from BITS LIMBS)) ].
  End Impl_core_convert_From_ruint_Uint_BITS_LIMBS_for_f32.
  
  Module Impl_core_convert_From_ref__ruint_Uint_BITS_LIMBS_for_f32.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "f32".
    
    (*
        fn from(value: &Uint<BITS, LIMBS>) -> Self {
            let (bits, exponent) = value.most_significant_bits();
            (bits as Self) * (exponent as Self).exp2()
        }
    *)
    Definition from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "f32" ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.path "u64"; Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "most_significant_bits",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let bits := M.copy (| γ0_0 |) in
                    let exponent := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "f32",
                        BinOp.Wrap.mul,
                        [
                          M.cast (Ty.path "f32") (M.read (| bits |));
                          M.call_closure (|
                            Ty.path "f32",
                            M.get_associated_function (| Ty.path "f32", "exp2", [], [] |),
                            [ M.cast (Ty.path "f32") (M.read (| exponent |)) ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("from", InstanceField.Method (from BITS LIMBS)) ].
  End Impl_core_convert_From_ref__ruint_Uint_BITS_LIMBS_for_f32.
  
  Module Impl_core_convert_From_ruint_Uint_BITS_LIMBS_for_f64.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "f64".
    
    (*
        fn from(value: Uint<BITS, LIMBS>) -> Self {
            Self::from(&value)
        }
    *)
    Definition from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "f64",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ],
              "from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, value |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("from", InstanceField.Method (from BITS LIMBS)) ].
  End Impl_core_convert_From_ruint_Uint_BITS_LIMBS_for_f64.
  
  Module Impl_core_convert_From_ref__ruint_Uint_BITS_LIMBS_for_f64.
    Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "f64".
    
    (*
        fn from(value: &Uint<BITS, LIMBS>) -> Self {
            let (bits, exponent) = value.most_significant_bits();
            (bits as Self) * (exponent as Self).exp2()
        }
    *)
    Definition from
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "f64" ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.path "u64"; Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "most_significant_bits",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let bits := M.copy (| γ0_0 |) in
                    let exponent := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "f64",
                        BinOp.Wrap.mul,
                        [
                          M.cast (Ty.path "f64") (M.read (| bits |));
                          M.call_closure (|
                            Ty.path "f64",
                            M.get_associated_function (| Ty.path "f64", "exp2", [], [] |),
                            [ M.cast (Ty.path "f64") (M.read (| exponent |)) ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("from", InstanceField.Method (from BITS LIMBS)) ].
  End Impl_core_convert_From_ref__ruint_Uint_BITS_LIMBS_for_f64.
End from.
