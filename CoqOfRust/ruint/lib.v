(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructRecord
  {
    name := "Uint";
    const_params := [ "BITS"; "LIMBS" ];
    ty_params := [];
    fields := [ ("limbs", Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ]) ];
  } *)

Module Impl_core_clone_Clone_for_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  (* Clone *)
  Definition clone
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          M.match_operator (|
            None,
            Value.DeclaredButUndefined,
            [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (BITS LIMBS : Value.t),
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self BITS LIMBS)
      (* Instance *) [ ("clone", InstanceField.Method (clone BITS LIMBS)) ].
End Impl_core_clone_Clone_for_ruint_Uint_BITS_LIMBS.

Module Impl_core_marker_Copy_for_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  Axiom Implements :
    forall (BITS LIMBS : Value.t),
    M.IsTraitInstance
      "core::marker::Copy"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self BITS LIMBS)
      (* Instance *) [].
End Impl_core_marker_Copy_for_ruint_Uint_BITS_LIMBS.

Module Impl_core_cmp_Eq_for_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  (* Eq *)
  Definition assert_receiver_is_total_eq
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          M.match_operator (|
            None,
            Value.DeclaredButUndefined,
            [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (BITS LIMBS : Value.t),
    M.IsTraitInstance
      "core::cmp::Eq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self BITS LIMBS)
      (* Instance *)
      [
        ("assert_receiver_is_total_eq",
          InstanceField.Method (assert_receiver_is_total_eq BITS LIMBS))
      ].
End Impl_core_cmp_Eq_for_ruint_Uint_BITS_LIMBS.

Module Impl_core_marker_StructuralPartialEq_for_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  Axiom Implements :
    forall (BITS LIMBS : Value.t),
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self BITS LIMBS)
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_ruint_Uint_BITS_LIMBS.

Module Impl_core_cmp_PartialEq_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  (* PartialEq *)
  Definition eq (BITS LIMBS : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_trait_method (|
            "core::cmp::PartialEq",
            Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ],
            [],
            [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
            "eq",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "ruint::Uint",
                "limbs"
              |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| other |) |),
                "ruint::Uint",
                "limbs"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (BITS LIMBS : Value.t),
    M.IsTraitInstance
      "core::cmp::PartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
      (Self BITS LIMBS)
      (* Instance *) [ ("eq", InstanceField.Method (eq BITS LIMBS)) ].
End Impl_core_cmp_PartialEq_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.

Module Impl_core_hash_Hash_for_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  (* Hash *)
  Definition hash
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [ __H ], [ self; state ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let state := M.alloc (| state |) in
        M.call_closure (|
          Ty.tuple [],
          M.get_trait_method (|
            "core::hash::Hash",
            Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ],
            [],
            [],
            "hash",
            [],
            [ __H ]
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "ruint::Uint",
                    "limbs"
                  |)
                |)
              |)
            |);
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (BITS LIMBS : Value.t),
    M.IsTraitInstance
      "core::hash::Hash"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self BITS LIMBS)
      (* Instance *) [ ("hash", InstanceField.Method (hash BITS LIMBS)) ].
End Impl_core_hash_Hash_for_ruint_Uint_BITS_LIMBS.

Module Impl_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  (*
      pub const LIMBS: usize = {
          let limbs = nlimbs(BITS);
          assert!(
              LIMBS == limbs,
              "Can not construct Uint<BITS, LIMBS> with incorrect LIMBS"
          );
          limbs
      };
  *)
  (* Ty.path "usize" *)
  Definition value_LIMBS
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    ltac:(M.monadic
      (let~ limbs : Ty.path "usize" :=
        M.alloc (|
          M.call_closure (|
            Ty.path "usize",
            M.get_function (| "ruint::nlimbs", [], [] |),
            [ BITS ]
          |)
        |) in
      let~ _ : Ty.tuple [] :=
        M.match_operator (|
          Some (Ty.tuple []),
          M.alloc (| Value.Tuple [] |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ :=
                  M.use
                    (M.alloc (|
                      UnOp.not (|
                        M.call_closure (| Ty.path "bool", BinOp.eq, [ LIMBS; M.read (| limbs |) ] |)
                      |)
                    |)) in
                let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                M.alloc (|
                  M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_fmt", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Value.Array
                                      [
                                        mk_str (|
                                          "Can not construct Uint<BITS, LIMBS> with incorrect LIMBS"
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)
                |)));
            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
          ]
        |) in
      limbs)).
  
  Global Instance AssociatedConstant_value_LIMBS :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "LIMBS" (value_LIMBS BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque value_LIMBS.
  
  (*     pub const MASK: u64 = mask(BITS); *)
  (* Ty.path "u64" *)
  Definition value_MASK
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (| Ty.path "u64", M.get_function (| "ruint::mask", [], [] |), [ BITS ] |)
      |))).
  
  Global Instance AssociatedConstant_value_MASK :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "MASK" (value_MASK BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque value_MASK.
  
  (*     pub const BITS: usize = BITS; *)
  (* Ty.path "usize" *)
  Definition value_BITS
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    ltac:(M.monadic (M.alloc (| BITS |))).
  
  Global Instance AssociatedConstant_value_BITS :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "BITS" (value_BITS BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque value_BITS.
  
  (*     pub const ZERO: Self = Self::from_limbs([0; LIMBS]); *)
  (* Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] *)
  Definition value_ZERO
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
          M.get_associated_function (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            "from_limbs",
            [],
            []
          |),
          [ repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) ]
        |)
      |))).
  
  Global Instance AssociatedConstant_value_ZERO :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "ZERO" (value_ZERO BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque value_ZERO.
  
  (*     pub const MIN: Self = Self::ZERO; *)
  (* Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] *)
  Definition value_MIN
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    ltac:(M.monadic
      (get_associated_constant (|
        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
        "ZERO",
        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
      |))).
  
  Global Instance AssociatedConstant_value_MIN :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "MIN" (value_MIN BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque value_MIN.
  
  (*
      pub const MAX: Self = {
          let mut limbs = [u64::MAX; LIMBS];
          if BITS > 0 {
              limbs[LIMBS - 1] &= Self::MASK;
          }
          Self::from_limbs(limbs)
      };
  *)
  (* Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] *)
  Definition value_MAX
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    ltac:(M.monadic
      (let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
        M.alloc (|
          repeat (|
            M.read (| get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |) |),
            LIMBS
          |)
        |) in
      let~ _ : Ty.tuple [] :=
        M.match_operator (|
          Some (Ty.tuple []),
          M.alloc (| Value.Tuple [] |),
          [
            fun γ =>
              ltac:(M.monadic
                (let γ :=
                  M.use
                    (M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.gt,
                        [ BITS; Value.Integer IntegerKind.Usize 0 ]
                      |)
                    |)) in
                let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    let β :=
                      M.SubPointer.get_array_field (|
                        limbs,
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [ LIMBS; Value.Integer IntegerKind.Usize 1 ]
                        |)
                      |) in
                    M.write (|
                      β,
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.bit_and,
                        [
                          M.read (| β |);
                          M.read (|
                            get_associated_constant (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "MASK",
                              Ty.path "u64"
                            |)
                          |)
                        ]
                      |)
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)));
            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
          ]
        |) in
      M.alloc (|
        M.call_closure (|
          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
          M.get_associated_function (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            "from_limbs",
            [],
            []
          |),
          [ M.read (| limbs |) ]
        |)
      |))).
  
  Global Instance AssociatedConstant_value_MAX :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "MAX" (value_MAX BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque value_MAX.
  
  (*
      pub const fn as_limbs(&self) -> &[u64; LIMBS] {
          &self.limbs
      }
  *)
  Definition as_limbs
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "ruint::Uint",
                "limbs"
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_as_limbs :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "as_limbs" (as_limbs BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque as_limbs.
  
  (*
      pub unsafe fn as_limbs_mut(&mut self) -> &mut [u64; LIMBS] {
          &mut self.limbs
      }
  *)
  Definition as_limbs_mut
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.borrow (|
          Pointer.Kind.MutRef,
          M.deref (|
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "ruint::Uint",
                    "limbs"
                  |)
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_as_limbs_mut :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "as_limbs_mut" (as_limbs_mut BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque as_limbs_mut.
  
  (*
      pub const fn into_limbs(self) -> [u64; LIMBS] {
          self.limbs
      }
  *)
  Definition into_limbs
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (| M.SubPointer.get_struct_record_field (| self, "ruint::Uint", "limbs" |) |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_into_limbs :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "into_limbs" (into_limbs BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque into_limbs.
  
  (*
      pub const fn from_limbs(limbs: [u64; LIMBS]) -> Self {
          if BITS > 0 && Self::MASK != u64::MAX {
              // FEATURE: (BLOCKED) Add `<{BITS}>` to the type when Display works in const fn.
              assert!(
                  limbs[Self::LIMBS - 1] <= Self::MASK,
                  "Value too large for this Uint"
              );
          }
          Self { limbs }
      }
  *)
  Definition from_limbs
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ limbs ] =>
      ltac:(M.monadic
        (let limbs := M.alloc (| limbs |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.and (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [ BITS; Value.Integer IntegerKind.Usize 0 ]
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                BinOp.ne,
                                [
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      "MASK",
                                      Ty.path "u64"
                                    |)
                                  |);
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "u64",
                                      "MAX",
                                      Ty.path "u64"
                                    |)
                                  |)
                                ]
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.le,
                                        [
                                          M.read (|
                                            M.SubPointer.get_array_field (|
                                              limbs,
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.sub,
                                                [
                                                  M.read (|
                                                    get_associated_constant (|
                                                      Ty.apply
                                                        (Ty.path "ruint::Uint")
                                                        [ BITS; LIMBS ]
                                                        [],
                                                      "LIMBS",
                                                      Ty.path "usize"
                                                    |)
                                                  |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |)
                                            |)
                                          |);
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              "MASK",
                                              Ty.path "u64"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::Arguments",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_const",
                                          [ Value.Integer IntegerKind.Usize 1 ],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Value.Array
                                                    [ mk_str (| "Value too large for this Uint" |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (| Value.StructRecord "ruint::Uint" [ ("limbs", M.read (| limbs |)) ] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_from_limbs :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "from_limbs" (from_limbs BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque from_limbs.
  
  (*
      pub fn from_limbs_slice(slice: &[u64]) -> Self {
          match Self::overflowing_from_limbs_slice(slice) {
              (n, false) => n,
              (_, true) => panic!("Value too large for this Uint"),
          }
      }
  *)
  Definition from_limbs_slice
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ slice ] =>
      ltac:(M.monadic
        (let slice := M.alloc (| slice |) in
        M.read (|
          M.match_operator (|
            Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
            M.alloc (|
              M.call_closure (|
                Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "overflowing_from_limbs_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let n := M.copy (| γ0_0 |) in
                  let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                  n));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Value too large for this Uint" |) ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_from_limbs_slice :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C (Self BITS LIMBS) "from_limbs_slice" (from_limbs_slice BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque from_limbs_slice.
  
  (*
      pub fn checked_from_limbs_slice(slice: &[u64]) -> Option<Self> {
          match Self::overflowing_from_limbs_slice(slice) {
              (n, false) => Some(n),
              (_, true) => None,
          }
      }
  *)
  Definition checked_from_limbs_slice
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ slice ] =>
      ltac:(M.monadic
        (let slice := M.alloc (| slice |) in
        M.read (|
          M.match_operator (|
            Some
              (Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]),
            M.alloc (|
              M.call_closure (|
                Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "overflowing_from_limbs_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let n := M.copy (| γ0_0 |) in
                  let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                  M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| n |) ] |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_checked_from_limbs_slice :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C
      (Self BITS LIMBS)
      "checked_from_limbs_slice"
      (checked_from_limbs_slice BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque checked_from_limbs_slice.
  
  (*
      pub fn wrapping_from_limbs_slice(slice: &[u64]) -> Self {
          Self::overflowing_from_limbs_slice(slice).0
      }
  *)
  Definition wrapping_from_limbs_slice
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ slice ] =>
      ltac:(M.monadic
        (let slice := M.alloc (| slice |) in
        M.read (|
          M.SubPointer.get_tuple_field (|
            M.alloc (|
              M.call_closure (|
                Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "overflowing_from_limbs_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
              |)
            |),
            0
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_wrapping_from_limbs_slice :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C
      (Self BITS LIMBS)
      "wrapping_from_limbs_slice"
      (wrapping_from_limbs_slice BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque wrapping_from_limbs_slice.
  
  (*
      pub fn overflowing_from_limbs_slice(slice: &[u64]) -> (Self, bool) {
          if slice.len() < LIMBS {
              let mut limbs = [0; LIMBS];
              limbs[..slice.len()].copy_from_slice(slice);
              (Self::from_limbs(limbs), false)
          } else {
              let (head, tail) = slice.split_at(LIMBS);
              let mut limbs = [0; LIMBS];
              limbs.copy_from_slice(head);
              let mut overflow = tail.iter().any(|&limb| limb != 0);
              if LIMBS > 0 {
                  overflow |= limbs[LIMBS - 1] > Self::MASK;
                  limbs[LIMBS - 1] &= Self::MASK;
              }
              (Self::from_limbs(limbs), overflow)
          }
      }
  *)
  Definition overflowing_from_limbs_slice
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ slice ] =>
      ltac:(M.monadic
        (let slice := M.alloc (| slice |) in
        M.read (|
          M.match_operator (|
            Some (Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ]),
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.lt,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                            |);
                            LIMBS
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                    M.alloc (| repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                          "copy_from_slice",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::IndexMut",
                                  Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeTo")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, limbs |);
                                  Value.StructRecord
                                    "core::ops::range::RangeTo"
                                    [
                                      ("end_",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| slice |) |)
                                            |)
                                          ]
                                        |))
                                    ]
                                ]
                              |)
                            |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.Tuple
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "from_limbs",
                            [],
                            []
                          |),
                          [ M.read (| limbs |) ]
                        |);
                        Value.Bool false
                      ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    None,
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                          "split_at",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |); LIMBS ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let head := M.copy (| γ0_0 |) in
                          let tail := M.copy (| γ0_1 |) in
                          let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                            M.alloc (| repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) |) in
                          let~ _ : Ty.tuple [] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                  "copy_from_slice",
                                  [],
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion (M.borrow (| Pointer.Kind.MutRef, limbs |));
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| head |) |) |)
                                ]
                              |)
                            |) in
                          let~ overflow : Ty.path "bool" :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u64" ],
                                  [],
                                  [],
                                  "any",
                                  [],
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ] ]
                                      (Ty.path "bool")
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [ Ty.path "u64" ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                                          "iter",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| tail |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Some
                                                (Ty.function
                                                  [
                                                    Ty.tuple
                                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ]
                                                      ]
                                                  ]
                                                  (Ty.path "bool")),
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ := M.read (| γ |) in
                                                    let limb := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.ne,
                                                      [
                                                        M.read (| limb |);
                                                        Value.Integer IntegerKind.U64 0
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.gt,
                                            [ LIMBS; Value.Integer IntegerKind.Usize 0 ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        let β := overflow in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.Wrap.bit_or,
                                            [
                                              M.read (| β |);
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.gt,
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_array_field (|
                                                      limbs,
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [ LIMBS; Value.Integer IntegerKind.Usize 1 ]
                                                      |)
                                                    |)
                                                  |);
                                                  M.read (|
                                                    get_associated_constant (|
                                                      Ty.apply
                                                        (Ty.path "ruint::Uint")
                                                        [ BITS; LIMBS ]
                                                        [],
                                                      "MASK",
                                                      Ty.path "u64"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        let β :=
                                          M.SubPointer.get_array_field (|
                                            limbs,
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.sub,
                                              [ LIMBS; Value.Integer IntegerKind.Usize 1 ]
                                            |)
                                          |) in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.bit_and,
                                            [
                                              M.read (| β |);
                                              M.read (|
                                                get_associated_constant (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "MASK",
                                                  Ty.path "u64"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    "from_limbs",
                                    [],
                                    []
                                  |),
                                  [ M.read (| limbs |) ]
                                |);
                                M.read (| overflow |)
                              ]
                          |)))
                    ]
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_overflowing_from_limbs_slice :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C
      (Self BITS LIMBS)
      "overflowing_from_limbs_slice"
      (overflowing_from_limbs_slice BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque overflowing_from_limbs_slice.
  
  (*
      pub fn saturating_from_limbs_slice(slice: &[u64]) -> Self {
          match Self::overflowing_from_limbs_slice(slice) {
              (n, false) => n,
              (_, true) => Self::MAX,
          }
      }
  *)
  Definition saturating_from_limbs_slice
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [ slice ] =>
      ltac:(M.monadic
        (let slice := M.alloc (| slice |) in
        M.read (|
          M.match_operator (|
            Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
            M.alloc (|
              M.call_closure (|
                Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  "overflowing_from_limbs_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let n := M.copy (| γ0_0 |) in
                  let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                  n));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                  get_associated_constant (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "MAX",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_saturating_from_limbs_slice :
    forall (BITS LIMBS : Value.t),
    M.IsAssociatedFunction.C
      (Self BITS LIMBS)
      "saturating_from_limbs_slice"
      (saturating_from_limbs_slice BITS LIMBS).
  Admitted.
  Global Typeclasses Opaque saturating_from_limbs_slice.
End Impl_ruint_Uint_BITS_LIMBS.

Module Impl_core_default_Default_for_ruint_Uint_BITS_LIMBS.
  Definition Self (BITS LIMBS : Value.t) : Ty.t :=
    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
  
  (*
      fn default() -> Self {
          Self::ZERO
      }
  *)
  Definition default
      (BITS LIMBS : Value.t)
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    let Self : Ty.t := Self BITS LIMBS in
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.read (|
          get_associated_constant (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            "ZERO",
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    forall (BITS LIMBS : Value.t),
    M.IsTraitInstance
      "core::default::Default"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      (Self BITS LIMBS)
      (* Instance *) [ ("default", InstanceField.Method (default BITS LIMBS)) ].
End Impl_core_default_Default_for_ruint_Uint_BITS_LIMBS.

(*
pub const fn nlimbs(bits: usize) -> usize {
    (bits + 63) / 64
}
*)
Definition nlimbs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ bits ] =>
    ltac:(M.monadic
      (let bits := M.alloc (| bits |) in
      M.call_closure (|
        Ty.path "usize",
        BinOp.Wrap.div,
        [
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.add,
            [ M.read (| bits |); Value.Integer IntegerKind.Usize 63 ]
          |);
          Value.Integer IntegerKind.Usize 64
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_nlimbs : M.IsFunction.C "ruint::nlimbs" nlimbs.
Admitted.
Global Typeclasses Opaque nlimbs.

(*
pub const fn mask(bits: usize) -> u64 {
    if bits == 0 {
        return 0;
    }
    let bits = bits % 64;
    if bits == 0 {
        u64::MAX
    } else {
        (1 << bits) - 1
    }
}
*)
Definition mask (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ bits ] =>
    ltac:(M.monadic
      (let bits := M.alloc (| bits |) in
      M.catch_return (|
        ltac:(M.monadic
          (M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [ M.read (| bits |); Value.Integer IntegerKind.Usize 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (| M.return_ (| Value.Integer IntegerKind.U64 0 |) |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ bits : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.rem,
                  [ M.read (| bits |); Value.Integer IntegerKind.Usize 64 ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.path "u64"),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [ M.read (| bits |); Value.Integer IntegerKind.Usize 0 ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.sub,
                        [
                          M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.shl,
                            [ Value.Integer IntegerKind.U64 1; M.read (| bits |) ]
                          |);
                          Value.Integer IntegerKind.U64 1
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_mask : M.IsFunction.C "ruint::mask" mask.
Admitted.
Global Typeclasses Opaque mask.
