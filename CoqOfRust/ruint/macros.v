(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module add.
  Module Impl_core_ops_arith_AddAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Uint<BITS, LIMBS>) {
                    *self = self.$fdel(rhs);
                }
    *)
    Definition add_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_add",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("add_assign", InstanceField.Method (add_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_AddAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_AddAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Uint<BITS, LIMBS>) {
                    *self = self.$fdel( *rhs);
                }
    *)
    Definition add_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_add",
                    [],
                    []
                  |),
                  [
                    M.read (| M.deref (| M.read (| self |) |) |);
                    M.read (| M.deref (| M.read (| rhs |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("add_assign", InstanceField.Method (add_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_AddAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Add_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition add
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_add",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("add", InstanceField.Method (add BITS LIMBS))
        ].
  End Impl_core_ops_arith_Add_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Add_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition add
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_add",
              [],
              []
            |),
            [ M.read (| self |); M.read (| M.deref (| M.read (| rhs |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("add", InstanceField.Method (add BITS LIMBS))
        ].
  End Impl_core_ops_arith_Add_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Add_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition add
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_add",
              [],
              []
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("add", InstanceField.Method (add BITS LIMBS))
        ].
  End Impl_core_ops_arith_Add_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Add_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition add
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_add",
              [],
              []
            |),
            [
              M.read (| M.deref (| M.read (| self |) |) |);
              M.read (| M.deref (| M.read (| rhs |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("add", InstanceField.Method (add BITS LIMBS))
        ].
  End Impl_core_ops_arith_Add_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_SubAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Uint<BITS, LIMBS>) {
                    *self = self.$fdel(rhs);
                }
    *)
    Definition sub_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_sub",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::SubAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_SubAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_SubAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Uint<BITS, LIMBS>) {
                    *self = self.$fdel( *rhs);
                }
    *)
    Definition sub_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_sub",
                    [],
                    []
                  |),
                  [
                    M.read (| M.deref (| M.read (| self |) |) |);
                    M.read (| M.deref (| M.read (| rhs |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::SubAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_SubAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Sub_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition sub
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_sub",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("sub", InstanceField.Method (sub BITS LIMBS))
        ].
  End Impl_core_ops_arith_Sub_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Sub_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition sub
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_sub",
              [],
              []
            |),
            [ M.read (| self |); M.read (| M.deref (| M.read (| rhs |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("sub", InstanceField.Method (sub BITS LIMBS))
        ].
  End Impl_core_ops_arith_Sub_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Sub_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition sub
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_sub",
              [],
              []
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("sub", InstanceField.Method (sub BITS LIMBS))
        ].
  End Impl_core_ops_arith_Sub_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Sub_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition sub
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_sub",
              [],
              []
            |),
            [
              M.read (| M.deref (| M.read (| self |) |) |);
              M.read (| M.deref (| M.read (| rhs |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("sub", InstanceField.Method (sub BITS LIMBS))
        ].
  End Impl_core_ops_arith_Sub_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
End add.

Module div.
  Module Impl_core_ops_arith_DivAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Uint<BITS, LIMBS>) {
                    *self = self.$fdel(rhs);
                }
    *)
    Definition div_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_div",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::DivAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("div_assign", InstanceField.Method (div_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_DivAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_DivAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Uint<BITS, LIMBS>) {
                    *self = self.$fdel( *rhs);
                }
    *)
    Definition div_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_div",
                    [],
                    []
                  |),
                  [
                    M.read (| M.deref (| M.read (| self |) |) |);
                    M.read (| M.deref (| M.read (| rhs |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::DivAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("div_assign", InstanceField.Method (div_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_DivAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Div_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition div
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_div",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Div"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("div", InstanceField.Method (div BITS LIMBS))
        ].
  End Impl_core_ops_arith_Div_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Div_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition div
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_div",
              [],
              []
            |),
            [ M.read (| self |); M.read (| M.deref (| M.read (| rhs |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Div"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("div", InstanceField.Method (div BITS LIMBS))
        ].
  End Impl_core_ops_arith_Div_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Div_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition div
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_div",
              [],
              []
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Div"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("div", InstanceField.Method (div BITS LIMBS))
        ].
  End Impl_core_ops_arith_Div_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Div_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition div
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_div",
              [],
              []
            |),
            [
              M.read (| M.deref (| M.read (| self |) |) |);
              M.read (| M.deref (| M.read (| rhs |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Div"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("div", InstanceField.Method (div BITS LIMBS))
        ].
  End Impl_core_ops_arith_Div_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_RemAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Uint<BITS, LIMBS>) {
                    *self = self.$fdel(rhs);
                }
    *)
    Definition rem_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_rem",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::RemAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("rem_assign", InstanceField.Method (rem_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_RemAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_RemAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Uint<BITS, LIMBS>) {
                    *self = self.$fdel( *rhs);
                }
    *)
    Definition rem_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_rem",
                    [],
                    []
                  |),
                  [
                    M.read (| M.deref (| M.read (| self |) |) |);
                    M.read (| M.deref (| M.read (| rhs |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::RemAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("rem_assign", InstanceField.Method (rem_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_RemAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Rem_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition rem
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_rem",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Rem"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("rem", InstanceField.Method (rem BITS LIMBS))
        ].
  End Impl_core_ops_arith_Rem_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Rem_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition rem
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_rem",
              [],
              []
            |),
            [ M.read (| self |); M.read (| M.deref (| M.read (| rhs |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Rem"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("rem", InstanceField.Method (rem BITS LIMBS))
        ].
  End Impl_core_ops_arith_Rem_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Rem_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition rem
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_rem",
              [],
              []
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Rem"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("rem", InstanceField.Method (rem BITS LIMBS))
        ].
  End Impl_core_ops_arith_Rem_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Rem_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition rem
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_rem",
              [],
              []
            |),
            [
              M.read (| M.deref (| M.read (| self |) |) |);
              M.read (| M.deref (| M.read (| rhs |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Rem"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("rem", InstanceField.Method (rem BITS LIMBS))
        ].
  End Impl_core_ops_arith_Rem_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
End div.

Module mul.
  Module Impl_core_ops_arith_MulAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: Uint<BITS, LIMBS>) {
                    *self = self.$fdel(rhs);
                }
    *)
    Definition mul_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_mul",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::MulAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_MulAssign_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_MulAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn_assign(&mut self, rhs: &Uint<BITS, LIMBS>) {
                    *self = self.$fdel( *rhs);
                }
    *)
    Definition mul_assign
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.deref (| M.read (| self |) |),
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "wrapping_mul",
                    [],
                    []
                  |),
                  [
                    M.read (| M.deref (| M.read (| self |) |) |);
                    M.read (| M.deref (| M.read (| rhs |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::MulAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign BITS LIMBS)) ].
  End Impl_core_ops_arith_MulAssign_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Mul_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition mul
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_mul",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("mul", InstanceField.Method (mul BITS LIMBS))
        ].
  End Impl_core_ops_arith_Mul_ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Mul_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition mul
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], self |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_mul",
              [],
              []
            |),
            [ M.read (| self |); M.read (| M.deref (| M.read (| rhs |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("mul", InstanceField.Method (mul BITS LIMBS))
        ].
  End Impl_core_ops_arith_Mul_ref__ruint_Uint_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Mul_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel(rhs)
                }
    *)
    Definition mul
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_mul",
              [],
              []
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("mul", InstanceField.Method (mul BITS LIMBS))
        ].
  End Impl_core_ops_arith_Mul_ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
  
  Module Impl_core_ops_arith_Mul_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ].
    
    (*             type Output = Uint<BITS, LIMBS>; *)
    Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
                fn $fn(self, rhs: &Uint<BITS, LIMBS>) -> Self::Output {
                    self.$fdel( *rhs)
                }
    *)
    Definition mul
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              self
            |) in
          let rhs :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
              rhs
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_mul",
              [],
              []
            |),
            [
              M.read (| M.deref (| M.read (| self |) |) |);
              M.read (| M.deref (| M.read (| rhs |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (BITS LIMBS : Value.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ] ]
        (Self BITS LIMBS)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output BITS LIMBS));
          ("mul", InstanceField.Method (mul BITS LIMBS))
        ].
  End Impl_core_ops_arith_Mul_ref__ruint_Uint_BITS_LIMBS_for_ref__ruint_Uint_BITS_LIMBS.
End mul.
