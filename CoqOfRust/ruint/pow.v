(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module pow.
  Module Impl_ruint_Uint_BITS_LIMBS.
    Definition Self (BITS LIMBS : Value.t) : Ty.t :=
      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
    
    (*
        pub fn checked_pow(self, exp: Self) -> Option<Self> {
            match self.overflowing_pow(exp) {
                (x, false) => Some(x),
                (_, true) => None,
            }
        }
    *)
    Definition checked_pow
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]),
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "overflowing_pow",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let x := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    M.alloc (|
                      Value.StructTuple "core::option::Option::Some" [ M.read (| x |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_pow :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_pow" (checked_pow BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque checked_pow.
    
    (*
        pub fn overflowing_pow(mut self, mut exp: Self) -> (Self, bool) {
            if BITS == 0 {
                return (self, false);
            }
    
            // Exponentiation by squaring
            let mut overflow = false;
            let mut base_overflow = false;
            let mut result = Self::from(1);
            while exp != Self::ZERO {
                // Multiply by base
                if exp.bit(0) {
                    let (r, o) = result.overflowing_mul(self);
                    result = r;
                    overflow |= o | base_overflow;
                }
    
                // Square base
                let (s, o) = self.overflowing_mul(self);
                self = s;
                base_overflow |= o;
                exp >>= 1;
            }
            (result, overflow)
        }
    *)
    Definition overflowing_pow
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| BITS, Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ M.read (| self |); Value.Bool false ] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ overflow : Ty.path "bool" := M.alloc (| Value.Bool false |) in
                let~ base_overflow : Ty.path "bool" := M.alloc (| Value.Bool false |) in
                let~ result : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "from",
                        [],
                        [ Ty.path "i32" ]
                      |),
                      [ Value.Integer IntegerKind.I32 1 ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        [],
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                        "ne",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, exp |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            "ZERO",
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "bit",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (| Pointer.Kind.Ref, exp |);
                                                  Value.Integer IntegerKind.Usize 0
                                                ]
                                              |)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.match_operator (|
                                          None,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [];
                                                  Ty.path "bool"
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                                "overflowing_mul",
                                                [],
                                                []
                                              |),
                                              [ M.read (| result |); M.read (| self |) ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let r := M.copy (| γ0_0 |) in
                                                let o := M.copy (| γ0_1 |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.write (| result, M.read (| r |) |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    let β := overflow in
                                                    M.write (|
                                                      β,
                                                      BinOp.bit_or
                                                        (M.read (| β |))
                                                        (BinOp.bit_or
                                                          (M.read (| o |))
                                                          (M.read (| base_overflow |)))
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.match_operator (|
                                None,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.path "bool"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      "overflowing_mul",
                                      [],
                                      []
                                    |),
                                    [ M.read (| self |); M.read (| self |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let s := M.copy (| γ0_0 |) in
                                      let o := M.copy (| γ0_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (| M.write (| self, M.read (| s |) |) |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          let β := base_overflow in
                                          M.write (|
                                            β,
                                            BinOp.bit_or (M.read (| β |)) (M.read (| o |))
                                          |)
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::ops::bit::ShrAssign",
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              [],
                                              [ Ty.path "i32" ],
                                              "shr_assign",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (| Pointer.Kind.MutRef, exp |);
                                              Value.Integer IntegerKind.I32 1
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| Value.Tuple [ M.read (| result |); M.read (| overflow |) ] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_overflowing_pow :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_pow" (overflowing_pow BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque overflowing_pow.
    
    (*
        pub fn pow(self, exp: Self) -> Self {
            self.wrapping_pow(exp)
        }
    *)
    Definition pow
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.call_closure (|
            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
            M.get_associated_function (|
              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
              "wrapping_pow",
              [],
              []
            |),
            [ M.read (| self |); M.read (| exp |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_pow :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "pow" (pow BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque pow.
    
    (*
        pub fn saturating_pow(self, exp: Self) -> Self {
            match self.overflowing_pow(exp) {
                (x, false) => x,
                (_, true) => Self::MAX,
            }
        }
    *)
    Definition saturating_pow
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.read (|
            M.match_operator (|
              Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "overflowing_pow",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let x := M.copy (| γ0_0 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    x));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                    get_associated_constant (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "MAX",
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_saturating_pow :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_pow" (saturating_pow BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque saturating_pow.
    
    (*
        pub fn wrapping_pow(mut self, mut exp: Self) -> Self {
            if BITS == 0 {
                return self;
            }
    
            // Exponentiation by squaring
            let mut result = Self::from(1);
            while exp != Self::ZERO {
                // Multiply by base
                if exp.bit(0) {
                    result = result.wrapping_mul(self);
                }
    
                // Square base
                self = self.wrapping_mul(self);
                exp >>= 1;
            }
            result
        }
    *)
    Definition wrapping_pow
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ self; exp ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| BITS, Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ result : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "from",
                        [],
                        [ Ty.path "i32" ]
                      |),
                      [ Value.Integer IntegerKind.I32 1 ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        [],
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                        "ne",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, exp |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            "ZERO",
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "bit",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (| Pointer.Kind.Ref, exp |);
                                                  Value.Integer IntegerKind.Usize 0
                                                ]
                                              |)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.alloc (|
                                            M.write (|
                                              result,
                                              M.call_closure (|
                                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "wrapping_mul",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| result |); M.read (| self |) ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    self,
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "wrapping_mul",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |); M.read (| self |) ]
                                    |)
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::ops::bit::ShrAssign",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [ Ty.path "i32" ],
                                      "shr_assign",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.MutRef, exp |);
                                      Value.Integer IntegerKind.I32 1
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                result
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_pow :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_pow" (wrapping_pow BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque wrapping_pow.
    
    (*
        pub fn approx_pow2(exp: f64) -> Option<Self> {
            const LN2_1P5: f64 = 0.584_962_500_721_156_2_f64;
            const EXP2_63: f64 = 9_223_372_036_854_775_808_f64;
    
            // FEATURE: Round negative to zero.
            #[allow(clippy::cast_precision_loss)] // Self::BITS ~< 2^52 and so fits f64.
            if exp < LN2_1P5 {
                if exp < -1.0 {
                    return Some(Self::ZERO);
                }
                return Self::try_from(1).ok();
            }
            #[allow(clippy::cast_precision_loss)]
            if exp > Self::BITS as f64 {
                return None;
            }
    
            // Since exp < BITS, it has an integer and fractional part.
            #[allow(clippy::cast_possible_truncation)] // exp <= BITS <= usize::MAX.
            #[allow(clippy::cast_sign_loss)] // exp >= 0.
            let shift = exp.trunc() as usize;
            let fract = exp.fract();
    
            // Compute the leading 64 bits
            // Since `fract < 1.0` we have `fract.exp2() < 2`, so we can rescale by
            // 2^63 and cast to u64.
            #[allow(clippy::cast_possible_truncation)] // fract < 1.0
            #[allow(clippy::cast_sign_loss)] // fract >= 0.
            let bits = (fract.exp2() * EXP2_63) as u64;
            // Note: If `fract` is zero this will result in `u64::MAX`.
    
            if shift >= 63 {
                // OPT: A dedicated function avoiding full-sized shift.
                Some(Self::try_from(bits).ok()?.checked_shl(shift - 63)?)
            } else {
                let shift = 63 - shift;
                // Divide `bits` by `2^shift`, rounding to nearest.
                let bits = (bits >> shift) + ((bits >> (shift - 1)) & 1);
                Self::try_from(bits).ok()
            }
        }
    *)
    Definition approx_pow2
        (BITS LIMBS : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self BITS LIMBS in
      match ε, τ, α with
      | [], [], [ exp ] =>
        ltac:(M.monadic
          (let exp := M.alloc (| exp |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.lt (|
                                  M.read (| exp |),
                                  M.read (|
                                    get_constant (|
                                      "ruint::pow::approx_pow2::LN2_1P5",
                                      Ty.path "f64"
                                    |)
                                  |)
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                BinOp.lt (|
                                                  M.read (| exp |),
                                                  M.read (| UnsupportedLiteral |)
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  Value.StructTuple
                                                    "core::option::Option::Some"
                                                    [
                                                      M.read (|
                                                        get_associated_constant (|
                                                          Ty.apply
                                                            (Ty.path "ruint::Uint")
                                                            [ BITS; LIMBS ]
                                                            [],
                                                          "ZERO",
                                                          Ty.apply
                                                            (Ty.path "ruint::Uint")
                                                            [ BITS; LIMBS ]
                                                            []
                                                        |)
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                          Ty.apply
                                            (Ty.path "ruint::from::ToUintError")
                                            []
                                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                        ],
                                      "ok",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                            Ty.apply
                                              (Ty.path "ruint::from::ToUintError")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ],
                                        M.get_trait_method (|
                                          "core::convert::TryFrom",
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          [],
                                          [ Ty.path "i32" ],
                                          "try_from",
                                          [],
                                          []
                                        |),
                                        [ Value.Integer IntegerKind.I32 1 ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.gt (|
                                  M.read (| exp |),
                                  M.cast
                                    (Ty.path "f64")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "BITS",
                                        Ty.path "usize"
                                      |)
                                    |))
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ shift : Ty.path "usize" :=
                  M.alloc (|
                    M.cast
                      (Ty.path "usize")
                      (M.call_closure (|
                        Ty.path "f64",
                        M.get_associated_function (| Ty.path "f64", "trunc", [], [] |),
                        [ M.read (| exp |) ]
                      |))
                  |) in
                let~ fract : Ty.path "f64" :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "f64",
                      M.get_associated_function (| Ty.path "f64", "fract", [], [] |),
                      [ M.read (| exp |) ]
                    |)
                  |) in
                let~ bits : Ty.path "u64" :=
                  M.alloc (|
                    M.cast
                      (Ty.path "u64")
                      (BinOp.Wrap.mul (|
                        M.call_closure (|
                          Ty.path "f64",
                          M.get_associated_function (| Ty.path "f64", "exp2", [], [] |),
                          [ M.read (| fract |) ]
                        |),
                        M.read (|
                          get_constant (| "ruint::pow::approx_pow2::EXP2_63", Ty.path "f64" |)
                        |)
                      |))
                  |) in
                M.match_operator (|
                  Some
                    (Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.ge (| M.read (| shift |), Value.Integer IntegerKind.Usize 63 |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.read (|
                                M.match_operator (|
                                  Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::ops::control_flow::ControlFlow")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ];
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                        [],
                                        [],
                                        "branch",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            "checked_shl",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.match_operator (|
                                                Some
                                                  (Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    []),
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::ops::control_flow::ControlFlow")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "core::convert::Infallible" ];
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [ BITS; LIMBS ]
                                                          []
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "ruint::Uint")
                                                            [ BITS; LIMBS ]
                                                            []
                                                        ],
                                                      [],
                                                      [],
                                                      "branch",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [ BITS; LIMBS ]
                                                              []
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "ruint::Uint")
                                                                [ BITS; LIMBS ]
                                                                [];
                                                              Ty.apply
                                                                (Ty.path "ruint::from::ToUintError")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "ruint::Uint")
                                                                    [ BITS; LIMBS ]
                                                                    []
                                                                ]
                                                            ],
                                                          "ok",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "ruint::Uint")
                                                                  [ BITS; LIMBS ]
                                                                  [];
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "ruint::from::ToUintError")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "ruint::Uint")
                                                                      [ BITS; LIMBS ]
                                                                      []
                                                                  ]
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::convert::TryFrom",
                                                              Ty.apply
                                                                (Ty.path "ruint::Uint")
                                                                [ BITS; LIMBS ]
                                                                [],
                                                              [],
                                                              [ Ty.path "u64" ],
                                                              "try_from",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.read (| bits |) ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "ruint::Uint")
                                                                      [ BITS; LIMBS ]
                                                                      []
                                                                  ],
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "ruint::Uint")
                                                                        [ BITS; LIMBS ]
                                                                        []
                                                                    ],
                                                                  [],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  [],
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)
                                            |);
                                            BinOp.Wrap.sub (|
                                              M.read (| shift |),
                                              Value.Integer IntegerKind.Usize 63
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "ruint::Uint")
                                                        [ BITS; LIMBS ]
                                                        []
                                                    ],
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::Uint")
                                                          [ BITS; LIMBS ]
                                                          []
                                                      ],
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "core::convert::Infallible" ]
                                                    ],
                                                    "from_residual",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ shift : Ty.path "usize" :=
                          M.alloc (|
                            BinOp.Wrap.sub (|
                              Value.Integer IntegerKind.Usize 63,
                              M.read (| shift |)
                            |)
                          |) in
                        let~ bits : Ty.path "u64" :=
                          M.alloc (|
                            BinOp.Wrap.add (|
                              BinOp.Wrap.shr (| M.read (| bits |), M.read (| shift |) |),
                              BinOp.bit_and
                                (BinOp.Wrap.shr (|
                                  M.read (| bits |),
                                  BinOp.Wrap.sub (|
                                    M.read (| shift |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                |))
                                (Value.Integer IntegerKind.U64 1)
                            |)
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.apply
                                    (Ty.path "ruint::from::ToUintError")
                                    []
                                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                ],
                              "ok",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                    Ty.apply
                                      (Ty.path "ruint::from::ToUintError")
                                      []
                                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                  ],
                                M.get_trait_method (|
                                  "core::convert::TryFrom",
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  [],
                                  [ Ty.path "u64" ],
                                  "try_from",
                                  [],
                                  []
                                |),
                                [ M.read (| bits |) ]
                              |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_approx_pow2 :
      forall (BITS LIMBS : Value.t),
      M.IsAssociatedFunction.C (Self BITS LIMBS) "approx_pow2" (approx_pow2 BITS LIMBS).
    Admitted.
    Global Typeclasses Opaque approx_pow2.
  End Impl_ruint_Uint_BITS_LIMBS.
End pow.
