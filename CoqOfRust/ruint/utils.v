(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module utils.
  (*
  pub(crate) const fn rem_up(a: usize, b: usize) -> usize {
      let rem = a % b;
      if rem > 0 {
          rem
      } else {
          b
      }
  }
  *)
  Definition rem_up (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ a; b ] =>
      ltac:(M.monadic
        (let a := M.alloc (| a |) in
        let b := M.alloc (| b |) in
        M.read (|
          let~ rem : Ty.path "usize" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.rem,
                [ M.read (| a |); M.read (| b |) ]
              |)
            |) in
          M.match_operator (|
            Some (Ty.path "usize"),
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.gt,
                          [ M.read (| rem |); Value.Integer IntegerKind.Usize 0 ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  rem));
              fun γ => ltac:(M.monadic b)
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rem_up : M.IsFunction.C "ruint::utils::rem_up" rem_up.
  Admitted.
  Global Typeclasses Opaque rem_up.
  
  (*
  fn last_idx<T: PartialEq>(x: &[T], value: &T) -> usize {
      x.iter().rposition(|b| b != value).map_or(0, |idx| idx + 1)
  }
  *)
  Definition last_idx (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ x; value ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        let value := M.alloc (| value |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_associated_function (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
            "map_or",
            [],
            [ Ty.path "usize"; Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize") ]
          |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                [],
                [],
                "rposition",
                [],
                [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ] (Ty.path "bool") ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "iter",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                    |)
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.path "bool")),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let b := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ T ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                      "ne",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, b |);
                                      M.borrow (| Pointer.Kind.Ref, value |)
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |);
            Value.Integer IntegerKind.Usize 0;
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")),
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let idx := M.copy (| γ |) in
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [ M.read (| idx |); Value.Integer IntegerKind.Usize 1 ]
                              |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_last_idx : M.IsFunction.C "ruint::utils::last_idx" last_idx.
  Admitted.
  Global Typeclasses Opaque last_idx.
  
  (*
  pub(crate) fn trim_end_slice<'a, T: PartialEq>(slice: &'a [T], value: &T) -> &'a [T] {
      &slice[..last_idx(slice, value)]
  }
  *)
  Definition trim_end_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ slice; value ] =>
      ltac:(M.monadic
        (let slice := M.alloc (| slice |) in
        let value := M.alloc (| value |) in
        M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "slice") [] [ T ],
                    [],
                    [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ],
                    "index",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |);
                    Value.StructRecord
                      "core::ops::range::RangeTo"
                      [
                        ("end_",
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "ruint::utils::last_idx", [], [ T ] |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |);
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                            ]
                          |))
                      ]
                  ]
                |)
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_trim_end_slice :
    M.IsFunction.C "ruint::utils::trim_end_slice" trim_end_slice.
  Admitted.
  Global Typeclasses Opaque trim_end_slice.
  
  (*
  pub(crate) fn trim_end_vec<T: PartialEq>(vec: &mut Vec<T>, value: &T) {
      vec.truncate(last_idx(vec, value));
  }
  *)
  Definition trim_end_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ vec; value ] =>
      ltac:(M.monadic
        (let vec := M.alloc (| vec |) in
        let value := M.alloc (| value |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "truncate",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| vec |) |) |);
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (| "ruint::utils::last_idx", [], [ T ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| vec |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                    ]
                  |)
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_trim_end_vec :
    M.IsFunction.C "ruint::utils::trim_end_vec" trim_end_vec.
  Admitted.
  Global Typeclasses Opaque trim_end_vec.
End utils.
